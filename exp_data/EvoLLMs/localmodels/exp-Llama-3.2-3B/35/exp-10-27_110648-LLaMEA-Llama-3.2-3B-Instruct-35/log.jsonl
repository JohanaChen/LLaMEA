{"id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 58, in <module>\n  File \"<string>\", line 25, in __call__\nIndexError: invalid index to scalar variable.\n.", "error": "IndexError('invalid index to scalar variable.')Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 58, in <module>\n  File \"<string>\", line 25, in __call__\nIndexError: invalid index to scalar variable.\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "ae6719b7-efde-4054-aa73-607902f29c69", "solution": "import numpy as np\nimport random\n\nclass MultiObjectiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solutions = []\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solutions = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the solutions using probabilistic refinement\n            for i in range(self.population_size):\n                if random.random() < 0.35:\n                    # Select a random solution from the current population\n                    random_solution = population[np.random.choice(self.population_size, 1, replace=False)]\n                    # Calculate the fitness difference between the current solution and the random solution\n                    fitness_diff = self.fitness_values[i] - self.fitness_values[np.random.choice(self.population_size, 1, replace=False)]\n                    # Update the current solution using the fitness difference\n                    population[i] = population[i] + fitness_diff * random_solution\n\n            # Check if the best solutions have improved\n            for i in range(len(self.best_solutions)):\n                for j in range(i+1, len(self.best_solutions)):\n                    if self.fitness_values[indices[np.argmin(self.fitness_values[indices])]] > self.fitness_values[indices[np.argmin(self.fitness_values[indices])]]:\n                        self.best_solutions[i], self.best_solutions[j] = self.best_solutions[j], self.best_solutions[i]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nmulti_objective_harmony_search = MultiObjectiveHarmonySearch(100, 5)\nbest_solutions = multi_objective_harmony_search(func)\nprint(\"Best solutions:\", best_solutions)\nprint(\"Fitness values:\", func(best_solutions))", "name": "MultiObjectiveHarmonySearch", "description": "Novel \"Multi-Objective Harmony Search\" algorithm with \"Probabilistic Refinement\" strategy.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "2e7702b5-86b1-4a25-bd29-c36b2e29216b", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the strategy using probabilistic refinement\n            refinement_prob = 0.35\n            if random.random() < refinement_prob:\n                # Select a random individual to refine\n                refine_index = random.randint(0, self.population_size - 1)\n                # Refine the individual by changing its lines with probability 0.35\n                new_individual = population[refine_index]\n                for j in range(self.dim):\n                    if random.random() < refinement_prob:\n                        new_individual[j] = self.bounds[0] + (self.bounds[1] - self.bounds[0]) * random.random()\n                # Evaluate the fitness of the refined individual\n                refined_fitness = func(new_individual)\n                # Update the pheromone matrix\n                self.pheromone_matrix[refine_index] = refined_fitness / np.sum(refined_fitness)\n                # Update the best solution if the refined individual is better\n                if refined_fitness < self.fitness_values[refine_index]:\n                    self.best_solution = new_individual", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and \"Probabilistic Refinement\" technique.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "ff645a1e-6e52-458f-af04-b8e8e1ab4a0f", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.adaptive_prob = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution with adaptive mutation\n                if random.random() < self.adaptive_prob:\n                    population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n                else:\n                    population[i] = population[i] + np.random.uniform(-self.bounds[1] + self.bounds[0], self.bounds[1] - self.bounds[0])\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Mutation\" algorithm with 0.35 probability to refine the strategy.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "54e69904-f83b-45ab-8e7a-6636b8e8a703", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.mutation_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Perform probabilistic mutation\n            if random.random() < self.mutation_probability:\n                # Select a random individual to mutate\n                individual_to_mutate = np.random.choice(self.population_size)\n                # Generate a new individual by perturbing the current individual\n                new_individual = population[individual_to_mutate] + np.random.uniform(-self.bounds[1] - self.bounds[0], self.bounds[1] - self.bounds[0], self.dim)\n                # Ensure the new individual is within the bounds\n                new_individual = np.clip(new_individual, self.bounds[0], self.bounds[1])\n                # Evaluate the fitness of the new individual\n                fitness_values = func(new_individual)\n                # Replace the original individual with the new individual if it has a better fitness\n                if fitness_values < self.fitness_values[individual_to_mutate]:\n                    population[individual_to_mutate] = new_individual\n                    self.fitness_values[individual_to_mutate] = fitness_values\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and probabilistic mutation.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "72eda03a-91f6-4b1b-950a-c469b3cb6dc9", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the best solution with a probability of 0.35\n            if random.random() < self.refine_probability:\n                # Select a random individual to refine\n                individual_to_refine = population[np.random.choice(self.population_size)]\n                # Refine the individual by perturbing its coordinates\n                refined_individual = individual_to_refine + self.bounds[1] - self.bounds[0] * np.random.normal(0, 1, self.dim)\n                # Evaluate the fitness of the refined individual\n                refined_fitness = func(refined_individual)\n                # Update the best solution if the refined individual has a better fitness\n                if refined_fitness < self.fitness_values[indices[0]]:\n                    self.best_solution = refined_individual\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Multi-Fidelity Exploration\" algorithm.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "d40739c8-eaf1-4f27-9253-ef5a93d5a74d", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the strategy with multi-fidelity exploration\n            refinement_prob = 0.35\n            refined_population = []\n            for individual in population:\n                if np.random.rand() < refinement_prob:\n                    # Select a random dimension to refine\n                    dim_to_refine = np.random.randint(0, self.dim)\n                    # Generate a new solution with a small perturbation\n                    new_solution = individual.copy()\n                    new_solution[dim_to_refine] += np.random.uniform(-0.1, 0.1)\n                    refined_population.append(new_solution)\n                else:\n                    refined_population.append(individual)\n            population = refined_population\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Multi-Fidelity Exploration\" algorithm", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "6924a0f9-2c40-43fd-b3c7-92037520d765", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.adaptive_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the best solution using adaptive probability\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                refinement_indices = np.random.choice(self.population_size, size=int(self.population_size * self.adaptive_probability), replace=False)\n                refinement_indices = refinement_indices[~np.isin(refinement_indices, indices)]\n                refinement_population = population[refinement_indices]\n                refinement_fitness = func(refinement_population)\n                refinement_indices = refinement_indices[np.argsort(refinement_fitness)]\n                self.best_solution = refinement_population[refinement_indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "c5085ae5-ba3d-45fe-b01a-0dc9a913d922", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                updated_population = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n                # Refine the solution with probability 0.35\n                if random.random() < 0.35:\n                    updated_population = updated_population + np.random.uniform(-0.1, 0.1, self.dim)\n\n                # Evaluate the fitness of the new solutions\n                updated_fitness_values = func(updated_population)\n\n                # Update the pheromone matrix\n                for j in range(self.population_size):\n                    self.pheromone_matrix[j] = updated_fitness_values[j] / np.sum(updated_fitness_values)\n\n                # Check if the best solution has improved\n                if updated_fitness_values[indices[0]] < self.fitness_values[indices[0]]:\n                    self.best_solution = updated_population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Probability Refinement\" algorithm with \"Multi-Fidelity\" exploration strategy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "99e333a7-ed46-4fa1-8e6a-e7f225d839e2", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refine_prob = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the best solution\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = self.refine_solution(self.best_solution)\n\n    def refine_solution(self, solution):\n        # Generate a new solution by perturbing the current solution\n        new_solution = solution + np.random.uniform(-0.1, 0.1, self.dim)\n        # Check if the new solution is better\n        if np.random.rand() < self.refine_prob and func(new_solution) < func(solution):\n            return new_solution\n        else:\n            return solution\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and \"Probabilistic\" refinement.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "8946680f-4915-4190-9514-fd8924f7aa81", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.adaptive_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution with adaptive probability\n                if random.random() < self.adaptive_probability:\n                    population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n                else:\n                    population[i] = population[i] + random.uniform(-self.bounds[1] - self.bounds[0], self.bounds[1] - self.bounds[0])\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Probability\" algorithm with \"Multi-Fidelity\" exploration strategy.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "4db52fd2-70b7-499c-8083-d2c1cbaaf5d8", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the best solution with a probability of 0.35\n            if random.random() < self.refine_probability:\n                # Select a random dimension to refine\n                dim_to_refine = random.randint(0, self.dim - 1)\n                # Generate a new solution by adding a small random value to the best solution\n                new_solution = self.best_solution.copy()\n                new_solution[dim_to_refine] += np.random.uniform(-0.1, 0.1)\n                # Evaluate the fitness of the new solution\n                new_fitness = func(new_solution)\n                # If the new solution has a better fitness, update the best solution\n                if new_fitness < self.fitness_values[indices[0]]:\n                    self.best_solution = new_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "d3d7c76c-f42c-4d70-b29a-3b1a3575a2e8", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))\n# ```", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Refinement\" algorithm with \"Multi-Fidelity\" exploration strategy.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "2c758ab1-447b-462c-9128-41469ca4444a", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refinement_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the best solution with probability 0.35\n            if np.random.rand() < self.refinement_probability:\n                # Select a random solution from the population\n                new_individual = population[np.random.choice(self.population_size, 1, replace=False)]\n                # Refine the new individual by adding a small perturbation\n                new_individual = new_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Ensure the new individual is within the bounds\n                new_individual = np.clip(new_individual, self.bounds[0], self.bounds[1])\n                # Evaluate the fitness of the new individual\n                new_fitness = func(new_individual)\n                # Update the best solution if the new individual has a better fitness\n                if new_fitness < self.fitness_values[indices[0]]:\n                    self.best_solution = new_individual\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Probabilistic Refinement\" algorithm with \"Multi-Fidelity\" exploration strategy.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "cc16b5c5-a0e0-41f2-9428-b5002c21e3c8", "solution": "import numpy as np\nimport random\nimport time\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the strategy by changing individual lines with probability 0.35\n            refine_indices = np.random.choice(self.population_size, size=int(self.population_size * self.refine_probability), replace=False)\n            for index in refine_indices:\n                new_individual = population[index]\n                new_individual = new_individual + np.random.uniform(-1, 1, self.dim) * 0.1\n                population[index] = np.clip(new_individual, self.bounds[0], self.bounds[1])\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "590db3d6-1d04-42e2-958e-5281a4ac92c6", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refine_prob = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the best solution with a probability of 0.35\n            if random.random() < self.refine_prob:\n                # Select a random individual to refine\n                refine_individual = population[random.randint(0, self.population_size - 1)]\n                # Refine the individual by changing 35% of its lines\n                refined_individual = refine_individual.copy()\n                for _ in range(int(self.population_size * self.refine_prob)):\n                    # Choose a random dimension to change\n                    dim = random.randint(0, self.dim - 1)\n                    # Choose a random value between the bounds\n                    new_value = random.uniform(self.bounds[0], self.bounds[1])\n                    # Change the value\n                    refined_individual[dim] = new_value\n                # Replace the best solution with the refined individual\n                self.best_solution = refined_individual\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Multi-Fidelity Exploration\" algorithm", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "33fb26be-c7e2-4efe-92cd-b7429f74ef42", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.adaptive_expansion_rate = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Adaptive exploration\n            if np.random.rand() < self.adaptive_expansion_rate:\n                # Refine the best solution\n                new_solution = self.best_solution + np.random.uniform(-0.1, 0.1, self.dim)\n                new_fitness = func(new_solution)\n                if new_fitness < self.fitness_values[indices[0]]:\n                    self.best_solution = new_solution\n                    self.fitness_values[indices[0]] = new_fitness\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Exploration\" algorithm", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "96578a28-2463-40b2-949c-b10251c1dbf0", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "b6915587-fdf8-4980-97ae-861f8cf3236b", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the strategy with probability 0.35\n            if random.random() < self.refine_probability:\n                for i in range(self.population_size):\n                    # Generate a new solution by perturbing the current solution\n                    new_solution = population[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    # Evaluate the fitness of the new solution\n                    new_fitness = func(new_solution)\n                    # If the new solution has better fitness, replace the current solution\n                    if new_fitness < self.fitness_values[i]:\n                        population[i] = new_solution\n                        self.fitness_values[i] = new_fitness\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy using probability 0.35 to refine the strategy.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "b3916f49-6c37-46db-aece-120c7092f5ef", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the strategy with probability 0.35\n            if random.random() < 0.35:\n                for _ in range(int(self.population_size * 0.35)):\n                    # Select a random solution to refine\n                    index = random.randint(0, self.population_size - 1)\n                    # Generate a new solution by perturbing the selected solution\n                    new_solution = population[index] + np.random.uniform(-self.bounds[1] + self.bounds[0], self.bounds[1] - self.bounds[0])\n                    # Evaluate the fitness of the new solution\n                    new_fitness = func(new_solution)\n                    # Replace the original solution with the new solution if it has a better fitness\n                    if new_fitness < self.fitness_values[index]:\n                        population[index] = new_solution\n                        self.fitness_values[index] = new_fitness\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Probability Refinement\" algorithm", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "b60090ef-10f7-40d5-9a0d-94b123f1205a", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the best solution with probability 0.35\n            if random.random() < self.refine_probability:\n                # Select a random individual to refine\n                individual_to_refine = population[np.random.choice(self.population_size)]\n                # Calculate the fitness of the best solution\n                fitness = func(self.best_solution)\n                # Calculate the fitness of the individual to refine\n                fitness_to_refine = func(individual_to_refine)\n                # If the fitness of the individual to refine is better, update the best solution\n                if fitness_to_refine < fitness:\n                    self.best_solution = individual_to_refine\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Multi-Fidelity Exploration\" algorithm", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "b1f49b26-5405-448b-92c6-23f1f34f1079", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the strategy with probabilistic mutation\n            if random.random() < 0.35:\n                mutation_index = random.randint(0, self.population_size - 1)\n                mutated_solution = population[mutation_index]\n                mutated_solution += random.uniform(-self.bounds[1] - self.bounds[0], self.bounds[1] - self.bounds[0])\n                mutated_solution = np.clip(mutated_solution, self.bounds[0], self.bounds[1])\n                population[mutation_index] = mutated_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and probabilistic refinement.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "9ad08f90-03bf-4ef5-9f04-1c3ae589d87e", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))\n\n# Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy using probability-based mutation\n# ```python\nimport numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.mutation_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                new_individual = population[i] + self.bounds[1] - self.bounds[0] * difference\n                # Apply mutation with probability\n                if random.random() < self.mutation_probability:\n                    new_individual = new_individual + np.random.uniform(-self.bounds[1] - self.bounds[0], self.bounds[1] - self.bounds[0])\n                population[i] = new_individual\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy using probability-based mutation.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "e135437c-98ac-4cc3-b561-5de67b410eb9", "solution": "import numpy as np\nimport random\n\nclass MultiObjectiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solutions = None\n        self.fitness_values = np.zeros((self.population_size, 2))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i, 0] / np.sum(self.fitness_values[:, 0])\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values[:, 0])\n            self.best_solutions = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i, 0] / np.sum(self.fitness_values[:, 0])\n\n            # Refine the solutions using probabilistic refinement\n            for i in range(self.population_size):\n                if random.random() < 0.35:\n                    # Randomly select a solution to refine\n                    idx = random.randint(0, self.population_size - 1)\n                    # Refine the solution\n                    refined_solution = population[idx] + random.uniform(-1, 1, self.dim)\n                    # Evaluate the fitness of the refined solution\n                    refined_fitness = func(refined_solution)\n                    # Update the pheromone matrix\n                    self.pheromone_matrix[idx] = refined_fitness / np.sum(self.fitness_values[:, 0])\n                    # Update the fitness values\n                    self.fitness_values[idx, 0] = refined_fitness\n\n            # Check if the best solutions have improved\n            for i in range(self.harmony_size):\n                if self.fitness_values[indices[i], 0] < self.fitness_values[indices[i+1], 0]:\n                    self.best_solutions = population[indices[i]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2), np.sum(x**3)\n\nmulti_objective_harmony_search = MultiObjectiveHarmonySearch(100, 5)\nbest_solutions = multi_objective_harmony_search(func)\nprint(\"Best solutions:\", best_solutions)\nprint(\"Fitness values:\", func(best_solutions[:, 0]))", "name": "MultiObjectiveHarmonySearch", "description": "Novel \"Multi-Objective Harmony Search\" algorithm with \"Probabilistic Refinement\" strategy", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('tuple indices must be integers or slices, not tuple').", "error": "TypeError('tuple indices must be integers or slices, not tuple')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "d66234e6-ed92-4741-bdde-afccf8b78ea9", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearchAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.mutation_prob = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the strategy with adaptive mutation\n            refine_indices = np.random.choice(self.population_size, int(self.population_size * self.mutation_prob), replace=False)\n            for index in refine_indices:\n                # Generate a new individual\n                new_individual = population[index] + np.random.uniform(-self.bounds[1] + self.bounds[0], self.bounds[1] - self.bounds[0])\n                # Evaluate the fitness of the new individual\n                new_fitness = func(new_individual)\n                # Check if the new individual is better\n                if new_fitness < self.fitness_values[index]:\n                    population[index] = new_individual\n                    self.fitness_values[index] = new_fitness\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search_adaptive = SwarmHarmonySearchAdaptive(100, 5)\nbest_solution = swarm_harmony_search_adaptive(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearchAdaptive", "description": "Novel \"Swarm Harmony Search with Adaptive Mutation\" algorithm with \"Multi-Fidelity\" exploration strategy.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "6e0a0c9d-e7c7-431a-a350-8f32a4ddd10b", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.adaptation_rate = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the strategy with adaptive exploration\n            if random.random() < self.adaptation_rate:\n                # Randomly select a solution to refine\n                refine_solution = population[random.randint(0, self.population_size - 1)]\n                # Refine the solution by changing a random dimension\n                refine_index = random.randint(0, self.dim - 1)\n                refine_solution[refine_index] = refine_solution[refine_index] + random.uniform(-0.1, 0.1)\n                # Evaluate the fitness of the refined solution\n                self.fitness_values[random.randint(0, self.population_size - 1)] = func(refine_solution)\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Exploration\" algorithm with \"Multi-Fidelity\" exploration strategy.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "30bebc52-0c89-4cf2-afaa-b6302d09ece8", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference * random.random()\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the strategy by changing the individual lines with probability 0.35\n            if random.random() < self.probability:\n                indices_to_change = np.random.choice(self.population_size, size=self.harmony_size, replace=False)\n                for j in indices_to_change:\n                    new_solution = population[j]\n                    for k in range(self.dim):\n                        new_solution[k] = population[j][k] + random.uniform(-self.bounds[1] - self.bounds[0], self.bounds[1] - self.bounds[0])\n                    population[j] = new_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "95858920-cbdf-45f8-9137-6a0af796eea5", "solution": "import numpy as np\nimport random\n\nclass MultiFidelityEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refinement_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the best solution with a probability of 0.35\n            if random.random() < self.refinement_probability:\n                # Randomly select a dimension to refine\n                dim_to_refine = random.randint(0, self.dim - 1)\n                # Generate a new value for the dimension\n                new_value = np.random.uniform(self.bounds[0], self.bounds[1])\n                # Replace the old value with the new value\n                self.best_solution[:, dim_to_refine] = new_value\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nmulti_fidelity_evolutionary_algorithm = MultiFidelityEvolutionaryAlgorithm(100, 5)\nbest_solution = multi_fidelity_evolutionary_algorithm(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "MultiFidelityEvolutionaryAlgorithm", "description": "Novel \"Multi-Fidelity Evolutionary Algorithm\" with \"Probabilistic Refinement\" strategy", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "fc2ce639-9e20-45c6-b5dc-47e316920553", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearchWithRefinement:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refinement_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the best solution\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n                # Refine the best solution with adaptive refinement\n                refinement_indices = np.random.choice(self.population_size, size=int(self.population_size * self.refinement_probability), replace=False)\n                for j in refinement_indices:\n                    new_solution = self.best_solution + self.bounds[1] - self.bounds[0] * np.random.uniform(0, 1, self.dim)\n                    self.fitness_values[j] = func(new_solution)\n                    if self.fitness_values[j] < self.fitness_values[indices[0]]:\n                        self.best_solution = new_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search_with_refinement = SwarmHarmonySearchWithRefinement(100, 5)\nbest_solution = swarm_harmony_search_with_refinement(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearchWithRefinement", "description": "Novel \"Swarm Harmony Search with Adaptive Refinement\" algorithm with \"Multi-Fidelity\" exploration strategy.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "19eb573c-a009-4b3d-a659-7ee2701c02dd", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.adaptive_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution with adaptive probability\n                if random.random() < self.adaptive_probability:\n                    population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n                else:\n                    population[i] = population[i] + self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Probability\" algorithm with \"Multi-Fidelity\" exploration strategy.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "d1704493-3e7c-4f04-8ada-86a2880cdae2", "solution": "import numpy as np\nimport random\nimport copy\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution with probability\n                if random.random() < self.probability:\n                    population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "a550c505-8d2c-4d20-8da8-a2f708e7d253", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine individual solutions using probability refinement\n            refinement_prob = 0.35\n            refined_population = population.copy()\n            for i in range(self.population_size):\n                if random.random() < refinement_prob:\n                    # Select a random neighbor\n                    neighbor_index = np.random.randint(0, self.population_size)\n                    refined_population[i] = population[i] + (population[neighbor_index] - population[i]) * random.random()\n            population = refined_population\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and \"Probability Refinement\" for refining individual solutions.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "58fe6e4a-89b5-4ac4-a3d0-839a69a5bdfe", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.probability_refinement = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the solutions using probability refinement\n            refined_population = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if random.random() < self.probability_refinement:\n                    refined_population[i] = population[i] + random.uniform(-0.1, 0.1, self.dim)\n                else:\n                    refined_population[i] = population[i]\n\n            # Evaluate the fitness of the refined solutions\n            refined_fitness_values = func(refined_population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = refined_fitness_values[i] / np.sum(refined_fitness_values)\n\n            # Check if the best solution has improved\n            if refined_fitness_values[indices[0]] < self.fitness_values[indices[0]]:\n                self.best_solution = refined_population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and \"Probability Refinement\" for improving the solution.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "406ec464-a73b-4bf3-b527-928cd13dff64", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the best solution with adaptive strategy\n            if self.fitness_values[indices[0]]!= -np.inf:\n                refinement_rate = 0.35\n                refinement_count = 0\n                while refinement_count < 10 and self.fitness_values[indices[0]]!= -np.inf:\n                    new_individual = population[indices[0]]\n                    new_individual = new_individual + np.random.uniform(-1, 1, self.dim) * refinement_rate\n                    new_individual = np.clip(new_individual, self.bounds[0], self.bounds[1])\n                    self.fitness_values[indices[0]] = func(new_individual)\n                    refinement_count += 1\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Refinement\" algorithm", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "28fcca49-9ac4-4ea8-b01e-de0a792080ec", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the solution using probability refinement\n            if random.random() < 0.35:\n                # Select a random individual from the population\n                individual = population[random.randint(0, self.population_size - 1)]\n                # Refine the individual by changing one of its lines\n                individual[random.randint(0, self.dim - 1)] += random.uniform(-0.1, 0.1)\n                # Evaluate the fitness of the refined individual\n                self.fitness_values = func(individual)\n                # Update the pheromone matrix\n                self.pheromone_matrix[random.randint(0, self.population_size - 1)] = self.fitness_values[random.randint(0, self.population_size - 1)] / np.sum(self.fitness_values)\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and \"Probability Refinement\" for improving solution.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "532ce103-22bd-4754-9758-76309d5be71f", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n    def mutate(self, individual):\n        # Calculate the probability of mutation\n        mutation_probability = 0.35\n\n        # Generate a random number\n        random_number = np.random.rand()\n\n        # If the random number is less than the mutation probability, mutate the individual\n        if random_number < mutation_probability:\n            # Generate a random mutation vector\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n\n            # Add the mutation vector to the individual\n            individual += mutation_vector\n\n            # Clip the individual to the bounds\n            individual = np.clip(individual, self.bounds[0], self.bounds[1])\n\n            # Return the mutated individual\n            return individual\n        else:\n            # Return the original individual\n            return individual\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and probabilistic mutation.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "dd7253fb-6873-48b5-9c16-ac63b0071d2d", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearchAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.adaptive_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution with adaptive probability\n                if random.random() < self.adaptive_probability:\n                    population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n                else:\n                    population[i] = population[i] + random.uniform(-self.bounds[1] + self.bounds[0], self.bounds[1] - self.bounds[0]) * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search_adaptive = SwarmHarmonySearchAdaptive(100, 5)\nbest_solution = swarm_harmony_search_adaptive(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearchAdaptive", "description": "Novel \"Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "d61b9d7d-0f26-4f81-a877-a3d87bfac8dd", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution with adaptive probability\n                if random.random() < 0.35:\n                    population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n                else:\n                    population[i] = population[i] + self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Probability\" algorithm with \"Multi-Fidelity\" exploration strategy.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "871873e8-491b-4589-857a-c329cf365907", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference * random.random()\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "8af51bfc-6990-4e22-954c-a9e50c1bf3d8", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the strategy with probability 0.35\n            if random.random() < 0.35:\n                # Randomly select two individuals\n                individual1, individual2 = np.random.choice(population, size=2, replace=False)\n                # Calculate the difference between the two individuals\n                difference = individual1 - individual2\n                # Update the first individual\n                population[i] = individual1 + difference\n                # Evaluate the fitness of the updated individual\n                self.fitness_values[i] = func(population[i])\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Multi-Fidelity Exploration\" algorithm", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "d3ccdb62-de4d-4896-bd27-e7ebac0335b0", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the best solution\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                refine_indices = np.random.choice(indices[:self.harmony_size], size=int(self.population_size * self.refine_probability), replace=False)\n                new_population = population.copy()\n                for index in refine_indices:\n                    new_population[index] = population[index] + np.random.uniform(-self.bounds[1] + self.bounds[0], self.bounds[1] - self.bounds[0])\n                self.fitness_values = func(new_population)\n                self.pheromone_matrix = self.fitness_values / np.sum(self.fitness_values)\n                self.best_solution = new_population[np.argsort(self.fitness_values)[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Multi-Fidelity Exploration\" algorithm.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "1f7bd311-b01d-45aa-b8a8-2e9a655024f4", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the solution using probability-based refinement\n            if random.random() < 0.35:\n                # Select a random solution from the population\n                random_solution = population[random.randint(0, self.population_size - 1)]\n                # Calculate the difference between the current solution and the random solution\n                difference = self.best_solution - random_solution\n                # Update the current solution\n                self.best_solution = self.best_solution + difference * random.random()\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and probability-based refinement.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "3de15757-ddcd-44f3-8ac7-8652637b6056", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refinement_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the best solution with probabilistic refinement\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                if random.random() < self.refinement_probability:\n                    # Generate a new solution by perturbing the best solution\n                    new_solution = self.best_solution + np.random.uniform(-0.1, 0.1, self.dim)\n                    # Evaluate the fitness of the new solution\n                    new_fitness = func(new_solution)\n                    # Update the best solution if the new solution is better\n                    if new_fitness < self.fitness_values[indices[0]]:\n                        self.best_solution = new_solution\n                        self.fitness_values = np.zeros(self.population_size)\n                        self.fitness_values[indices[0]] = new_fitness\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and probabilistic refinement.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "d1d2aa6d-9428-4667-b816-48c8f8c65665", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refinement_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the best solution with probability 0.35\n            if random.random() < self.refinement_probability:\n                # Generate a new solution by perturbing the best solution\n                new_solution = population[indices[0]]\n                # Perturb the new solution with a small random value\n                new_solution = new_solution + random.uniform(-0.1, 0.1, self.dim)\n                # Check if the new solution has a better fitness value\n                if func(new_solution) < func(new_solution):\n                    self.best_solution = new_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and \"Probability Refinement\" for improving convergence.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "d93f1b63-6834-4a46-ae1e-296a8d0b1c25", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                updated_population = population.copy()\n                for j in range(self.population_size):\n                    if random.random() < self.refine_probability:\n                        updated_population[j] = updated_population[j] + self.bounds[1] - self.bounds[0] * difference\n                # Evaluate the fitness of the new solutions\n                new_fitness_values = func(updated_population)\n                # Update the pheromone matrix\n                for k in range(self.population_size):\n                    self.pheromone_matrix[k] = new_fitness_values[k] / np.sum(new_fitness_values)\n                # Check if the best solution has improved\n                if self.fitness_values[indices[0]] < new_fitness_values[indices[0]]:\n                    self.best_solution = updated_population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Multi-Fidelity Exploration\" algorithm.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "888bbe02-a6db-4371-8731-5da20f0eceaf", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the strategy with probabilistic refinement\n            refine_indices = np.random.choice(self.population_size, size=int(self.population_size * 0.35), replace=False)\n            refined_population = population.copy()\n            for i in refine_indices:\n                refined_solution = population[i]\n                # Randomly choose a dimension to refine\n                dim_to_refine = np.random.randint(0, self.dim)\n                # Randomly choose a step size for the dimension\n                step_size = np.random.uniform(-1, 1)\n                refined_solution[dim_to_refine] += step_size\n                # Ensure the solution stays within the bounds\n                refined_solution = np.clip(refined_solution, self.bounds[0], self.bounds[1])\n                refined_population[i] = refined_solution\n            # Evaluate the fitness of the refined solutions\n            refined_fitness_values = func(refined_population)\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = refined_fitness_values[i] / np.sum(refined_fitness_values)\n\n            # Check if the best solution has improved\n            if refined_fitness_values[indices[0]] < refined_fitness_values[indices[1]]:\n                self.best_solution = refined_population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and \"Probabilistic Refinement\" technique.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "4eae4a3d-c3d4-4ab0-b232-07fdd1817ec9", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the best solution\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                if random.random() < self.refine_probability:\n                    # Refine the best solution by changing 35% of its lines\n                    refined_solution = population[indices[0]]\n                    refined_solution[0] += random.uniform(-1, 1)\n                    refined_solution[1] += random.uniform(-1, 1)\n                    refined_solution[2] += random.uniform(-1, 1)\n                    refined_solution[3] += random.uniform(-1, 1)\n                    refined_solution[5] += random.uniform(-1, 1)\n                    refined_solution[6] += random.uniform(-1, 1)\n                    refined_solution[7] += random.uniform(-1, 1)\n                    refined_solution[9] += random.uniform(-1, 1)\n                    refined_solution[10] += random.uniform(-1, 1)\n                    refined_solution[11] += random.uniform(-1, 1)\n                    self.best_solution = refined_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Multi-Fidelity Exploration\" algorithm", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "37bce49f-7b5a-4000-a5d7-024f49b063ba", "solution": "import numpy as np\nimport random\n\nclass MultiFidelityHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution with probability 0.35\n                if random.random() < 0.35:\n                    population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n                # Evaluate the fitness of the new solutions\n                self.fitness_values = func(population)\n\n                # Update the pheromone matrix\n                for j in range(self.population_size):\n                    self.pheromone_matrix[j] = self.fitness_values[j] / np.sum(self.fitness_values)\n\n                # Check if the best solution has improved\n                if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                    self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nmulti_fidelity_harmony_search = MultiFidelityHarmonySearch(100, 5)\nbest_solution = multi_fidelity_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "MultiFidelityHarmonySearch", "description": "Novel \"Multi-Fidelity Harmony Search\" algorithm with probabilistic refinement.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "0d6e2f13-902f-444a-bd76-272a73516bf7", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                new_population = []\n                for j in range(self.population_size):\n                    if random.random() < 0.35:\n                        new_population.append(population[i] + self.bounds[1] - self.bounds[0] * difference)\n                    else:\n                        new_population.append(population[j])\n                population = np.array(new_population)\n\n                # Evaluate the fitness of the new solutions\n                self.fitness_values = func(population)\n\n                # Update the pheromone matrix\n                for k in range(self.population_size):\n                    self.pheromone_matrix[k] = self.fitness_values[k] / np.sum(self.fitness_values)\n\n                # Check if the best solution has improved\n                if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                    self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy using probability 0.35 to refine its strategy.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "8026d9be-b3b3-44c7-a1a4-3c44888af0a5", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference * np.random.choice([-1, 1], p=[0.35, 0.65])\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Probability\" algorithm with \"Multi-Fidelity\" exploration strategy.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "f13477c2-d482-4bda-8605-80ed7f110924", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refinement_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the best solution with probability 0.35\n            if random.random() < self.refinement_probability:\n                # Randomly select two individuals from the best solutions\n                individual1 = self.best_solution[np.random.choice(self.harmony_size)]\n                individual2 = self.best_solution[np.random.choice(self.harmony_size)]\n                # Calculate the difference between the two individuals\n                difference = individual1 - individual2\n                # Calculate the new individual by adding a fraction of the difference to the first individual\n                new_individual = individual1 + 0.5 * difference\n                # Replace the first individual with the new individual\n                self.best_solution = new_individual\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and \"Probability Refinement\" for improving the solution.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "3a88a8d7-611b-45bc-92a6-eef1193248ce", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the strategy with multi-fidelity exploration\n            refine_prob = 0.35\n            refine_indices = np.random.choice(self.population_size, size=int(self.population_size * refine_prob), replace=False)\n            for index in refine_indices:\n                # Select a random solution to refine\n                new_solution = population[index]\n                # Generate a new solution with a different combination of the original solution and the average harmony\n                new_solution = new_solution + np.random.uniform(-0.1, 0.1, self.dim) * (new_solution - average_harmony)\n                # Evaluate the fitness of the new solution\n                new_fitness = func(new_solution)\n                # Replace the original solution with the new solution if it has a better fitness\n                if new_fitness < self.fitness_values[index]:\n                    population[index] = new_solution\n                    self.fitness_values[index] = new_fitness\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Multi-Fidelity Exploration\" algorithm", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "2d1aa0b4-dc9c-4885-86b9-6d199ed9bc87", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.adaptive_probabilities = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the strategy with adaptive probabilities\n            for i in range(self.population_size):\n                if random.random() < self.adaptive_probabilities[i]:\n                    # Refine the current solution\n                    new_individual = population[i] + random.uniform(-self.bounds[1] + self.bounds[0], self.bounds[1] - self.bounds[0])\n                    new_individual = np.clip(new_individual, self.bounds[0], self.bounds[1])\n                    self.fitness_values[i] = func(new_individual)\n\n            # Update the adaptive probabilities\n            for i in range(self.population_size):\n                if self.fitness_values[i] < self.fitness_values[indices[i]]:\n                    self.adaptive_probabilities[i] = min(self.adaptive_probabilities[i] + 0.35, 1.0)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and adaptive probability refinement.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "2393f2ed-57ac-4bbc-b419-0c9028e356e3", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "f24b28bc-28cc-4fb3-a0b5-513b4860f789", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))\n\n# Modified code to implement multi-fidelity exploration\nclass SwarmHarmonySearchMultiFidelity:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n                # Apply multi-fidelity exploration with probability\n                if random.random() < self.probability:\n                    # Refine the current solution\n                    new_solution = population[i] + self.bounds[1] - self.bounds[0] * np.random.uniform(-1, 1, self.dim)\n                    population[i] = new_solution\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search_multi_fidelity = SwarmHarmonySearchMultiFidelity(100, 5)\nbest_solution = swarm_harmony_search_multi_fidelity(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Multi-Fidelity\" algorithm", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "b9a40dab-f2a7-4c9e-8766-eafdfc164911", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refinement_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the solutions with probability\n            refine_indices = np.random.choice(self.population_size, size=int(self.population_size * self.refinement_probability), replace=False)\n            for j in refine_indices:\n                # Calculate the fitness of the current solution\n                current_fitness = self.fitness_values[j]\n                # Calculate the fitness of the neighboring solutions\n                neighboring_fitness = self.fitness_values[(j + 1) % self.population_size]\n                # If the neighboring solution has better fitness, update the current solution\n                if neighboring_fitness < current_fitness:\n                    self.fitness_values[j] = neighboring_fitness\n                    population[j] = population[(j + 1) % self.population_size]\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and probability-based refinement.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "5a62f1d1-1a6d-44ab-affa-4c23678eed5a", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refinement_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the solutions with probability 0.35\n            for i in range(self.population_size):\n                if random.random() < self.refinement_probability:\n                    # Select a random solution to refine\n                    j = random.randint(0, self.population_size - 1)\n                    # Calculate the difference between the current solution and the selected solution\n                    difference = population[i] - population[j]\n                    # Update the current solution\n                    population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Probabilistic Refinement\" algorithm", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "2530b48f-64ee-4879-a287-20c7fc1c07b0", "solution": "import numpy as np\nimport random\n\nclass MultiFidelitySwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                new_individual = population[i] + self.bounds[1] - self.bounds[0] * difference\n                # Refine the solution with adaptive probability\n                if random.random() < self.probability:\n                    new_individual = self.refine_solution(new_individual)\n                population[i] = new_individual\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n    def refine_solution(self, individual):\n        # Refine the solution by perturbing its components\n        refined_individual = individual.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                refined_individual[i] += random.uniform(-0.1, 0.1)\n        return refined_individual\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nmulti_fidelity_swarm_harmony_search = MultiFidelitySwarmHarmonySearch(100, 5)\nbest_solution = multi_fidelity_swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "MultiFidelitySwarmHarmonySearch", "description": "Novel \"Multi-Fidelity Swarm Harmony Search\" algorithm with adaptive probability.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "486d2bde-7ae8-434a-91aa-68d40bcd7524", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the solutions using probability refinement\n            refined_population = []\n            for i in range(self.population_size):\n                if random.random() < self.probability:\n                    # Select a random solution from the current population\n                    selected_solution = population[i]\n                    # Generate a new solution by changing a random dimension\n                    new_solution = selected_solution.copy()\n                    # Choose a random dimension to change\n                    dimension_index = random.randint(0, self.dim - 1)\n                    # Change the value of the selected dimension\n                    new_solution[dimension_index] += random.uniform(-1, 1)\n                    # Ensure the new solution is within the bounds\n                    new_solution[dimension_index] = np.clip(new_solution[dimension_index], self.bounds[0], self.bounds[1])\n                    refined_population.append(new_solution)\n                else:\n                    refined_population.append(population[i])\n\n            # Update the population\n            population = refined_population\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and \"Probability Refinement\" technique.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "bf1ba9b2-fcb3-4bd4-a4a6-c7108b10dd75", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Probability-based mutation\n            mutation_probability = 0.35\n            mutated_population = population.copy()\n            for i in range(self.population_size):\n                if random.random() < mutation_probability:\n                    # Select a random dimension\n                    dimension = random.randint(0, self.dim - 1)\n                    # Generate a random mutation value\n                    mutation_value = random.uniform(-1.0, 1.0)\n                    # Apply the mutation\n                    mutated_population[i, dimension] += mutation_value\n                    # Ensure the solution is within the bounds\n                    mutated_population[i, dimension] = np.clip(mutated_population[i, dimension], self.bounds[0], self.bounds[1])\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy using probability-based mutation.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "c84707d6-b026-47f7-85d5-158f498b279c", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))\n\ndef probabilistic_line_search(func, x0, bounds, step_size=0.1, max_steps=10):\n    best_x = x0\n    best_f = func(x0)\n    for _ in range(max_steps):\n        x = best_x + step_size * np.random.uniform(-1, 1, size=len(best_x))\n        if func(x) < best_f:\n            best_x = x\n            best_f = func(x)\n    return best_x\n\ndef multi_fidelity_func(x):\n    return np.sum(x**2)\n\ndef multi_fidelity_search(func, x0, bounds, step_size=0.1, max_steps=10, prob_line_search=0.35):\n    best_x = x0\n    best_f = func(x0)\n    for _ in range(max_steps):\n        x = best_x + step_size * np.random.uniform(-1, 1, size=len(best_x))\n        if np.random.rand() < prob_line_search:\n            x = probabilistic_line_search(func, x, bounds, step_size, max_steps)\n        if func(x) < best_f:\n            best_x = x\n            best_f = func(x)\n    return best_x\n\ndef swarm_harmony_search_with_probabilistic_line_search(func, x0, bounds, step_size=0.1, max_steps=10, prob_line_search=0.35):\n    # Initialize the population with random solutions\n    population = np.random.uniform(bounds[0], bounds[1], (50, len(x0)))\n    # Evaluate the fitness of each solution\n    fitness_values = func(population)\n    # Update the pheromone matrix\n    pheromone_matrix = fitness_values / np.sum(fitness_values)\n    # Select the best solutions\n    indices = np.argsort(fitness_values)\n    best_solution = population[indices[:20]]\n    # Perform the harmony search\n    for i in range(50):\n        # Calculate the harmony memory\n        harmony_memory = pheromone_matrix[indices[:20]]\n        # Calculate the average harmony\n        average_harmony = np.mean(harmony_memory, axis=0)\n        # Calculate the difference between the current solution and the average harmony\n        difference = population[i] - average_harmony\n        # Update the current solution\n        population[i] = population[i] + step_size * difference\n        # Evaluate the fitness of the new solutions\n        fitness_values = func(population)\n        # Update the pheromone matrix\n        pheromone_matrix = fitness_values / np.sum(fitness_values)\n        # Select the best solutions\n        indices = np.argsort(fitness_values)\n        best_solution = population[indices[:20]]\n        # Check if the best solution has improved\n        if fitness_values[indices[0]] < fitness_values[indices[1]]:\n            best_solution = population[indices[0]]\n    # Refine the best solution using probabilistic line search\n    refined_solution = multi_fidelity_search(func, best_solution, bounds, step_size, max_steps, prob_line_search)\n    return refined_solution\n\n# Example usage\nbest_solution = swarm_harmony_search_with_probabilistic_line_search(multi_fidelity_func, np.array([1, 2, 3]), (-5, 5), 0.1, 10, 0.35)\nprint(\"Refined best solution:\", best_solution)\nprint(\"Refined fitness value:\", multi_fidelity_func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and \"Probabilistic Line Search\" for hyperparameter tuning.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "620d01b0-3974-408c-9e64-ee4b86d54166", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the solution with a probability of 0.35\n            if random.random() < self.refine_probability:\n                # Select a random individual from the population\n                individual = population[random.randint(0, self.population_size - 1)]\n                # Refine the individual by changing its lines with a probability of 0.35\n                refined_individual = individual.copy()\n                for j in range(self.dim):\n                    if random.random() < self.refine_probability:\n                        refined_individual[j] = individual[j] + np.random.uniform(-0.5, 0.5)\n                # Evaluate the fitness of the refined individual\n                refined_fitness = func(refined_individual)\n                # Replace the individual if the refined individual has a better fitness\n                if refined_fitness < self.fitness_values[indices[0]]:\n                    population[indices[0]] = refined_individual\n                    self.fitness_values[indices[0]] = refined_fitness\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Multi-Fidelity Exploration\" algorithm", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "7c0271a7-626d-4f91-9127-ced39a403600", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the strategy with multi-fidelity exploration\n            refine_prob = 0.35\n            if np.random.rand() < refine_prob:\n                # Select a random individual to refine\n                individual_to_refine = np.random.choice(self.population_size)\n                # Create a new individual with a random perturbation\n                new_individual = population[individual_to_refine] + np.random.uniform(-0.1, 0.1, self.dim)\n                # Ensure the new individual is within the bounds\n                new_individual = np.clip(new_individual, self.bounds[0], self.bounds[1])\n                # Evaluate the fitness of the new individual\n                new_fitness = func(new_individual)\n                # If the new individual has a better fitness, replace the original individual\n                if new_fitness < self.fitness_values[individual_to_refine]:\n                    population[individual_to_refine] = new_individual\n                    self.fitness_values[individual_to_refine] = new_fitness\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Multi-Fidelity Exploration\" algorithm", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "56388715-8569-4079-ad22-7586f73323c3", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refinement_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the strategy with probability 0.35\n            if random.random() < self.refinement_probability:\n                # Select a random individual to refine\n                individual_to_refine = population[random.randint(0, self.population_size - 1)]\n                # Generate a new solution by perturbing the individual\n                new_solution = individual_to_refine + np.random.uniform(-0.1, 0.1, self.dim)\n                # Evaluate the fitness of the new solution\n                new_fitness = func(new_solution)\n                # Replace the original individual with the new solution if it has a better fitness\n                if new_fitness < self.fitness_values[population.index(individual_to_refine)]:\n                    population[population.index(individual_to_refine)] = new_solution\n                    self.fitness_values[population.index(individual_to_refine)] = new_fitness\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and \"Probability Refinement\" to adapt the solution's strategy.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "8b8e8fe0-2bfe-4514-aa48-aa93456e3a1e", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution with probabilistic line search\n                if random.random() < self.probability:\n                    population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and probabilistic line search.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "293334eb-f99f-4022-9a7f-5de8acf8edf4", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the best solution with a probability of 0.35\n            if random.random() < self.refine_probability:\n                # Generate a new solution with a different dimension\n                new_dim = np.random.randint(1, self.dim + 1)\n                new_solution = np.random.uniform(self.bounds[0], self.bounds[1], (new_dim, ))\n                # Calculate the fitness of the new solution\n                new_fitness = func(new_solution)\n                # Update the best solution if the new solution is better\n                if new_fitness < self.fitness_values[indices[0]]:\n                    self.best_solution = new_solution\n                    self.fitness_values[indices[0]] = new_fitness\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Multi-Fidelity Exploration\" algorithm", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "8249adc3-f146-4e17-bf37-07360ce7c056", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))\n\n# Description: Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy using probability 0.35.\n# Code: \n# ```python\nimport numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution with probability 0.35\n                if random.random() < self.probability:\n                    population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "15fdc405-e290-4ccb-a291-5e5dc5ac072c", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refinement_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the best solution with adaptive probability\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                if random.random() < self.refinement_probability:\n                    # Refine the solution by changing individual lines\n                    refined_solution = self.refine_solution(population[indices[0]], self.bounds, self.dim)\n                    # Evaluate the fitness of the refined solution\n                    refined_fitness = func(refined_solution)\n                    # Update the best solution\n                    if refined_fitness < self.fitness_values[indices[0]]:\n                        self.best_solution = refined_solution\n\n    def refine_solution(self, solution, bounds, dim):\n        # Split the solution into individual lines\n        lines = solution.reshape(-1, dim)\n        # Refine each line with probability 0.35\n        refined_lines = []\n        for line in lines:\n            refined_line = line.copy()\n            for i in range(dim):\n                if random.random() < self.refinement_probability:\n                    # Change the individual line\n                    refined_line[i] = np.random.uniform(bounds[0], bounds[1])\n            refined_lines.append(refined_line)\n        # Reshape the refined solution\n        refined_solution = np.array(refined_lines).reshape(-1)\n        return refined_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Refinement\" algorithm with \"Multi-Fidelity\" exploration strategy.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "aaae7a63-95b0-4178-8519-045668bca1d6", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the strategy with probability 0.35\n            if random.random() < 0.35:\n                # Select a random individual\n                individual = population[np.random.randint(0, self.population_size)]\n                # Refine its strategy\n                new_individual = individual + (self.bounds[1] - self.bounds[0]) * np.random.uniform(-1, 1, self.dim)\n                # Evaluate the fitness of the new individual\n                new_fitness = func(new_individual)\n                # Update the best solution if the new individual has better fitness\n                if new_fitness < self.fitness_values[indices[0]]:\n                    self.best_solution = new_individual\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and \"Probability Refinement\" technique.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "8e3fc4c8-9237-4242-a925-7c7a07424361", "solution": "import numpy as np\nimport random\nimport copy\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the best solution\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n                if random.random() < self.refine_probability:\n                    # Refine the best solution by changing individual lines with probability 0.35\n                    new_solution = copy.deepcopy(self.best_solution)\n                    for j in range(self.dim):\n                        if random.random() < self.refine_probability:\n                            new_solution[j] = self.bounds[0] + (self.bounds[1] - self.bounds[0]) * random.random()\n                    self.best_solution = new_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Multi-Fidelity Exploration\" algorithm", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "5fe055f1-1840-4bf5-a552-4d4b57af93b9", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the strategy with probabilistic refinement\n            refine_prob = 0.35\n            for i in range(self.population_size):\n                if np.random.rand() < refine_prob:\n                    # Randomly select a dimension to refine\n                    dim_to_refine = np.random.randint(0, self.dim)\n                    # Generate a new value for the dimension\n                    new_value = np.random.uniform(self.bounds[0], self.bounds[1])\n                    # Update the solution\n                    population[i, dim_to_refine] = new_value\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Probabilistic Refinement\" algorithm with \"Multi-Fidelity\" exploration strategy.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "97aa2c47-a7fa-4493-9856-e0b6d8adc758", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the strategy using probability-based replacement\n            if random.random() < 0.35:\n                # Select a random solution to refine\n                refine_index = random.randint(0, self.population_size - 1)\n                # Calculate the new solution by replacing the worst solution\n                refine_solution = np.copy(population[refine_index])\n                # Calculate the new fitness value\n                refine_solution = refine_solution + self.bounds[1] - self.bounds[0] * np.random.rand(self.dim)\n                # Evaluate the fitness of the new solution\n                refine_fitness = func(refine_solution)\n                # Replace the worst solution with the new solution\n                population[refine_index] = refine_solution\n                # Update the fitness values\n                self.fitness_values[refine_index] = refine_fitness\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and probability-based refinement.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "57aa3180-5668-436e-ad2e-c0053d1402d7", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refinement_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the best solution with probabilistic refinement\n            if random.random() < self.refinement_probability:\n                # Randomly select a dimension to refine\n                dim_to_refine = random.randint(0, self.dim - 1)\n                # Generate a new solution by perturbing the best solution in the selected dimension\n                new_solution = self.best_solution.copy()\n                new_solution[dim_to_refine] += np.random.uniform(-0.1, 0.1)\n                # Evaluate the fitness of the new solution\n                new_fitness = func(new_solution)\n                # Update the best solution if the new solution has better fitness\n                if new_fitness < self.fitness_values[indices[0]]:\n                    self.best_solution = new_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and probabilistic refinement.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "4aaa2d9b-f19a-49e3-adf7-c04a315fa318", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.adaptive_probabilities = np.ones(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n                # Refine the current solution using adaptive probability\n                if random.random() < self.adaptive_probabilities[i]:\n                    # Change the individual lines of the selected solution\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    population[i] = population[indices[0]] + np.random.uniform(-1, 1, self.dim)\n                    population[i] = np.clip(population[i], self.bounds[0], self.bounds[1])\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Update the adaptive probabilities\n            self.adaptive_probabilities = self.adaptive_probabilities * 0.7 + 0.35 * np.random.uniform(0, 1, self.population_size)\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Probability\" algorithm with \"Multi-Fidelity\" exploration strategy.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "65b330c3-b5e4-4d6d-abf1-4b174ec2490c", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearchAdaptiveRefinement:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refinement_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the best solutions with adaptive probability\n            for i in range(self.harmony_size):\n                if random.random() < self.refinement_probability:\n                    # Select a random solution from the best solutions\n                    refined_solution = population[indices[i]]\n                    # Refine the solution by perturbing it randomly\n                    refined_solution += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Ensure the refined solution is within the bounds\n                    refined_solution = np.clip(refined_solution, self.bounds[0], self.bounds[1])\n                    # Evaluate the fitness of the refined solution\n                    self.fitness_values[indices[i]] = func(refined_solution)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search_adaptive_refinement = SwarmHarmonySearchAdaptiveRefinement(100, 5)\nbest_solution = swarm_harmony_search_adaptive_refinement(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearchAdaptiveRefinement", "description": "Novel \"Swarm Harmony Search with Adaptive Refinement\" algorithm", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "e640f247-a99d-4bc9-bd14-091d276c127b", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the solutions with probability 0.35\n            if random.random() < self.refine_probability:\n                for i in range(self.population_size):\n                    # Calculate the fitness values of the current solution\n                    fitness_values = func(population[i])\n                    # Calculate the indices of the top 3 solutions\n                    indices = np.argsort(fitness_values)\n                    # Select the top 3 solutions\n                    top_solutions = population[indices[:3]]\n                    # Calculate the average fitness value of the top 3 solutions\n                    average_fitness = np.mean(fitness_values[indices[:3]])\n                    # Calculate the difference between the current solution and the average fitness value\n                    difference = population[i] - average_fitness\n                    # Update the current solution\n                    population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and \"Probability Refinement\" for improving convergence.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "95f110f7-cd36-4dba-b22b-3fbc8ef12021", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refinement_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the best solution with probability\n            if random.random() < self.refinement_probability:\n                # Select two individuals to refine\n                individual1, individual2 = random.sample(population, 2)\n                # Refine the first individual\n                refined_individual1 = individual1 + self.bounds[1] - self.bounds[0] * (individual1 - self.best_solution) * random.random()\n                # Refine the second individual\n                refined_individual2 = individual2 + self.bounds[1] - self.bounds[0] * (individual2 - self.best_solution) * random.random()\n                # Replace the best solution with the refined individuals\n                self.best_solution = max(refined_individual1, refined_individual2)\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and probability-based refinement.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "d690eac4-7a7e-4a04-9bda-bed63cfb335d", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the best solution with probability 0.35\n            if random.random() < self.refine_probability:\n                # Select two solutions from the harmony size\n                indices = np.random.choice(self.harmony_size, size=2, replace=False)\n                # Select the best solution\n                best_solution = population[indices[0]]\n                # Refine the solution using the other solution\n                refined_solution = (best_solution + population[indices[1]]) / 2\n                # Update the best solution\n                self.best_solution = refined_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and probability-based refinement.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "5e7ca266-6fc0-495c-86bf-b96f700e9f10", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refinement_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the strategy with probabilistic refinement\n            for j in range(self.population_size):\n                if random.random() < self.refinement_probability:\n                    # Refine the current solution\n                    new_individual = population[j]\n                    # Generate a new solution with a different parameter\n                    for k in range(self.dim):\n                        if random.random() < 0.5:\n                            new_individual[k] = self.bounds[1] - (new_individual[k] - self.bounds[0]) * random.random()\n                        else:\n                            new_individual[k] = self.bounds[0] + (new_individual[k] - self.bounds[0]) * random.random()\n                    # Evaluate the fitness of the new solution\n                    new_fitness = func(new_individual)\n                    # Update the fitness values\n                    self.fitness_values[j] = new_fitness\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and \"Probabilistic Refinement\" for black box optimization.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "f8a7b65a-1e2a-47df-b3fb-4218e4525b1c", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refinement_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the best solution\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                # Calculate the probability of refinement\n                refinement_probability = np.random.rand()\n                if refinement_probability < self.refinement_probability:\n                    # Refine the best solution\n                    refinement_indices = np.random.choice(self.harmony_size, size=self.dim, replace=False)\n                    refinement_amount = np.random.uniform(-1, 1, self.dim)\n                    refinement_amount = refinement_amount / np.sum(np.abs(refinement_amount)) * self.bounds[1] - self.bounds[0]\n                    self.best_solution[refinement_indices] += refinement_amount\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and \"Probability Refinement\" for improving the solution.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "06672d1d-8892-4f4c-bc00-4d5d167febbe", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.adaptive_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the best solution with adaptive probability\n            if self.best_solution is not None:\n                refine_indices = np.random.choice(self.population_size, size=int(self.population_size * self.adaptive_probability), replace=False)\n                refined_population = population[refine_indices]\n                refined_fitness_values = func(refined_population)\n                refined_indices = np.argsort(refined_fitness_values)\n                self.best_solution = refined_population[refined_indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Probability\" algorithm with \"Multi-Fidelity\" exploration strategy.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "af8f9bcb-f28c-47e2-a802-27333008507e", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refine_prob = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the best solution with probabilistic refinement\n            if random.random() < self.refine_prob:\n                # Randomly select two dimensions to refine\n                dim1, dim2 = random.sample(range(self.dim), 2)\n                # Generate new values for the selected dimensions\n                new_values = np.random.uniform(self.bounds[0], self.bounds[1], 2)\n                # Update the best solution\n                self.best_solution[dim1, dim2] = new_values\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and probabilistic refinement.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "bc15748d-7084-47e6-a926-f458e2cbebf1", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                updated_population = population[i] + self.bounds[1] - self.bounds[0] * difference\n                # Randomly decide whether to refine the solution\n                if random.random() < self.refine_probability:\n                    updated_population = updated_population + self.bounds[1] - self.bounds[0] * np.random.uniform(-1, 1, size=self.dim)\n                population[i] = updated_population\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Multi-Fidelity Exploration\" algorithm", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "4f418c29-b3ed-42b6-b002-a551b7f850f0", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.adaptive_probabilities = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n                # Update the adaptive probabilities\n                self.adaptive_probabilities[i] = self.adaptive_probabilities[i] * 0.7 + 0.3 * random.random()\n                if random.random() < self.adaptive_probabilities[i]:\n                    # Refine the current solution\n                    new_solution = population[i] + random.uniform(-0.5, 0.5, self.dim)\n                    new_solution = np.clip(new_solution, self.bounds[0], self.bounds[1])\n                    population[i] = new_solution\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Multi-Fidelity\" algorithm", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "ea08c2d0-4579-4ae8-9df7-679b663b1a27", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "64c648a3-8230-49ed-8364-b689173a26b0", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the strategy with adaptive mutation\n            refine_indices = np.random.choice(self.population_size, size=int(self.budget * 0.35), replace=False)\n            for index in refine_indices:\n                # Calculate the mutation factor\n                mutation_factor = np.random.uniform(0, 1)\n                # Calculate the mutation amount\n                mutation_amount = mutation_factor * (self.bounds[1] - self.bounds[0])\n                # Calculate the new solution\n                new_solution = population[index] + mutation_amount * np.random.uniform(-1, 1, self.dim)\n                # Evaluate the fitness of the new solution\n                new_fitness = func(new_solution)\n                # Update the population\n                population[index] = new_solution\n                # Update the fitness values\n                self.fitness_values[index] = new_fitness\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Mutation\" algorithm with \"Multi-Fidelity\" exploration strategy.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "bad739a9-3af9-4bd0-80df-db9d7a09360c", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the strategy with probability 0.35\n            if random.random() < self.refine_probability:\n                # Randomly select an individual to refine\n                individual_to_refine = random.choice(population)\n                # Refine the individual by changing one dimension\n                index_to_change = random.randint(0, self.dim - 1)\n                individual_to_refine[index_to_change] += np.random.uniform(-0.5, 0.5)\n                # Evaluate the fitness of the refined individual\n                self.fitness_values = func(population)\n                # Update the pheromone matrix\n                for i in range(self.population_size):\n                    self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Multi-Fidelity Exploration\" algorithm", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "22a7e3fe-1468-41aa-b9fb-270fca17794f", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Multi-Fidelity Exploration\" algorithm", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "d183f540-b724-4cc0-8aed-649a29b9b81f", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the solution with probabilistic refinement\n            if random.random() < 0.35:\n                # Select a random solution\n                random_solution = population[np.random.choice(self.population_size)]\n                # Refine the selected solution\n                refined_solution = random_solution + np.random.uniform(-1, 1, self.dim)\n                # Check if the refined solution is within the bounds\n                if np.all(refined_solution >= self.bounds[0]) and np.all(refined_solution <= self.bounds[1]):\n                    population[i] = refined_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and \"Probabilistic\" refinement.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "33e679e2-1a37-417d-8c32-47dea88e5cca", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                new_solution = population[i] + self.bounds[1] - self.bounds[0] * difference\n                # Refine the solution with probability 0.35\n                if random.random() < self.refine_probability:\n                    new_solution = self.refine_solution(new_solution, population, self.bounds)\n                population[i] = new_solution\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n    def refine_solution(self, new_solution, population, bounds):\n        # Refine the solution by perturbing its lines\n        refined_solution = np.copy(new_solution)\n        for i in range(self.dim):\n            if random.random() < self.refine_probability:\n                refined_solution[i] += np.random.uniform(-bounds[1] - bounds[0], bounds[1] - bounds[0])\n        return refined_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nmulti_directional_harmony_search = MultiDirectionalHarmonySearch(100, 5)\nbest_solution = multi_directional_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability for refining solutions", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "c94a2f2b-ec0b-41eb-9162-e3b96b31e1d8", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n                # Perform probabilistic line search\n                if random.random() < self.probability:\n                    # Calculate the new solution\n                    new_solution = population[i] + self.bounds[1] - self.bounds[0] * difference * random.random()\n                    # Evaluate the fitness of the new solution\n                    new_fitness = func(new_solution)\n                    # Update the population if the new solution is better\n                    if new_fitness < self.fitness_values[i]:\n                        population[i] = new_solution\n                        self.fitness_values[i] = new_fitness\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and probabilistic line search.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "64bdc678-86ce-4e8e-ad13-516dc9bf2101", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.mutation_prob = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the strategy\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_prob:\n                    # Generate a new solution\n                    new_solution = population[i] + np.random.uniform(-0.5, 0.5, self.dim)\n                    # Evaluate the fitness of the new solution\n                    new_fitness = func(new_solution)\n                    # Update the fitness values\n                    self.fitness_values[i] = new_fitness\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and adaptive mutation.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "bd162a65-87ed-4bd7-91e9-8cc5756c55b2", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the solutions with probability 0.35\n            if random.random() < self.refine_probability:\n                for i in range(self.population_size):\n                    # Generate a new solution by changing a random line\n                    new_solution = population[i].copy()\n                    new_solution[random.randint(0, self.dim-1)] += random.uniform(-0.1, 0.1)\n                    # Check if the new solution is within the bounds\n                    if new_solution[0] < self.bounds[0]:\n                        new_solution[0] = self.bounds[0]\n                    if new_solution[1] > self.bounds[1]:\n                        new_solution[1] = self.bounds[1]\n                    population[i] = new_solution\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Multi-Fidelity Exploration\" algorithm", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "1cc9f180-eb75-4024-bd41-4f947f0b2252", "solution": "import numpy as np\nimport random\nimport copy\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the strategy with probability 0.35\n            if random.random() < self.refine_probability:\n                # Select a random individual from the population\n                individual = population[np.random.randint(0, self.population_size)]\n                # Refine its strategy by changing its lines with probability 0.35\n                refined_individual = copy.deepcopy(individual)\n                for j in range(self.dim):\n                    if random.random() < self.refine_probability:\n                        refined_individual[j] = (individual[j] + np.random.uniform(-1, 1)) / 2\n                # Evaluate the fitness of the refined individual\n                refined_fitness = func(refined_individual)\n                # Replace the individual with the refined one if its fitness is better\n                if refined_fitness < self.fitness_values[np.where(population == individual)[0][0]]:\n                    population[np.where(population == individual)[0][0]] = refined_individual\n                    self.fitness_values[np.where(population == individual)[0][0]] = refined_fitness\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Multi-Fidelity Exploration\" algorithm", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "6fd1e8dc-04c5-4f18-8c1e-a9d4886f3a6f", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the strategy with probabilistic refinement\n            if random.random() < 0.35:\n                # Select a random individual to refine\n                index = random.randint(0, self.population_size - 1)\n                # Refine the individual by adding a random perturbation\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                population[index] += perturbation\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Probabilistic Refinement\" algorithm", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "71a848e3-e346-4cfc-8d37-b3f85f3a81cc", "solution": "import numpy as np\nimport random\nimport functools\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))\n\n# Refine the strategy by changing individual lines with probability 0.35\ndef refine_strategy(individual, pheromone_matrix):\n    for i in range(individual.shape[0]):\n        for j in range(individual.shape[1]):\n            if random.random() < 0.35:\n                individual[i, j] = pheromone_matrix[i, j] * individual[i, j]\n    return individual\n\n# Modify the __call__ method to refine the strategy\ndef __call__(self, func):\n    for _ in range(self.budget):\n        # Initialize the population with random solutions\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n        # Evaluate the fitness of each solution\n        self.fitness_values = func(population)\n\n        # Update the pheromone matrix\n        pheromone_matrix = np.copy(self.pheromone_matrix)\n        for i in range(self.population_size):\n            pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n        # Select the best solutions\n        indices = np.argsort(self.fitness_values)\n        self.best_solution = population[indices[:self.harmony_size]]\n\n        # Perform the harmony search\n        for i in range(self.population_size):\n            # Calculate the harmony memory\n            harmony_memory = pheromone_matrix[indices[:self.harmony_size]]\n            # Calculate the average harmony\n            average_harmony = np.mean(harmony_memory, axis=0)\n            # Calculate the difference between the current solution and the average harmony\n            difference = population[i] - average_harmony\n            # Update the current solution\n            population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n        # Evaluate the fitness of the new solutions\n        self.fitness_values = func(population)\n\n        # Update the pheromone matrix\n        pheromone_matrix = np.copy(self.pheromone_matrix)\n        for i in range(self.population_size):\n            pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n        # Refine the strategy\n        refined_population = np.copy(population)\n        refined_population = refined_population * refine_strategy(refined_population, pheromone_matrix)\n\n        # Check if the best solution has improved\n        if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n            self.best_solution = refined_population[indices[0]]", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "a761463d-9707-4967-8c2c-ea11f9fae03c", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the solution with adaptive probability\n            if np.random.rand() < self.refine_probability:\n                # Calculate the fitness values of the best solutions\n                fitness_values = self.fitness_values[indices[:self.harmony_size]]\n                # Calculate the average fitness\n                average_fitness = np.mean(fitness_values)\n                # Refine the solution by changing one line at a time with probability 0.35\n                indices_to_refine = np.random.choice(indices[:self.harmony_size], size=int(self.population_size * self.refine_probability), replace=False)\n                for index in indices_to_refine:\n                    # Calculate the difference between the current solution and the average fitness\n                    difference = population[index] - average_fitness\n                    # Update the current solution\n                    population[index] = population[index] + self.bounds[1] - self.bounds[0] * difference\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and adaptive probability for refining the solution.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "50e092de-7654-4c52-b4c4-2c1056a43ff3", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.refinement_probability = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Refine the best solution with probability 0.35\n            if random.random() < self.refinement_probability:\n                # Select a random solution from the population\n                new_solution = population[np.random.choice(self.population_size, 1, replace=False)]\n                # Refine the new solution by adding a random perturbation\n                new_solution = new_solution + np.random.uniform(-self.bounds[1] - self.bounds[0], self.bounds[1] - self.bounds[0], self.dim)\n                # Evaluate the fitness of the new solution\n                new_fitness = func(new_solution)\n                # Update the pheromone matrix\n                self.pheromone_matrix[np.random.choice(self.population_size, 1, replace=False)] = new_fitness / np.sum(new_fitness)\n                # Check if the new solution is better\n                if new_fitness < self.fitness_values[indices[0]]:\n                    self.best_solution = new_solution\n                    self.fitness_values = np.array([new_fitness])\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and probability-based refinement.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "c3c26a99-2071-443a-8efb-41e4264d4c3a", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution\n                population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n            # Refine the best solution using probabilistic refinement\n            if random.random() < 0.35:\n                # Select a random dimension to refine\n                dim_to_refine = random.randint(0, self.dim-1)\n                # Generate a new solution by adding a small random perturbation to the best solution\n                new_solution = self.best_solution.copy()\n                new_solution[dim_to_refine] += random.uniform(-0.1, 0.1)\n                # Evaluate the fitness of the new solution\n                new_fitness = func(new_solution)\n                # If the new solution is better, replace the best solution\n                if new_fitness < self.fitness_values[indices[0]]:\n                    self.best_solution = new_solution\n                    self.fitness_values = new_fitness\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm with \"Multi-Fidelity\" exploration strategy and \"Probabilistic Refinement\" for improving convergence.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
{"id": "c87d5d75-5adc-4391-92a7-6aab0f37fe95", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.harmony_size = 20\n        self.pheromone_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.fitness_values = np.zeros(self.population_size)\n        self.adaptive_expansion = 0.35\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize the population with random solutions\n            population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            # Evaluate the fitness of each solution\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Select the best solutions\n            indices = np.argsort(self.fitness_values)\n            self.best_solution = population[indices[:self.harmony_size]]\n\n            # Perform the harmony search\n            for i in range(self.population_size):\n                # Calculate the harmony memory\n                harmony_memory = self.pheromone_matrix[indices[:self.harmony_size]]\n                # Calculate the average harmony\n                average_harmony = np.mean(harmony_memory, axis=0)\n                # Calculate the difference between the current solution and the average harmony\n                difference = population[i] - average_harmony\n                # Update the current solution with adaptive expansion\n                if random.random() < self.adaptive_expansion:\n                    population[i] = population[i] + self.bounds[1] - self.bounds[0] * difference\n                else:\n                    population[i] = population[i] + self.bounds[1] * np.random.uniform(-1, 1, self.dim)\n\n            # Evaluate the fitness of the new solutions\n            self.fitness_values = func(population)\n\n            # Update the pheromone matrix\n            for i in range(self.population_size):\n                self.pheromone_matrix[i] = self.fitness_values[i] / np.sum(self.fitness_values)\n\n            # Check if the best solution has improved\n            if self.fitness_values[indices[0]] < self.fitness_values[indices[1]]:\n                self.best_solution = population[indices[0]]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_harmony_search = SwarmHarmonySearch(100, 5)\nbest_solution = swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Fitness value:\", func(best_solution))", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Exploration\" algorithm.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "9efd0564-cc62-4225-99c7-d9d14f7fe1f3", "metadata": {}, "mutation_prompt": null}
