{"id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 72, in <module>\n  File \"<string>\", line 16, in __call__\n  File \"numpy/random/mtrand.pyx\", line 1171, in numpy.random.mtrand.RandomState.uniform\n  File \"_common.pyx\", line 600, in numpy.random._common.cont\n  File \"_common.pyx\", line 517, in numpy.random._common.cont_broadcast_2\n  File \"__init__.cython-30.pxd\", line 780, in numpy.PyArray_MultiIterNew3\nValueError: shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).\n.", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 72, in <module>\n  File \"<string>\", line 16, in __call__\n  File \"numpy/random/mtrand.pyx\", line 1171, in numpy.random.mtrand.RandomState.uniform\n  File \"_common.pyx\", line 600, in numpy.random._common.cont\n  File \"_common.pyx\", line 517, in numpy.random._common.cont_broadcast_2\n  File \"__init__.cython-30.pxd\", line 780, in numpy.PyArray_MultiIterNew3\nValueError: shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "d08f1fbf-630d-4bae-8879-e84c39f38016", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine strategy\n            refined_population = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                refined_individual = offspring[i]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.3:\n                        refined_individual[j] = self.bounds[j][0] + (self.bounds[j][1] - self.bounds[j][0]) * np.random.rand()\n                refined_population[i] = refined_individual\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_population])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_population[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "43a23783-becb-454a-a080-8c5014476fe1", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < self.mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "aab1e3af-889a-475b-9193-f89518f21a07", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n            # Refine the solution\n            refined_solution = self.refine_solution(selected_offspring, mutation_probabilities)\n\n        return refined_solution, self.best_fitness\n\n    def refine_solution(self, solution, mutation_probabilities):\n        refined_solution = solution.copy()\n        for i in range(len(solution)):\n            for j in range(len(solution[i])):\n                if mutation_probabilities[i, j] < 0.3:\n                    refined_solution[i, j] += np.random.uniform(-1.0, 1.0)\n        return refined_solution\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "893bec0f-8568-48f1-9611-f9b58faa0055", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Probabilistic mutation\n            mutation_indices = np.where(np.random.rand(self.population_size, self.dim) < self.mutation_prob)\n            for i in mutation_indices[0]:\n                for j in range(self.dim):\n                    offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size, crossover strategy and probabilistic mutation.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "9c41d507-3750-453a-a8ee-92c9824453dd", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.crossover_probabilities = np.zeros((self.population_size, self.population_size))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    self.crossover_probabilities[i, j] = np.random.rand()\n                if np.random.rand() < 0.5:\n                    for k in range(self.dim):\n                        selected_population[i, k], selected_population[j, k] = selected_population[j, k], selected_population[i, k]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        selected_population[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in selected_population])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = selected_population[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "a8917d5e-bddc-4186-a9c5-57edb08dcc70", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probabilities = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < self.mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Update mutation probabilities\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n            for i in range(self.population_size):\n                self.mutation_probabilities[i, selected_offspring[i, :]] += 0.1\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "82cbab1b-4626-445a-badb-6f7362d444eb", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.crossover_probabilities = np.zeros((self.population_size, self.population_size))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            for i in range(self.population_size):\n                crossover_probabilities = np.random.uniform(0.5, 1.0, size=self.population_size)\n                self.crossover_probabilities[i] = crossover_probabilities\n                if np.random.rand() < 0.3:\n                    j = np.random.choice(self.population_size)\n                    parent1, parent2 = selected_population[i], selected_population[j]\n                    offspring = np.zeros(self.dim)\n                    for k in range(self.dim):\n                        if np.random.rand() < 0.5:\n                            offspring[k] = parent1[k]\n                        else:\n                            offspring[k] = parent2[k]\n                    selected_population[i] = offspring\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        selected_population[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in selected_population])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = selected_population[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "9e8df50b-edc8-4d28-88f5-962a8bb4d735", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine strategy\n            refined_population = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < 0.3:\n                    refined_population[i] = offspring[i] + np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_population])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_population[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "33ed41e6-dcf5-4ec6-8c19-59901cea234c", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine mutation\n            refined_offspring = np.copy(offspring)\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < 0.3:\n                        refined_offspring[i, j] += np.random.uniform(-0.1, 0.1)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size, crossover strategy, and mutation refinement.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "5e57d5d6-e1a3-4784-bab1-cae136615657", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine selected solution\n            refined_solution = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                refined_solution[i] = self.refine_solution(offspring[i], func)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_solution])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_solution[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n    def refine_solution(self, solution, func):\n        # Refine the selected solution by changing 30% of its lines\n        refined_solution = solution.copy()\n        refined_solution = refined_solution * (1 - 0.3) + np.random.uniform(-0.3, 0.3, size=(self.dim))\n        return refined_solution\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "be3147ac-6730-45e2-9ebb-4eaaee9d03c4", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Refine the selected solution\n            refined_solution = selected_offspring[np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)]\n            refined_solution = refined_solution + (offspring - refined_solution) * np.random.uniform(0.0, 0.3, size=(self.population_size, self.dim))\n            refined_solution = np.clip(refined_solution, self.bounds[0], self.bounds[1])\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = refined_solution[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "6cacad37-7c50-4351-b663-abaf20ac6efa", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_refine_prob = 0.3\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_indices = np.where(np.random.uniform(0, 1, size=(self.population_size, self.dim)) < self.mutation_refine_prob)[0]\n            for i in mutation_indices:\n                for j in range(self.dim):\n                    offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size, crossover strategy and mutation refinement.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "1b5617da-2442-4f57-b287-824e1f1d0a4d", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHSRefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refinement_prob = 0.3\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine selected solution\n            refined_solution = np.zeros(self.dim)\n            refined_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            for i in refined_indices:\n                if np.random.rand() < self.refinement_prob:\n                    refined_solution = offspring[i]\n                    break\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHSRefine(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHSRefine", "description": "Novel \"Multi-Phase Adaptive Harmony Search with Refinement\" algorithm with adaptive population size, crossover strategy, and probability-based refinement.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "25b63675-f5f3-4f4b-a6d3-d4509d981973", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine solution\n            refined_offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                refined_solution = offspring[i]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.3:\n                        refined_solution[j] += np.random.uniform(-0.1, 0.1)\n                refined_offspring[i] = refined_solution\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "e0739141-e0b7-4a64-b969-0dacc532604b", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Refine selected solution\n            refined_solution = offspring[np.random.choice(self.population_size, size=1, p=self.mutation_probabilities)[0]]\n            refined_solution = refined_solution + np.random.uniform(-1.0, 1.0, size=self.dim)\n            refined_solution = np.clip(refined_solution, self.bounds[0], self.bounds[1])\n            refined_solution = refined_solution.tolist()\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "bdf22d66-f004-4b02-ad24-5cc5e4c87c4e", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.phase = 0\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n            # Update phase\n            if phase < 5:\n                self.phase += 1\n                # Adaptive mutation\n                for i in range(self.population_size):\n                    for j in range(self.dim):\n                        if np.random.rand() < 0.3:\n                            offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Prune weak individuals\n            if phase > 5:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.3:\n                        offspring[i, :] = np.random.uniform(self.bounds[0], self.bounds[1], size=self.dim)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search with Adaptive Mutation\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "0bf7317f-592a-4e87-8758-03fed555c015", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.crossover_probabilities = np.zeros((self.population_size, self.population_size))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            for i in range(self.population_size):\n                self.crossover_probabilities[i, :] = np.random.uniform(0.5, 1.0, size=self.population_size)\n                if np.random.rand() < self.crossover_probabilities[i, i]:\n                    parent1, parent2 = selected_population[i], selected_population[j]\n                    offspring = np.zeros(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() < 0.5:\n                            offspring[j] = parent1[j]\n                        else:\n                            offspring[j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in mutation_indices:\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "b22c16ef-0388-4852-a718-f5e43fb1d416", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "2037243c-93ef-40aa-af49-d790e191112f", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.phase = 0\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n            # Update phase\n            self.phase += 1\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "2e331ea2-e5ae-4042-a41a-3feb92517c97", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine the solution\n            refined_solution = np.zeros(self.dim)\n            for i in range(self.population_size):\n                refined_solution += (offspring[i] - selected_population[i]) * 0.3\n            refined_solution = np.clip(refined_solution, self.bounds[0], self.bounds[1])\n            refined_population = np.clip(refined_solution, self.bounds[0], self.bounds[1])\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_population])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_population[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "9470222e-1df0-4e7a-95ba-8ab14bac6456", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = self.refine_probabilities\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "4e37b6b2-ee12-4bd5-a36e-e97306d9e5bc", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "a222ce90-0a46-467a-93c8-b7da52163850", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine strategy\n            refine_indices = np.where(mutation_probabilities > 0.3)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if i in refine_indices:\n                        offspring[i, j] = offspring[i, j] + np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "f513bfaa-ea2b-424c-b11d-99c4ceb37dfb", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHSRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Probabilistic refinement\n            refined_indices = np.random.choice(mutation_indices, size=int(self.population_size * 0.3), replace=False)\n            refined_offspring = offspring[refined_indices]\n            refined_fitnesses = np.array([func(x) for x in refined_offspring])\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n            selected_refined_offspring = refined_offspring[np.argsort(refined_fitnesses)]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHSRefined(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHSRefined", "description": "Novel \"Multi-Phase Adaptive Harmony Search with Probabilistic Refinement\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "111cfcc8-73b9-413a-adae-3ab006dd80c0", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n            # Refine selected solution\n            refined_solution = self.refine_solution(selected_offspring, mutation_probabilities)\n            fitnesses = np.array([func(x) for x in refined_solution])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_solution[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n    def refine_solution(self, solution, mutation_probabilities):\n        refined_solution = solution.copy()\n        for i in range(len(solution)):\n            for j in range(len(solution[i])):\n                if np.random.rand() < 0.3:\n                    refined_solution[i, j] += np.random.uniform(-1.0, 1.0)\n        return refined_solution\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "05000602-ea9a-4b85-9b3d-b85d34e18061", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine strategy\n            refinement_probabilities = np.random.uniform(0.3, 0.5, size=(self.population_size, self.dim))\n            refined_offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < refinement_probabilities[i, j]:\n                        refined_offspring[i, j] = offspring[i, j] + np.random.uniform(-0.1, 0.1)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "74f43456-e0b7-4e6b-8e2c-3dbfa0f70866", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHSProbRefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refinement_probability = 0.3\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine selected solution with probability 0.3\n            refine_indices = np.random.choice(self.population_size, size=int(self.population_size * self.refinement_probability), replace=False)\n            refined_population = np.copy(selected_population)\n            for i in refine_indices:\n                refined_population[i] = offspring[i]\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_population])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_population[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHSProbRefine(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHSProbRefine", "description": "Novel \"Multi-Phase Adaptive Harmony Search with Probabilistic Refinement\" algorithm.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "0dcea1ff-5358-4a02-a9ce-2ea92b5fc4b1", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probabilities = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < self.mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluate and refine mutation probabilities\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n            for i in range(self.population_size):\n                self.mutation_probabilities[i, selected_offspring[i, 0]] += 0.3\n\n            # Evaluate and update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size, crossover strategy, and mutation refinement.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "4e3bd4d6-5d7f-43a0-9085-1e8c3b0c782d", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine solution\n            refined_population = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                refined_solution = np.copy(offspring[i])\n                for j in range(self.dim):\n                    if np.random.rand() < 0.3:\n                        refined_solution[j] = np.random.uniform(self.bounds[0][j], self.bounds[1][j])\n                refined_population[i] = refined_solution\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_population])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_population[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "5a03969d-2625-4a3d-93d2-386189ee3b42", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probabilities = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < self.mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine the solution\n            for i in range(self.population_size):\n                if np.random.rand() < 0.3:\n                    for j in range(self.dim):\n                        offspring[i, j] = (offspring[i, j] + np.random.uniform(-1.0, 1.0)) * np.random.choice([-1, 1])\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "b44ecc85-143f-44e1-b695-98ec5617ed63", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.phase = 0\n\n    def __call__(self, func):\n        for phase in range(10):\n            self.phase = phase\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Refine strategy\n            refine_indices = np.random.choice(self.population_size, size=int(self.population_size * 0.3), p=selection_probabilities)\n            for i in refine_indices:\n                for j in range(self.dim):\n                    offspring[i, j] += np.random.uniform(-0.1, 0.1)\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in mutation_indices:\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "4ba01890-5bea-43b4-b394-62a98d61b16c", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        # Refined strategy\n        refined_solution = self.best_solution.copy()\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                if np.random.rand() < 0.3:\n                    refined_solution[i, j] += np.random.uniform(-1.0, 1.0)\n        return refined_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "ef0ecd9d-6f92-4d18-9e8c-2843500f0b18", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.crossover_probabilities = np.zeros((self.population_size, self.population_size))\n        self.mutation_probabilities = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            for i in range(self.population_size):\n                self.crossover_probabilities[i, :] = np.random.uniform(0.5, 1.0, size=self.population_size)\n                crossover_indices = np.where(self.crossover_probabilities[i, :] > 0.5)[0]\n                offspring = np.zeros((self.population_size,))\n                for j in range(self.population_size):\n                    if j not in crossover_indices:\n                        parent1, parent2 = selected_population[i, :], selected_population[j, :]\n                        for k in range(self.dim):\n                            if np.random.rand() < 0.5:\n                                offspring[j] = parent1[k]\n                            else:\n                                offspring[j] = parent2[k]\n\n            # Mutation\n            for i in range(self.population_size):\n                self.mutation_probabilities[i, :] = np.random.uniform(0.1, 0.3, size=self.dim)\n                mutation_indices = np.where(self.mutation_probabilities[i, :] > 0.5)[0]\n                for j in mutation_indices:\n                    offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "1e803715-1726-41c1-9ba9-7f7c6752fed4", "solution": "import numpy as np\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refinement_prob = 0.3\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + np.random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Probabilistic refinement\n            refinement_mask = np.random.rand(self.population_size, self.dim) < self.refinement_prob\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if refinement_mask[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search with Probabilistic Refinement\" algorithm.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "134e3a04-90e8-4716-887b-5bf6405d437a", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation refinement\n            mutation_indices = np.random.choice(self.population_size, size=self.population_size, p=np.ones(self.population_size) / self.population_size)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.3:\n                    for j in range(self.dim):\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size, crossover strategy, and mutation refinement.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "f1d24d53-5cc8-478c-ad2e-cf552bd87e37", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Refine the solution\n            refine_indices = np.where(np.random.rand(self.population_size) < self.refine_prob)[0]\n            for i in refine_indices:\n                for j in range(self.dim):\n                    offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "e39b4122-0926-4240-a6f8-47e1f0451587", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.phase = 0\n\n    def __call__(self, func):\n        while self.budget > 0:\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if self.phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n            # Increase phase\n            self.phase += 1\n\n            # Decrease budget\n            self.budget -= 1\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "9eda7f83-9fc5-4b65-bafe-e18319488251", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "29e0463f-4c08-4c31-9418-e32cebd29c1a", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "b6bf91e1-c387-4e36-8282-dc64e9b82423", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_probabilities[i, i]:\n                    j = np.random.choice(self.population_size, 1)[0]\n                    parent1, parent2 = selected_population[i], selected_population[j]\n                    offspring = np.zeros((1, self.dim))\n                    for k in range(self.dim):\n                        if np.random.rand() < 0.5:\n                            offspring[0, k] = parent1[k]\n                        else:\n                            offspring[0, k] = parent2[k]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in mutation_indices:\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "9791128d-05a8-4564-858f-7495d8c30cb7", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHSRefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refinement_probabilities = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine selected solutions\n            for i in range(self.population_size):\n                if np.random.rand() < 0.3:\n                    refinement_indices = np.where(np.random.uniform(0, 1, size=(self.dim,)) < refinement_probabilities[i, :])[0]\n                    offspring[i, refinement_indices] = offspring[i, refinement_indices] + np.random.uniform(-0.5, 0.5, size=(len(refinement_indices),))\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHSRefine(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHSRefine", "description": "Novel \"Multi-Phase Adaptive Harmony Search with Probabilistic Refinement\" algorithm.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "41419c35-bc58-4b5b-a1aa-fc5e8903254b", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine the strategy of the selected solution\n            for i in range(self.population_size):\n                if np.random.rand() < 0.3:\n                    for j in range(self.dim):\n                        offspring[i, j] += np.random.uniform(-0.1, 0.1)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "b94ee625-37d7-42bc-b34e-65e514b20911", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_indices = np.where(np.random.rand(self.population_size, self.dim) < self.mutation_prob)[0]\n            for i in mutation_indices:\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy, combined with probability-based mutation.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "557ac4e0-8664-48cf-aca1-6bcff50197ce", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Refine strategy for selected solution\n            refined_solution = selected_offspring[np.random.choice(selected_indices, size=1)[0]]\n            refined_solution += np.random.uniform(-0.3, 0.3, size=self.dim)\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = refined_solution\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "1591a9e8-86f5-4c4b-b0c7-3464ec07b7b5", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Refine solution\n            refine_indices = np.random.choice(self.population_size, size=int(self.population_size * self.refine_prob), replace=False)\n            refined_offspring = np.zeros((len(refine_indices), self.dim))\n            for i in range(len(refine_indices)):\n                refined_offspring[i] = offspring[refine_indices[i]]\n            refined_fitnesses = np.array([func(x) for x in refined_offspring])\n            refined_indices = np.argsort(refined_fitnesses)\n            refined_offspring = refined_offspring[refined_indices]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        refined_offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "08597bf8-b57c-4a57-84e2-77543ee7dab8", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Refine the strategy of the selected solution\n            for i in range(self.population_size):\n                if np.random.rand() < 0.3:\n                    selected_offspring[i] += np.random.uniform(-0.1, 0.1, size=self.dim)\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "cae6a9a5-69a0-4a3b-b7cf-f1a9de362c41", "solution": "import numpy as np\nimport random\n\nclass ProbabilisticHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Probabilistic refinement\n            refinement_probabilities = np.random.uniform(0.3, 0.5, size=(self.population_size, self.dim))\n            refinement_indices = np.where(refinement_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < refinement_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = ProbabilisticHarmonySearch(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "ProbabilisticHarmonySearch", "description": "Novel \"Multi-Phase Adaptive Harmony Search with Probabilistic Refinement\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "0ab1b186-476e-411e-bd0e-92891ca2e951", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_refine_prob = 0.3\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_indices = np.where(np.random.rand(self.population_size, self.dim) < self.mutation_refine_prob)[0]\n            for i in mutation_indices:\n                for j in range(self.dim):\n                    offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size, crossover strategy and mutation refinement.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "3c4e71cc-0457-4f9b-b8b2-644b312e6a2b", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.3\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_indices = np.where(np.random.rand(self.population_size, self.dim) < self.refine_probability)\n            for i in mutation_indices:\n                for j in range(self.dim):\n                    offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "8bb6ed8d-798a-4171-8d02-2fd2068a3b0e", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHSRefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Probabilistic refinement of selected solutions\n            refinement_probabilities = np.random.uniform(0.3, 1.0, size=(self.population_size, self.dim))\n            refinement_indices = np.where(refinement_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if refinement_indices[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if mutation_indices[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHSRefine(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHSRefine", "description": "Novel \"Multi-Phase Adaptive Harmony Search with Refinement\" algorithm with adaptive population size, crossover strategy, and probabilistic refinement of selected solutions.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "adf66c81-157b-4a96-9be4-098cf428cdbb", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHSProbRefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refinement_prob = 0.3\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine solution with probability 0.3\n            refine_indices = np.random.choice(self.population_size, size=int(self.population_size * self.refinement_prob), replace=False)\n            refined_offspring = offspring[refine_indices]\n            for i in range(len(refined_offspring)):\n                for j in range(self.dim):\n                    refined_offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHSProbRefine(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHSProbRefine", "description": "Novel \"Multi-Phase Adaptive Harmony Search with Probabilistic Refinement\" algorithm", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "06fb2e63-3bd4-4b1a-92ae-c332b836811b", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine the selected solution\n            refined_solution = np.copy(selected_population)\n            for i in range(self.population_size):\n                refined_solution[i] += np.random.uniform(-0.1, 0.1, size=self.dim)\n                refined_solution[i] = np.clip(refined_solution[i], self.bounds[0], self.bounds[1])\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_solution])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_solution[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "64afd2c5-b8a3-4d50-8477-a929b20afcd8", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n        self.mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_probabilities[i, i]:\n                    parent1, parent2 = selected_population[i], selected_population[i]\n                else:\n                    parent1, parent2 = selected_population[i], selected_population[np.random.choice(self.population_size, size=1, p=selection_probabilities)[0]]\n                offspring = np.zeros(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[j] = parent1[j]\n                    else:\n                        offspring[j] = parent2[j]\n                selected_population[i] = offspring\n\n            # Mutation\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < self.mutation_probabilities[i, j]:\n                        selected_population[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in selected_population])\n            selected_indices = np.argsort(fitnesses)\n            selected_population = selected_population[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_population[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "639f2ad5-da06-40f1-92d6-614a5c5bc6f2", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probabilities = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n                        if np.random.rand() < 0.3:\n                            self.refine_probabilities[i, j] = np.random.uniform(0.1, 0.3)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size, crossover strategy and mutation refinement.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "fb0b691a-1377-4060-ab29-5d9f693752ac", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine strategy\n            for i in range(self.population_size):\n                refined_indices = np.random.choice(mutation_indices, size=int(self.population_size * 0.3), replace=False)\n                refined_offspring = offspring[refined_indices]\n                for j in range(self.population_size):\n                    offspring[i, :] = refined_offspring[j, :]\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "c010d318-d1d4-4dbc-b5fc-746369985197", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < self.mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search with Adaptive Mutation\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "70c51852-d2e7-459c-abf3-3e754e12f758", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.crossover_probabilities = np.zeros((self.population_size, self.population_size))\n        self.mutation_probabilities = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            for i in range(self.population_size):\n                self.crossover_probabilities[i, :] = np.random.uniform(0.5, 1.0, size=self.population_size)\n                self.mutation_probabilities[i, :] = np.random.uniform(0.1, 0.3, size=self.dim)\n\n            # Evaluate crossover probabilities\n            crossover_indices = np.where(self.crossover_probabilities > 0.5)[0]\n            for i in crossover_indices:\n                parent1, parent2 = selected_population[i], selected_population[crossover_indices[i][0]]\n                for j in range(self.dim):\n                    if np.random.rand() < self.mutation_probabilities[i, j]:\n                        offspring[j] = parent1[j]\n                    else:\n                        offspring[j] = parent2[j]\n\n            # Mutation\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < self.mutation_probabilities[i, j]:\n                        offspring[j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluate fitnesses\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "5107cb1b-b55b-46db-a8e2-2c68453b8f4b", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.phase = 0\n\n    def __call__(self, func):\n        for phase in range(10):\n            self.phase = phase\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "23c34f0a-665e-4ac0-bdf6-e5c68c428128", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHSProbRefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refinement_prob = 0.3\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine selected solutions with probabilistic refinement\n            refine_indices = np.where(np.random.rand(self.population_size) < self.refinement_prob)[0]\n            for i in refine_indices:\n                for j in range(self.dim):\n                    offspring[i, j] += np.random.uniform(-0.1, 0.1)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHSProbRefine(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHSProbRefine", "description": "Novel \"Multi-Phase Adaptive Harmony Search with Probabilistic Refinement\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "c4b1ce2e-054c-4f1a-902f-ee0664814303", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[i], selected_population[(i + 1) % self.population_size]\n                crossover_indices = np.where(self.crossover_probabilities[i] > 0.5)[0]\n                offspring = np.zeros((self.dim,))\n                for j in crossover_indices:\n                    if np.random.rand() < 0.5:\n                        offspring[j] = parent1[j]\n                    else:\n                        offspring[j] = parent2[j]\n                selected_population[i] = offspring\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        selected_population[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in selected_population])\n            selected_indices = np.argsort(fitnesses)\n            selected_population = selected_population[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_population[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "034fc058-7c75-4800-9045-f5b2f2d5be2a", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.phase = 0\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n            # Refine the strategy\n            if self.phase < 5:\n                refined_population = np.zeros((self.population_size, self.dim))\n                for i in range(self.population_size):\n                    refined_individual = self.best_solution[i]\n                    for j in range(self.dim):\n                        if np.random.rand() < 0.3:\n                            refined_individual[j] += np.random.uniform(-1.0, 1.0)\n                    refined_population[i] = refined_individual\n                refined_fitnesses = np.array([func(x) for x in refined_population])\n                refined_indices = np.argsort(refined_fitnesses)\n                refined_offspring = refined_population[refined_indices]\n                fitnesses = refined_fitnesses\n                selected_indices = refined_indices\n\n            self.phase += 1\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "6424dc86-5556-49e0-a59f-570fef7b63ef", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHSProbRefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Probabilistic refinement\n            refinement_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            refinement_indices = np.where(refinement_probabilities > 0.5)[0]\n            for i in refinement_indices:\n                for j in range(self.dim):\n                    if np.random.rand() < refinement_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in mutation_indices:\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHSProbRefine(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHSProbRefine", "description": "Novel \"Multi-Phase Adaptive Harmony Search with Probabilistic Refinement\" algorithm", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "4f4be27e-337f-47df-9a19-6531cb4dc52c", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHSRefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Refinement\n            refinement_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            refined_offspring = np.copy(offspring)\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < refinement_probabilities[i, j]:\n                        refined_offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHSRefine(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHSRefine", "description": "Novel \"Multi-Phase Adaptive Harmony Search with Refinement\" algorithm with adaptive population size, crossover strategy, and probability-based refinement.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "4e6b116a-8a1f-4947-b7ed-8e97c1930213", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHSRefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Probabilistic refinement\n            refined_offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < 0.3:\n                    refined_offspring[i] = offspring[i] + np.random.uniform(-0.1, 0.1, size=self.dim)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHSRefine(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHSRefine", "description": "Novel \"Multi-Phase Adaptive Harmony Search with Probabilistic Refinement\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "a78b7bea-0f22-4446-b2c7-74315f9b0ad6", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probabilities = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine the selected solution\n            refined_solution = np.copy(selected_population)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.3:\n                    refined_solution[i] += np.random.uniform(-1.0, 1.0)\n            refined_fitnesses = np.array([func(x) for x in refined_solution])\n            refined_indices = np.argsort(refined_fitnesses)\n            refined_solution = refined_solution[refined_indices]\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "a64943d7-135a-4381-b37e-d5df0b9c5491", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation refinement\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in mutation_indices:\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size, crossover strategy, and mutation refinement.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "53cdb556-bf5b-4113-8991-eaaf005dfe98", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.crossover_probabilities = np.zeros((self.population_size, self.population_size))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            for i in range(self.population_size):\n                crossover_indices = np.where(np.random.rand(self.population_size) < self.crossover_probabilities[i, :])[0]\n                if len(crossover_indices) > 0:\n                    parent1, parent2 = selected_population[crossover_indices[0]], selected_population[crossover_indices[1]]\n                    offspring = np.zeros((self.dim,))\n                    for j in range(self.dim):\n                        if np.random.rand() < 0.5:\n                            offspring[j] = parent1[j]\n                        else:\n                            offspring[j] = parent2[j]\n                    selected_population[i] = offspring\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in mutation_indices:\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        selected_population[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in selected_population])\n            selected_indices = np.argsort(fitnesses)\n            selected_population = selected_population[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_population[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "bd3339d6-f68d-45ee-a7a6-bff753670922", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine strategy\n            refine_indices = np.random.choice(self.population_size, size=int(self.population_size * 0.3), p=mutation_probabilities)\n            refined_offspring = np.zeros((len(refine_indices), self.dim))\n            for i, index in enumerate(refine_indices):\n                refined_offspring[i] = offspring[index]\n                for j in range(self.dim):\n                    refined_offspring[i, j] += np.random.uniform(-0.3, 0.3)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "dc806016-1754-4172-94ea-0f969a699971", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine selected solution\n            for i in range(self.population_size):\n                if np.random.rand() < self.refine_prob:\n                    refine_indices = np.random.choice(self.dim, size=1)\n                    offspring[i, refine_indices] += np.random.uniform(-0.1, 0.1)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "18d5f13c-dbd7-473a-a3d9-87d1ba54c900", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.phase = 0\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine selected solution\n            refined_population = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < 0.3:\n                    refined_population[i] = offspring[i] + np.random.uniform(-1.0, 1.0, size=self.dim)\n                else:\n                    refined_population[i] = offspring[i]\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_population])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_population[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n            self.phase += 1\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "280d0430-e7f4-46c5-8f5e-10ca93bf2f6c", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n            # Refine the selected solution\n            refined_solution = self.refine_solution(selected_offspring, mutation_probabilities)\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = refined_solution\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n    def refine_solution(self, solution, mutation_probabilities):\n        refined_solution = solution.copy()\n        for i in range(len(solution)):\n            for j in range(len(solution[0])):\n                if np.random.rand() < 0.3:\n                    refined_solution[i, j] += np.random.uniform(-1.0, 1.0)\n        return refined_solution\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "b64acc81-77ad-42c2-bc11-e9a9605d0e08", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "d87deea2-1570-4474-bcdf-2c703eff8a3c", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine strategy\n            refined_population = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                refined_solution = np.copy(offspring[i])\n                for j in range(self.dim):\n                    if np.random.rand() < 0.3:\n                        refined_solution[j] += np.random.uniform(-1.0, 1.0)\n                refined_population[i] = refined_solution\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_population])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_population[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "84e1a781-c91b-4bb4-95f4-d7d24293b717", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine the selected solution\n            refine_indices = np.random.choice(self.population_size, size=int(self.population_size * self.refine_prob), replace=False)\n            refined_offspring = offspring[refine_indices]\n            fitnesses = np.array([func(x) for x in refined_offspring])\n            selected_indices = np.argsort(fitnesses)\n            refined_offspring = refined_offspring[selected_indices]\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "aae24e63-9dd0-4fcc-ac10-bdcd575f5d9f", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.crossover_probabilities = np.zeros((self.population_size, self.population_size))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            for i in range(self.population_size):\n                crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size,))\n                self.crossover_probabilities[i] = crossover_probabilities\n                if np.random.rand() < 0.3:\n                    j = np.random.randint(0, self.population_size)\n                    parent1, parent2 = selected_population[i], selected_population[j]\n                    for k in range(self.dim):\n                        if np.random.rand() < self.crossover_probabilities[i, j]:\n                            offspring = parent1.copy()\n                            offspring[k] = parent2[k]\n                            selected_population[i] = offspring\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        selected_population[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in selected_population])\n            selected_indices = np.argsort(fitnesses)\n            selected_population = selected_population[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_population[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "5d462e3f-963e-411c-b1df-3d071c93883a", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probabilities = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < self.mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Update mutation probabilities\n            for i in range(self.population_size):\n                fitness = func(offspring[i])\n                if fitness < self.best_fitness:\n                    self.mutation_probabilities[i] = 0.3\n                else:\n                    self.mutation_probabilities[i] = np.random.uniform(0.1, 0.3)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy, combined with a new mutation strategy.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "1ea77fe6-9255-435d-a86d-9a6a17130574", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine the selected solution\n            refined_solution = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                refined_solution[i] = self.fine_tune(offspring[i], func)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_solution])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_solution[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n    def fine_tune(self, solution, func):\n        for _ in range(int(self.budget * 0.1)):\n            # Random perturbation\n            perturbation = np.random.uniform(-1.0, 1.0, size=self.dim)\n            solution += perturbation\n\n            # Evaluation\n            fitness = func(solution)\n            if fitness < func(solution):\n                solution -= perturbation\n        return solution\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "ee48a957-4689-460f-95c3-ca4fe82cbb19", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.phase = 0\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n            # Phase update\n            if phase < 5:\n                # Refine strategy\n                refined_population = selected_offspring[np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)]\n                refined_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n                refined_offspring = refined_population[refined_indices]\n                for i in range(self.population_size):\n                    for j in range(self.dim):\n                        if np.random.rand() < 0.3:\n                            refined_offspring[i, j] += np.random.uniform(-1.0, 1.0)\n            else:\n                # Final evaluation\n                final_indices = np.argsort(fitnesses)\n                final_offspring = offspring[final_indices]\n\n            # Update population\n            population = np.vstack((population, final_offspring))\n            fitnesses = np.hstack((fitnesses, np.array([func(x) for x in final_offspring])))\n            self.phase += 1\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "bcc314f6-bf0f-4398-aa8a-f3445c5185ad", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_probabilities[i]:\n                    parent1, parent2 = selected_population[i], selected_population[(i+1)%self.population_size]\n                    offspring = np.zeros(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() < 0.5:\n                            offspring[j] = parent1[j]\n                        else:\n                            offspring[j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in mutation_indices:\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "61daa3db-d000-4bf6-b0de-b7738e126f14", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.3:\n                    for j in range(self.dim):\n                        offspring[i, j] += np.random.uniform(-0.1, 0.1)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "7dc43c0f-6bff-451c-9705-8a52090f5050", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "4d1aaf5b-647b-49f1-a5be-24eb69cc05d6", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation refinement\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in mutation_indices:\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-0.3, 0.3)  # Refine mutation by changing individual lines\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size, crossover strategy and mutation refinement.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "21b7bef1-6067-4c39-8509-3d6d2cace6f9", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHSProbRefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Probability refinement\n            refined_indices = np.random.choice(self.population_size, size=self.population_size, p=mutation_probabilities)\n            refined_population = offspring[refined_indices]\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_population])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_population[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHSProbRefine(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHSProbRefine", "description": "Novel \"Multi-Phase Adaptive Harmony Search with Probability Refinement\" algorithm", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "d2a7b3e6-0d56-42f4-8136-642ea1023978", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine solution\n            refined_solution = np.copy(offspring)\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < 0.3:\n                        refined_solution[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_solution])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_solution[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "8ac3213f-46c2-419f-a40a-908b98af1d56", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.phase = 0\n\n    def __call__(self, func):\n        for phase in range(10):\n            if phase == self.phase:\n                break\n\n            self.phase = phase\n\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine strategy\n            refine_indices = np.random.choice(self.population_size, size=int(self.population_size * 0.3), replace=False)\n            for i in refine_indices:\n                for j in range(self.dim):\n                    offspring[i, j] += np.random.uniform(-0.1, 0.1)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "69ac35b2-ac69-45a6-80c3-cf02624d9057", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHSProbRefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Probabilistic refinement\n            refinement_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            refinement_indices = np.where(refinement_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if refinement_indices[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if mutation_indices[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHSProbRefine(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHSProbRefine", "description": "Novel \"Multi-Phase Adaptive Harmony Search with Probabilistic Refinement\" algorithm that combines adaptive population size, crossover strategy, and probabilistic refinement to optimize black box functions.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "9aa803e1-0529-4a67-b508-4452f8ce725b", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probabilities = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_indices = np.where(self.mutation_probabilities > 0.3)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if i in mutation_indices[j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Update mutation probabilities\n            self.mutation_probabilities = np.where(self.mutation_probabilities > 0.3, 0.3, 0.1)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "df17359b-f8e1-4853-a06a-6fcf18329bb5", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine the selected solution\n            refined_solution = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                refined_solution[i] = offspring[i] + 0.3 * (offspring[i] - self.best_solution)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_solution])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_solution[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "20e81c63-ffcb-456b-95cc-9029958c29ff", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.phase = 0\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine solution\n            refined_solution = np.copy(offspring)\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < 0.3:\n                        refined_solution[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_solution])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_solution[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search with Adaptive Mutation\" algorithm with adaptive population size, crossover strategy, and mutation.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "f60fae3b-1520-450e-80ea-627b4df2ec28", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHSRefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refinement_prob = 0.3\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine selected solutions\n            refined_population = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.refinement_prob:\n                    refined_population[i] = offspring[i] + (offspring[i] - selected_population[i]) * np.random.uniform(0, 1)\n                else:\n                    refined_population[i] = offspring[i]\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_population])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_population[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHSRefine(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHSRefine", "description": "Novel \"Multi-Phase Adaptive Harmony Search with Refinement\" algorithm that combines adaptive population size, crossover strategy, and refinement of selected solutions.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "b6349682-fd03-423c-a132-8a1c0640ac4c", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine the selected solution\n            refined_solution = np.copy(selected_population[np.argmin(fitnesses)])\n            for j in range(self.dim):\n                if np.random.rand() < 0.3:\n                    refined_solution[j] += np.random.uniform(-0.1, 0.1)\n            refined_solution = np.clip(refined_solution, self.bounds[0], self.bounds[1])\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy, combined with a mutation strategy that refines the selected solution.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "3c210567-50cf-4d46-914c-1b0609c4af08", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine solution\n            for i in range(self.population_size):\n                refined_indices = np.where(np.abs(offspring[i]) > 0.3)[0]\n                if len(refined_indices) > 0:\n                    for j in refined_indices:\n                        offspring[i, j] = np.sign(offspring[i, j]) * np.maximum(np.abs(offspring[i, j]) - 0.3, 0.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "0d5b01b7-6df3-4b77-b916-e81a95e51cd8", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine strategy for selected solution\n            refined_solution = np.copy(selected_population)\n            for _ in range(int(self.population_size * 0.3)):\n                i = np.random.randint(0, self.population_size)\n                j = np.random.randint(0, self.dim)\n                refined_solution[i, j] += np.random.uniform(-1.0, 1.0)\n                refined_solution[i, j] = np.clip(refined_solution[i, j], self.bounds[0][j], self.bounds[1][j])\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_solution])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_solution[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "a3d5d978-85e0-4ede-a261-f453a931aa06", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < self.mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "7bb9d5c6-0e64-49d4-a363-996e8a5f87ed", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation refinement\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < self.mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size, crossover strategy, and mutation refinement.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "ebf1c9f5-2757-4127-ac71-7f16ef1cdbe5", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Probabilistic Refinement\n            refinement_probabilities = np.random.uniform(0.3, 0.6, size=(self.population_size, self.dim))\n            refinement_indices = np.where(refinement_probabilities > 0.5)[0]\n            for i in refinement_indices:\n                for j in range(self.dim):\n                    if np.random.rand() < refinement_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in mutation_indices:\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search with Probabilistic Refinement\" algorithm.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "cec6435c-1e9c-401a-a01a-fa94dda9dae2", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine the selected solution\n            refined_solution = np.copy(selected_population)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.3:\n                    refined_solution[i] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in refined_solution])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = refined_solution[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "a32d58e6-d609-425a-901f-c22567862f97", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probabilities = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for phase in range(10):\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n            fitnesses = np.array([func(x) for x in population])\n\n            # Selection\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Mutation\n            mutation_probabilities = self.mutation_probabilities\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Refine the solution with probability 0.3\n            refine_probabilities = np.random.uniform(0.0, 0.3, size=(self.population_size, self.dim))\n            refine_indices = np.where(refine_probabilities > 0.0)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if refine_indices[i, j] > 0:\n                        offspring[i, j] = offspring[i, j] + np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
{"id": "31df8e3c-c2d7-46fe-88c3-7c9095070c9a", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(budget * 0.2)\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.phase = 0\n\n    def __call__(self, func):\n        while self.budget > 0:\n            # Initialize population\n            population = np.random.uniform(self.bounds[0], self.bounds[1], size=(self.population_size, self.dim))\n\n            # Selection\n            fitnesses = np.array([func(x) for x in population])\n            selection_probabilities = fitnesses / np.sum(fitnesses)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=selection_probabilities)\n            selected_population = population[selected_indices]\n\n            # Adaptation\n            if self.phase < 5:\n                # Adaptive population size\n                new_population_size = int(self.population_size * 0.9 + random.uniform(0.1, 0.3))\n                selected_indices = np.random.choice(self.population_size, size=new_population_size, p=selection_probabilities)\n                selected_population = selected_population[selected_indices]\n                self.population_size = new_population_size\n\n            # Crossover\n            crossover_probabilities = np.random.uniform(0.5, 1.0, size=(self.population_size, self.population_size))\n            crossover_indices = np.where(crossover_probabilities > 0.5)[0]\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = selected_population[crossover_indices[i][0]], selected_population[crossover_indices[i][1]]\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        offspring[i, j] = parent1[j]\n                    else:\n                        offspring[i, j] = parent2[j]\n\n            # Refine the strategy\n            refine_probabilities = np.random.uniform(0.3, 1.0, size=(self.population_size, self.dim))\n            refine_indices = np.where(refine_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < refine_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Mutation\n            mutation_probabilities = np.random.uniform(0.1, 0.3, size=(self.population_size, self.dim))\n            mutation_indices = np.where(mutation_probabilities > 0.5)[0]\n            for i in range(self.population_size):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i, j]:\n                        offspring[i, j] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluation\n            fitnesses = np.array([func(x) for x in offspring])\n            selected_indices = np.argsort(fitnesses)\n            selected_offspring = offspring[selected_indices]\n\n            # Update best solution\n            if np.min(fitnesses) < self.best_fitness:\n                self.best_solution = selected_offspring[np.argmin(fitnesses)]\n                self.best_fitness = np.min(fitnesses)\n\n            # Increment phase\n            self.phase += 1\n            self.budget -= 1\n\n        return self.best_solution, self.best_fitness\n\n# Example usage:\nif __name__ == \"__main__\":\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    optimizer = MultiPhaseAdaptiveHS(budget, dim)\n    best_solution, best_fitness = optimizer(func)\n    print(\"Best solution:\", best_solution)\n    print(\"Best fitness:\", best_fitness)", "name": "MultiPhaseAdaptiveHS", "description": "Novel \"Multi-Phase Adaptive Harmony Search\" algorithm with adaptive population size and crossover strategy.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "1f3ba0a4-04de-4a45-b2f9-a5616fb5714a", "metadata": {}, "mutation_prompt": null}
