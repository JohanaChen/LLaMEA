{"id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "solution": "", "name": "", "description": "", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "No code was extracted.", "error": "", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "81b9c368-24bc-494c-bf64-3b57ed829a70", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_probability = 0.1\n        self.crossover_probability = 0.7\n        self.mutator = random.Random()\n\n    def __call__(self, func):\n        # Initialize the population with random points in the search space\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        # Run the differential evolution algorithm\n        for _ in range(self.budget):\n            # Evaluate the fitness of each point in the population\n            fitness = [func(point) for point in population]\n\n            # Select the fittest points\n            fittest_points = np.array(population[np.argsort(fitness)])\n\n            # Perform crossover and mutation\n            new_population = []\n            for i in range(self.population_size):\n                # Select two parents\n                parent1 = fittest_points[i]\n                parent2 = fittest_points[self.mutator.randint(0, self.population_size - 1)]\n\n                # Perform crossover\n                child = parent1 + (parent2 - parent1) * self.crossover_probability\n\n                # Perform mutation\n                if self.mutator.random() < self.mutation_probability:\n                    child += np.random.uniform(-0.1, 0.1, self.dim)\n\n                new_population.append(child)\n\n            # Replace the old population with the new one\n            population = np.array(new_population)\n\n        # Return the best point in the final population\n        return np.min(population, axis=0)\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 5\nhe = HybridEvolutionaryAlgorithm(budget, dim)\n\nbest_point = he(func)\nprint(\"Best point:\", best_point)", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm (HEA) with probability-based mutation and crossover.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "f77ffd91-7ba8-472d-9c82-bc12d17498ef", "solution": "import numpy as np\nimport random\n\nclass ProbabilisticAdaptiveEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.population = self.initialize_population()\n        self.score = self.evaluate_population()\n\n    def initialize_population(self):\n        return [self.sample_uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)]\n\n    def sample_uniform(self, lower, upper, dim):\n        return np.random.uniform(lower, upper, dim)\n\n    def evaluate_population(self):\n        scores = []\n        for individual in self.population:\n            score = self.func(individual)\n            scores.append(score)\n        return np.mean(scores)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            best_individual = self.population[np.argmax(self.score)]\n            new_population = []\n            for _ in range(self.population_size):\n                if random.random() < 0.3:\n                    new_individual = self.sample_uniform(-5.0, 5.0, self.dim)\n                    new_population.append(new_individual)\n                else:\n                    new_individual = best_individual\n                    new_population.append(new_individual)\n            self.population = new_population\n            self.score = self.evaluate_population()\n\n    def select_solution(self):\n        # Select the best individual in the population\n        best_individual = self.population[np.argmax(self.score)]\n        return best_individual\n\n# Example usage\nfunc = lambda x: x[0]**2 + x[1]**2\nevolution = ProbabilisticAdaptiveEvolution(budget=100, dim=2)\nevolution(func)\nselected_solution = evolution.select_solution()\nprint(selected_solution)", "name": "ProbabilisticAdaptiveEvolution", "description": "Novel probabilistic adaptive evolution algorithm", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ProbabilisticAdaptiveEvolution' object has no attribute 'func'\").", "error": "AttributeError(\"'ProbabilisticAdaptiveEvolution' object has no attribute 'func'\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "96bfe434-dca0-4953-ae83-0da449c95221", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass DEAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x0 = np.random.uniform(-5.0, 5.0, size=(budget, dim))\n        self.f_best = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            res = differential_evolution(func, [(-5.0, 5.0)] * self.dim)\n            self.x0 = np.vstack((self.x0, res.x))\n            self.f_best = min(self.f_best, res.fun)\n            if np.random.rand() < 0.3:\n                idx = np.random.randint(0, self.budget)\n                self.x0[idx] = res.x\n                self.f_best = min(self.f_best, res.fun)\n        return self.x0, self.f_best\n\n# Example usage\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nbudget = 100\ndim = 2\nsolver = DEAdaptive(budget, dim)\nx_opt, f_opt = solver(func)\nprint(f\"Optimal solution: x = {x_opt}, f(x) = {f_opt}\")", "name": "DEAdaptive", "description": "Novel \"Differential Evolution with Adaptive Probability\" algorithm for black box optimization", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "c6a4de43-5d09-468b-a9ef-ac5da60a9001", "solution": "import numpy as np\n\nclass PBEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population = self.initialize_population()\n        self.fitness = self.evaluate_fitness()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.budget):\n            x = np.random.uniform(-5.0, 5.0, self.dim)\n            population.append(x)\n        return population\n\n    def evaluate_fitness(self):\n        fitness = np.zeros(self.budget)\n        for i, x in enumerate(self.population):\n            fitness[i] = func(x)\n        return fitness\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Select parents using probability-based selection\n            parents = np.random.choice(self.population, size=self.dim, replace=False, p=self.fitness / np.sum(self.fitness))\n            # Perform crossover and mutation\n            offspring = []\n            for _ in range(self.dim):\n                parent1, parent2 = np.random.choice(parents, size=2, replace=False)\n                child = (parent1 + parent2) / 2 + np.random.uniform(-0.5, 0.5, self.dim)\n                offspring.append(child)\n            # Evaluate fitness of offspring\n            fitness_offspring = np.zeros(self.dim)\n            for i, x in enumerate(offspring):\n                fitness_offspring[i] = func(x)\n            # Update population and fitness\n            self.population = np.concatenate((self.population, offspring))\n            self.fitness = np.concatenate((self.fitness, fitness_offspring))\n            # Replace worst individual with the best one\n            self.population = self.population[np.argsort(self.fitness)]\n            self.fitness = self.fitness[np.argsort(self.fitness)]\n\n# Example usage:\nbudget = 100\ndim = 10\npbea = PBEA(budget, dim)\npbea(func)", "name": "PBEA", "description": "Novel \"Probability-Based Evolutionary Algorithm\" for black box optimization", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "c49215ae-e758-4deb-b71f-b1c3ec5cb75f", "solution": "import numpy as np\nimport random\n\nclass PAHEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.population = []\n        self.fitness = []\n        self.best_solution = None\n        self.best_score = -np.inf\n\n    def __call__(self, func):\n        # Initialize population with random solutions\n        for _ in range(self.population_size):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            self.population.append(solution)\n            self.fitness.append(func(solution))\n\n        # Evaluate the fitness of each solution\n        for i in range(self.population_size):\n            self.fitness[i] = -self.fitness[i]  # Use negative fitness for maximization problems\n\n        # Select parents using tournament selection\n        parents = []\n        for _ in range(self.population_size):\n            tournament_size = 5\n            tournament = random.sample(range(self.population_size), tournament_size)\n            winner = max(tournament, key=lambda i: self.fitness[i])\n            parents.append(self.population[winner])\n\n        # Apply probability-adaptive mutation\n        for _ in range(self.population_size):\n            if random.random() < 0.3:\n                mutation_rate = random.random()\n                if mutation_rate < 0.5:\n                    # Swap two random components of the solution\n                    i, j = random.sample(range(self.dim), 2)\n                    parents[_][i], parents[_][j] = parents[_][j], parents[_][i]\n\n        # Apply hybrid evolution\n        for _ in range(self.budget - self.population_size):\n            # Select parents using tournament selection\n            parents = []\n            for _ in range(self.population_size):\n                tournament_size = 5\n                tournament = random.sample(range(self.population_size), tournament_size)\n                winner = max(tournament, key=lambda i: self.fitness[i])\n                parents.append(self.population[winner])\n\n            # Apply crossover\n            offspring = []\n            for _ in range(self.population_size):\n                parent1, parent2 = random.sample(parents, 2)\n                crossover_point = random.randint(1, self.dim - 1)\n                child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                offspring.append(child)\n\n            # Apply mutation\n            for _ in range(self.population_size):\n                if random.random() < 0.3:\n                    mutation_rate = random.random()\n                    if mutation_rate < 0.5:\n                        # Swap two random components of the solution\n                        i, j = random.sample(range(self.dim), 2)\n                        offspring[_][i], offspring[_][j] = offspring[_][j], offspring[_][i]\n\n            # Replace the worst solution with the new offspring\n            worst_solution = min(offspring, key=lambda x: self.fitness[self.fitness.index(min(self.fitness))])\n            self.population[self.fitness.index(worst_solution)] = worst_solution\n\n        # Update the best solution\n        self.best_solution = max(self.population, key=lambda x: self.fitness[self.fitness.index(max(self.fitness))])\n        self.best_score = -self.fitness[self.fitness.index(max(self.fitness))]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\npahea = PAHEA(100, 10)\npahea(func)", "name": "PAHEA", "description": "Novel \"Probability-Adaptive Hybrid Evolutionary Algorithm\" (PAHEA) for black box optimization", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "28f38ce1-1753-4a95-9718-b16655b60546", "solution": "import numpy as np\nimport random\n\nclass PAEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.population = self.initialize_population()\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.5\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = [random.uniform(-5.0, 5.0) for _ in range(self.dim)]\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        self.fitnesses = [func(individual) for individual in self.population]\n        self.population = self.select_population()\n        self.mutate()\n        self.crossover()\n\n    def select_population(self):\n        fitnesses = np.array(self.fitnesses)\n        probabilities = fitnesses / np.sum(fitnesses)\n        selected_indices = np.random.choice(len(self.population), size=self.population_size, p=probabilities, replace=False)\n        selected_population = [self.population[i] for i in selected_indices]\n        return selected_population\n\n    def mutate(self):\n        for i in range(self.population_size):\n            if random.random() < self.mutation_rate:\n                index = random.randint(0, self.dim - 1)\n                self.population[i][index] += random.uniform(-1.0, 1.0)\n\n    def crossover(self):\n        for i in range(self.population_size):\n            if random.random() < self.crossover_rate:\n                parent1 = self.population[i]\n                parent2 = random.choice(self.population)\n                child1 = parent1[:self.dim//2] + [random.uniform(-5.0, 5.0) for _ in range(self.dim//2)]\n                child2 = parent2[:self.dim//2] + [random.uniform(-5.0, 5.0) for _ in range(self.dim//2)]\n                self.population[i] = child1\n                self.population[i + self.population_size // 2] = child2\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n        return self.population[np.argmin(self.fitnesses)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\npaea = PAEA(budget=100, dim=10)\nbest_individual = paea(func)\nprint(best_individual)", "name": "PAEA", "description": "Novel \"Probability-Adaptive Evolutionary Algorithm\" (PAEA) with adaptive mutation and crossover.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'list' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'list' and 'int'\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "145c7589-e8a8-45b2-80f7-137dfc6b4e0a", "solution": "import numpy as np\n\nclass ProbabilityPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population = []\n        self.best_solution = None\n        self.best_score = -np.inf\n\n    def __call__(self, func):\n        # Initialize population with random solutions\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            self.population.append(solution)\n\n        # Evaluate population\n        scores = [func(solution) for solution in self.population]\n\n        # Update best solution\n        self.best_solution = np.argmax(scores)\n        self.best_score = scores[self.best_solution]\n\n        # Perturb solutions based on probability\n        perturbed_population = []\n        for i in range(self.budget):\n            if np.random.rand() < 0.3:\n                # Perturb x-axis\n                perturbation = np.random.uniform(-1.0, 1.0)\n                perturbed_population.append(self.population[i] + perturbation)\n            else:\n                perturbed_population.append(self.population[i])\n\n        # Replace worst solution with perturbed solution\n        scores = [func(solution) for solution in perturbed_population]\n        worst_index = np.argmin(scores)\n        self.population[worst_index] = perturbed_population[worst_index]\n\n        # Evaluate perturbed population\n        scores = [func(solution) for solution in self.population]\n\n        # Update best solution\n        self.best_solution = np.argmax(scores)\n        self.best_score = scores[self.best_solution]\n\n# Test the algorithm\nbudget = 100\ndim = 10\nfunc = lambda x: np.sum([i**2 for i in x])  # Example black box function\noptimizer = ProbabilityPerturbation(budget, dim)\noptimizer(func)\nprint(optimizer.best_solution)\nprint(optimizer.best_score)", "name": "ProbabilityPerturbation", "description": "Novel \"Probability Perturbation\" metaheuristic algorithm", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "07120e53-ce17-4e08-97c2-9dcdecf128aa", "solution": "import numpy as np\nimport random\nimport operator\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.elitism_rate = 0.1\n        self.elite_size = 10\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            population.append(individual)\n        return population\n\n    def fitness(self, individual):\n        return func(individual)\n\n    def evaluate(self):\n        fitnesses = [self.fitness(individual) for individual in self.population]\n        sorted_indices = np.argsort(fitnesses)\n        self.population = [self.population[i] for i in sorted_indices]\n        if len(self.population) > self.elite_size:\n            self.population = self.population[:self.elite_size]\n\n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            child = [0] * self.dim\n            for i in range(self.dim):\n                if random.random() < 0.5:\n                    child[i] = parent1[i]\n                else:\n                    child[i] = parent2[i]\n            return child\n        else:\n            return parent1\n\n    def mutation(self, individual):\n        if random.random() < self.mutation_rate:\n            index = random.randint(0, self.dim - 1)\n            individual[index] += random.uniform(-1, 1)\n            individual[index] = max(self.lower_bound, min(individual[index], self.upper_bound))\n        return individual\n\n    def evolve(self):\n        for _ in range(self.budget):\n            self.evaluate()\n            new_population = []\n            for _ in range(self.population_size):\n                parent1, parent2 = random.sample(self.population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                new_population.append(child)\n            self.population = new_population\n            self.evaluate()\n\n    def __call__(self, func):\n        self.evolve()\n        return self.population[np.argmax([self.fitness(individual) for individual in self.population])]\n\n# Example usage:\nhybrid_ea = HybridEvolutionaryAlgorithm(100, 10)\nbest_solution = hybrid_ea(func)\nprint(f\"Best solution: {best_solution}\")", "name": "HybridEvolutionaryAlgorithm", "description": "Novel \"Hybrid Evolutionary Algorithm with Probability-Based Crossover\"", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "0585c1ec-407d-450c-9dba-fe32d26e1783", "solution": "import random\nimport numpy as np\n\nclass AdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = []\n        self.best_particle = None\n        self.best_func_value = float('inf')\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.best_particle\n\n        # Initialize particles\n        for _ in range(self.population_size):\n            particle = [random.uniform(-5.0, 5.0) for _ in range(self.dim)]\n            self.particles.append(particle)\n\n        for _ in range(self.budget):\n            # Evaluate particles\n            values = [func(p) for p in self.particles]\n            best_particle_index = np.argmin(values)\n\n            # Update best particle\n            if values[best_particle_index] < self.best_func_value:\n                self.best_particle = self.particles[best_particle_index]\n                self.best_func_value = values[best_particle_index]\n\n            # Update particles\n            for i, particle in enumerate(self.particles):\n                # Crossover\n                if random.random() < 0.3:\n                    crossover_point = random.randint(0, self.dim - 1)\n                    particle[crossover_point:] = self.particles[best_particle_index][crossover_point:]\n\n                # Mutation\n                if random.random() < 0.3:\n                    mutation_point = random.randint(0, self.dim - 1)\n                    particle[mutation_point] += random.uniform(-1.0, 1.0)\n\n                # Update velocity\n                velocity = [0.0] * self.dim\n                velocity[best_particle_index] = values[best_particle_index] - func(particle)\n                self.particles[i] = [p + v for p, v in zip(particle, velocity)]\n\n        return self.best_particle\n\n# Example usage\ndef func(x):\n    return sum([i**2 for i in x])\n\nbudget = 100\ndim = 10\noptimizer = AdaptivePSO(budget, dim)\nbest_particle = optimizer(func)\nprint(best_particle)", "name": "AdaptivePSO", "description": "Adaptive Particle Swarm Optimization with Crossover and Mutation", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list assignment index out of range').", "error": "IndexError('list assignment index out of range')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "f32930a7-0d18-4ddc-aa97-0dedeb19968e", "solution": "import numpy as np\nimport random\n\nclass DiversityAdaptation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return [np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)]\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n        return np.mean([func(individual) for individual in self.population])\n\n    def mutate(self, individual, mutation_prob=0.3):\n        if random.random() < mutation_prob:\n            idx = random.randint(0, self.dim - 1)\n            individual[idx] = np.random.uniform(-5.0, 5.0)\n        return individual\n\n    def select(self, func):\n        scores = [func(individual) for individual in self.population]\n        selected_indices = np.argsort(scores)[-self.population_size:]\n        selected_individuals = [self.population[i] for i in selected_indices]\n        return selected_individuals\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.population = self.select(func)\n            self.population = [self.mutate(individual) for individual in self.population]\n            self.population = [self.mutate(individual, mutation_prob=0.3) if random.random() < 0.3 else individual for individual in self.population]\n\ndef diversity_adaptation(func, budget, dim):\n    algorithm = DiversityAdaptation(budget, dim)\n    algorithm.optimize(func)\n    return algorithm.population\n\n# Example usage:\n# func = lambda x: x[0]**2 + x[1]**2\n# budget = 100\n# dim = 2\n# population = diversity_adaptation(func, budget, dim)\n# print(population)", "name": "DiversityAdaptation", "description": "Novel \"Diversity-Adaptation\" algorithm with probability 0.3 mutation and selection", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityAdaptation' object is not callable\").", "error": "TypeError(\"'DiversityAdaptation' object is not callable\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "b7655d5d-b0af-4d53-a703-5e472eaf571c", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.cma_es = CMAES(self.dim)\n        self.es = EvolutionStrategies(self.dim)\n\n    def __call__(self, func):\n        population_size = 100\n        bounds = [(-5.0, 5.0)] * self.dim\n        n_calls = self.budget\n        constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})\n        result = differential_evolution(func, bounds, x0=np.random.uniform(-5.0, 5.0, size=population_size), \n                                         method='SDE', n_calls=n_calls, constraints=constraints)\n        best_solution = result.x\n        best_score = result.fun\n        return best_solution, best_score\n\nclass CMAES:\n    def __init__(self, dim):\n        self.dim = dim\n        self.cma = CMAES()\n\n    def __call__(self, func):\n        self.cma.optimize(func, self.dim)\n\nclass EvolutionStrategies:\n    def __init__(self, dim):\n        self.dim = dim\n        self.x = np.random.uniform(-5.0, 5.0, size=self.dim)\n\n    def __call__(self, func):\n        self.x = self.es.update(self.x, func)\n\n    def update(self, x, func):\n        self.x = self.es.update(x, func)\n        return self.x\n\n# Load BBOB test suite\nfrom bbob.benchmark import benchmark\n\ndef bbbenchmark(func, dim, budget, maxeval):\n    algorithm = HybridEvolutionaryAlgorithm(budget, dim)\n    results = []\n    for i in range(maxeval):\n        result = algorithm(func)\n        results.append(result)\n    return results\n\n# Run the benchmark\nresults = benchmark(bbbenchmark, 24, 100, 100)\nprint(results)", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm (HEA) combining CMA-ES with Evolution Strategies (ES)", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'bbob'\").", "error": "ModuleNotFoundError(\"No module named 'bbob'\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "bc1828a2-4be4-4135-bb5a-5e3e012c233e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass PGB:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population = []\n        self.eval_func = None\n\n    def __call__(self, func):\n        # Initialize the population with random points in the search space\n        population = np.random.uniform(-5.0, 5.0, (self.budget, self.dim))\n        \n        # Evaluate the objective function at each point in the population\n        scores = [func(point) for point in population]\n        for i, (point, score) in enumerate(zip(population, scores)):\n            self.population.append((f\"Point {i}\", \"Random initialization\", score))\n        \n        # Select the best point in the population\n        best_point = population[np.argmin(scores)]\n        self.population.append((f\"Best point so far\", \"Random initialization\", scores[np.argmin(scores)]))\n        \n        # Refine the search strategy using gradient boosting\n        for _ in range(self.budget - 1):\n            # Select a subset of the population to refine\n            subset = np.random.choice(len(self.population), int(self.budget * 0.3), replace=False)\n            subset_points = [self.population[i][0] for i in subset]\n            subset_scores = [self.population[i][2] for i in subset]\n            \n            # Refine the search strategy using gradient boosting\n            refined_points = []\n            for _ in range(int(self.budget * 0.7)):\n                # Select a point to refine\n                idx = np.random.choice(subset_points)\n                point = self.population[idx][0]\n                \n                # Refine the point using gradient boosting\n                gradient = np.gradient(func(point))\n                refined_point = point + 0.1 * gradient\n                refined_points.append(refined_point)\n            \n            # Evaluate the objective function at the refined points\n            refined_scores = [func(point) for point in refined_points]\n            for i, (point, score) in enumerate(zip(refined_points, refined_scores)):\n                self.population.append((f\"Refined point {i}\", \"Gradient boosting\", score))\n            \n            # Update the best point in the population\n            scores = [func(point) for point in refined_points]\n            best_point = refined_points[np.argmin(scores)]\n            self.population.append((f\"Best point after refinement\", \"Gradient boosting\", scores[np.argmin(scores)]))\n        \n        # Refine the search strategy using probability-based mutation\n        for _ in range(self.budget - 1):\n            # Select a point to refine\n            idx = np.random.choice(len(self.population))\n            point = self.population[idx][0]\n            \n            # Refine the point using probability-based mutation\n            mutation_prob = np.random.rand()\n            if mutation_prob < 0.3:\n                # Apply a random mutation to the point\n                mutation = np.random.uniform(-0.1, 0.1, self.dim)\n                point += mutation\n            self.population.append((f\"Refined point after mutation\", \"Probability-based mutation\", func(point)))\n        \n        # Return the best point in the population\n        best_point = population[np.argmin([func(point) for point in population])]\n        return best_point\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\npgb = PGB(100, 10)\nbest_point = pgb(func)\nprint(best_point)", "name": "PGB", "description": "Novel \"Probabilistic-Gradient-Boosting\" (PGB) algorithm for black box optimization", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('list indices must be integers or slices, not numpy.str_').", "error": "TypeError('list indices must be integers or slices, not numpy.str_')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "843c7286-da1c-452c-9a7e-17610f1e3a07", "solution": "import numpy as np\nimport random\n\nclass AdaptiveEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n        self.fitness_values = np.zeros(self.population_size)\n        self.best_individual = self.population[0]\n        self.best_fitness = self.fitness_values[0]\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of the population\n            self.fitness_values = func(self.population)\n            # Select the fittest individuals\n            fitness_order = np.argsort(self.fitness_values)\n            self.population = self.population[fitness_order]\n            self.population = self.population[:self.population_size//2]\n            # Create a new generation by crossover and mutation\n            new_population = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1 = self.population[i]\n                parent2 = self.population[(i+1)%self.population_size]\n                child = parent1 + parent2\n                child = child + np.random.uniform(-0.5, 0.5, size=self.dim)\n                new_population[i] = child\n            # Update the population\n            self.population = new_population\n            # Update the best individual\n            self.best_individual = self.population[np.argmax(self.fitness_values)]\n            self.best_fitness = np.max(self.fitness_values)\n\n            # Adaptive probability update\n            if np.random.rand() < 0.3:\n                # Randomly replace a fraction of the population\n                replace_indices = np.random.choice(self.population_size, size=int(self.population_size*0.3), replace=False)\n                self.population[replace_indices] = self.population[np.random.choice(self.population_size, size=self.population_size, replace=True)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\nalgorithm = AdaptiveEvolutionaryAlgorithm(budget, dim)\nbest_individual = algorithm(func)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", func(best_individual))", "name": "AdaptiveEvolutionaryAlgorithm", "description": "Novel \"Multi-Phase Evolutionary Algorithm with Adaptive Probability\" for black box optimization.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 1 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 1 is out of bounds for axis 0 with size 1')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "6571c962-b1a7-4005-a472-23ea64766956", "solution": "import numpy as np\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.fitness_values = np.zeros(self.population_size)\n        self.fittest_index = np.argmax(self.fitness_values)\n        self.fittest_individual = self.population[self.fittest_index]\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate fitness\n            self.fitness_values = func(self.population)\n\n            # Selection\n            self.fittest_index = np.argmax(self.fitness_values)\n            self.fittest_individual = self.population[self.fittest_index]\n\n            # Crossover\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1 = self.population[i]\n                parent2 = self.population[(i + 1) % self.population_size]\n                child = (parent1 + parent2) / 2\n                offspring[i] = child\n\n            # Mutation\n            for i in range(self.population_size):\n                if np.random.rand() < 0.3:\n                    mutation = np.random.uniform(-0.5, 0.5, self.dim)\n                    offspring[i] += mutation\n\n            # Adaptation\n            self.population = offspring\n            self.fitness_values = func(self.population)\n\n            # Perturbation\n            if np.random.rand() < 0.3:\n                perturbation = np.random.uniform(-0.5, 0.5, self.dim)\n                self.population += perturbation\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nhybrid_ea = HybridEvolutionaryAlgorithm(budget=100, dim=10)\nhybrid_ea( func )", "name": "HybridEvolutionaryAlgorithm", "description": "Hybrid Evolutionary Algorithm with Adaptation and Perturbation", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "ff2b0d7e-6e98-46a5-98d7-eda9a8da18cf", "solution": "import numpy as np\nimport random\n\nclass HyperTree:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population = []\n        self.selected_solution = None\n\n    def __call__(self, func):\n        if self.selected_solution is not None:\n            self.update_solution(func)\n        else:\n            self.population = [self.create_individual(func)]\n            self.selected_solution = random.choice(self.population)\n\n        for _ in range(self.budget - 1):\n            self.population.append(self.evolve(self.population))\n\n        self.selected_solution = max(self.population, key=lambda x: x.fitness)\n\n    def create_individual(self, func):\n        individual = {\n            'fitness': func(np.array([-5.0] * self.dim)),\n            'params': np.random.uniform(-5.0, 5.0, self.dim)\n        }\n        return individual\n\n    def evolve(self, population):\n        new_population = []\n        for _ in range(len(population)):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutate(child)\n            new_population.append(child)\n        return new_population\n\n    def crossover(self, parent1, parent2):\n        child = {\n            'fitness': 0,\n            'params': np.zeros(self.dim)\n        }\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child['params'][i] = (parent1['params'][i] + parent2['params'][i]) / 2\n            else:\n                child['params'][i] = parent1['params'][i]\n        child['fitness'] = func(child['params'])\n        return child\n\n    def mutate(self, individual):\n        mutation_rate = 0.1\n        for i in range(self.dim):\n            if random.random() < mutation_rate:\n                individual['params'][i] += random.uniform(-1.0, 1.0)\n                individual['fitness'] = func(individual['params'])\n        return individual\n\n    def update_solution(self, func):\n        probability = 0.3\n        for individual in self.population:\n            if random.random() < probability:\n                individual['params'] = (individual['params'] + self.selected_solution['params']) / 2\n                individual['fitness'] = func(individual['params'])\n        self.selected_solution = max(self.population, key=lambda x: x.fitness)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\nhyper_tree = HyperTree(budget, dim)\nhyper_tree('func')", "name": "HyperTree", "description": "Novel \"Probability-Adaptive Hyper-Tree\" algorithm for black box optimization", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'str' object is not callable\").", "error": "TypeError(\"'str' object is not callable\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "1fceab17-bc17-44ee-ab40-492d9ee28e9b", "solution": "import numpy as np\n\nclass ProbabilisticMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.mutation_rate = 0.3\n\n    def __call__(self, func):\n        population = []\n        for _ in range(self.budget):\n            x = np.random.uniform(-5.0, 5.0, self.dim)\n            population.append(x)\n        \n        scores = [func(x) for x in population]\n        best_idx = np.argmax(scores)\n        best_x = population[best_idx]\n        best_score = scores[best_idx]\n\n        new_population = []\n        for _ in range(self.budget):\n            if np.random.rand() < self.mutation_rate:\n                mutation = np.random.uniform(-1.0, 1.0, self.dim)\n                x = best_x + mutation\n            else:\n                x = best_x\n            new_population.append(x)\n        \n        scores = [func(x) for x in new_population]\n        new_best_idx = np.argmax(scores)\n        new_best_x = new_population[new_best_idx]\n        new_best_score = scores[new_best_idx]\n\n        if new_best_score > best_score:\n            best_x = new_best_x\n            best_score = new_best_score\n\n        return best_x, best_score\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 5\n    func = lambda x: x[0]**2 + x[1]**2 + x[2]**2 + x[3]**2 + x[4]**2\n    mutation = ProbabilisticMutation(budget, dim)\n    best_x, best_score = mutation(func)\n    print(\"Best x:\", best_x)\n    print(\"Best score:\", best_score)", "name": "ProbabilisticMutation", "description": "Novel probabilistic mutation operator for metaheuristic algorithms", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "b00f9947-dbba-435b-8901-4a90e442119c", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass AdaptiveMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population = np.random.uniform(-5.0, 5.0, size=(budget, dim))\n        self.fitness = np.zeros(budget)\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current population\n            self.fitness[i] = func(self.population[i])\n\n            # Calculate the probability of mutation for each dimension\n            mutation_prob = np.random.uniform(0.0, 1.0, size=self.dim)\n            mutation_prob[mutation_prob < 0.3] = 0.0\n\n            # Perform mutation on the fittest individual\n            fittest_idx = np.argmin(self.fitness)\n            mutation_idx = np.random.choice(self.dim, p=mutation_prob)\n            self.population[fittest_idx, mutation_idx] += np.random.uniform(-0.5, 0.5)\n\n            # Ensure bounds are not exceeded\n            self.population[fittest_idx, :] = np.clip(self.population[fittest_idx, :], -5.0, 5.0)\n\n        # Perform differential evolution optimization\n        res = differential_evolution(func, [(-5.0, 5.0)] * self.dim, x0=self.population, maxiter=self.budget)\n        self.population = res.x\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nbudget = 50\ndim = 2\noptimizer = AdaptiveMutation(budget, dim)\noptimizer(func)", "name": "AdaptiveMutation", "description": "Novel adaptive mutation strategy for black box optimization", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities do not sum to 1').", "error": "ValueError('probabilities do not sum to 1')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "3666cc27-cbc4-49ad-81d2-05034f663cb8", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass PADP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10\n        self.population = []\n        self.fitness_values = []\n\n    def __call__(self, func):\n        # Initialize the population\n        for _ in range(self.population_size):\n            x0 = np.random.uniform(-5.0, 5.0, self.dim)\n            self.population.append(x0)\n            self.fitness_values.append(func(x0))\n\n        # Perform adaptive dynamic programming\n        for i in range(self.budget):\n            # Select the best individual\n            idx = np.argmin(self.fitness_values)\n            best_individual = self.population[idx]\n\n            # Refine the best individual's strategy\n            for j in range(self.population_size):\n                # With probability 0.3, change one line of the best individual\n                if np.random.rand() < 0.3:\n                    idx = np.random.randint(0, self.dim)\n                    best_individual[idx] += np.random.uniform(-0.5, 0.5)\n                # Evaluate the new individual\n                new_individual = best_individual.copy()\n                new_individual[idx] = np.clip(new_individual[idx], -5.0, 5.0)\n                new_fitness = func(new_individual)\n                self.population[j] = new_individual\n                self.fitness_values[j] = new_fitness\n\n                # Replace the worst individual with the new one\n                idx = np.argmin(self.fitness_values)\n                self.population[idx] = new_individual\n                self.fitness_values[idx] = new_fitness\n\n        # Return the best individual\n        best_individual = np.min(self.population, axis=0)\n        return best_individual, np.min(self.fitness_values)\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 5\npadp = PADP(budget, dim)\nbest_individual, best_fitness = padp(func)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)", "name": "PADP", "description": "Novel \"Probabilistic Adaptive Dynamic Programming\" (PADP) algorithm", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 5 is out of bounds for axis 0 with size 5').", "error": "IndexError('index 5 is out of bounds for axis 0 with size 5')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "cfed2deb-1391-49c8-a66e-0c67c63cce27", "solution": "import numpy as np\n\nclass PAEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.fitness_values = np.zeros(self.population_size)\n        self.fitness_history = []\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of the current population\n            self.fitness_values = func(self.population)\n\n            # Select the fittest individuals\n            indices = np.argsort(self.fitness_values)[:self.population_size//2]\n            self.population = self.population[indices]\n            self.fitness_values = self.fitness_values[indices]\n\n            # Create a new generation by applying the probability-adaptive crossover and mutation\n            new_generation = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1 = np.random.choice(self.population, p=self.fitness_values)\n                parent2 = np.random.choice(self.population, p=self.fitness_values)\n                child = parent1 + (parent2 - parent1) * np.random.uniform(0, 1, self.dim)\n                new_generation[i] = child\n\n            # Apply probability-adaptive mutation\n            for i in range(self.population_size):\n                if np.random.rand() < 0.3:\n                    new_generation[i] += np.random.uniform(-0.5, 0.5, self.dim)\n\n            # Replace the old population with the new generation\n            self.population = new_generation\n\n            # Store the fitness history\n            self.fitness_history.append(self.fitness_values)\n\n            # Check for convergence\n            if np.all(self.fitness_values == self.fitness_values[0]):\n                break\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npaea = PAEA(budget=100, dim=10)\npaea(func)", "name": "PAEA", "description": "Novel \"Probability-Adaptive Evolutionary Algorithm\" (PAEA) for black box optimization", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "0778ed05-fe11-4839-93f3-b7d761b15a14", "solution": "import numpy as np\nimport random\n\nclass PRES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = (-5.0, 5.0)\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.5\n        self.evolution_strategy = self.evolution_strategy_fn\n\n    def evolution_strategy_fn(self, func):\n        # Initialize the population with random points in the search space\n        population = [np.random.uniform(self.search_space[0], self.search_space[1], self.dim) for _ in range(self.population_size)]\n\n        # Initialize the best point and its score\n        best_point = population[0]\n        best_score = func(best_point)\n\n        # Evolve the population using the evolutionary strategy\n        for _ in range(self.budget):\n            # Evaluate the population\n            scores = [func(point) for point in population]\n\n            # Select the best points\n            best_points = np.array(population)[np.argsort(scores)]\n\n            # Crossover and mutate the selected points\n            new_population = []\n            for i in range(self.population_size):\n                if random.random() < self.crossover_rate:\n                    parent1, parent2 = best_points[i], best_points[(i+1)%self.population_size]\n                    child = (parent1 + parent2) / 2\n                    if random.random() < self.mutation_rate:\n                        child += np.random.uniform(-self.search_space[1], self.search_space[1], self.dim)\n                else:\n                    child = best_points[i]\n                new_population.append(child)\n\n            # Replace the old population with the new one\n            population = new_population\n\n            # Update the best point and its score\n            scores = [func(point) for point in population]\n            best_point = population[np.argmax(scores)]\n            best_score = scores[np.argmax(scores)]\n\n        return best_point, best_score\n\n    def __call__(self, func):\n        return self.evolution_strategy_fn(func)\n\n# Example usage:\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    pres = PRES(budget, dim)\n    for i in range(budget):\n        best_point, best_score = pres(func)\n        print(f\"Function evaluation {i+1}: {best_score}\")", "name": "PRES", "description": "Novel \"Probability Refinement with Evolutionary Strategies\" (PRES) algorithm", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "6921ff31-7277-4d08-b299-9e58bfe099af", "solution": "import numpy as np\nimport random\n\nclass ProbabilisticElitistSelection:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = []\n        self.best_individual = None\n\n    def __call__(self, func):\n        # Initialize population with random individuals\n        for _ in range(self.budget):\n            self.population.append([random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)])\n\n        # Evaluate population and update best individual\n        for individual in self.population:\n            value = func(individual)\n            if self.best_individual is None or value < func(self.best_individual):\n                self.best_individual = individual\n\n        # Select and refine the best individual\n        if self.best_individual is not None:\n            # Calculate probability of changing each line of the best individual\n            probabilities = [0.3] * self.dim\n            new_individual = []\n            for i in range(self.dim):\n                if random.random() < probabilities[i]:\n                    new_individual.append(random.uniform(self.lower_bound, self.upper_bound))\n                else:\n                    new_individual.append(self.best_individual[i])\n            self.population[0] = new_individual\n\n        # Repeat until budget is reached\n        while len(self.population) < self.budget:\n            # Select and refine the best individual\n            if self.best_individual is not None:\n                # Calculate probability of changing each line of the best individual\n                probabilities = [0.3] * self.dim\n                new_individual = []\n                for i in range(self.dim):\n                    if random.random() < probabilities[i]:\n                        new_individual.append(random.uniform(self.lower_bound, self.upper_bound))\n                    else:\n                        new_individual.append(self.best_individual[i])\n                self.population.append(new_individual)\n            else:\n                # Create a new individual\n                new_individual = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n                self.population.append(new_individual)\n\n            # Evaluate new individual and update best individual\n            value = func(new_individual)\n            if value < func(self.best_individual):\n                self.best_individual = new_individual\n\n# Example usage\nif __name__ == \"__main__\":\n    func = lambda x: sum([i**2 for i in x])  # Example function\n    optimizer = ProbabilisticElitistSelection(100, 10)\n    optimizer(func)\n    print(\"Best individual:\", optimizer.best_individual)\n    print(\"Best function value:\", func(optimizer.best_individual))", "name": "ProbabilisticElitistSelection", "description": "Novel probabilistic elitist selection algorithm", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "5b82c53d-87f2-42e3-ae43-d6dea9d339e7", "solution": "import numpy as np\n\nclass PEAAC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = self.initialize_population()\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.adaptive_crossover_rate = 0.3\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(-5.0, 5.0, self.dim)\n            population.append(individual)\n        return population\n\n    def fitness(self, func, individual):\n        return func(individual)\n\n    def selection(self, population, func):\n        fitnesses = [self.fitness(func, individual) for individual in population]\n        fitnesses = np.array(fitnesses)\n        probabilities = np.exp(-fitnesses) / np.sum(np.exp(-fitnesses))\n        selected_indices = np.random.choice(len(population), size=self.population_size, p=probabilities)\n        selected_individuals = [population[i] for i in selected_indices]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            child = np.random.uniform(-5.0, 5.0, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.5:\n                    child[i] = parent1[i]\n                else:\n                    child[i] = parent2[i]\n            return child\n        else:\n            return parent1\n\n    def mutation(self, individual):\n        if np.random.rand() < self.mutation_rate:\n            index = np.random.randint(0, self.dim)\n            individual[index] = np.random.uniform(-5.0, 5.0)\n        return individual\n\n    def update(self, func):\n        self.population = self.selection(self.population, func)\n        new_population = []\n        for i in range(self.population_size):\n            parent1 = self.population[i]\n            parent2 = self.population[(i+1) % self.population_size]\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        self.population = new_population\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            self.update(func)\n            best_individual = max(self.population, key=lambda x: self.fitness(func, x))\n            print(f'Iteration {_+1}: Best individual = {best_individual}, Fitness = {self.fitness(func, best_individual)}')", "name": "PEAAC", "description": "Novel \"Probabilistic Evolutionary Algorithm with Adaptive Crossover\" (PEAAC)", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities contain NaN').", "error": "ValueError('probabilities contain NaN')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "d998b854-6fba-42ff-bcfc-a18334af42d3", "solution": "import numpy as np\nimport random\n\nclass PDA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = self.initialize_population()\n        self.best_solution = None\n        self.best_score = float('-inf')\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            population.append(solution)\n        return population\n\n    def evaluate(self, func):\n        for solution in self.population:\n            score = func(solution)\n            self.population[np.argmin(self.population[:, 0])] = solution\n            self.population[np.argmin(self.population[:, 0])] = solution\n            self.population[np.argmin(self.population[:, 0])] = solution\n        self.population = self.population[np.argsort(self.population[:, 0])]\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            if self.best_score < self.population[0, 0]:\n                self.best_solution = self.population[0]\n                self.best_score = self.population[0, 0]\n\n        # Probability-driven adaptive strategy\n        if self.best_solution is not None:\n            probabilities = np.zeros(self.population_size)\n            for i in range(self.population_size):\n                probabilities[i] = np.exp(-((self.population[i, 0] - self.best_solution[0]) ** 2) / (2 * (self.population_size - 1)))\n\n            selection_probabilities = np.random.choice(self.population_size, size=self.population_size, replace=True, p=probabilities)\n            self.population = [self.population[i] for i in selection_probabilities]\n\n            # Refine the best solution\n            for i in range(self.population_size):\n                if random.random() < 0.3:\n                    self.population[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    self.population[i] = np.clip(self.population[i], -5.0, 5.0)\n\n        return self.population[0, 0]", "name": "PDA", "description": "Novel \"Probability-Driven Adaptive\" (PDA) metaheuristic algorithm", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('list indices must be integers or slices, not tuple').", "error": "TypeError('list indices must be integers or slices, not tuple')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "64de16db-dec3-4a07-a579-bc65b4e5c98d", "solution": "import numpy as np\n\nclass SPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_particles = np.zeros((self.population_size, self.dim))\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.rbest = np.zeros((self.population_size, self.dim))\n        self.candidates = []\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the objective function\n            values = func(self.particles)\n            # Update the best particles\n            for i in range(self.population_size):\n                if values[i] < self.best_particles[i, 0]:\n                    self.best_particles[i] = values[i]\n                    self.pbest[i] = values[i]\n                    self.rbest[i] = values[i]\n            # Update the swarm\n            for i in range(self.population_size):\n                if np.random.rand() < 0.3:\n                    self.particles[i] += np.random.uniform(-1, 1, self.dim)\n                if np.random.rand() < 0.3:\n                    self.particles[i] += np.random.uniform(0, 1, self.dim)\n                if np.random.rand() < 0.3:\n                    self.particles[i] += self.pbest[i] - self.particles[i]\n                if np.random.rand() < 0.3:\n                    self.particles[i] += self.rbest[i] - self.particles[i]\n            # Evaluate the objective function again\n            values = func(self.particles)\n            # Update the candidates\n            for i in range(self.population_size):\n                if values[i] > self.rbest[i, 0]:\n                    self.rbest[i] = values[i]\n                    self.candidates.append([self.particles[i], values[i]])\n            # Update the swarm\n            self.particles = np.array(self.candidates)\n            self.candidates = []\n            # Sort the particles\n            self.particles = self.particles[np.argsort(self.rbest, axis=0)]\n            # Update the best particles\n            self.best_particles = self.particles[:, 0]\n        # Return the best particle\n        return self.particles[:, 0]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nsp = SPS(budget=100, dim=10)\nbest_particle = sp(func)\nprint(best_particle)", "name": "SPS", "description": "Novel \"Swarm-Particle-Swarm\" (SPS) algorithm combining particle swarm optimization and swarm intelligence.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "2d9fa310-3d2e-49ed-87e1-0422fa8c8fb6", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryGradient:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.population = self.initialize_population()\n        self.best_solution = self.evaluate_best_solution()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(-5.0, 5.0) for _ in range(self.dim)]\n            population.append(solution)\n        return population\n\n    def evaluate_best_solution(self):\n        best_solution = min(self.population, key=lambda x: self.func(x))\n        return best_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Select parents using tournament selection\n            parents = self.select_parents()\n\n            # Crossover (recombination) with probability 0.7\n            offspring = []\n            for _ in range(self.population_size):\n                parent1, parent2 = random.sample(parents, 2)\n                child = self.recombine(parent1, parent2)\n                offspring.append(child)\n\n            # Mutate with probability 0.3\n            mutated_offspring = []\n            for child in offspring:\n                if random.random() < 0.3:\n                    mutated_child = self.mutate(child)\n                    mutated_offspring.append(mutated_child)\n                else:\n                    mutated_offspring.append(child)\n\n            # Replace the worst solution with the new offspring\n            self.population = mutated_offspring\n            self.best_solution = self.evaluate_best_solution()\n\n            # Evaluate the function at the new best solution\n            self.func(self.best_solution)\n\n    def select_parents(self):\n        parents = []\n        for _ in range(self.population_size):\n            tournament = random.sample(self.population, 5)\n            winner = min(tournament, key=lambda x: self.func(x))\n            parents.append(winner)\n        return parents\n\n    def recombine(self, parent1, parent2):\n        child = [0.5 * (parent1[i] + parent2[i]) for i in range(self.dim)]\n        return child\n\n    def mutate(self, child):\n        mutated_child = child.copy()\n        for i in range(self.dim):\n            if random.random() < 0.3:\n                mutated_child[i] += random.uniform(-1.0, 1.0)\n                mutated_child[i] = max(-5.0, min(5.0, mutated_child[i]))\n        return mutated_child\n\n    def func(self, solution):\n        # Evaluate the function at the given solution\n        # Replace this with your actual function\n        return np.sum([solution[i]**2 for i in range(self.dim)])\n\n# Example usage\neg = EvolutionaryGradient(budget=100, dim=10)\neg.func(np.array([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]))", "name": "EvolutionaryGradient", "description": "Novel \"Evolutionary-Gradient\" (EG) algorithm combining evolutionary search with gradient-based optimization.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "40d2aaa1-60c5-41dc-895e-5b3de91ce870", "solution": "import numpy as np\nimport random\n\nclass PAEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population = []\n        self.fitness_values = []\n\n    def __call__(self, func):\n        if len(self.population) < self.budget:\n            # Initialize population with random points\n            self.population = [np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.budget)]\n            self.fitness_values = [func(point) for point in self.population]\n        else:\n            # Replace old population with new ones using probability\n            new_population = []\n            for _ in range(self.budget):\n                if random.random() < 0.3:\n                    # Replace with new random point\n                    new_population.append(np.random.uniform(-5.0, 5.0, self.dim))\n                else:\n                    # Replace with best individual\n                    new_population.append(self.population[np.argmin(self.fitness_values)])\n            self.population = new_population\n            self.fitness_values = [func(point) for point in self.population]\n\n        # Evaluate fitness values\n        self.fitness_values = [func(point) for point in self.population]\n\n        # Select best individual\n        best_index = np.argmin(self.fitness_values)\n        self.population = [self.population[best_index]]\n        self.fitness_values = [self.fitness_values[best_index]]\n\n    def get_best_solution(self):\n        return self.population[0]\n\n# Example usage\ndef func(x):\n    return sum(i**2 for i in x)\n\npaea = PAEA(budget=100, dim=10)\npaea(func)\nprint(paea.get_best_solution())", "name": "PAEA", "description": "Novel \"Probabilistic Adaptive Evolutionary Algorithm\" (PAEA) for black box optimization", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "d3e999c5-07b3-44ae-b2c8-e54b03221683", "solution": "import numpy as np\nimport random\n\nclass ProbEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(-5.0, 5.0, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n        self.population = self.select_population()\n\n    def select_population(self):\n        # Select parents using tournament selection\n        parents = []\n        for _ in range(self.population_size):\n            tournament = random.sample(self.population, 3)\n            winner = max(tournament, key=lambda x: func(x))\n            parents.append(winner)\n        return parents\n\n    def mutate(self, individual):\n        if random.random() < self.mutation_rate:\n            index = random.randint(0, self.dim - 1)\n            individual[index] += np.random.uniform(-1.0, 1.0)\n            if individual[index] < -5.0:\n                individual[index] = -5.0\n            elif individual[index] > 5.0:\n                individual[index] = 5.0\n        return individual\n\n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            index = random.randint(0, self.dim - 1)\n            child = parent1.copy()\n            child[index] = parent2[index]\n            return child\n        return parent1\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            new_population = []\n            for _ in range(self.population_size):\n                parent1 = random.choice(self.population)\n                parent2 = random.choice(self.population)\n                child = self.crossover(parent1, parent2)\n                child = self.mutate(child)\n                new_population.append(child)\n            self.population = new_population\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nprob_evolution = ProbEvolution(budget=100, dim=10)\nprob_evolution.optimize(func)", "name": "ProbEvolution", "description": "Novel probabilistic evolutionary algorithm with adaptive mutation and crossover", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'ProbEvolution' object is not callable\").", "error": "TypeError(\"'ProbEvolution' object is not callable\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "c488fca3-381b-4eec-8998-babb89bf352c", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass AdaptiveMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.fitness = np.zeros(budget)\n        self.score = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at each point in the population\n            self.fitness[i] = func(self.population[i])\n\n            # Calculate the fitness score for each point\n            self.score = np.min(self.score, np.min(self.fitness))\n\n            # Apply mutation and crossover to the population\n            self.population[i] = self.mutate(self.population[i])\n            self.population[i] = self.crossover(self.population[i])\n\n        # Select the best point in the population\n        self.population = self.population[np.argmin(self.fitness)]\n\n    def mutate(self, point):\n        # Apply mutation with probability 0.3\n        if np.random.rand() < 0.3:\n            point = point + np.random.uniform(-1.0, 1.0, self.dim)\n        return point\n\n    def crossover(self, point):\n        # Apply crossover with probability 0.3\n        if np.random.rand() < 0.3:\n            point1 = point + np.random.uniform(-1.0, 1.0, self.dim)\n            point2 = point - np.random.uniform(-1.0, 1.0, self.dim)\n            point = (point1 + point2) / 2\n        return point\n\n# Test the algorithm\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nbudget = 100\ndim = 2\n\nalgorithm = AdaptiveMetaheuristic(budget, dim)\nbest_point = algorithm(func)\n\n# Print the best point found\nprint(\"Best point:\", best_point)\nprint(\"Fitness:\", func(best_point))", "name": "AdaptiveMetaheuristic", "description": "Novel adaptive mutation and crossover strategy with probability-based selection", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'numpy.float64' object cannot be interpreted as an integer\").", "error": "TypeError(\"'numpy.float64' object cannot be interpreted as an integer\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "44104464-5d41-4a6c-9f18-7bd552dc14df", "solution": "import numpy as np\nimport random\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n        self.fitness_values = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual\n            self.fitness_values = func(self.population)\n\n            # Select parents using tournament selection\n            parents = []\n            for _ in range(self.population_size // 2):\n                tournament = random.sample(range(self.population_size), 3)\n                winner = np.argmax([self.fitness_values[i] for i in tournament])\n                parents.append(self.population[winner])\n\n            # Create offspring using crossover and mutation\n            offspring = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = random.sample(parents, 2)\n                child = np.random.uniform(-5.0, 5.0, size=self.dim)\n                child[np.random.choice(self.dim, size=2, replace=False)] = (parent1 + parent2) / 2\n                child[np.random.choice(self.dim, size=1, replace=False)] *= 0.9 + np.random.uniform(-0.1, 0.1)\n                offspring.append(child)\n\n            # Replace the least fit individuals with the new offspring\n            self.population = np.array([self.population[i] if self.fitness_values[i] < np.min(self.fitness_values) else child for i, child in enumerate(offspring)])\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nhybrid_ea = HybridEvolutionaryAlgorithm(budget=100, dim=10)\nhybrid_ea(func)", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm with Probabilistic Mutation and Crossover", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "d4d7a2eb-8f0b-45d5-aa86-6ed9e929e2fa", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryProbabilisticAdaptation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = self.initialize_population()\n        self.fitness = self.evaluate_fitness()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = [random.uniform(-5.0, 5.0) for _ in range(self.dim)]\n            population.append(individual)\n        return population\n\n    def evaluate_fitness(self):\n        fitness = []\n        for individual in self.population:\n            fitness.append(self(func(individual)))\n        return fitness\n\n    def selection(self):\n        fitness = self.evaluate_fitness()\n        probabilities = np.array(fitness) / np.sum(fitness)\n        selected_indices = np.random.choice(len(fitness), size=self.population_size, p=probabilities, replace=False)\n        selected_population = [self.population[i] for i in selected_indices]\n        return selected_population\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def mutation(self, individual):\n        mutated_individual = individual.copy()\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                mutated_individual[i] += random.uniform(-1.0, 1.0)\n                if mutated_individual[i] < -5.0:\n                    mutated_individual[i] = -5.0\n                elif mutated_individual[i] > 5.0:\n                    mutated_individual[i] = 5.0\n        return mutated_individual\n\n    def update_population(self):\n        selected_population = self.selection()\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(selected_population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        self.population = new_population\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            self.update_population()\n            best_individual = max(self.population, key=lambda individual: self.func(individual))\n            print(f\"Best individual: {best_individual}, Fitness: {self.func(best_individual)}\")\n            if self.budget - _ <= 10:\n                print(\"Converged!\")\n\ndef func(individual):\n    # Replace this with your black box function\n    return np.sum([i**2 for i in individual])\n\n# Usage\nepa = EvolutionaryProbabilisticAdaptation(100, 5)\nepa()", "name": "EvolutionaryProbabilisticAdaptation", "description": "Novel \"Evolutionary Probabilistic Adaptation\" (EPA) algorithm for black box optimization.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: RecursionError('maximum recursion depth exceeded while calling a Python object').", "error": "RecursionError('maximum recursion depth exceeded while calling a Python object')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "b40257a3-5afa-45b7-8402-a044c478d5a2", "solution": "import numpy as np\nimport random\n\nclass AEAP_E:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population = self.initialize_population()\n        self.best_solution = self.population[0]\n        self.current_function_evaluations = 0\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            population.append((solution, self.evaluate_function(solution)))\n        return population\n\n    def evaluate_function(self, func):\n        return func()\n\n    def __call__(self, func):\n        if self.current_function_evaluations >= self.budget:\n            return self.population\n\n        for i in range(self.budget):\n            if random.random() < 0.3:\n                # Refine the current solution\n                new_solution = self.population[i][0] + np.random.uniform(-0.1, 0.1, self.dim)\n                self.population[i] = (new_solution, self.evaluate_function(new_solution))\n\n        # Replace the worst solution with a new one\n        self.population.sort(key=lambda x: x[1])\n        self.population[0] = (self.population[i][0], self.evaluate_function(self.population[i][0]))\n        self.population.sort(key=lambda x: x[1])\n\n        self.best_solution = max(self.population, key=lambda x: x[1])\n        self.current_function_evaluations += 1\n\n        return self.population\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Define the black box function\n    def func(x):\n        return np.sum(x**2)\n\n    # Create an instance of the AEAP_E algorithm\n    aeap_e = AEAP_E(budget=100, dim=10)\n\n    # Optimize the function using the AEAP_E algorithm\n    optimized_population = aeap_e(func)\n\n    # Print the optimized solution\n    print(\"Optimized solution:\", optimized_population[0])", "name": "AEAP_E", "description": "Novel \"Adaptive Evolutionary Algorithm with Probabilistic Exploration\" (AEAP-E) for black box optimization.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'numpy.ndarray' object is not callable\").", "error": "TypeError(\"'numpy.ndarray' object is not callable\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "7dc17c3f-5ede-4939-86a3-6b4d20d73700", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass HETS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.tabu_list = []\n        self.search_space = np.linspace(-5.0, 5.0, dim)\n        self.population = [self.search_space[i] for i in random.sample(range(dim), population_size)]\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            best_solution = self.population[np.argmin([func(x) for x in self.population])]\n            score = func(best_solution)\n            self.population = [self.search_space[i] for i in random.sample(range(dim), population_size)]\n            self.population = [self.search_space[i] if random.random() > 0.3 else best_solution for i in range(dim)]\n            self.population = [min(max(x, -5.0), 5.0) for x in self.population]\n            self.population = [x for x in self.population if x not in self.tabu_list]\n            self.tabu_list.extend([best_solution] + [x for x in self.population if x not in self.tabu_list])\n            self.tabu_list = self.tabu_list[-self.population_size:]\n            if score < np.inf:\n                print(f\"New best solution: {best_solution}, Score: {score}\")\n\ndef evaluate_function(func, x):\n    return func(x)\n\ndef optimize_function(func, hets, dim):\n    x0 = np.linspace(-5.0, 5.0, dim)\n    res = minimize(evaluate_function(func, x0), x0, method=\"SLSQP\")\n    return res.x\n\n# Example usage:\ndef example_func(x):\n    return x[0]**2 + x[1]**2\n\nhets = HETS(budget=100, dim=2)\nhets(example_func)", "name": "HETS", "description": "Novel \"Hybrid Evolutionary-Tabu Search\" (HETS) algorithm combining the strengths of evolutionary strategies and tabu search to handle diverse black box optimization tasks.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'population_size' is not defined\").", "error": "NameError(\"name 'population_size' is not defined\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "7c26cd81-d5e2-4f74-b1b2-b213c8eb7d46", "solution": "import numpy as np\nimport random\n\nclass CrossoverAdaptation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.population = self.initialize_population()\n        self.fitness_values = [func(x) for x in self.population[0]]\n        self.best_solution = self.population[0]\n        self.iteration = 0\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(-5.0, 5.0, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = [func(x) for x in self.population]\n        self.best_solution = self.population[np.argmin(self.fitness_values)]\n        self.iteration += 1\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n        return child\n\n    def mutation(self, individual):\n        mutation_rate = 0.1\n        for i in range(self.dim):\n            if random.random() < mutation_rate:\n                individual[i] = np.random.uniform(-5.0, 5.0)\n        return individual\n\n    def adapt(self):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(self.population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        self.population = new_population\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            self.adapt()\n            if self.iteration % 10 == 0:\n                self.fitness_values.sort()\n                print(f\"Iteration {_}, Best fitness: {self.fitness_values[0]}\")\n        return self.best_solution\n\n# Example usage\nif __name__ == \"__main__\":\n    func = lambda x: np.sum(x**2)\n    ca = CrossoverAdaptation(budget=100, dim=10)\n    solution = ca(func)\n    print(\"Optimal solution:\", solution)", "name": "CrossoverAdaptation", "description": "Novel \"Crossover-Adaptation\" (CA) algorithm with probability-based refinement.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "f98128c6-2b61-4cfe-9ae9-1387023c1805", "solution": "import numpy as np\n\nclass ProbabilisticAdaptiveMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = (np.array([-5.0, 5.0]) + 1) / 2\n        self.population_size = 20\n        self.population = np.random.uniform(self.search_space, size=(self.population_size, self.dim))\n        self.fitness_values = np.zeros((self.population_size,))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate fitness for each individual\n            self.fitness_values = func(self.population)\n            \n            # Select parents using tournament selection\n            parents = np.random.choice(self.population_size, size=self.population_size, replace=False, p=self.fitness_values / np.sum(self.fitness_values))\n            \n            # Crossover (recombination)\n            offspring = np.zeros((self.population_size, self.dim))\n            for j in range(self.population_size):\n                parent1, parent2 = np.random.choice(parents, size=2, replace=False)\n                offspring[j] = (self.population[parent1] + self.population[parent2]) / 2\n            \n            # Adaptive mutation\n            mutation_probabilities = np.random.uniform(0, 1, size=self.population_size)\n            for j in range(self.population_size):\n                if mutation_probabilities[j] < 0.3:\n                    mutation = np.random.uniform(-1, 1, size=self.dim)\n                    offspring[j] += mutation\n            \n            # Replace worst individual\n            self.population = np.minimum(self.population, offspring)\n            \n            # Print progress\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best Fitness: {np.min(self.fitness_values)}\")\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = ProbabilisticAdaptiveMutation(budget, dim)\nbest_fitness = np.inf\nfor i in range(budget):\n    optimizer(func)\n    if np.min(optimizer.fitness_values) < best_fitness:\n        best_fitness = np.min(optimizer.fitness_values)\n        print(f\"Best Fitness: {best_fitness}\")", "name": "ProbabilisticAdaptiveMutation", "description": "Novel probabilistic adaptive mutation algorithm for black box optimization", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (20, 10) and arg 1 with shape (2,).')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "786730d9-19ca-494d-a986-e98448baf464", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass PADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_probability = 0.7\n        self.mutation_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population with random points\n        self.population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        # Evaluate the objective function for each point in the population\n        self.values = func(self.population)\n\n        # Repeat the process until the budget is reached\n        for _ in range(self.budget):\n            # Select the best point in the population\n            best_idx = np.argmin(self.values)\n            best_point = self.population[best_idx]\n\n            # Select the worst point in the population\n            worst_idx = np.argmax(self.values)\n            worst_point = self.population[worst_idx]\n\n            # Create a new population by applying the differential evolution operator\n            new_population = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                # Randomly select a point to be the parent\n                parent_idx = np.random.randint(0, self.population_size)\n                parent = self.population[parent_idx]\n\n                # Randomly select a point to be the child\n                child_idx = np.random.randint(0, self.population_size)\n                child = self.population[child_idx]\n\n                # Apply the crossover operator\n                if np.random.rand() < self.crossover_probability:\n                    child = self.crossover(parent, child)\n\n                # Apply the mutation operator\n                if np.random.rand() < self.mutation_probability:\n                    child = self.mutation(child)\n\n                # Replace the worst point in the population with the child\n                if i == worst_idx:\n                    new_population[i] = child\n                    self.values[i] = func(child)\n                else:\n                    new_population[i] = child\n                    self.values[i] = func(child)\n\n            # Update the population\n            self.population = new_population\n\n            # Evaluate the objective function for each point in the population\n            self.values = func(self.population)\n\n        # Return the best point in the final population\n        return np.argmin(self.values)\n\n    def crossover(self, parent, child):\n        # Perform a simple crossover by taking the average of the two parents\n        return (parent + child) / 2\n\n    def mutation(self, point):\n        # Perform a simple mutation by adding a random value to the point\n        return point + np.random.uniform(-1.0, 1.0)", "name": "PADE", "description": "Novel probabilistic adaptive differential evolution algorithm for black box optimization", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "96f8670c-5fac-4af3-b0c0-08c6d7e6b5f6", "solution": "import random\nimport numpy as np\n\nclass HybridGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        # Initialize the population\n        population = [random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)]\n\n        # Evaluate the initial population\n        fitnesses = [func(individual) for individual in population]\n        best_individual = np.argmin(fitnesses)\n        best_individual = population[best_individual]\n\n        # Evolve the population\n        for _ in range(self.budget):\n            # Select parents\n            parents = random.sample(population, self.population_size)\n\n            # Perform crossover\n            offspring = []\n            for _ in range(self.population_size):\n                parent1, parent2 = random.sample(parents, 2)\n                child = [(parent1[i] + parent2[i]) / 2 for i in range(self.dim)]\n                if random.random() < self.crossover_rate:\n                    child = random.sample(parents, 2)\n                offspring.append(child)\n\n            # Perform mutation\n            for i in range(self.population_size):\n                if random.random() < self.mutation_rate:\n                    mutation = [random.uniform(-1.0, 1.0) for _ in range(self.dim)]\n                    offspring[i] = [x + y for x, y in zip(offspring[i], mutation)]\n\n            # Evaluate the offspring\n            fitnesses = [func(individual) for individual in offspring]\n            best_individual = np.argmin(fitnesses)\n            best_individual = offspring[best_individual]\n\n            # Replace the least fit individual\n            population[best_individual] = best_individual\n\n            # Update the best individual\n            if fitnesses[best_individual] < fitnesses[best_individual - 1]:\n                best_individual = population[best_individual]\n\n# Test the algorithm\ndef func(individual):\n    return sum(x**2 for x in individual)\n\nga = HybridGA(budget=100, dim=10)\nbest_individual = ga(func)\nprint(best_individual)", "name": "HybridGA", "description": "Hybrid Genetic Algorithm with Probabilistic Mutation", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Random.uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('Random.uniform() takes 3 positional arguments but 4 were given')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "93ad6112-395d-4201-a824-0f20c859be31", "solution": "import numpy as np\n\nclass CRP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = self.initialize_population()\n        self.fitness_values = np.zeros(self.population_size)\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(-5.0, 5.0, self.dim)\n            population.append(individual)\n        return population\n\n    def fitness(self, individual):\n        return func(individual)\n\n    def evaluate(self):\n        self.fitness_values = np.array([self.fitness(individual) for individual in self.population])\n\n    def selection(self):\n        indices = np.argsort(self.fitness_values)\n        selected_indices = indices[:int(self.population_size/2)]\n        return [self.population[i] for i in selected_indices]\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if np.random.rand() < 0.5:\n                child[i] = parent2[i]\n        return child\n\n    def recombination(self):\n        children = []\n        while len(children) < self.population_size - self.population_size // 2:\n            parent1, parent2 = np.random.choice(self.population, size=2, replace=False)\n            child = self.crossover(parent1, parent2)\n            children.append(child)\n        return children\n\n    def mutation(self, individual):\n        mutation_rate = 0.1\n        for i in range(self.dim):\n            if np.random.rand() < mutation_rate:\n                individual[i] += np.random.uniform(-1.0, 1.0)\n                individual[i] = np.clip(individual[i], -5.0, 5.0)\n        return individual\n\n    def update(self):\n        self.evaluate()\n        selected_individuals = self.selection()\n        children = self.recombination()\n        for i, child in enumerate(children):\n            parent1, parent2 = selected_individuals[i % len(selected_individuals)]\n            child = self.mutation(child)\n            child = self.crossover(parent1, child)\n            self.population[i] = child\n        return np.mean(self.fitness_values)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            self.update()\n        return np.mean(self.fitness_values)\n\n# Example usage:\nfunc = lambda x: np.sum(x**2)\ncrp = CRP(budget=100, dim=10)\nresult = crp(func)\nprint(result)", "name": "CRP", "description": "Novel \"Crossover-Recombination-Probability\" (CRP) algorithm", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "1ab1cfd6-e317-49e0-8179-bf11bc56d380", "solution": "import numpy as np\nimport random\n\nclass PEAHM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.memory_size = 10\n        self.population = self.initialize_population()\n        self.memory = self.initialize_memory()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(-5.0, 5.0, self.dim)\n            population.append(individual)\n        return population\n\n    def initialize_memory(self):\n        memory = []\n        for _ in range(self.memory_size):\n            individual = np.random.uniform(-5.0, 5.0, self.dim)\n            memory.append(individual)\n        return memory\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func_value = func(individual)\n            self.population.append((individual, func_value))\n\n        self.population = sorted(self.population, key=lambda x: x[1])\n\n        if len(self.population) > self.budget:\n            self.population = self.population[:self.budget]\n\n    def update_memory(self):\n        self.memory = []\n        for individual in self.population:\n            if individual not in self.memory:\n                self.memory.append(individual)\n\n    def update_population(self):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(self.population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutate(child)\n            new_population.append(child)\n        self.population = new_population\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros(self.dim)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutate(self, individual):\n        mutation_rate = 0.1\n        for i in range(self.dim):\n            if random.random() < mutation_rate:\n                individual[i] += np.random.uniform(-1.0, 1.0)\n        return individual\n\n    def update(self, func):\n        self.evaluate(func)\n        self.update_memory()\n        self.update_population()\n\n        # Refine the strategy of the best individual with probability 0.3\n        if random.random() < 0.3:\n            best_individual, _ = self.population[0]\n            best_individual = np.array(best_individual)\n            best_individual = best_individual * 0.9 + np.random.uniform(-0.1, 0.1, self.dim)\n            self.population[0] = (best_individual, self.population[0][1])\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\npeahm = PEAHM(budget=10, dim=5)\npeahm.update(func)", "name": "PEAHM", "description": "Novel \"Probabilistic Evolutionary Algorithm with Hybrid Memory\" (PEA-HM) for black box optimization.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'tuple' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'tuple' and 'int'\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "4ba97ae5-1246-47cc-b46e-adc741450246", "solution": "import numpy as np\n\nclass PEAHM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = self.initialize_population()\n        self.hypermutation_rate = 0.3\n\n    def initialize_population(self):\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        return population\n\n    def evaluate(self, func):\n        fitnesses = np.array([func(x) for x in self.population])\n        min_fitness = np.min(fitnesses)\n        max_fitness = np.max(fitnesses)\n        if min_fitness == max_fitness:\n            return min_fitness\n        else:\n            return (max_fitness - min_fitness) / (max_fitness - min_fitness + 1e-6)\n\n    def selection(self, fitnesses):\n        probabilities = fitnesses / np.sum(fitnesses)\n        selection_indices = np.random.choice(self.population_size, size=self.population_size, p=probabilities)\n        selected_population = self.population[selection_indices]\n        return selected_population\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, child):\n        for i in range(self.dim):\n            if np.random.rand() < self.hypermutation_rate:\n                child[i] += np.random.uniform(-1.0, 1.0)\n                child[i] = np.clip(child[i], -5.0, 5.0)\n        return child\n\n    def hypermutation(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if np.random.rand() < self.hypermutation_rate:\n                child[i] = parent2[i] + np.random.uniform(-1.0, 1.0)\n                child[i] = np.clip(child[i], -5.0, 5.0)\n        return child\n\n    def evolve(self, func):\n        for _ in range(self.budget):\n            fitnesses = np.array([func(x) for x in self.population])\n            selected_population = self.selection(fitnesses)\n            new_population = []\n            for i in range(self.population_size):\n                parent1 = selected_population[i]\n                parent2 = selected_population[(i+1) % self.population_size]\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                new_population.append(child)\n            self.population = np.array(new_population)\n        return self.population\n\n    def __call__(self, func):\n        self.population = self.evolve(func)\n        return self.population\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\npeahm = PEAHM(budget=100, dim=10)\noptimal_solution = peahm(func)\nprint(optimal_solution)", "name": "PEAHM", "description": "Novel \"Probabilistic Evolutionary Algorithm with Hypermutation\" (PEA-HM)", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "4530aafd-7b01-43ff-9d1f-3cfb7fd5bbf0", "solution": "import numpy as np\n\nclass AdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.selection_prob = 0.3\n        self.crossover_prob = 0.5\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(-5.0, 5.0, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n        self.population = self.select_and_crossover()\n\n    def select(self):\n        scores = np.array([func(individual) for individual in self.population])\n        probabilities = scores / np.max(scores)\n        selected_indices = np.random.choice(len(self.population), size=self.population_size, p=probabilities)\n        selected_individuals = [self.population[i] for i in selected_indices]\n        return selected_individuals\n\n    def crossover(self):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = np.random.choice(self.population, size=2, replace=False)\n            child = self.adaptive_crossover(parent1, parent2)\n            new_population.append(child)\n        return new_population\n\n    def adaptive_crossover(self, parent1, parent2):\n        child = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.crossover_prob:\n                if np.random.rand() < self.selection_prob:\n                    child[i] = parent1[i]\n                else:\n                    child[i] = parent2[i]\n            else:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        if np.random.rand() < self.mutation_rate:\n            child += np.random.uniform(-0.1, 0.1, self.dim)\n        return child\n\n    def mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] += np.random.uniform(-0.1, 0.1)\n        return individual\n\n    def select_and_crossover(self):\n        selected_individuals = self.select()\n        new_population = self.crossover()\n        for individual in selected_individuals:\n            new_population.append(individual)\n        new_population = [self.mutate(individual) for individual in new_population]\n        return new_population\n\n# Test the algorithm\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\nalgorithm = AdaptiveCrossover(budget, dim)\nfor _ in range(budget):\n    algorithm.evaluate(func)", "name": "AdaptiveCrossover", "description": "Adaptive Crossover with Mutation and Probabilistic Selection", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities do not sum to 1').", "error": "ValueError('probabilities do not sum to 1')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "3d1efac8-83c7-4940-9246-0e27e03a1de0", "solution": "import numpy as np\nimport random\n\nclass HyperEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.fitness = np.zeros(budget)\n        self.fitness_argsort = np.argsort(self.fitness)\n        self.best_idx = 0\n        self.perturb_prob = 0.3\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            idx = self.fitness_argsort[i]\n            self.fitness[idx] = func(self.population[idx])\n            if i < self.budget - 1:\n                if random.random() < self.perturb_prob:\n                    self.population[idx] += np.random.uniform(-0.1, 0.1, self.dim)\n                    self.fitness[idx] = func(self.population[idx])\n                else:\n                    idx2 = np.random.choice(self.fitness_argsort[:i+1])\n                    self.population[idx], self.population[idx2] = self.population[idx2], self.population[idx]\n                    self.fitness[idx], self.fitness[idx2] = self.fitness[idx2], self.fitness[idx]\n\n        self.population = self.population[self.fitness_argsort]\n        self.fitness = self.fitness[self.fitness_argsort]\n        self.best_idx = np.argmax(self.fitness)\n        self.population = self.population[self.best_idx]\n        self.fitness = self.fitness[self.best_idx]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nevolution = HyperEvolution(budget=100, dim=10)\nbest_x = evolution(func)\nprint(best_x)", "name": "HyperEvolution", "description": "Novel \"Hyper-Evolution\" algorithm combining mutation and crossover with adaptive probability adaptation", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "5b2a02a9-2749-47f6-bd46-e315d9d0b9a5", "solution": "import numpy as np\n\nclass Heap:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population = []\n        self.score = -np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if len(self.population) < self.dim:\n                # Initialize individual with random search space\n                individual = np.random.uniform(-5.0, 5.0, self.dim)\n            else:\n                # Select parent with highest score\n                parent_idx = np.argmax([func(individual) for individual in self.population])\n                parent = self.population[parent_idx]\n\n                # Refine parent's strategy with adaptive probability\n                parent_idx = np.random.choice(len(self.population), p=[0.7, 0.3])\n                parent = self.population[parent_idx]\n\n                # Create offspring by perturbing parent\n                offspring = parent + np.random.uniform(-0.5, 0.5, self.dim)\n\n                # Ensure search space bounds\n                offspring = np.clip(offspring, -5.0, 5.0)\n\n            # Evaluate offspring\n            score = func(offspring)\n\n            # Update population and score\n            self.population.append(offspring)\n            self.score = max(self.score, score)\n\n            # Replace worst individual if necessary\n            if len(self.population) > self.dim:\n                self.population.remove(min(self.population, key=lambda x: func(x)))\n\n    def get_best(self):\n        return self.population[np.argmax([func(individual) for individual in self.population])]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nheap = Heap(100, 10)\nheap(0, func)\nprint(heap.get_best())", "name": "Heap", "description": "Novel \"Hybrid Evolutionary Algorithm with Adaptive Probability\" (HEAP) to optimize black box functions.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Heap.__call__() takes 2 positional arguments but 3 were given').", "error": "TypeError('Heap.__call__() takes 2 positional arguments but 3 were given')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "b05b8132-a999-402f-90c0-27298d1ead4e", "solution": "import numpy as np\nimport random\n\nclass HybridEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.fitness_values = np.zeros(self.population_size)\n        self.best_individual = self.population[0]\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of the current population\n            self.fitness_values = func(self.population)\n\n            # Selection\n            parents = np.array([self.population[i] for i in np.argsort(self.fitness_values)[:-self.population_size]])\n            parents = parents[:self.population_size]\n\n            # Crossover\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = random.sample(parents, 2)\n                crossover_point = random.randint(0, self.dim - 1)\n                offspring[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n\n            # Mutation\n            for i in range(self.population_size):\n                if random.random() < 0.1:\n                    mutation_point = random.randint(0, self.dim - 1)\n                    offspring[i, mutation_point] = random.uniform(-5.0, 5.0)\n\n            # Replacement\n            self.population = offspring\n            self.fitness_values = func(self.population)\n\n            # Update the best individual\n            self.best_individual = np.max(self.population, axis=0)\n\n    def refine_solution(self):\n        # Select the best individual\n        best_individual = self.best_individual\n\n        # Refine the solution by changing individual lines with a probability of 0.3\n        refined_solution = list(best_individual)\n        for i in range(self.dim):\n            if random.random() < 0.3:\n                refined_solution[i] = random.uniform(-5.0, 5.0)\n        refined_solution = np.array(refined_solution)\n\n        return refined_solution\n\n# Example usage\ndef bbb_function(x):\n    return np.sum(x**2)\n\nhybrid_ea = HybridEA(100, 10)\nhybrid_ea(bbb_function)\nprint(hybrid_ea.refine_solution())", "name": "HybridEA", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "a696da90-c1dc-4c2e-bf0b-76cd55d323a3", "solution": "import numpy as np\n\nclass PESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.fitness_values = np.zeros(self.population_size)\n        self.best_solution = self.population[np.argmax(self.fitness_values)]\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of the current population\n            self.fitness_values = func(self.population)\n\n            # Replace the worst solution with a new one\n            self.population[np.argmin(self.fitness_values)] = self._mutate(self.population[np.argmin(self.fitness_values)])\n\n            # Select the best solution\n            self.best_solution = self.population[np.argmax(self.fitness_values)]\n\n            # Refine the strategy with 0.3 probability\n            if np.random.rand() < 0.3:\n                self.population[np.random.choice(self.population_size)] = self._crossover(self.population[np.random.choice(self.population_size)], self.best_solution)\n\n    def _mutate(self, solution):\n        # Perform mutation with a probability of 0.1\n        if np.random.rand() < 0.1:\n            return solution + np.random.uniform(-1.0, 1.0, self.dim)\n        else:\n            return solution\n\n    def _crossover(self, parent1, parent2):\n        # Perform crossover with a probability of 0.5\n        if np.random.rand() < 0.5:\n            child = np.random.choice([parent1, parent2])\n            return child + np.random.uniform(-1.0, 1.0, self.dim)\n        else:\n            return parent1", "name": "PESA", "description": "Novel Probabilistic Evolutionary Algorithm (P-ESA) for black box optimization", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "e5b56ac6-077b-4f67-8a9a-7455473f4de7", "solution": "import numpy as np\nimport random\n\nclass NovelizedStochasticMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.differential_evolution_params = {\n            'CR': 0.5,\n            'F': 0.5\n        }\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(-5.0, 5.0, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        evaluations = []\n        for individual in self.population:\n            evaluation = func(individual)\n            evaluations.append(evaluation)\n        return evaluations\n\n    def select_parents(self, evaluations):\n        parents = []\n        for _ in range(self.population_size):\n            indices = np.argsort(evaluations)\n            parents.append(self.population[indices[0]])\n        return parents\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + (parent2 - parent1) * random.uniform(0, 1)\n        return child\n\n    def mutate(self, individual):\n        mutated_individual = individual.copy()\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                mutated_individual[i] += np.random.uniform(-1.0, 1.0)\n        return mutated_individual\n\n    def differential_evolution(self, parent1, parent2):\n        child = parent1 + self.differential_evolution_params['F'] * (parent2 - parent1)\n        return child\n\n    def novelized_stochastic_memetic_algorithm(self, func):\n        for _ in range(self.budget):\n            evaluations = self.evaluate(func)\n            parents = self.select_parents(evaluations)\n            children = []\n            for _ in range(self.population_size):\n                parent1, parent2 = random.sample(parents, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutate(child)\n                children.append(child)\n            self.population = children\n            evaluations = self.evaluate(func)\n            parents = self.select_parents(evaluations)\n            for i in range(self.population_size):\n                parent1, parent2 = random.sample(parents, 2)\n                child = self.differential_evolution(parent1, parent2)\n                self.population[i] = child\n        best_individual = min(self.population, key=lambda individual: func(individual))\n        return best_individual\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nnovelized_sma = NovelizedStochasticMemeticAlgorithm(budget=100, dim=10)\nbest_individual = novelized_sma(novelized_sma.__call__, func)\nprint(best_individual)", "name": "NovelizedStochasticMemeticAlgorithm", "description": "Novelized Stochastic Memetic Algorithm with Differential Evolution and Mutation for Black Box Optimization", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'NovelizedStochasticMemeticAlgorithm' object has no attribute '__call__'\").", "error": "AttributeError(\"'NovelizedStochasticMemeticAlgorithm' object has no attribute '__call__'\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "51f19c78-3749-44cd-ab8f-1b0f76a01637", "solution": "import numpy as np\nimport random\n\nclass EADS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.population = self.initialize_population()\n        self.fitness_values = [self.evaluate_func(func) for func in self.population]\n        self.best_solution = self.get_best_solution()\n        self.budget_evaluations = 0\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            population.append(individual)\n        return population\n\n    def evaluate_func(self, func):\n        if self.budget_evaluations < self.budget:\n            self.budget_evaluations += 1\n            return func(*individual)\n        else:\n            return float('inf')\n\n    def get_best_solution(self):\n        best_solution = self.population[np.argmin(self.fitness_values)]\n        return best_solution\n\n    def update_solution(self, solution):\n        if self.budget_evaluations < self.budget:\n            new_solution = solution.copy()\n            for _ in range(int(self.budget_evaluations * 0.3)):\n                i = random.randint(0, self.dim - 1)\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n            self.fitness_values = [self.evaluate_func(func) for func in self.population]\n            self.best_solution = self.get_best_solution()\n            self.population = [new_solution]\n            self.fitness_values = [self.evaluate_func(func) for func in self.population]\n            return self.best_solution\n        else:\n            return solution\n\n# Example usage\ndef func1(x):\n    return sum(x**2)\n\ndef func2(x):\n    return sum(x**3)\n\ndef func3(x):\n    return sum(x**4)\n\ndef func4(x):\n    return sum(x**5)\n\ndef func5(x):\n    return sum(x**6)\n\ndef func6(x):\n    return sum(x**7)\n\ndef func7(x):\n    return sum(x**8)\n\ndef func8(x):\n    return sum(x**9)\n\ndef func9(x):\n    return sum(x**10)\n\ndef func10(x):\n    return sum(x**11)\n\ndef func11(x):\n    return sum(x**12)\n\ndef func12(x):\n    return sum(x**13)\n\ndef func13(x):\n    return sum(x**14)\n\ndef func14(x):\n    return sum(x**15)\n\ndef func15(x):\n    return sum(x**16)\n\ndef func16(x):\n    return sum(x**17)\n\ndef func17(x):\n    return sum(x**18)\n\ndef func18(x):\n    return sum(x**19)\n\ndef func19(x):\n    return sum(x**20)\n\ndef func20(x):\n    return sum(x**21)\n\ndef func21(x):\n    return sum(x**22)\n\ndef func22(x):\n    return sum(x**23)\n\ndef func23(x):\n    return sum(x**24)\n\ndef func24(x):\n    return sum(x**25)\n\neads = EADS(budget=100, dim=10)\nfor _ in range(100):\n    eads.update_solution(eads.best_solution)\n    print(eads.best_solution)", "name": "EADS", "description": "Novel Evolutionary Algorithm with Differential Search (EADS) for black box optimization.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'EADS' object has no attribute 'budget_evaluations'\").", "error": "AttributeError(\"'EADS' object has no attribute 'budget_evaluations'\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "ed641ace-f2d7-4b2d-b5e8-cf9d041b7d59", "solution": "import numpy as np\nimport random\n\nclass PEABBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.population = self.initialize_population()\n        self.best_solution = self.get_best_solution()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            population.append(solution)\n        return population\n\n    def get_best_solution(self):\n        best_solution = min(self.population, key=lambda x: self.evaluate_function(x))\n        return best_solution\n\n    def evaluate_function(self, solution):\n        return self.func(solution)\n\n    def update_population(self, func):\n        for _ in range(self.population_size):\n            if self.budget > 0:\n                # Select a random parent from the current population\n                parent = random.choice(self.population)\n                # Generate a child using crossover and mutation\n                child = self.crossover(parent)\n                child = self.mutate(child)\n                # Evaluate the child and replace the worst solution in the population\n                child_score = self.evaluate_function(child)\n                if child_score < self.evaluate_function(min(self.population, key=lambda x: self.evaluate_function(x))):\n                    self.population.remove(min(self.population, key=lambda x: self.evaluate_function(x)))\n                    self.population.append(child)\n                    self.best_solution = min(self.population, key=lambda x: self.evaluate_function(x))\n                    self.budget -= 1\n            else:\n                break\n\n    def crossover(self, parent):\n        child = parent.copy()\n        # Perform a random crossover\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent[i] + np.random.uniform(-1.0, 1.0)\n        return child\n\n    def mutate(self, solution):\n        # Perform a random mutation\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                solution[i] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            self.update_population(func)\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\npeabbo = PEABBO(budget=100, dim=10)\nbest_solution = peabbo(func)\nprint(best_solution)", "name": "PEABBO", "description": "Novel Probabilistic Evolutionary Algorithm for Black Box Optimization (PEABBO)", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'PEABBO' object has no attribute 'func'\").", "error": "AttributeError(\"'PEABBO' object has no attribute 'func'\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "87890b20-1b80-418c-93a8-0e0fdb905e42", "solution": "import random\nimport math\nimport numpy as np\n\nclass HybridGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        # Initialize population\n        population = []\n        for _ in range(self.population_size):\n            individual = [random.uniform(-5.0, 5.0) for _ in range(self.dim)]\n            population.append(individual)\n\n        # Evaluate initial population\n        scores = [func(individual) for individual in population]\n        for i in range(self.population_size):\n            population[i] = (population[i], scores[i])\n\n        # Genetic Algorithm\n        for _ in range(self.budget):\n            # Select parents\n            parents = random.sample(population, self.population_size // 2)\n\n            # Crossover\n            offspring = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = random.sample(parents, 2)\n                child = [(parent1[0][i] + parent2[0][i]) / 2 for i in range(self.dim)]\n                offspring.append(child)\n\n            # Mutation\n            for i in range(self.population_size // 2):\n                if random.random() < self.mutation_rate:\n                    mutation = [random.uniform(-5.0, 5.0) for _ in range(self.dim)]\n                    child = [(child[0][i] + mutation[i]) for i in range(self.dim)]\n                    offspring[i] = (child, [func(child)])\n\n            # Update population\n            population = offspring + parents\n\n            # Simulated Annealing\n            scores = [func(individual[0]) for individual in population]\n            for i in range(self.population_size):\n                if scores[i] < population[i][1]:\n                    population[i] = (population[i][0], scores[i])\n                elif random.random() < math.exp((population[i][1] - scores[i]) / self.temperature):\n                    population[i] = (population[i][0], scores[i])\n\n            # Cool down temperature\n            self.temperature *= self.cooling_rate\n\n        # Return best individual\n        best_individual = max(population, key=lambda individual: individual[1])\n        return best_individual[0]\n\n# Test the algorithm\ndef func(x):\n    return sum(i**2 for i in x)\n\nhybrid_ga = HybridGA(budget=100, dim=10)\nbest_individual = hybrid_ga(func)\nprint(best_individual)", "name": "HybridGA", "description": "Hybrid Genetic Algorithm with Simulated Annealing", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "b454f7d6-8d09-4bfc-a202-e6199b2242d0", "solution": "import numpy as np\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n        self.fitness = np.zeros(self.population_size)\n        self.best_solution = self.population[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of the current population\n            self.fitness = func(self.population)\n\n            # Select the best individual\n            self.best_solution = self.population[np.argmin(self.fitness)]\n\n            # Perform probabilistic mutation\n            mutation_prob = 0.3\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    # Select a random dimension to mutate\n                    dim_idx = np.random.randint(0, self.dim)\n                    # Generate a new value for the dimension\n                    new_val = np.random.uniform(-5.0, 5.0)\n                    # Replace the old value with the new one\n                    self.population[i, dim_idx] = new_val\n\n            # Perform selection\n            self.population = self.population[np.argsort(self.fitness)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 5\nalgorithm = HybridEvolutionaryAlgorithm(budget, dim)\nbest_solution = algorithm(func)\nprint(\"Best solution:\", best_solution)", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Evolutionary Algorithm with Hybrid Probabilistic Mutation and Selection", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 3 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 3 is out of bounds for axis 0 with size 1')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "803e111c-1bd0-4f09-89f7-9685d3f8a26a", "solution": "import numpy as np\nimport random\n\nclass MetaHeuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.population = self.initialize_population()\n        self.best_individual = self.population[0]\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(-5.0, 5.0, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n        self.population = sorted(self.population, key=lambda x: func(x))\n        self.best_individual = self.population[0]\n\n    def mutate(self, individual):\n        mutation_rate = 0.3\n        mutated_individual = individual.copy()\n        for i in range(self.dim):\n            if random.random() < mutation_rate:\n                mutated_individual[i] += np.random.uniform(-1.0, 1.0)\n                mutated_individual[i] = max(-5.0, min(5.0, mutated_individual[i]))\n        return mutated_individual\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            if len(self.population) > self.population_size:\n                self.population.pop()\n            best_individual = self.population[0]\n            mutated_individual = self.mutate(best_individual)\n            self.population.append(mutated_individual)\n            self.population = sorted(self.population, key=lambda x: func(x))\n            self.best_individual = self.population[0]\n        return self.best_individual\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nmeta_heuristic = MetaHeuristic(100, 10)\nbest_individual = meta_heuristic(func)\nprint(best_individual)", "name": "MetaHeuristic", "description": "Novel \"Probability-Adaptive Meta-Heuristic\" algorithm that adapts to the best-performing individuals in the population and applies a probability-based mutation to refine their strategies.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "1b732eb9-d4d3-433d-8aa1-736af3a34c22", "solution": "import numpy as np\nimport random\n\nclass PAEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = [random.uniform(-5.0, 5.0) for _ in range(self.dim)]\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        scores = []\n        for individual in self.population:\n            score = func(individual)\n            scores.append(score)\n        return scores\n\n    def selection(self, scores):\n        probabilities = np.array(scores) / np.sum(scores)\n        selected_indices = np.random.choice(len(self.population), size=self.population_size, p=probabilities)\n        selected_individuals = [self.population[i] for i in selected_indices]\n        return selected_individuals\n\n    def crossover(self, individuals1, individuals2):\n        offspring = []\n        for i in range(len(individuals1)):\n            if random.random() < self.crossover_rate:\n                parent1 = individuals1[i]\n                parent2 = individuals2[i]\n                child = [(parent1[j] + parent2[j]) / 2 for j in range(self.dim)]\n                offspring.append(child)\n            else:\n                offspring.append(parent1)\n        return offspring\n\n    def mutation(self, individuals):\n        mutated_individuals = []\n        for individual in individuals:\n            mutated_individual = individual.copy()\n            for j in range(self.dim):\n                if random.random() < self.mutation_rate:\n                    mutated_individual[j] += random.uniform(-1.0, 1.0)\n                    mutated_individual[j] = max(-5.0, min(5.0, mutated_individual[j]))\n            mutated_individuals.append(mutated_individual)\n        return mutated_individuals\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            scores = self.evaluate(func)\n            selected_individuals = self.selection(scores)\n            offspring = self.crossover(selected_individuals, selected_individuals)\n            mutated_offspring = self.mutation(offspring)\n            self.population = mutated_offspring\n            scores = self.evaluate(func)\n            selected_indices = np.argmax(scores)\n            best_individual = self.population[selected_indices]\n            print(f\"Best individual: {best_individual}\")\n            print(f\"Best score: {scores[selected_indices]}\")", "name": "PAEA", "description": "Novel \"Probabilistic Adaptive Evolutionary Algorithm\" (PAEA) with adaptive mutation and crossover.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'PAEA' object is not callable\").", "error": "TypeError(\"'PAEA' object is not callable\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "4e60eb87-bd6b-4244-a1b9-a4206726d9e1", "solution": "import numpy as np\nimport random\n\nclass CRS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        # Initialize the population with random individuals\n        population = []\n        for _ in range(self.budget):\n            individual = np.random.uniform(-5.0, 5.0, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        # Evaluate the fitness of each individual in the population\n        fitness = [func(individual) for individual in self.population]\n        # Select the fittest individual\n        fittest_individual = np.argmax(fitness)\n        return fittest_individual\n\n    def crossover(self, parent1, parent2):\n        # Perform crossover to create a new individual\n        child = parent1 + (parent2 - parent1) * np.random.uniform(0, 1)\n        return child\n\n    def recombination(self, parent1, parent2):\n        # Perform recombination to create a new individual\n        child = parent1 + (parent2 - parent1) * np.random.uniform(0, 1)\n        return child\n\n    def selection(self, population):\n        # Select the fittest individual\n        fitness = [func(individual) for individual in population]\n        fittest_individual = np.argmax(fitness)\n        return population[fittest_individual]\n\n    def refine(self, selected_individual):\n        # Refine the strategy of the selected individual with a probability of 0.3\n        if random.random() < 0.3:\n            # Randomly change a dimension of the individual\n            dim_to_change = random.randint(0, self.dim - 1)\n            self.population[self.population.index(selected_individual)][dim_to_change] += np.random.uniform(-1.0, 1.0)\n        return selected_individual\n\n    def optimize(self, func):\n        # Optimize the black box function using the CRS algorithm\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fittest_individual = self.evaluate(func)\n            # Select the fittest individual\n            selected_individual = self.selection(self.population)\n            # Refine the strategy of the selected individual\n            selected_individual = self.refine(selected_individual)\n            # Create a new individual by crossover and recombination\n            new_individual = self.crossover(selected_individual, selected_individual)\n            # Replace the fittest individual with the new individual\n            self.population[fittest_individual] = new_individual\n\n# Usage\ndef func(x):\n    return np.sum(x**2)\n\ncrs = CRS(budget=100, dim=10)\ncrs.optimize(func)\nprint(crs.population)", "name": "CRS", "description": "Novel \"Crossover-Recombination-Selection\" (CRS) algorithm with probabilistic refinement.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "104aab32-d13f-4843-a5d8-17be72a72837", "solution": "import numpy as np\n\nclass ProbabilisticMutationCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = (-5.0, 5.0)\n        self.population_size = 100\n        self.population = np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n        self.fitness_values = np.zeros(self.population_size)\n        self.best_solution = np.random.uniform(self.search_space[0], self.search_space[1], (self.dim,))\n\n    def __call__(self, func):\n        # Evaluate the fitness of the current population\n        for i in range(self.population_size):\n            self.fitness_values[i] = func(self.population[i])\n\n        # Select the best solution\n        idx = np.argmin(self.fitness_values)\n        self.best_solution = self.population[idx]\n\n        # Perform mutation and crossover\n        for i in range(self.population_size):\n            if np.random.rand() < 0.3:\n                # Mutation: perturb the solution by a small amount\n                self.population[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                self.population[i] = np.clip(self.population[i], self.search_space[0], self.search_space[1])\n\n            if np.random.rand() < 0.3:\n                # Crossover: combine two solutions\n                parent1_idx = np.random.randint(0, self.population_size)\n                parent2_idx = np.random.randint(0, self.population_size)\n                child = self.population[parent1_idx] + (self.population[parent2_idx] - self.population[parent1_idx])\n                self.population[i] = np.clip(child, self.search_space[0], self.search_space[1])\n\n        # Evaluate the fitness of the new population\n        for i in range(self.population_size):\n            self.fitness_values[i] = func(self.population[i])\n\n        # Replace the least fit solution with the best solution\n        idx = np.argmin(self.fitness_values)\n        self.population[idx] = self.best_solution\n\n        # Check if the budget is exhausted\n        if self.fitness_values[np.argmin(self.fitness_values)] < func(self.best_solution):\n            return\n        if self.budget == 0:\n            raise Exception(\"Budget exhausted\")\n\n        # Decrement the budget\n        self.budget -= 1\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = ProbabilisticMutationCrossover(budget, dim)\noptimizer(func)", "name": "ProbabilisticMutationCrossover", "description": "Novel probabilistic mutation and crossover algorithm for black box optimization.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "36c94e97-ad71-4e9b-8891-98588c10b22f", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.harmony_memory_size = 100\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def fitness(self, func, individual):\n        return func(individual)\n\n    def evaluate_population(self, func):\n        fitnesses = [self.fitness(func, individual) for individual in self.population]\n        return fitnesses\n\n    def select_parents(self, fitnesses):\n        parents = np.array(self.population)[np.argsort(fitnesses)]\n        return parents[:self.population_size//2]\n\n    def crossover(self, parents):\n        offspring = []\n        for _ in range(self.population_size//2):\n            parent1, parent2 = random.sample(parents, 2)\n            child = (parent1 + parent2) / 2\n            offspring.append(child)\n        return offspring\n\n    def mutate(self, offspring):\n        mutated_offspring = []\n        for individual in offspring:\n            for i in range(self.dim):\n                if random.random() < 0.1:\n                    individual[i] += random.uniform(-1, 1)\n                    individual[i] = max(self.lower_bound, min(individual[i], self.upper_bound))\n            mutated_offspring.append(individual)\n        return mutated_offspring\n\n    def harmony_search(self, func):\n        for _ in range(self.budget):\n            fitnesses = self.evaluate_population(func)\n            parents = self.select_parents(fitnesses)\n            offspring = self.crossover(parents)\n            offspring = self.mutate(offspring)\n            self.population = np.array(offspring)\n            new_fitnesses = self.evaluate_population(func)\n            for i, (parent, new_individual) in enumerate(zip(parents, offspring)):\n                if new_fitnesses[i] < fitnesses[i]:\n                    self.population[i] = new_individual\n\n    def __call__(self, func):\n        self.harmony_search(func)\n        return self.population[np.argmin([self.fitness(func, individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return sum(i**2 for i in x)\n\nbudget = 100\ndim = 10\nswarm_harmony_search = SwarmHarmonySearch(budget, dim)\nbest_individual = swarm_harmony_search(func)\nprint(best_individual)", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search\" algorithm for black box optimization.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "45c12279-8f2d-4ffe-9319-d848df5eb130", "solution": "import numpy as np\n\nclass PHEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population = self.initialize_population()\n        self.score = np.inf\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.budget):\n            # Randomly select a dimension\n            dim = np.random.randint(0, self.dim)\n            # Randomly generate a solution within the search space\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            population.append(solution)\n        return population\n\n    def evaluate(self, func):\n        # Evaluate the fitness of each solution\n        fitness = np.array([func(solution) for solution in self.population])\n        # Update the population with the fittest solutions\n        self.population = self.population[np.argsort(fitness)][-self.budget:]\n        # Update the score\n        self.score = np.min(fitness)\n\n    def refine_solution(self, index):\n        # Select a random solution to refine\n        solution = self.population[np.random.randint(0, self.budget)]\n        # Randomly select a dimension to change\n        dim = np.random.randint(0, self.dim)\n        # Randomly select a change type (within the bounds of the search space)\n        change_type = np.random.choice(['+/-', '-/+', '*/+'])\n        # Apply the change\n        if change_type == '+/-':\n            solution[dim] += np.random.uniform(-1.0, 1.0)\n        elif change_type == '-/+':\n            solution[dim] -= np.random.uniform(1.0, 5.0)\n        elif change_type == '*/+':\n            solution[dim] *= np.random.uniform(0.5, 2.0)\n        # Return the refined solution\n        return solution\n\n    def __call__(self, func):\n        # Evaluate the initial population\n        self.evaluate(func)\n        # Refine the solution using probability 0.3\n        for _ in range(int(self.budget * 0.3)):\n            index = np.random.randint(0, self.budget)\n            self.population[index] = self.refine_solution(index)\n        # Evaluate the refined population\n        self.evaluate(func)", "name": "PHEA", "description": "Novel \"Probability-Adaptive Hybrid Evolutionary Algorithm\" (PHEA) with probability 0.3 to refine the selected solution.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('only integer scalar arrays can be converted to a scalar index').", "error": "TypeError('only integer scalar arrays can be converted to a scalar index')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "27c01d65-461d-478b-bd9d-baa6da9cdda5", "solution": "import numpy as np\n\nclass EvolutionarySpaceShifting:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.5\n        self.initial_population = self.generate_initial_population()\n\n    def generate_initial_population(self):\n        return [np.random.uniform(self.lower_bound, self.upper_bound, self.dim) for _ in range(self.population_size)]\n\n    def fitness(self, x):\n        return np.mean(np.abs(np.random.normal(0, 1, x.shape) * (x - self.lower_bound) + self.upper_bound))\n\n    def evolve(self, func):\n        for _ in range(self.budget):\n            # Select parents\n            parents = np.array([np.random.choice(self.initial_population, 2, replace=False) for _ in range(self.population_size)])\n\n            # Calculate fitness\n            fitnesses = np.array([self.fitness(parent) for parent in parents])\n\n            # Select fittest\n            fittest_indices = np.argsort(fitnesses)[:int(self.population_size * 0.2)]\n            fittest_parents = parents[fittest_indices]\n\n            # Crossover\n            offspring = []\n            for _ in range(self.population_size):\n                parent1, parent2 = np.random.choice(fittest_parents, 2, replace=False)\n                child = (parent1 + parent2) / 2\n                if np.random.rand() < self.crossover_rate:\n                    child = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                offspring.append(child)\n\n            # Mutation\n            mutated_offspring = []\n            for child in offspring:\n                if np.random.rand() < self.mutation_rate:\n                    mutated_child = child + np.random.uniform(-0.1, 0.1, self.dim)\n                    mutated_child = np.clip(mutated_child, self.lower_bound, self.upper_bound)\n                mutated_offspring.append(mutated_child)\n\n            # Replace worst individuals\n            self.initial_population = mutated_offspring\n\n            # Evaluate fitness\n            fitnesses = np.array([self.fitness(x) for x in self.initial_population])\n            self.initial_population = self.initial_population[np.argsort(fitnesses)]\n\n    def __call__(self, func):\n        self.evolve(func)\n        return self.initial_population[np.argmin([self.fitness(x) for x in self.initial_population])]\n\n# Usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    algorithm = EvolutionarySpaceShifting(budget, dim)\n    best_solution = algorithm(np)\n    print(\"Best solution:\", best_solution)", "name": "EvolutionarySpaceShifting", "description": "Novel \"Evolutionary Space Shifting\" algorithm for black box optimization", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "67b569fe-4df7-46b4-8625-bee0b37de5b4", "solution": "import numpy as np\nimport random\n\nclass EvolutionarySwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.particles = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.pbest = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.gbest = np.random.uniform(-5.0, 5.0, self.dim)\n        self.candidates = []\n        self.fitness_values = []\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for particle in self.particles:\n                fitness = func(particle)\n                self.fitness_values.append(fitness)\n                if fitness < func(self.pbest[np.argmin(self.fitness_values)]):\n                    self.pbest[np.argmin(self.fitness_values)] = particle\n                if fitness < func(self.gbest):\n                    self.gbest = particle\n            self.candidates.append(self.pbest[np.argmin(self.fitness_values)])\n            self.fitness_values = []\n            # Evolutionary strategy: perturb the best particle\n            if random.random() < 0.3:\n                self.pbest[np.argmin(self.fitness_values)] += np.random.uniform(-0.1, 0.1, self.dim)\n                self.fitness_values.append(func(self.pbest[np.argmin(self.fitness_values)]))\n            # Particle swarm optimization: update the best particle\n            if random.random() < 0.3:\n                self.pbest[np.argmin(self.fitness_values)] = self.gbest + np.random.uniform(-0.1, 0.1, self.dim)\n                self.fitness_values.append(func(self.pbest[np.argmin(self.fitness_values)]))\n            # Random mutation\n            if random.random() < 0.3:\n                self.pbest[np.argmin(self.fitness_values)] += np.random.uniform(-0.1, 0.1, self.dim)\n                self.fitness_values.append(func(self.pbest[np.argmin(self.fitness_values)]))\n        return self.candidates[np.argmin(self.fitness_values)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\noptimizer = EvolutionarySwarmOptimizer(100, 2)\nbest_solution = optimizer(func)\nprint(best_solution)", "name": "EvolutionarySwarmOptimizer", "description": "Novel \"Evolutionary Swarm Optimization\" algorithm using particle swarm optimization and evolutionary strategies to handle black box optimization problems.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('attempt to get argmin of an empty sequence').", "error": "ValueError('attempt to get argmin of an empty sequence')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "f984d288-1b55-4e4a-8753-9f205aeac77d", "solution": "import numpy as np\n\nclass ProbabilisticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = np.zeros((self.population_size, self.dim))\n        self.best_position_global = np.zeros(self.dim)\n        self.best_fitness_global = np.inf\n        self.perturbation_probability = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.particles)\n            for i in range(self.population_size):\n                if np.random.rand() < self.perturbation_probability:\n                    self.particles[i] += np.random.uniform(-1, 1, self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                if fitness[i] < self.best_fitness_global:\n                    self.best_position_global = self.particles[i]\n                    self.best_fitness_global = fitness[i]\n                if fitness[i] < self.best_fitness_global[i]:\n                    self.best_position[i] = self.particles[i]\n            self.velocity = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocity[i] = self.best_position[i] + r1 * (self.particles[i] - self.best_position[i])\n                self.velocity[i] = np.clip(self.velocity[i], self.lower_bound, self.upper_bound)\n            self.particles += self.velocity\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = ProbabilisticPSO(budget, dim)\nbest_position = optimizer(func)\nprint(\"Best position:\", best_position)\nprint(\"Best fitness:\", func(best_position))", "name": "ProbabilisticPSO", "description": "Novel \"Probabilistic-Particle- Swarm-Optimization\" algorithm", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "e6d7c2b1-7b27-4ad2-b5f1-35917c806ae2", "solution": "import numpy as np\nimport random\n\nclass EvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = [self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.dim)]\n        self.mutation_rate = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the objective function\n            x = np.array(self.population)\n            f_x = func(x)\n            # Update the population\n            self.population = [self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.dim) for _ in range(len(x))]\n            # Replace the worst individual with the best one\n            self.population = [min(self.population, key=lambda x: f_x(x)) if f_x(x) < f_x(best) else best for best in self.population]\n            # Refine the best individual with a probabilistic mutation\n            if random.random() < self.mutation_rate:\n                index = np.random.randint(0, len(self.population))\n                self.population[index] = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.dim)\n        return min(self.population, key=lambda x: func(x))\n\n# Example usage\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nes = EvolutionStrategy(budget=100, dim=2)\nbest_x = es(func)\nprint(f\"Best x: {best_x}\")\nprint(f\"Best f(x): {func(best_x)}\")", "name": "EvolutionStrategy", "description": "Novel probabilistic evolution strategy with adaptive mutation rate.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 1 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 1 is out of bounds for axis 0 with size 1')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "d0848d69-f183-4962-86ad-fda80e619f1e", "solution": "import numpy as np\nimport random\n\nclass Paea:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.selection_rate = 0.5\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(-5.0, 5.0, self.dim)\n            population.append(individual)\n        return population\n\n    def fitness(self, func, individual):\n        return func(individual)\n\n    def select(self, population):\n        scores = [self.fitness(func, individual) for individual in population]\n        sorted_indices = np.argsort(scores)\n        selected_indices = sorted_indices[:int(self.population_size * self.selection_rate)]\n        return [population[i] for i in selected_indices]\n\n    def crossover(self, parent1, parent2):\n        if random.random() < 0.5:\n            child = parent1 + (parent2 - parent1) / 2\n        else:\n            child = parent2 + (parent1 - parent2) / 2\n        return child\n\n    def mutate(self, individual):\n        mutated_individual = individual.copy()\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                mutated_individual[i] += np.random.uniform(-1.0, 1.0)\n        return mutated_individual\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            population = self.select(self.population)\n            new_population = []\n            for _ in range(self.population_size):\n                parent1, parent2 = random.sample(population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutate(child)\n                new_population.append(child)\n            self.population = new_population\n        return self.population[np.argmin([self.fitness(func, individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\npaea = Paea(budget=100, dim=10)\nresult = paea(func)\nprint(result)", "name": "Paea", "description": "Novel Probabilistic-Adaptive Evolutionary Algorithm (Paea) with adaptive mutation and selection.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "5030bfef-efa8-48cb-8d16-37ca7a0ea71e", "solution": "import numpy as np\nimport random\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n        self.best_individual = np.random.uniform(-5.0, 5.0, size=self.dim)\n        self.best_score = float('inf')\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Selection\n            scores = [func(individual) for individual in self.population]\n            probabilities = np.array(scores) / np.sum(scores)\n            selected_indices = np.random.choice(self.population_size, size=self.population_size, p=probabilities)\n            selected_population = [self.population[i] for i in selected_indices]\n\n            # Crossover\n            offspring_population = []\n            for _ in range(self.population_size):\n                parent1, parent2 = random.sample(selected_population, 2)\n                child = (parent1 + parent2) / 2\n                offspring_population.append(child)\n\n            # Mutation\n            mutated_population = []\n            for individual in offspring_population:\n                if random.random() < 0.1:\n                    mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                    individual += mutation\n                    individual = np.clip(individual, -5.0, 5.0)\n                mutated_population.append(individual)\n\n            # Replacement\n            self.population = mutated_population\n            self.population = np.array(self.population)\n            self.population = np.sort(self.population, axis=0)\n\n            # Update best individual\n            for individual in self.population:\n                if func(individual) < self.best_score:\n                    self.best_individual = individual\n                    self.best_score = func(individual)\n\n            # Probabilistic adaptation\n            if random.random() < 0.3:\n                for i in range(self.population_size):\n                    if random.random() < 0.5:\n                        self.population[i] += random.uniform(-0.1, 0.1)\n                        self.population[i] = np.clip(self.population[i], -5.0, 5.0)\n\n        return self.best_individual, self.best_score\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    func = lambda x: np.sum(x**2)\n    algorithm = HybridEvolutionaryAlgorithm(budget, dim)\n    best_individual, best_score = algorithm(func)\n    print(\"Best Individual:\", best_individual)\n    print(\"Best Score:\", best_score)", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm with Probabilistic Adaptation", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "be3e21f3-343b-4d07-814d-962445dec90f", "solution": "import numpy as np\nfrom scipy.stats import norm\n\nclass EvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.mutation_std = 1.0\n        self.mean = np.zeros(self.dim)\n        self.std = np.ones(self.dim)\n        self.population = np.random.normal(self.mean, self.std, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the function at the current population\n            evaluations = np.array([func(x) for x in self.population.flatten()]).reshape(self.population_size, self.dim)\n\n            # Select the best individual\n            best_idx = np.argmax(evaluations, axis=0)\n            best_individual = self.population[best_idx]\n\n            # Compute the probability of mutation for each dimension\n            mutation_probabilities = norm.pdf(np.abs(evaluations), scale=self.mutation_std)\n\n            # Refine the strategy with probability 0.3\n            if np.random.rand() < 0.3:\n                for i in range(self.dim):\n                    if np.random.rand() < mutation_probabilities[i]:\n                        # Perform mutation\n                        self.population[:, i] += np.random.normal(0, self.mutation_std, self.population_size)\n                        self.std[i] *= 1.1  # Increase the standard deviation for the next iteration\n\n            # Update the mean\n            self.mean = np.mean(self.population, axis=0)\n\n            # Update the population\n            self.population = np.random.normal(self.mean, self.std, (self.population_size, self.dim))\n\n            # Print the best individual and its evaluation\n            print(f\"Best individual: {best_individual}, Evaluation: {evaluations[best_idx]}\")\n\n# Test the algorithm\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionStrategy(budget=100, dim=10)\nes(\"func\")", "name": "EvolutionStrategy", "description": "Novel probabilistic evolution strategy with adaptive mutation rate", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'str' object is not callable\").", "error": "TypeError(\"'str' object is not callable\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "6dc5a027-a2a4-4731-9c58-77237b2f4a7d", "solution": "import numpy as np\nimport random\n\nclass PAEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.population = []\n        self.boundaries = [-5.0, 5.0]\n        self.init_population()\n\n    def init_population(self):\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.boundaries[0], self.boundaries[1], self.dim)\n            self.population.append(individual)\n\n    def __call__(self, func):\n        if len(self.population) == 0:\n            self.init_population()\n\n        # Evaluate the fitness of each individual\n        fitness = [func(individual) for individual in self.population]\n\n        # Select the fittest individuals\n        fittest_indices = np.argsort(fitness)[:self.population_size//2]\n        self.population = [self.population[i] for i in fittest_indices]\n\n        # Crossover and mutation\n        new_population = []\n        for _ in range(self.population_size//2):\n            parent1, parent2 = random.sample(self.population, 2)\n            child = parent1 + (parent2 - parent1) * np.random.uniform(0, 1, self.dim)\n            new_population.append(child)\n\n        # Adaptive mutation\n        mutation_prob = 0.1\n        for individual in new_population:\n            if np.random.rand() < mutation_prob:\n                individual += np.random.uniform(-0.1, 0.1, self.dim)\n                individual = np.clip(individual, self.boundaries[0], self.boundaries[1])\n\n        # Update the population\n        self.population = new_population\n\n        # Check if the budget is reached\n        if len(self.population) >= self.budget:\n            return max(fitness)\n\n        # Replace the least fit individual with a new one\n        least_fit_individual = min(self.population, key=lambda x: func(x))\n        new_individual = np.random.uniform(self.boundaries[0], self.boundaries[1], self.dim)\n        new_individual = np.clip(new_individual, self.boundaries[0], self.boundaries[1])\n        self.population[self.population.index(least_fit_individual)] = new_individual\n\n        return None\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\npaea = PAEA(100, 5)\nprint(paea(func))", "name": "PAEA", "description": "Novel \"Probability-Adaptive Evolutionary Algorithm\" (PAEA) for black box optimization", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "faaf7668-1d19-42d9-8779-b520943fe66f", "solution": "import numpy as np\nimport random\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.population = [np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)]\n        self.best_individual = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_score = -np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the population\n            scores = [func(individual) for individual in self.population]\n            # Select the best individual\n            best_individual_index = np.argmax(scores)\n            self.best_individual = self.population[best_individual_index]\n            self.best_score = scores[best_individual_index]\n\n            # Update the population using simulated annealing and particle swarm optimization\n            new_population = []\n            for _ in range(self.population_size):\n                # Generate a new individual using simulated annealing\n                new_individual = self.population[best_individual_index]\n                while True:\n                    new_individual = new_individual + np.random.normal(0, 1)\n                    new_individual = np.clip(new_individual, -5.0, 5.0)\n                    new_individual_score = func(new_individual)\n                    if new_individual_score > self.best_score:\n                        break\n                # Update the new individual using particle swarm optimization\n                new_individual = new_individual + np.random.uniform(-1, 1, self.dim)\n                new_individual = np.clip(new_individual, -5.0, 5.0)\n                new_individual_score = func(new_individual)\n                if new_individual_score > self.best_score:\n                    new_individual = new_individual + np.random.normal(0, 1)\n                    new_individual = np.clip(new_individual, -5.0, 5.0)\n                new_individual_score = func(new_individual)\n                if new_individual_score > self.best_score:\n                    break\n                new_individual = new_individual + np.random.normal(0, 1)\n                new_individual = np.clip(new_individual, -5.0, 5.0)\n                new_individual_score = func(new_individual)\n                if new_individual_score > self.best_score:\n                    break\n                new_population.append(new_individual)\n            self.population = new_population\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nhybrid = HybridMetaheuristic(budget=100, dim=5)\nhybrid()", "name": "HybridMetaheuristic", "description": "Novel hybrid of simulated annealing and particle swarm optimization for black box optimization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"HybridMetaheuristic.__call__() missing 1 required positional argument: 'func'\").", "error": "TypeError(\"HybridMetaheuristic.__call__() missing 1 required positional argument: 'func'\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "d0b38cb3-05ac-458e-86c9-5d6754f0188c", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass AdaptiveProbabilisticEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutate_prob = 0.1\n        self.crossover_prob = 0.7\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        return population\n\n    def fitness(self, func, x):\n        return func(x)\n\n    def evaluate(self, func):\n        for _ in range(self.budget):\n            fitnesses = [self.fitness(func, x) for x in self.population]\n            best_idx = np.argmin(fitnesses)\n            best_x = self.population[best_idx]\n            best_f = fitnesses[best_idx]\n\n            # Select parents\n            parents = np.array([self.population[np.random.choice(self.population_size, 2, replace=False)] for _ in range(self.population_size)])\n\n            # Crossover\n            offspring = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = parents[i, :]\n                if np.random.rand() < self.crossover_prob:\n                    offspring[i] = (parent1 + parent2) / 2\n\n            # Mutation\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutate_prob:\n                    offspring[i] += np.random.uniform(-1.0, 1.0, self.dim)\n\n            # Replace worst individual\n            worst_idx = np.argmin([self.fitness(func, x) for x in offspring])\n            self.population[worst_idx] = offspring[worst_idx]\n\n    def optimize(self, func):\n        self.evaluate(func)\n        return np.min([self.fitness(func, x) for x in self.population])\n\n# Usage\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = AdaptiveProbabilisticEvolutionaryAlgorithm(budget, dim)\nbest_x = optimizer.optimize(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f:\", func(best_x))", "name": "AdaptiveProbabilisticEvolutionaryAlgorithm", "description": "Novel adaptive probabilistic evolutionary algorithm for black box optimization.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'AdaptiveProbabilisticEvolutionaryAlgorithm' object is not callable\").", "error": "TypeError(\"'AdaptiveProbabilisticEvolutionaryAlgorithm' object is not callable\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "10e7b8bc-e89c-40ab-96d0-26da7c18f3b5", "solution": "import numpy as np\nimport random\n\nclass Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_score = -np.inf\n        self.pswarm = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            scores = np.zeros(self.population_size)\n            for i in range(self.population_size):\n                scores[i] = func(self.population[i])\n            best_idx = np.argmin(scores)\n            self.population[best_idx] = self.pswarm[best_idx]\n            scores = np.zeros(self.population_size)\n            for i in range(self.population_size):\n                scores[i] = func(self.population[i])\n            best_idx = np.argmin(scores)\n            self.best_solution = self.population[best_idx]\n            self.best_score = scores[best_idx]\n            if self.best_score < self.best_score:\n                self.pswarm[best_idx] = self.population[best_idx]\n                self.pswarm = self.pswarm / np.sum(self.pswarm) * self.budget\n                self.pswarm = self.pswarm + self.pswarm * np.random.normal(size=(self.population_size, self.dim))\n\n            # Probabilistic mutation\n            if random.random() < 0.3:\n                self.population[best_idx] += np.random.uniform(-0.1, 0.1, self.dim)\n                scores = np.zeros(self.population_size)\n                for i in range(self.population_size):\n                    scores[i] = func(self.population[i])\n                best_idx = np.argmin(scores)\n                self.best_solution = self.population[best_idx]\n                self.best_score = scores[best_idx]\n\n            # Probabilistic mutation\n            if random.random() < 0.3:\n                self.pswarm[best_idx] += np.random.uniform(-0.1, 0.1, self.dim)\n                scores = np.zeros(self.population_size)\n                for i in range(self.population_size):\n                    scores[i] = func(self.pswarm[i])\n                best_idx = np.argmin(scores)\n                self.pswarm[best_idx] = self.population[best_idx]\n                self.pswarm = self.pswarm / np.sum(self.pswarm) * self.budget\n                self.pswarm = self.pswarm + self.pswarm * np.random.normal(size=(self.population_size, self.dim))\n\n            # Probabilistic mutation\n            if random.random() < 0.3:\n                self.population[best_idx] += np.random.uniform(-0.1, 0.1, self.dim)\n                scores = np.zeros(self.population_size)\n                for i in range(self.population_size):\n                    scores[i] = func(self.population[i])\n                best_idx = np.argmin(scores)\n                self.best_solution = self.population[best_idx]\n                self.best_score = scores[best_idx]", "name": "Optimizer", "description": "Novel hybrid of Genetic Algorithm and Particle Swarm Optimization with probabilistic mutation.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "6ce48edc-aeef-40c4-ac2a-b2d8dda6f7ff", "solution": "import numpy as np\n\nclass ProbabilityRefinement:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.population = self.initialize_population()\n        self.best_solution = None\n        self.f_best = float('inf')\n\n    def initialize_population(self):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        return population\n\n    def evaluate(self, func):\n        self.f_best = min(self.f_best, func(self.population[:, 0]))\n        for i in range(self.population_size):\n            self.f_best = min(self.f_best, func(self.population[i, :]))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n            self.evaluate(func)\n\n            # Select best solution\n            self.best_solution = np.argmin(self.f_best)\n            self.f_best = func(self.population[self.best_solution, :])\n\n            # Refine strategy\n            if self.f_best < self.f_best * 0.7:\n                # 30% chance to change individual line of the selected solution\n                if np.random.rand() < 0.3:\n                    self.population[self.best_solution, :] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            else:\n                # 30% chance to change individual line of the selected solution\n                if np.random.rand() < 0.3:\n                    self.population[self.best_solution, :] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    self.f_best = func(self.population[self.best_solution, :])\n\n            # Update best solution\n            self.f_best = min(self.f_best, func(self.population[:, 0]))\n\n        return self.population[self.best_solution, :], self.f_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\nrf = ProbabilityRefinement(budget, dim)\nsolution, f_best = rf(func)\nprint(f\"Best solution: {solution}, Best fitness: {f_best}\")", "name": "ProbabilityRefinement", "description": "Novel \"Probability Refinement\" metaheuristic algorithm for black box optimization.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "761764a0-1017-4988-8934-ceab94d9fa1b", "solution": "import numpy as np\n\nclass EvolutionaryGradient:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.fitness = np.zeros((self.population_size,))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of the current population\n            self.fitness = func(self.population)\n\n            # Select the fittest individuals\n            indices = np.argsort(self.fitness)[:self.population_size//2]\n            self.population = self.population[indices]\n            self.fitness = self.fitness[indices]\n\n            # Calculate the gradient of the fitness function\n            gradient = np.zeros((self.dim,))\n            for i in range(self.population_size):\n                gradient += (self.fitness[i] - self.fitness[i-1]) * (self.population[i] - self.population[i-1]) / (self.population[i] - self.population[i-1])**2\n\n            # Update the population using evolutionary strategies\n            self.population += 0.1 * np.random.normal(0, 1, (self.population_size, self.dim))\n            self.population = np.clip(self.population, -5.0, 5.0)\n\n            # Refine the strategy by changing the learning rate and mutation rate with a probability of 0.3\n            if np.random.rand() < 0.3:\n                self.population *= np.random.uniform(0.9, 1.1, (self.population_size, self.dim))\n            if np.random.rand() < 0.3:\n                self.population += np.random.normal(0, 0.1, (self.population_size, self.dim))\n\n            # Normalize the population\n            self.population = self.population / np.max(np.abs(self.population))\n            self.fitness = func(self.population)\n\n# Test the algorithm\ndef test_evolutionary_gradient():\n    def func(x):\n        return np.sum(x**2)\n\n    budget = 100\n    dim = 10\n    algorithm = EvolutionaryGradient(budget, dim)\n    algorithm()\n    print(algorithm.population)\n\ntest_evolutionary_gradient()", "name": "EvolutionaryGradient", "description": "Novel \"Evolutionary-Gradient\" algorithm combining the strengths of evolutionary strategies and gradient information.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"EvolutionaryGradient.__call__() missing 1 required positional argument: 'func'\").", "error": "TypeError(\"EvolutionaryGradient.__call__() missing 1 required positional argument: 'func'\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "58797829-7cde-4d22-8120-de24dc4589aa", "solution": "import numpy as np\nimport random\n\nclass ProbabilityAdaptiveHybridEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.pso = PSO(self.population_size, self.dim, 0.8, 0.4)\n        self.de = DE(self.population_size, self.dim, 0.5, 0.2)\n        self.ga = GA(self.population_size, self.dim, 0.5, 0.1)\n        self.population = self.initialize_population()\n        self.best_individual = None\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Selection\n            population = self.population\n            weights = np.random.uniform(0, 1, size=self.population_size)\n            weights /= weights.sum()\n            selected = np.random.choice(self.population_size, size=self.population_size, p=weights)\n            selected = [population[i] for i in selected]\n\n            # Crossover\n            offspring = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = random.sample(selected, 2)\n                child = self.de.crossover(parent1, parent2)\n                offspring.append(child)\n\n            # Mutation\n            for i in range(len(offspring)):\n                if random.random() < 0.3:\n                    offspring[i] = self.pso.mutation(offspring[i])\n\n            # Hybridization\n            for i in range(len(offspring)):\n                if random.random() < 0.3:\n                    offspring[i] = self.ga.mutate(offspring[i])\n\n            # Evaluation\n            for i in range(len(offspring)):\n                offspring[i] = func(offspring[i])\n\n            # Replacement\n            self.population = offspring\n            self.population = [self.pso.select(self.population) for _ in range(self.population_size)]\n\n            # Update best individual\n            if self.best_individual is None or self.best_individual[1] < min(offspring):\n                self.best_individual = (min(offspring), min(offspring))\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(-5.0, 5.0, self.dim)\n            population.append(individual)\n        return population\n\n\nclass PSO:\n    def __init__(self, population_size, dim, c1, c2):\n        self.population_size = population_size\n        self.dim = dim\n        self.c1 = c1\n        self.c2 = c2\n        self.v = np.zeros((self.population_size, self.dim))\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best = np.zeros((self.population_size, self.dim))\n\n    def update(self, func):\n        for i in range(self.population_size):\n            r1 = np.random.uniform(0, 1)\n            r2 = np.random.uniform(0, 1)\n            self.x[i] += self.c1 * r1 * (self.best[i] - self.x[i]) + self.c2 * r2 * (self.x[i] - self.x[self.get_best()])\n            self.v[i] += self.c1 * r1 * (self.best[i] - self.x[i]) + self.c2 * r2 * (self.x[i] - self.x[self.get_best()])\n            self.x[i] += self.v[i]\n            self.best[i] = self.x[i]\n            self.best[i] = func(self.best[i])\n\n    def get_best(self):\n        return np.argmin([self.best[i, :].mean() for i in range(self.population_size)])\n\n    def select(self, population):\n        weights = np.random.uniform(0, 1, size=self.population_size)\n        weights /= weights.sum()\n        selected = np.random.choice(self.population_size, size=self.population_size, p=weights)\n        return [population[i] for i in selected]\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < 0.3:\n                individual[i] += np.random.uniform(-0.5, 0.5)\n        return individual\n\n\nclass DE:\n    def __init__(self, population_size, dim, c1, c2):\n        self.population_size = population_size\n        self.dim = dim\n        self.c1 = c1\n        self.c2 = c2\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.f = np.zeros((self.population_size, self.dim))\n\n    def update(self, func):\n        for i in range(self.population_size):\n            r1 = np.random.uniform(0, 1)\n            r2 = np.random.uniform(0, 1)\n            r3 = np.random.uniform(0, 1)\n            f1 = self.x[i] + r1 * (self.x[self.get_best(i)] - self.x[i])\n            f2 = self.x[i] + r2 * (self.x[self.get_best(i)] - self.x[i]) + r3 * (self.f[self.get_best(i)] - self.f[i])\n            self.x[i] = f1\n            self.f[i] = func(self.x[i])\n            if self.f[i] < self.f[self.get_best(i)]:\n                self.x[i] = f2\n                self.f[i] = func(self.x[i])\n\n    def get_best(self, i):\n        return np.argmin([self.f[j, :].mean() for j in range(self.population_size) if j!= i])\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + 0.5 * (parent2 - parent1)\n        return child\n\n    def mutate(self, individual):\n        for i in range(self.dim):\n            if random.random() < 0.3:\n                individual[i] += np.random.uniform(-0.5, 0.5)\n        return individual\n\n\nclass GA:\n    def __init__(self, population_size, dim, mutation_rate, crossover_rate):\n        self.population_size = population_size\n        self.dim = dim\n        self.mutation_rate = mutation_rate\n        self.crossover_rate = crossover_rate\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.f = np.zeros((self.population_size, self.dim))\n\n    def update(self, func):\n        for i in range(self.population_size):\n            if random.random() < self.mutation_rate:\n                self.x[i] = self.mutate(self.x[i])\n            if random.random() < self.crossover_rate:\n                self.x[i] = self.crossover(self.x[i], self.x[self.get_best(i)])\n            self.f[i] = func(self.x[i])\n\n    def get_best(self):\n        return np.argmin([self.f[i, :].mean() for i in range(self.population_size)])\n\n    def mutate(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += np.random.uniform(-0.5, 0.5)\n        return individual\n\n    def crossover(self, parent1, parent2):\n        child = 0.5 * (parent1 + parent2)\n        return child\n\n# Usage\ndef func(x):\n    return np.sum(x**2)\n\nea = ProbabilityAdaptiveHybridEA(100, 10)\nea()", "name": "ProbabilityAdaptiveHybridEA", "description": "Novel \"Probability-Adaptive Hybrid Evolutionary Algorithm\" with hybridization of PSO, DE, and GA.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"ProbabilityAdaptiveHybridEA.__call__() missing 1 required positional argument: 'func'\").", "error": "TypeError(\"ProbabilityAdaptiveHybridEA.__call__() missing 1 required positional argument: 'func'\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "b20dba95-2a6b-49e5-9add-f4d58d25947a", "solution": "import numpy as np\nimport random\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.x_best = np.zeros(self.dim)\n        self.f_best = np.inf\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.x_best\n\n        self.x = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n        self.f = np.zeros(self.population_size)\n\n        for i in range(self.population_size):\n            self.f[i] = func(self.x[i])\n\n        for _ in range(self.budget):\n            # Select the best individual\n            idx = np.argmin(self.f)\n            self.x_best = self.x[idx]\n            self.f_best = self.f[idx]\n\n            # Create a new population\n            new_x = np.zeros((self.population_size, self.dim))\n            new_f = np.zeros(self.population_size)\n\n            # Adaptive Differential Evolution\n            for j in range(self.population_size):\n                if random.random() < 0.3:\n                    # Refine the mutation strategy\n                    r1 = np.random.uniform(0, 1)\n                    r2 = np.random.uniform(0, 1)\n                    new_x[j] = self.x[j] + r1 * (self.x[idx] - self.x[j]) + r2 * (self.x[(idx + 1) % self.population_size] - self.x[j])\n                else:\n                    new_x[j] = self.x[j]\n\n                new_f[j] = func(new_x[j])\n\n            # Update the population\n            self.x = new_x\n            self.f = new_f\n\n            # Update the best individual\n            self.f_best = np.min(self.f)\n\n        return self.x_best\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nbudget = 100\ndim = 2\nde = AdaptiveDE(budget, dim)\nx_best = de(func)\nprint(x_best)", "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with probability-based mutation refinement", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "ca19fdca-7d27-4d9e-9bd3-9387cbba0c02", "solution": "import numpy as np\n\nclass HEAC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.elitism_rate = 0.3\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        for i in range(self.population_size):\n            population[i] = np.clip(population[i], -5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        fitness = np.array([func(x) for x in self.population])\n        self.population = np.array([x for _, x in sorted(zip(fitness, self.population))])\n        return fitness\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, child):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                child[i] = np.clip(child[i] + np.random.uniform(-1.0, 1.0), -5.0, 5.0)\n        return child\n\n    def update(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            if self.population_size < self.population:\n                new_individual = self.crossover(self.population[-1], self.population[np.random.randint(0, self.population_size - 1)])\n                new_individual = self.mutate(new_individual)\n                self.population = np.array([self.population[-1], new_individual])\n            else:\n                new_individual = self.crossover(self.population[np.random.randint(0, self.population_size - 1)], self.population[np.random.randint(0, self.population_size - 1)])\n                new_individual = self.mutate(new_individual)\n                self.population = np.array([self.population[-1], new_individual])\n            self.population = np.array([x for _, x in sorted(zip(self.evaluate(func), self.population))])\n        return self.population\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nheac = HEAC(budget=100, dim=10)\nselected_solution = heac.update(func)\nprint(selected_solution)", "name": "HEAC", "description": "Novel \"Hyper-Elitism and Adaptive Crossover\" (HEAC) algorithm for black box optimization.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "3ac2f556-0a97-4039-ba8e-520483574fe4", "solution": "import numpy as np\nimport random\n\nclass ESI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.swarm_size = 10\n        self.initial_population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = self.initial_population[0]\n        self.best_score = self.evaluate_function(self.best_individual, self.func)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the best individual in the current population\n            score = self.evaluate_function(self.best_individual, func)\n            print(f\"Best individual: {self.best_individual}, Best score: {score}\")\n\n            # Create a new population by combining the current population with a swarm of random individuals\n            new_population = np.concatenate((self.initial_population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim)).reshape(-1, self.dim)))\n\n            # Apply evolutionary strategies to the new population\n            for i in range(self.population_size):\n                # Select a parent from the current population\n                parent = np.random.choice(self.population_size, 1, p=np.array(self.evaluate_function(new_population, func)) / self.best_score)\n\n                # Select a child from the swarm\n                child = new_population[i]\n\n                # Apply crossover and mutation to the child\n                child = self.crossover(child, new_population[parent, :])\n                child = self.mutation(child)\n\n                # Replace the worst individual in the new population with the child\n                new_population[i] = child\n\n            # Update the best individual in the new population\n            self.best_individual = self.get_best_individual(new_population)\n\n            # Update the best score\n            self.best_score = self.evaluate_function(self.best_individual, func)\n\n    def evaluate_function(self, x, func):\n        return func(x)\n\n    def crossover(self, parent, child):\n        # Apply a random crossover strategy\n        if random.random() < 0.5:\n            return (parent + child) / 2\n        else:\n            return parent\n\n    def mutation(self, x):\n        # Apply a random mutation strategy\n        if random.random() < 0.1:\n            return x + np.random.uniform(-1.0, 1.0, self.dim)\n        else:\n            return x\n\n    def get_best_individual(self, population):\n        return population[np.argmax([self.evaluate_function(individual, self.func) for individual in population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nesi = ESI(100, 2)\nesi(func)", "name": "ESI", "description": "Novel \"Evolutionary-Swarm-Intelligence\" (ESI) algorithm combining swarm intelligence and evolutionary strategies to optimize black box functions.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ESI' object has no attribute 'func'\").", "error": "AttributeError(\"'ESI' object has no attribute 'func'\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "ced49d33-783e-4b23-8593-c904f0e155ed", "solution": "import random\nimport numpy as np\nimport operator\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.probability_threshold = 0.3\n\n    def __call__(self, func):\n        # Initialize population\n        population = [random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)]\n\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n\n            # Select best individuals\n            selected_indices = np.argsort(scores)[-self.population_size:]\n            selected_population = [population[i] for i in selected_indices]\n\n            # Apply crossover and mutation\n            new_population = []\n            for _ in range(self.population_size):\n                parent1, parent2 = random.sample(selected_population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutate(child)\n                new_population.append(child)\n\n            # Replace worst individual with new individual\n            worst_individual = min(new_population, key=lambda x: func(x))\n            worst_index = population.index(worst_individual)\n            population[worst_index] = new_population[np.argmin([func(x) for x in new_population])]\n\n        # Return best individual\n        return max(population, key=lambda x: func(x))\n\n    def crossover(self, parent1, parent2):\n        child = list(parent1)\n        if random.random() < self.crossover_rate:\n            idx = random.randint(0, self.dim - 1)\n            child[idx] = parent2[idx]\n        return child\n\n    def mutate(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n# Example usage\ndef func(x):\n    return sum(x**2)\n\nbudget = 100\ndim = 10\nalgorithm = HybridEvolutionaryAlgorithm(budget, dim)\nbest_individual = algorithm(func)\nprint(\"Best individual:\", best_individual)\nprint(\"Function value:\", func(best_individual))", "name": "HybridEvolutionaryAlgorithm", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation using Probability-Based Selection", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Random.uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('Random.uniform() takes 3 positional arguments but 4 were given')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "a65a36d0-7b21-414a-9085-23578b765c48", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.mu = 0.5\n        self.sigma = 1.0\n        self.population_size = 100\n\n    def __call__(self, func):\n        def objective(x):\n            return func(x)\n\n        def fitness(x):\n            return -objective(x)\n\n        def mutate(x):\n            return x + np.random.normal(0, self.sigma, self.dim)\n\n        def evolve(x):\n            new_x = np.array([mutate(x[i]) for i in range(self.population_size)])\n            new_x = np.array([minimize(fitness, x_i).x for x_i in new_x])\n            return new_x\n\n        # Initialize population\n        x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        for _ in range(self.budget):\n            x = evolve(x)\n\n        # Select best solution\n        best_idx = np.argmin([objective(x[i]) for i in range(self.population_size)])\n        best_x = x[best_idx]\n\n        # Refine strategy\n        refine_prob = 0.3\n        for i in range(self.population_size):\n            if np.random.rand() < refine_prob:\n                best_x[i] = mutate(best_x[i])\n\n        return best_x\n\n# Example usage\nbudget = 100\ndim = 10\nes = EvolutionStrategy(budget, dim)\nbest_x = es(lambda x: x**2)\nprint(best_x)", "name": "EvolutionStrategy", "description": "Novel probabilistic evolution strategy with adaptive mutation.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The user-provided objective function must return a scalar value.').", "error": "ValueError('The user-provided objective function must return a scalar value.')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "fb5e53d0-6853-41e3-b71f-8e5cc758f0da", "solution": "import numpy as np\nimport random\n\nclass PGC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population = self.initialize_population()\n        self.fitnesses = [self.evaluate_func(func, x) for x in self.population]\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.budget):\n            x = np.random.uniform(-5.0, 5.0, self.dim)\n            population.append(x)\n        return population\n\n    def evaluate_func(self, func, x):\n        return func(x)\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + (parent2 - parent1) * random.random()\n        return child\n\n    def mutate(self, child):\n        idx = random.randint(0, self.dim - 1)\n        child[idx] += random.uniform(-1.0, 1.0)\n        return child\n\n    def select_parents(self):\n        scores = [self.fitnesses[i] for i in range(len(self.fitnesses))]\n        scores = np.array(scores)\n        parents = []\n        for _ in range(len(self.population)):\n            idx = np.argmax(scores)\n            parents.append(self.population[idx])\n            scores[idx] = -np.inf\n        return parents\n\n    def optimize(self):\n        for _ in range(self.budget):\n            parents = self.select_parents()\n            new_population = []\n            for _ in range(len(self.population)):\n                parent1, parent2 = random.sample(parents, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutate(child)\n                new_population.append(child)\n            self.population = new_population\n            self.fitnesses = [self.evaluate_func(func, x) for x in self.population]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\npgc = PGC(budget=100, dim=10)\npgc.optimize()", "name": "PGC", "description": "Novel \"Probabilistic-Gradient-Crossover\" (PGC) algorithm for black box optimization", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'PGC' object is not callable\").", "error": "TypeError(\"'PGC' object is not callable\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "5620cca8-3c79-4178-aa1d-2c7fd7dc8a36", "solution": "import numpy as np\nimport random\n\nclass HybridAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.population = self.initialize_population()\n        self.best_solution = self.evaluate_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(solution)\n        return population\n\n    def evaluate_population(self):\n        best_solution = self.population[0]\n        best_score = self.func(best_solution)\n        for solution in self.population:\n            score = self.func(solution)\n            if score < best_score:\n                best_solution = solution\n                best_score = score\n        return best_solution, best_score\n\n    def func(self, x):\n        # Replace this with your black box function\n        return np.sum(x**2)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            self.population = self.mutate(self.population)\n            self.population = self.crossover(self.population)\n            self.population = self.evaluate_population()\n            self.best_solution, self.best_score = self.population[0]\n        return self.best_solution, self.best_score\n\n    def mutate(self, population):\n        mutated_population = []\n        for _ in range(len(population)):\n            solution = population[_]\n            mutation_rate = random.random()\n            if mutation_rate < 0.1:\n                index = random.randint(0, self.dim-1)\n                solution[index] += random.uniform(-1, 1)\n                if solution[index] < self.lower_bound:\n                    solution[index] = self.lower_bound\n                elif solution[index] > self.upper_bound:\n                    solution[index] = self.upper_bound\n            mutated_population.append(solution)\n        return mutated_population\n\n    def crossover(self, population):\n        crossed_population = []\n        for _ in range(len(population)):\n            parent1 = random.choice(population)\n            parent2 = random.choice(population)\n            child = parent1 + parent2\n            child = child / np.linalg.norm(child)\n            child = child * np.linalg.norm(parent1)\n            crossed_population.append(child)\n        return crossed_population\n\n    def select(self, population):\n        scores = [self.func(solution) for solution in population]\n        selected = []\n        for _ in range(len(population)):\n            score = random.random()\n            cumulative_score = 0\n            for i, s in enumerate(scores):\n                cumulative_score += s\n                if score <= cumulative_score:\n                    selected.append(population[i])\n                    scores.remove(s)\n                    break\n        return selected\n\n    def hybridize(self, population):\n        selected = self.select(population)\n        new_population = []\n        for _ in range(len(population)):\n            parent1 = random.choice(selected)\n            parent2 = random.choice(selected)\n            child = parent1 + parent2\n            child = child / np.linalg.norm(child)\n            child = child * np.linalg.norm(parent1)\n            child = child + 0.3 * (parent1 - child)\n            child = child + 0.3 * (parent2 - child)\n            new_population.append(child)\n        return new_population\n\n    def optimize(self, func):\n        self.population = self.initialize_population()\n        self.best_solution, self.best_score = self.population[0]\n        for _ in range(self.budget):\n            self.population = self.hybridize(self.population)\n            self.population = self.mutate(self.population)\n            self.population = self.crossover(self.population)\n            self.population = self.evaluate_population()\n            self.best_solution, self.best_score = self.population[0]\n        return self.best_solution, self.best_score\n\n# Example usage:\nbudget = 100\ndim = 10\nalgorithm = HybridAlgorithm(budget, dim)\nbest_solution, best_score = algorithm.optimize(lambda x: x[0]**2 + x[1]**2)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best score: {best_score}\")", "name": "HybridAlgorithm", "description": "Novel hybrid of swarm intelligence and evolutionary computation for black box optimization", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "7280caca-85e6-4b7d-8af8-50a7d8e81ec3", "solution": "import numpy as np\n\nclass HyperElitismWithAdaptiveProbabilisticMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population = self.initialize_population()\n        self.fitness_values = np.zeros(self.budget)\n\n    def initialize_population(self):\n        population = np.random.uniform(-5.0, 5.0, (self.budget, self.dim))\n        return population\n\n    def evaluate(self, func):\n        for i, x in enumerate(self.population):\n            self.fitness_values[i] = func(x)\n        self.population = self.select_elites()\n        self.population = self.mutate(self.population)\n        self.population = self.crossover(self.population)\n\n    def select_elites(self):\n        elite_size = int(self.budget * 0.2)\n        sorted_indices = np.argsort(self.fitness_values)\n        return self.population[sorted_indices[:elite_size]]\n\n    def mutate(self, population):\n        mutation_rate = 0.1\n        mutated_population = population.copy()\n        for i in range(self.budget):\n            if np.random.rand() < mutation_rate:\n                idx = np.random.randint(0, self.dim)\n                mutated_population[i, idx] += np.random.uniform(-1.0, 1.0)\n                mutated_population[i, idx] = np.clip(mutated_population[i, idx], -5.0, 5.0)\n        return mutated_population\n\n    def crossover(self, population):\n        crossover_rate = 0.5\n        crossover_population = population.copy()\n        for i in range(self.budget):\n            if np.random.rand() < crossover_rate:\n                idx1 = np.random.randint(0, self.dim)\n                idx2 = np.random.randint(0, self.dim)\n                while idx1 == idx2:\n                    idx2 = np.random.randint(0, self.dim)\n                crossover_population[i, idx1], crossover_population[i, idx2] = crossover_population[i, idx2], crossover_population[i, idx1]\n        return crossover_population\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n\ndef optimize_function(func, budget, dim):\n    algorithm = HyperElitismWithAdaptiveProbabilisticMutation(budget, dim)\n    algorithm()\n    return func(algorithm.population[0])\n\n# Example usage\ndef noiseless_function(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\nfunc = noiseless_function\nresult = optimize_function(func, budget, dim)\nprint(result)", "name": "HyperElitismWithAdaptiveProbabilisticMutation", "description": "Novel \"Hyper-Elitism with Adaptive Probabilistic Mutation\" algorithm for black box optimization.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"HyperElitismWithAdaptiveProbabilisticMutation.__call__() missing 1 required positional argument: 'func'\").", "error": "TypeError(\"HyperElitismWithAdaptiveProbabilisticMutation.__call__() missing 1 required positional argument: 'func'\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "67dcbc24-f2b0-43ea-acea-d5a82ad2df49", "solution": "import numpy as np\nimport random\n\nclass PEAA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population = self.initialize_population()\n        self.score = self.evaluate_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.budget):\n            individual = np.random.uniform(-5.0, 5.0, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate_population(self):\n        scores = []\n        for individual in self.population:\n            score = self.func(individual)\n            scores.append(score)\n        return scores\n\n    def func(self, x):\n        # Example black box function\n        return np.sum(x**2)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.budget > 0:\n                # Select parents using tournament selection\n                parents = self.select_parents()\n                # Crossover and mutation\n                offspring = self.crossover_and_mutate(parents)\n                # Replace the worst individual\n                self.replace_worst(offspring)\n                # Update the score\n                self.score = self.evaluate_population()\n            else:\n                break\n\n    def select_parents(self):\n        tournament_size = 5\n        parents = []\n        for _ in range(tournament_size):\n            individual = random.choice(self.population)\n            parents.append(individual)\n        return parents\n\n    def crossover_and_mutate(self, parents):\n        offspring = []\n        for _ in range(len(parents)):\n            parent1, parent2 = random.sample(parents, 2)\n            child = self.mutate(self.crossover(parent1, parent2))\n            offspring.append(child)\n        return offspring\n\n    def crossover(self, parent1, parent2):\n        # Simple crossover\n        child = (parent1 + parent2) / 2\n        return child\n\n    def mutate(self, individual):\n        # Simple mutation\n        mutation_rate = 0.1\n        if np.random.rand() < mutation_rate:\n            individual[random.randint(0, self.dim-1)] += np.random.uniform(-1.0, 1.0)\n        return individual\n\n    def replace_worst(self, offspring):\n        worst_index = np.argmin(self.score)\n        self.population[worst_index] = offspring[worst_index]\n\n# Example usage:\npeaa = PEAA(100, 5)\npeaa('func')", "name": "PEAA", "description": "Novel \"Probabilistic Evolutionary Algorithm with Adaptation\" (PEAA) for black box optimization.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "d5004581-afbb-4a31-a539-b9a75736e28d", "solution": "import numpy as np\n\nclass ProbEvolutionary:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.mutation_rate = 0.1\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the objective function\n            values = func(self.population)\n\n            # Calculate the fitness of each individual\n            fitness = np.sum(values, axis=1)\n\n            # Select the fittest individuals\n            indices = np.argsort(fitness)[-self.population_size // 2:]\n            self.population = self.population[indices]\n\n            # Perform mutation\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    self.population[i] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Perform crossover\n            for i in range(self.population_size // 2):\n                parent1, parent2 = np.random.choice(self.population_size, 2, replace=False)\n                child = (self.population[parent1] + self.population[parent2]) / 2\n                self.population[i * 2], self.population[i * 2 + 1] = child, self.population[parent1]\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    optimizer = ProbEvolutionary(budget, dim)\n    func = lambda x: np.sum(x**2)  # Example function\n    optimizer(func)", "name": "ProbEvolutionary", "description": "Novel probabilistic evolutionary algorithm with adaptive mutation", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: AxisError(1, 0, None).", "error": "AxisError(1, 0, None)", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "23ffdb00-56b1-4abb-a908-02f8770dc205", "solution": "import numpy as np\nimport random\nimport operator\n\nclass NovelizedHybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = self.initialize_population()\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.adaptation_rate = 0.3\n\n    def initialize_population(self):\n        return [self.sample_uniform() for _ in range(self.population_size)]\n\n    def sample_uniform(self):\n        return np.random.uniform(-5.0, 5.0, self.dim)\n\n    def fitness(self, func, x):\n        return func(x)\n\n    def evaluate(self, func):\n        self.population = self.evaluate_population(func)\n        if self.budget > 0:\n            self.population = self.adapt_and_evolve(func)\n\n    def evaluate_population(self, func):\n        population = [self.fitness(func, x) for x in self.population]\n        return np.array(population)\n\n    def adapt_and_evolve(self, func):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(self.population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutate(child)\n            new_population.append(child)\n        return new_population\n\n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            child = np.mean([parent1, parent2], axis=0)\n            return child\n        else:\n            return parent1\n\n    def mutate(self, x):\n        if random.random() < self.mutation_rate:\n            mutation = np.random.uniform(-1.0, 1.0, self.dim)\n            x += mutation\n            x = np.clip(x, -5.0, 5.0)\n            return x\n        else:\n            return x\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n        return np.min(self.evaluate_population(func))\n\n# Usage:\nnovelized_hhea = NovelizedHybridEvolutionaryAlgorithm(budget=100, dim=10)\nresult = novelized_hhea(\"noiseless_function_1\")\nprint(result)", "name": "NovelizedHybridEvolutionaryAlgorithm", "description": "Novelized Hybrid Evolutionary Algorithm with Adaptive Crossover and Mutation", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'str' object is not callable\").", "error": "TypeError(\"'str' object is not callable\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "2e47f44f-f41e-48a6-a763-d35217ae62b8", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryGradient:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.fitness_values = np.zeros(self.population_size)\n        self.best_individual = np.random.uniform(-5.0, 5.0, (1, self.dim))\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Calculate fitness values\n            self.fitness_values = func(self.population)\n\n            # Select best individual\n            self.best_individual = self.population[np.argmin(self.fitness_values)]\n            self.best_fitness = np.min(self.fitness_values)\n\n            # Create a new population by perturbing the best individual\n            new_population = self.population.copy()\n            for i in range(self.population_size):\n                # Perturb the individual with a probability of 0.3\n                if random.random() < 0.3:\n                    new_population[i] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Replace the old population with the new one\n            self.population = new_population\n\n            # Update the best individual\n            self.best_individual = self.population[np.argmin(self.fitness_values)]\n            self.best_fitness = np.min(self.fitness_values)\n\n            # Print the best individual and its fitness value\n            print(f\"Best individual: {self.best_individual}, Best fitness: {self.best_fitness}\")\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 5\noptimizer = EvolutionaryGradient(budget, dim)\noptimizer(\"func\")", "name": "EvolutionaryGradient", "description": "Novel \"Evolutionary-Gradient\" metaheuristic algorithm for black box optimization.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'str' object is not callable\").", "error": "TypeError(\"'str' object is not callable\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "8a220449-b502-466b-ac69-09ebf17135e7", "solution": "import numpy as np\n\nclass PEAHM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.hypermutation_rate = 0.3\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        \n        # Evaluate initial population\n        fitness = np.array([func(x) for x in population])\n        \n        # Main loop\n        for _ in range(self.budget):\n            # Select parents\n            parents = np.random.choice(population, size=self.population_size, p=fitness/np.sum(fitness))\n            \n            # Crossover\n            offspring = []\n            for _ in range(self.population_size):\n                parent1, parent2 = np.random.choice(parents, size=2, replace=False)\n                child = np.mean([parent1, parent2], axis=0)\n                if np.random.rand() < self.crossover_rate:\n                    child += np.random.uniform(-5.0, 5.0, self.dim)\n                offspring.append(child)\n            \n            # Hypermutation\n            for i in np.random.choice(offspring, size=int(self.population_size*self.hypermutation_rate), replace=False):\n                if np.random.rand() < self.hypermutation_rate:\n                    i += np.random.uniform(-5.0, 5.0, self.dim)\n                offspring[i] = np.clip(offspring[i], -5.0, 5.0)\n            \n            # Evaluate offspring\n            fitness_offspring = np.array([func(x) for x in offspring])\n            \n            # Replace worst individual\n            idx = np.argmin(fitness_offspring)\n            population[idx] = offspring[idx]\n            \n            # Update fitness\n            fitness = np.array([func(x) for x in population])\n        \n        # Return best individual\n        idx = np.argmin(fitness)\n        return population[idx]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\npea_hm = PEAHM(budget=10, dim=5)\nx_opt = pea_hm(func)\nprint(x_opt)", "name": "PEAHM", "description": "Novel \"Probabilistic Evolutionary Algorithm with Hypermutation\" (PEA-HM)", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "f20d2fc3-c05a-4f57-a43d-34f8faddf711", "solution": "import numpy as np\nimport random\n\nclass PADAE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population = []\n        self.fitness = []\n\n    def __call__(self, func):\n        # Initialize population with random candidates\n        for _ in range(self.budget):\n            candidate = np.random.uniform(-5.0, 5.0, self.dim)\n            self.population.append(candidate)\n            self.fitness.append(func(candidate))\n\n        # Dynamic evolution\n        for _ in range(self.budget):\n            # Select parents based on fitness\n            parents = np.array(self.population)[np.argsort(self.fitness)]\n            parents = parents[:int(self.budget/2)]\n\n            # Crossover and mutation\n            offspring = []\n            while len(offspring) < self.budget - len(parents):\n                parent1, parent2 = random.sample(parents, 2)\n                child = (parent1 + parent2) / 2 + np.random.uniform(-0.5, 0.5, self.dim)\n                offspring.append(child)\n\n            # Replace worst individual\n            worst_idx = np.argmin(self.fitness)\n            self.population[worst_idx] = offspring[worst_idx]\n\n            # Update fitness\n            self.fitness[worst_idx] = func(offspring[worst_idx])\n\n            # Adaptive probability\n            prob = 1 - (len(offspring) / self.budget)\n            if random.random() < prob:\n                # Randomly replace an offspring\n                offspring_idx = random.randint(0, len(offspring) - 1)\n                self.population[offspring_idx] = np.random.uniform(-5.0, 5.0, self.dim)\n                self.fitness[offspring_idx] = func(self.population[offspring_idx])\n\n# Example usage\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nbudget = 100\ndim = 2\npada = PADAE(budget, dim)\nbest_solution = None\nbest_score = -np.inf\nfor _ in range(100):\n    solution = np.random.uniform(-5.0, 5.0, dim)\n    score = func(solution)\n    if score < best_score:\n        best_solution = solution\n        best_score = score\n\n    # Refine the best solution\n    if best_solution is not None:\n        pada(solution)\n        padad.fitness = [score for score in padad.fitness if score!= score]  # Remove NaN values\n        padad.population = [solution] * len(padad.population)\n        padad.fitness = [score for score in padad.fitness if score!= score]  # Remove NaN values\n        best_solution = None\n        best_score = -np.inf\n\nprint(\"Best solution:\", best_solution)\nprint(\"Best score:\", best_score)", "name": "PADAE", "description": "Novel \"Probability-Adaptive Dynamic Evolution\" (PADE) algorithm", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "6cfabcc8-98b1-47b9-a73b-10995949d40f", "solution": "import numpy as np\nimport random\nfrom scipy import optimize\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.pso_alpha = 0.8\n        self.pso_beta = 0.4\n        self.pso_gamma = 0.4\n        self.ga_crossover_prob = 0.9\n        self.ga_mutation_prob = 0.1\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        # Evolve the population\n        for _ in range(self.budget):\n            # Evaluate the population\n            fitness = [func(x) for x in population]\n\n            # Select the fittest individuals\n            fittest_indices = np.argsort(fitness)[:self.population_size//2]\n            fittest_individuals = population[fittest_indices]\n\n            # Create a new population using Differential Evolution\n            new_population = []\n            for _ in range(self.population_size):\n                parent1, parent2 = random.sample(fittest_individuals, 2)\n                child = parent1 + (parent2 - parent1) * np.random.uniform(-1.0, 1.0, self.dim)\n                new_population.append(child)\n\n            # Create a new population using Particle Swarm Optimization\n            new_population_pso = []\n            for _ in range(self.population_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                velocity = np.zeros(self.dim)\n                best_position = particle\n                best_fitness = func(particle)\n                for _ in range(self.budget//2):\n                    new_particle = particle + velocity\n                    new_fitness = func(new_particle)\n                    if new_fitness < best_fitness:\n                        best_position = new_particle\n                        best_fitness = new_fitness\n                    velocity += self.pso_alpha * (best_position - particle) + self.pso_beta * np.random.uniform(-1.0, 1.0, self.dim)\n                new_population_pso.append(best_position)\n\n            # Create a new population using Genetic Algorithm\n            new_population_ga = []\n            for _ in range(self.population_size):\n                parent1, parent2 = random.sample(fittest_individuals, 2)\n                child = parent1 + parent2 * np.random.uniform(0.0, 1.0, self.dim)\n                new_population_ga.append(child)\n\n            # Combine the new populations\n            population = np.array(new_population + new_population_pso + new_population_ga)\n\n            # Apply mutation and crossover\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    population[i] += np.random.uniform(-1.0, 1.0, self.dim)\n                if np.random.rand() < self.crossover_rate:\n                    parent1, parent2 = random.sample(fittest_individuals, 2)\n                    child = parent1 + parent2 * np.random.uniform(0.0, 1.0, self.dim)\n                    population[i] = child\n\n        # Return the fittest individual\n        fitness = [func(x) for x in population]\n        fittest_index = np.argsort(fitness)[-1]\n        return population[fittest_index]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\nalgorithm = HybridEvolutionaryAlgorithm(budget, dim)\nbest_individual = algorithm(func)\nprint(best_individual)", "name": "HybridEvolutionaryAlgorithm", "description": "Novel \"Hybrid Evolutionary Algorithm\" combining Differential Evolution, Particle Swarm Optimization, and Genetic Algorithm techniques.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "0f465ea2-b415-47f6-b571-056ea59f9b2f", "solution": "# import numpy as np\n# import random\n\n# class HybridEvolutionaryAlgorithm:\n#     def __init__(self, budget, dim):\n#         self.budget = budget\n#         self.dim = dim\n#         self.population_size = 20\n#         self.population = self.initialize_population()\n#         self.adaptive_probabilities = [0.3] * self.population_size\n\n#     def initialize_population(self):\n#         population = []\n#         for _ in range(self.population_size):\n#             individual = [random.uniform(-5.0, 5.0) for _ in range(self.dim)]\n#             population.append(individual)\n#         return population\n\n#     def evaluate(self, func):\n#         fitness_values = [func(individual) for individual in self.population]\n#         for i in range(self.population_size):\n#             self.population[i] = [individual for individual, fitness in zip(self.population, fitness_values) if fitness == min(fitness_values)]\n#             self.adaptive_probabilities[i] = min(1, self.adaptive_probabilities[i] + (1 - self.adaptive_probabilities[i]) * (1 - fitness_values[i] / min(fitness_values)))\n\n#     def select_parents(self):\n#         parents = []\n#         for _ in range(self.population_size):\n#             parent_index = np.random.choice(self.population_size, p=self.adaptive_probabilities)\n#             parents.append(self.population[parent_index])\n#         return parents\n\n#     def crossover(self, parents):\n#         offspring = []\n#         for _ in range(self.population_size):\n#             parent1, parent2 = np.random.choice(parents, size=2, replace=False)\n#             child = [0.5 * (parent1[i] + parent2[i]) for i in range(self.dim)]\n#             offspring.append(child)\n#         return offspring\n\n#     def mutate(self, offspring):\n#         for i in range(self.dim):\n#             if random.random() < 0.1:\n#                 offspring[i] += random.uniform(-1.0, 1.0)\n\n#     def optimize(self, func):\n#         for _ in range(self.budget):\n#             self.evaluate(func)\n#             parents = self.select_parents()\n#             offspring = self.crossover(parents)\n#             self.mutate(offspring)\n#             self.population = offspring\n\n# def test_func(x):\n#     return np.sum([i**2 for i in x])\n\n# algorithm = HybridEvolutionaryAlgorithm(budget=100, dim=5)\n# algorithm.optimize(test_func)\n# print(algorithm.population)", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm with Adaptive Probability Refinement", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "fc31454f-8b8a-437e-80c2-4ac5d7ec9e50", "solution": "import numpy as np\nimport random\n\nclass ProbabilisticMutationOperator:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population = []\n        self.score = -np.inf\n\n    def __call__(self, func):\n        # Initialize population with random points\n        self.population = [np.random.uniform(-5.0, 5.0, self.dim) for _ in range(100)]\n\n        # Evaluate population and update score\n        self.score = max([func(x) for x in self.population])\n\n        # Repeat for budget iterations\n        for _ in range(self.budget):\n            # Select best 20% of population\n            self.population = sorted(self.population, key=lambda x: func(x))[:int(0.2 * len(self.population))]\n\n            # Apply mutation operator\n            mutated_population = []\n            for i in range(len(self.population)):\n                if random.random() < 0.3:\n                    # Randomly select two parents and apply crossover\n                    parent1, parent2 = random.sample(self.population, 2)\n                    child = (parent1 + parent2) / 2\n                    mutated_population.append(child)\n                else:\n                    mutated_population.append(self.population[i])\n\n            # Update population and score\n            self.population = mutated_population\n            self.score = max([func(x) for x in self.population])\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\noperator = ProbabilisticMutationOperator(100, 10)\noperator(func)\nprint(operator.score)", "name": "ProbabilisticMutationOperator", "description": "Novel probabilistic mutation operator with crossover and selection to adapt to changing environments", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('max() arg is an empty sequence').", "error": "ValueError('max() arg is an empty sequence')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "a3ccdc6a-4c3b-4ec0-be4c-1711876df460", "solution": "import numpy as np\nimport random\nimport math\n\nclass NHEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.particle swarm parameters = {'r': 0.8, 'c': 0.4, 'w': 0.4}\n        self.simulated annealing parameters = {'alpha': 0.99, 'T0': 1000, 'Tend': 1}\n\n    def __call__(self, func):\n        # Initialize the population\n        population = [np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)]\n\n        # Evaluate the initial population\n        fitness = [func(x) for x in population]\n\n        # Main loop\n        for _ in range(self.budget):\n            # Select the fittest particles\n            fittest_particles = np.argsort(fitness)[:self.population_size // 2]\n\n            # Select the worst particles\n            worst_particles = np.argsort(fitness)[-self.population_size // 2:]\n\n            # Create a new population\n            new_population = []\n            for _ in range(self.population_size):\n                # Select a parent from the fittest particles\n                parent = random.choice(fittest_particles)\n\n                # Select a child from the worst particles\n                child = random.choice(worst_particles)\n\n                # Apply mutation and crossover\n                child = self.mutation(child)\n                child = self.crossover(parent, child)\n\n                # Add the child to the new population\n                new_population.append(child)\n\n            # Evaluate the new population\n            fitness = [func(x) for x in new_population]\n\n            # Update the population\n            population = new_population\n\n            # Apply simulated annealing\n            if _ % 100 == 0:\n                T = self.simulated_annealing(T0=self.simulated_annealing_parameters['T0'], Tend=self.simulated_annealing_parameters['Tend'], alpha=self.simulated_annealing_parameters['alpha'])\n                for i in range(self.population_size):\n                    if random.random() < math.exp((fitness[i] - fitness[random.randint(0, self.population_size - 1)]) / T):\n                        population[i] = random.uniform(-5.0, 5.0, self.dim)\n\n        # Return the fittest solution\n        return population[np.argmin(fitness)]\n\n    def mutation(self, x):\n        # Apply mutation\n        x += np.random.normal(0, 0.1, self.dim)\n        return x\n\n    def crossover(self, parent, child):\n        # Apply crossover\n        child = parent[:self.dim // 2] + np.random.uniform(-5.0, 5.0, self.dim // 2)\n        return child\n\n    def simulated_annealing(self, T0, Tend, alpha):\n        T = T0\n        while T > Tend:\n            for _ in range(self.population_size):\n                if random.random() < math.exp((np.random.uniform(-5.0, 5.0, self.dim) - np.random.uniform(-5.0, 5.0, self.dim)) / T):\n                    np.random.uniform(-5.0, 5.0, self.dim)\n            T *= alpha\n        return T\n\n# Usage\nnhea = NHEA(budget=100, dim=10)\nnhea('func')", "name": "NHEA", "description": "Novel Hybrid Evolutionary Algorithm (NHEA) combining particle swarm optimization and simulated annealing for black box optimization.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 10, 23, \"        self.particle swarm parameters = {'r': 0.8, 'c': 0.4, 'w': 0.4}\\n\", 10, 28)).", "error": "SyntaxError('invalid syntax', ('<string>', 10, 23, \"        self.particle swarm parameters = {'r': 0.8, 'c': 0.4, 'w': 0.4}\\n\", 10, 28))", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "307917c0-9f32-450b-a816-e0999d22aae7", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.population = self.initialize_population()\n        self.best_solution = self.get_best_solution()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = self.generate_individual()\n            population.append(individual)\n        return population\n\n    def generate_individual(self):\n        individual = [random.uniform(-5.0, 5.0) for _ in range(self.dim)]\n        return individual\n\n    def get_best_solution(self):\n        best_solution = self.population[0]\n        best_score = self.evaluate(best_solution)\n        return best_solution, best_score\n\n    def evaluate(self, solution):\n        score = 0\n        for i in range(self.dim):\n            score += math.sin(solution[i])\n        return score\n\n    def simulate_annealing(self, solution):\n        temperature = 1000\n        cooling_rate = 0.99\n        for _ in range(self.budget):\n            if random.random() < 0.3:\n                # Permutation mutation\n                i, j = random.sample(range(self.dim), 2)\n                solution[i], solution[j] = solution[j], solution[i]\n            else:\n                # Genetic mutation\n                if random.random() < 0.3:\n                    i = random.randint(0, self.dim - 1)\n                    solution[i] += random.uniform(-1.0, 1.0)\n                    solution[i] = max(-5.0, min(5.0, solution[i]))\n            score = self.evaluate(solution)\n            if score > self.evaluate(self.best_solution):\n                self.best_solution = solution\n            if temperature > 1:\n                probability = math.exp((score - self.evaluate(self.best_solution)) / temperature)\n                if random.random() < probability:\n                    self.best_solution = solution\n            temperature *= cooling_rate\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            solution, score = self.get_best_solution()\n            self.simulate_annealing(solution)\n        return self.best_solution\n\n# Example usage:\nbudget = 100\ndim = 10\nhybrid = HybridOptimization(budget, dim)\nbest_solution = hybrid.optimize(lambda x: x[0]**2 + x[1]**2)\nprint(best_solution)", "name": "HybridOptimization", "description": "Novel hybrid of Permutation-Genetic Algorithm and Simulated Annealing", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('must be real number, not list').", "error": "TypeError('must be real number, not list')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "f3598fe6-5d1f-4070-a604-ae7074061d00", "solution": "import random\nimport numpy as np\n\nclass EvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.population = self.initialize_population()\n        self.best_solution = self.get_best_solution()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            population.append(solution)\n        return population\n\n    def get_best_solution(self):\n        return min(self.population, key=lambda x: self.evaluate(x))\n\n    def evaluate(self, solution):\n        return self.func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Probability-based mutation\n            if random.random() < 0.3:\n                solution = self.get_neighbor(self.best_solution)\n            else:\n                solution = np.random.uniform(-5.0, 5.0, self.dim)\n\n            # Selection\n            if self.evaluate(solution) < self.evaluate(self.best_solution):\n                self.best_solution = solution\n\n            # Replacement\n            self.population.remove(self.get_neighbor(self.best_solution))\n            self.population.append(solution)\n\n    def get_neighbor(self, solution):\n        neighbor = solution.copy()\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                neighbor[i] += random.uniform(-1.0, 1.0)\n        return neighbor\n\n# Example usage\nbudget = 100\ndim = 10\nfunc = lambda x: x[0]**2 + x[1]**2\noptimizer = EvolutionarySwarmOptimization(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", optimizer.evaluate(best_solution))", "name": "EvolutionarySwarmOptimization", "description": "Novel \"Evolutionary Swarm Optimization\" algorithm with probability-based mutation and selection.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'EvolutionarySwarmOptimization' object has no attribute 'func'\").", "error": "AttributeError(\"'EvolutionarySwarmOptimization' object has no attribute 'func'\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "bbc2a9a6-0bfa-476d-bdac-512c7018301d", "solution": "import numpy as np\nimport random\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.population = self.initialize_population()\n        self.fitness = self.evaluate_fitness()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(-5.0, 5.0, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate_fitness(self):\n        fitness = []\n        for individual in self.population:\n            fitness.append(self.func(individual))\n        return fitness\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Selection\n            parents = self.select_parents()\n\n            # Crossover\n            offspring = self.crossover(parents)\n\n            # Mutation\n            offspring = self.mutate(offspring)\n\n            # Replacement\n            self.population = self.replace_population(offspring)\n\n            # Refine strategy\n            if random.random() < 0.3:\n                self.refine_strategy()\n\n    def select_parents(self):\n        # Selection strategy\n        parents = random.sample(self.population, self.population_size // 2)\n        return parents\n\n    def crossover(self, parents):\n        offspring = []\n        for _ in range(self.population_size // 2):\n            parent1, parent2 = random.sample(parents, 2)\n            child = (parent1 + parent2) / 2\n            offspring.append(child)\n        return offspring\n\n    def mutate(self, offspring):\n        # Mutation strategy\n        for i in range(self.population_size // 2):\n            if random.random() < 0.1:\n                mutation = np.random.uniform(-1.0, 1.0)\n                offspring[i] += mutation\n        return offspring\n\n    def replace_population(self, offspring):\n        self.population = offspring\n        self.fitness = self.evaluate_fitness()\n        return self.fitness\n\n    def refine_strategy(self):\n        # Refine strategy\n        for i in range(self.population_size):\n            if random.random() < 0.3:\n                self.population[i] += np.random.uniform(-1.0, 1.0)\n\n    def func(self, x):\n        # Black box function\n        return np.sum(x**2)\n\n# Example usage\nbudget = 100\ndim = 10\nalgorithm = HybridEvolutionaryAlgorithm(budget, dim)\nalgorithm()", "name": "HybridEvolutionaryAlgorithm", "description": "Hybrid Evolutionary Algorithm with Probabilistic Refinement", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"HybridEvolutionaryAlgorithm.__call__() missing 1 required positional argument: 'func'\").", "error": "TypeError(\"HybridEvolutionaryAlgorithm.__call__() missing 1 required positional argument: 'func'\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "aebc02b3-6164-46c5-a759-7d518f5d043d", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_probability = 0.3\n        self.mutation_probability = 0.1\n        self.exploration_probability = 0.2\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n\n        # Run the optimization\n        for _ in range(self.budget):\n            # Evaluate the population\n            scores = np.array([func(x) for x in population])\n\n            # Select the best individuals\n            best_individuals = population[np.argsort(scores)]\n\n            # Crossover and mutation\n            new_population = []\n            for i in range(self.population_size):\n                # Select two parents\n                parent1 = best_individuals[i]\n                parent2 = best_individuals[(i + 1) % self.population_size]\n\n                # Crossover\n                if random.random() < self.crossover_probability:\n                    child = (parent1 + parent2) / 2\n                else:\n                    child = parent1\n\n                # Mutation\n                if random.random() < self.mutation_probability:\n                    child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                # Add the child to the new population\n                new_population.append(child)\n\n            # Replace the old population with the new one\n            population = np.array(new_population)\n\n            # Explore the search space\n            if random.random() < self.exploration_probability:\n                # Randomly select a point in the search space\n                exploration_point = np.random.uniform(-5.0, 5.0, self.dim)\n                # Evaluate the exploration point\n                scores = np.append(scores, func(exploration_point))\n                # Add the exploration point to the population\n                population = np.append(population, exploration_point)\n\n        # Return the best individual\n        scores = np.array([func(x) for x in population])\n        best_individual = population[np.argsort(scores)]\n        return best_individual[0]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\ncme = CME(budget=100, dim=10)\nbest_individual = cme(func)\nprint(\"Best individual:\", best_individual)", "name": "CME", "description": "Novel \"Crossover- Mutation- Exploration\" (CME) algorithm for black box optimization", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('setting an array element with a sequence. The requested array has an inhomogeneous shape after 1 dimensions. The detected shape was (50,) + inhomogeneous part.').", "error": "ValueError('setting an array element with a sequence. The requested array has an inhomogeneous shape after 1 dimensions. The detected shape was (50,) + inhomogeneous part.')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "acda9ee8-5f55-440d-be43-8dcf95e9c003", "solution": "import numpy as np\n\nclass HybridEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.mutation_prob = 0.3\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def evaluate_function(self, func):\n        fitness = np.array([func(x) for x in self.population.flatten()])\n        fitness = np.array([fitness.min(), fitness.max(), np.mean(fitness), np.median(fitness)])\n        return fitness\n\n    def select_parents(self, fitness):\n        parents = np.random.choice(self.population_size, size=2, p=fitness)\n        return self.population[parents].flatten()\n\n    def mutate(self, x):\n        if np.random.rand() < self.mutation_prob:\n            index = np.random.randint(0, self.dim)\n            x[index] += np.random.uniform(-1.0, 1.0)\n        return x\n\n    def evolve(self, func):\n        fitness = self.evaluate_function(func)\n        parents = self.select_parents(fitness)\n        children = np.array([self.mutate(parent) for parent in parents])\n        self.population = np.vstack((self.population, children))\n        self.population = self.population[:self.population_size]\n        return fitness\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            fitness = self.evolve(func)\n            best_idx = np.argmin(fitness)\n            best_x = self.population[best_idx]\n            print(f'Iteration {_+1}, Best x: {best_x}, Best fitness: {fitness[best_idx]}')\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nhybrid = HybridEvolution(100, 10)\nhybrid.optimize(func)", "name": "HybridEvolution", "description": "Novel hybrid algorithm combining memetic evolution and probability-based mutation to optimize black box functions.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"'a' and 'p' must have same size\").", "error": "ValueError(\"'a' and 'p' must have same size\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "d582d927-049a-45af-a264-3a7fc2b9afa4", "solution": "import numpy as np\nimport random\n\nclass CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x = np.random.uniform(-5.0, 5.0, size=(budget, dim))\n        self.f = np.zeros(budget)\n        self.x_best = self.x.copy()\n        self.f_best = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            if i > 0:\n                self.x[i] = self.x_best + np.random.normal(0, 0.1, size=(self.dim,))\n                self.f[i] = func(self.x[i])\n\n            if self.f[i] < self.f_best:\n                self.x_best = self.x[i].copy()\n                self.f_best = self.f[i]\n\n        return self.x_best, self.f_best\n\ndef refine_solution(x_best, f_best, x, f):\n    for i in range(len(x)):\n        if random.random() < 0.3:\n            x[i] += np.random.uniform(-0.1, 0.1)\n            f[i] = func(x[i])\n            if f[i] < f_best:\n                x_best = x[i].copy()\n                f_best = f[i]\n\n    return x_best, f_best\n\ndef evaluate_function(func, x, f):\n    if func(x) < f:\n        f = func(x)\n    return f\n\ndef main():\n    func = lambda x: np.sum(x**2)  # example function\n    cma = CMA(budget=100, dim=5)\n    x_best, f_best = cma(func)\n    print(\"Initial Solution: \", x_best, f_best)\n\n    for _ in range(10):\n        x_best, f_best = refine_solution(x_best, f_best, cma.x, cma.f)\n        x_best, f_best = evaluate_function(func, x_best, f_best)\n        print(\"Refined Solution: \", x_best, f_best)\n\nif __name__ == \"__main__\":\n    main()", "name": "CMA", "description": "Novel \"Crossover- Mutation- Adaptation\" (CMA) algorithm with probabilistic refinement", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('cannot unpack non-iterable numpy.float64 object').", "error": "TypeError('cannot unpack non-iterable numpy.float64 object')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "18b8a547-b97f-48e8-b95d-62bfa644c409", "solution": "import numpy as np\nimport random\n\nclass ProbabilisticMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population = []\n        self.current_solution = None\n\n    def __call__(self, func):\n        # Initialize the population with random solutions\n        self.population = [np.random.uniform(-5.0, 5.0, self.dim) for _ in range(10)]\n\n        # Evaluate the initial population\n        self.evaluate_population(func)\n\n        # Main optimization loop\n        for _ in range(self.budget):\n            # Select the best solution\n            self.current_solution = self.select_best_solution(func)\n\n            # Refine the best solution using probabilistic mutation\n            self.refine_solution(func)\n\n            # Evaluate the refined solution\n            self.evaluate_solution(func)\n\n    def evaluate_population(self, func):\n        # Evaluate each solution in the population\n        scores = [func(solution) for solution in self.population]\n        self.population = list(zip(self.population, scores))\n\n    def select_best_solution(self, func):\n        # Select the best solution based on the fitness score\n        best_solution = max(self.population, key=lambda x: x[1])\n        return best_solution[0]\n\n    def refine_solution(self, func):\n        # Refine the best solution using probabilistic mutation\n        if self.current_solution is not None:\n            # Randomly select a dimension to mutate\n            dim_to_mutate = random.randint(0, self.dim - 1)\n\n            # Randomly decide whether to increase or decrease the value\n            mutation_type = random.random()\n            if mutation_type < 0.3:\n                self.current_solution[dim_to_mutate] += random.uniform(0.0, 0.1)\n            else:\n                self.current_solution[dim_to_mutate] -= random.uniform(0.0, 0.1)\n\n            # Ensure the value is within the bounds\n            self.current_solution[dim_to_mutate] = max(-5.0, min(5.0, self.current_solution[dim_to_mutate]))\n\n    def evaluate_solution(self, func):\n        # Evaluate the refined solution\n        score = func(self.current_solution)\n        self.population = [(solution, score) for solution, score in self.population]\n        self.population.sort(key=lambda x: x[1])", "name": "ProbabilisticMutation", "description": "Novel probabilistic mutation operator for metaheuristic algorithms", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "736de124-5941-4f7d-a4d3-c3430761d5c3", "solution": "import numpy as np\nimport random\n\nclass DAE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population = []\n        self.mutate_prob = 0.3\n        self.adapt_prob = 0.7\n        self.expl_prob = 0.1\n\n    def __call__(self, func):\n        if len(self.population) == 0:\n            self.population = [np.random.uniform(-5.0, 5.0, self.dim) for _ in range(20)]\n\n        for _ in range(self.budget):\n            # Select best 5 individuals\n            self.population.sort(key=lambda x: func(x))\n            self.population = self.population[:5]\n\n            # Adapt individuals\n            for i in range(len(self.population)):\n                if random.random() < self.adapt_prob:\n                    self.population[i] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Explore individuals\n            for i in range(len(self.population)):\n                if random.random() < self.expl_prob:\n                    self.population[i] += np.random.uniform(-0.5, 0.5, self.dim)\n\n            # Mutate individuals\n            for i in range(len(self.population)):\n                if random.random() < self.mutate_prob:\n                    idx = random.randint(0, self.dim-1)\n                    self.population[i][idx] += np.random.uniform(-0.5, 0.5)\n\n            # Evaluate function\n            for individual in self.population:\n                func(individual)\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\ndae = DAE(100, 2)\ndae(func)", "name": "DAE", "description": "Novel \"Diversity-Adaptation-Exploration\" (DAE) metaheuristic algorithm", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "0bedb1b2-5426-4311-acfa-7864b1cf06e5", "solution": "import numpy as np\nimport random\n\nclass ProbabilisticMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.particle_swarm_size = 20\n        self.gene_size = 5\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.8\n        self.particle_swarm = np.random.uniform(-5.0, 5.0, (self.particle_swarm_size, self.dim))\n        self.gene_pool = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        scores = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            score = func(self.gene_pool[i])\n            scores[i] = score\n\n        # Select the best individual\n        best_index = np.argmin(scores)\n        best_individual = self.gene_pool[best_index]\n\n        # Select the top 20% of individuals with the best scores\n        top_individuals = self.gene_pool[np.argsort(scores)[:int(self.population_size * 0.2)]]\n\n        # Update the gene pool\n        self.gene_pool = top_individuals\n\n        # Perform particle swarm optimization\n        for _ in range(self.budget // 2):\n            for i in range(self.particle_swarm_size):\n                # Calculate the fitness of the current particle\n                score = func(self.particle_swarm[i])\n\n                # Update the particle's position\n                self.particle_swarm[i] = self.particle_swarm[i] + np.random.uniform(-1.0, 1.0, self.dim)\n\n                # Update the particle's velocity\n                velocity = np.random.uniform(-1.0, 1.0, self.dim)\n                self.particle_swarm[i] = self.particle_swarm[i] + velocity\n\n                # Update the particle's score\n                score = func(self.particle_swarm[i])\n\n                # Update the best individual\n                if score < scores[i]:\n                    scores[i] = score\n                    best_individual = self.particle_swarm[i]\n\n        # Perform genetic algorithm\n        for _ in range(self.budget // 2):\n            # Select parents\n            parent1 = random.choice(self.gene_pool)\n            parent2 = random.choice(self.gene_pool)\n\n            # Perform crossover\n            child = parent1 + (parent2 - parent1) * self.crossover_rate\n\n            # Perform mutation\n            if random.random() < self.mutation_rate:\n                child += np.random.uniform(-1.0, 1.0, self.dim)\n\n            # Update the gene pool\n            self.gene_pool = np.concatenate((self.gene_pool, [child]))\n\n            # Update the scores\n            score = func(child)\n            scores = np.append(scores, score)\n\n        # Update the best individual\n        best_individual = self.gene_pool[np.argmin(scores)]\n\n        return best_individual\n\n# Example usage\nbudget = 100\ndim = 5\nfunc = lambda x: x[0]**2 + x[1]**2 + x[2]**2 + x[3]**2 + x[4]**2\nmetaheuristic = ProbabilisticMetaheuristic(budget, dim)\nbest_individual = metaheuristic(func)\nprint(best_individual)", "name": "ProbabilisticMetaheuristic", "description": "Novel probabilistic metaheuristic algorithm combining particle swarm optimization and genetic algorithm for black box optimization.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 146 is out of bounds for axis 0 with size 70').", "error": "IndexError('index 146 is out of bounds for axis 0 with size 70')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "75d8f06b-aef3-4857-ada8-ae4e94030e85", "solution": "import numpy as np\nimport random\n\nclass NPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.particles = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_particles = np.copy(self.particles)\n        self.best_values = np.full(self.population_size, np.inf)\n        self.cognitive_coefficient = 0.5\n        self.social_coefficient = 0.5\n        self.mutation_probability = 0.1\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                # Evaluate the function at the current particle position\n                value = func(self.particles[i])\n\n                # Update the best particle if the current value is better\n                if value < self.best_values[i]:\n                    self.best_particles[i] = self.particles[i]\n                    self.best_values[i] = value\n\n                # Update the cognitive and social components\n                self.particles[i] += self.cognitive_coefficient * (self.best_particles[i] - self.particles[i]) + \\\n                                      self.social_coefficient * (self.particles[np.random.choice(self.population_size, 1, p=self.best_values / np.sum(self.best_values))][0] - self.particles[i])\n\n                # Apply mutation with probability\n                if random.random() < self.mutation_probability:\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nnpso = NPSO(100, 5)\nbest_value = npso(func)\nprint(f\"Best value: {best_value}\")", "name": "NPSO", "description": "Novelized Particle Swarm Optimization (NPSO) with adaptive mutation and probability-based selection", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities contain NaN').", "error": "ValueError('probabilities contain NaN')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "deea7986-aa4b-408b-a097-d2ccb329c3a6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom skopt import gp_minimize\nfrom skopt.space import Real, Categorical, Integer\nfrom skopt.utils import use_named_args\nfrom skopt import gp_minimize\n\nclass ProbabilisticHyperEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.search_space = {\n            'bounds': [(-5.0, 5.0)] * dim,\n            'type': ['real'] * dim\n        }\n        self.crossover_probability = 0.3\n        self.mutation_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize the population with random candidates\n        candidates = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n        \n        # Evaluate the candidates\n        evaluations = []\n        for candidate in candidates:\n            evaluation = func(candidate)\n            evaluations.append(evaluation)\n        \n        # Select the best candidates\n        best_candidates = np.argsort(evaluations)[-self.population_size:]\n        \n        # Hyper-evolution\n        for _ in range(self.budget):\n            # Select the best candidate\n            best_candidate = candidates[best_candidates[0]]\n            \n            # Evaluate the best candidate\n            best_evaluation = evaluations[best_candidates[0]]\n            \n            # Crossover\n            offspring = []\n            for _ in range(self.population_size):\n                parent1 = candidates[np.random.choice(best_candidates)]\n                parent2 = candidates[np.random.choice(best_candidates)]\n                child = self.crossover(parent1, parent2)\n                offspring.append(child)\n            \n            # Mutation\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_probability:\n                    offspring[i] += np.random.uniform(-1.0, 1.0, size=self.dim)\n            \n            # Evaluate the offspring\n            evaluations = []\n            for candidate in offspring:\n                evaluation = func(candidate)\n                evaluations.append(evaluation)\n            \n            # Select the best candidates\n            best_candidates = np.argsort(evaluations)[-self.population_size:]\n            \n            # Replace the old candidates with the new ones\n            candidates[best_candidates] = offspring[best_candidates]\n            \n            # Update the best candidate\n            best_candidates[0] = np.argmin(evaluations)\n        \n        # Return the best candidate\n        return candidates[best_candidates[0]]\n\n    @staticmethod\n    def crossover(parent1, parent2):\n        # Simple crossover using uniform selection\n        child = (parent1 + parent2) / 2\n        return child\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2 + x[2]**2\n\nbudget = 10\ndim = 3\nalgorithm = ProbabilisticHyperEvolution(budget, dim)\nbest_candidate = algorithm(func)\nprint(best_candidate)", "name": "ProbabilisticHyperEvolution", "description": "Novel 'Probabilistic Hyper-Evolution with Adaptive Crossover' algorithm for black box optimization.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'skopt'\").", "error": "ModuleNotFoundError(\"No module named 'skopt'\")", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
{"id": "1c710cb2-15b4-49f7-899f-3e0119a1ed87", "solution": "import numpy as np\nimport random\n\nclass ProbabilisticEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_prob = 0.3\n        self.population_size = 100\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            scores = np.array([func(x) for x in self.population])\n            best_idx = np.argmin(scores)\n            best_individual = self.population[best_idx]\n            new_population = np.copy(self.population)\n            new_population[best_idx] = self.mutate(best_individual)\n            scores = np.array([func(x) for x in new_population])\n            if np.random.rand() < self.mutation_prob:\n                new_population = self.mutate(new_population)\n            self.population = new_population\n        return self.population[np.argmin([func(x) for x in self.population])]\n\n    def mutate(self, individual):\n        mutated_individual = individual.copy()\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                mutated_individual[i] += np.random.uniform(-1.0, 1.0)\n                mutated_individual[i] = np.clip(mutated_individual[i], self.lower_bound, self.upper_bound)\n        return mutated_individual\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nbudget = 100\ndim = 2\nes = ProbabilisticEvolutionStrategy(budget, dim)\noptimal_x = es(func)\nprint(optimal_x)", "name": "ProbabilisticEvolutionStrategy", "description": "Novel probabilistic evolution strategy with adaptive mutation and exploration control.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "657eeea6-d8e8-4d29-8c6d-6d1c5eed0854", "metadata": {}, "mutation_prompt": null}
