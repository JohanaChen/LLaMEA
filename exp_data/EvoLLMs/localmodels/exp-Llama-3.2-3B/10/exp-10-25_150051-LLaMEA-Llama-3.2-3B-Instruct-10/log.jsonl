{"id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm for black box optimization.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 43, in <module>\n  File \"<string>\", line 33, in __call__\nValueError: shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)\n.", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 43, in <module>\n  File \"<string>\", line 33, in __call__\nValueError: shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "ba7a6dc8-6fb6-4eca-9bd5-8c159380389a", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_prob = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Probabilistic mutation\n            mutated_population = population.copy()\n            for j in range(self.population_size):\n                if np.random.rand() < self.mutation_prob:\n                    mutated_population[j] = self.mutate(population[j])\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], mutated_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n    def mutate(self, individual):\n        mutated_individual = individual.copy()\n        for i in range(self.dim):\n            mutated_individual[i] = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.uniform()\n        return mutated_individual\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Probabilistic Mutation\" algorithm for black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "bdf18e22-2e79-45bc-a747-eb684196bbb0", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.line_search_prob = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Line search\n            if np.random.rand() < self.line_search_prob:\n                new_population = self.line_search(func, new_population, best_individual)\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n    def line_search(self, func, new_population, best_individual):\n        # Perform line search to find the optimal step size\n        step_size = 0.1\n        while True:\n            new_population = new_population + step_size * (best_individual - new_population)\n            fitness = np.array([func(x) for x in new_population])\n            if np.min(fitness) < np.min([func(x) for x in population]):\n                population[np.argmin(fitness)] = new_population[np.argmin(fitness)]\n                return new_population\n            step_size *= 0.9\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Line Search\" algorithm for black box optimization.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "671e6d7f-0c14-4d84-8f99-bac3c0f62106", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.mutation_probability = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Apply mutation with probability\n            for j in range(self.population_size):\n                if np.random.rand() < self.mutation_probability:\n                    new_individual = population[j]\n                    for k in range(self.dim):\n                        new_individual[k] += np.random.uniform(-1, 1)\n                    new_individual = np.clip(new_individual, self.lower_bound, self.upper_bound)\n                    population[j] = new_individual\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Mutation Probability\" algorithm for black box optimization.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 51 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 51 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "31863d26-95f9-423a-a387-ca144dc9cff5", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Change individual lines with 10% probability\n            if np.random.rand() < 0.1:\n                new_population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with 10% probability of changing individual lines.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "3f3b277b-76c1-41e6-b301-10d3eebd3fc6", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.refine_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Refine strategy\n            if np.random.rand() < self.refine_probability:\n                # Select a random individual from the current population\n                individual_to_refine = population[np.random.randint(0, self.population_size)]\n                # Generate a new individual by perturbing the selected individual\n                new_individual = individual_to_refine + np.random.uniform(-0.1, 0.1, (self.dim,))\n                # Ensure the new individual is within the bounds\n                new_individual = np.clip(new_individual, self.lower_bound, self.upper_bound)\n                # Replace the selected individual with the new individual\n                population[np.argmin(fitness)] = new_individual\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with refinement strategy.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "a5a7bdfb-5d59-4966-9a0c-5bdc46bb92e4", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.probability_line_replacement = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual with probability\n            replace_worst = np.random.rand() < self.probability_line_replacement\n            if replace_worst:\n                new_population[np.argsort(fitness)] = np.concatenate((np.zeros((self.population_size, self.dim)), new_population[np.argsort(fitness)]))\n\n            # Update population\n            population = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Probability of Line Replacement\" algorithm for black box optimization.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (200,10) (100,10) ').", "error": "ValueError('operands could not be broadcast together with shapes (200,10) (100,10) ')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "17310fba-1b1b-45a1-817d-a94db4404413", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Refine strategy with 10% probability\n            if np.random.rand() < 0.1:\n                for j in range(self.population_size):\n                    idx = np.random.randint(0, self.population_size)\n                    population[j] = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm for black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "e63248ff-f8d5-4dcc-bd98-e1398aafc01e", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm for black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "ec900afb-0cb2-4df2-a14c-06137e0f0dd3", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.refinement_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Refine best individual with probability\n            if np.random.rand() < self.refinement_probability:\n                new_best_individual = best_individual + self.adaptive_step_size * np.random.uniform(-1, 1, (1, self.dim))\n                new_population[np.argmin(fitness)] = new_best_individual\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with probability-based refinement.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 71 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 71 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "5d3461dd-1aa4-4e2c-a71e-4d2a323a6119", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.line_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        for i in range(self.budget):\n            fitness = np.array([func(x) for x in population])\n            best_individual = population[np.argmin(fitness)]\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n            if np.random.rand() < self.line_search_probability:\n                new_population = self.line_search(new_population, func, fitness, best_individual)\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n        return population[np.argmin(fitness)]\n\n    def line_search(self, new_population, func, fitness, best_individual):\n        new_fitness = np.array([func(x) for x in new_population])\n        best_index = np.argmin(new_fitness)\n        best_new_individual = new_population[best_index]\n        step_size = 0.01\n        while True:\n            new_population[best_index] += step_size * (best_individual - best_new_individual)\n            new_fitness[best_index] = func(new_population[best_index])\n            if new_fitness[best_index] < fitness[best_index]:\n                return new_population\n            step_size *= 0.9\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Line Search\" algorithm for black box optimization.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "09c38601-6b0b-4020-918f-d9b7149a6628", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.mutation_probability = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Apply mutation with probability\n            if np.random.rand() < self.mutation_probability:\n                mutated_individual = population[np.random.randint(0, self.population_size)]\n                mutated_individual = mutated_individual + np.random.uniform(-self.adaptive_step_size, self.adaptive_step_size, self.dim)\n                population[np.argmin(fitness)] = mutated_individual\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Mutation Probability\" algorithm for black box optimization.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "087e2b6b-7793-48b4-89a8-b7a3162068ee", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_prob = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            fitness = np.array([func(x) for x in population])\n\n            best_individual = population[np.argmin(fitness)]\n\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            for j in range(self.population_size):\n                if np.random.rand() < self.mutation_prob:\n                    new_individual = population[j] + np.random.uniform(-1, 1, self.dim)\n                    new_population[j] = new_individual\n\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with 10% probability of line mutation for black box optimization.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 75 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 75 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "d36a9b68-b245-47e4-b08e-0fbb8a89c170", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.line_search_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Line search\n            if np.random.rand() < self.line_search_probability:\n                # Evaluate fitness at new individual\n                new_fitness = func(new_population)\n\n                # Refine best individual\n                best_individual = new_population[np.argmin(new_fitness)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Line Search\" algorithm for black box optimization with probabilistic line search.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "641658b7-7eb7-4477-a579-5b439e342e3c", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Probability-based mutation\n            mutated_population = []\n            for individual in population:\n                if np.random.rand() < self.mutation_probability:\n                    mutated_individual = individual + np.random.uniform(-1, 1, self.dim)\n                    mutated_population.append(mutated_individual)\n                else:\n                    mutated_population.append(individual)\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], mutated_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with probability-based mutation.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('only integer scalar arrays can be converted to a scalar index').", "error": "TypeError('only integer scalar arrays can be converted to a scalar index')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "d2e06d22-69af-4a8a-b5fc-ce0b42e534a7", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.line_search_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Line search\n            if np.random.rand() < self.line_search_probability:\n                new_population = self.line_search(new_population, func, self.lower_bound, self.upper_bound)\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n    def line_search(self, new_population, func, lower_bound, upper_bound):\n        # Perform line search to find the optimal step size\n        step_sizes = np.linspace(lower_bound, upper_bound, 100)\n        fitness_values = np.array([func(x + step_size * np.random.uniform(-1, 1, self.dim)) for x in new_population for step_size in step_sizes])\n        optimal_step_size = step_sizes[np.argmin(fitness_values)]\n        new_population = new_population + optimal_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return new_population\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Line Search\" algorithm for black box optimization.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 72 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 72 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "0fc3d4aa-9f17-4aec-a780-f088bf8c9917", "solution": "import numpy as np\nimport random\nimport scipy.optimize as optimize\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.line_search_prob = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Line search\n            if np.random.rand() < self.line_search_prob:\n                # Perform line search to find optimal step size\n                step_size = optimize.minimize(lambda x: func(best_individual + x * np.random.uniform(-1, 1, self.dim)), np.zeros(self.dim), method='SLSQP').x[0]\n                new_population = best_individual + step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Line Search\" algorithm for black box optimization.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 65 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 65 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "1bed279a-6f40-45d7-804f-5626db2e7410", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_prob = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            fitness = np.array([func(x) for x in population])\n\n            best_individual = population[np.argmin(fitness)]\n\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Adaptive mutation probability\n            if np.random.rand() < self.mutation_prob:\n                for j in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        new_population[j, :] = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.uniform(0, 1, self.dim)\n\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm for black box optimization with adaptive mutation probability.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 77 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 77 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "a634e2fe-1844-4ea6-b058-703a96eb2306", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_prob = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Probabilistic mutation\n            mutated_population = population.copy()\n            for j in range(self.population_size):\n                if np.random.rand() < self.mutation_prob:\n                    mutated_population[j] = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.uniform()\n            population = mutated_population\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Probabilistic Mutation\" algorithm for black box optimization.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "fd0bc2ca-7ef8-4cbf-a8c9-4caa365c3c48", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Change individual lines with 10% probability\n            if np.random.rand() < 0.1:\n                new_population = np.where(np.random.rand(self.population_size, self.dim) < 0.1, new_population, population)\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with 10% probability to change individual lines.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "d70d17b1-2bee-4e4a-a7b2-747741dad68c", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_prob = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Apply mutation with probability 0.1\n            if np.random.rand() < self.mutation_prob:\n                mutated_individual = population[np.random.randint(0, self.population_size)]\n                mutated_individual = mutated_individual + np.random.uniform(-self.mutation_prob, self.mutation_prob, self.dim)\n                population[np.random.randint(0, self.population_size)] = mutated_individual\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with probability 0.1 mutation.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 95 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 95 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "90ad0952-1bd7-4d47-a1f2-ec700d8c9f6a", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        for i in range(self.budget):\n            fitness = np.array([func(x) for x in population])\n            best_individual = population[np.argmin(fitness)]\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n            for j in range(self.population_size):\n                if np.random.rand() < self.mutation_probability:\n                    new_individual = self.mutate(new_population[j])\n                    new_population[j] = new_individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n        return population[np.argmin(fitness)]\n\n    def mutate(self, individual):\n        mutated_individual = individual + np.random.uniform(-0.1, 0.1, self.dim)\n        return np.clip(mutated_individual, self.lower_bound, self.upper_bound)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm for black box optimization with probabilistic mutation.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "d2619e41-57dd-416a-bc48-21b5acaf6b79", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Adaptive mutation\n            if np.random.rand() < 0.1:\n                mutation_index = np.random.choice(self.population_size, size=self.dim, replace=False)\n                new_individual = population[mutation_index]\n                new_individual += np.random.uniform(-0.1, 0.1, self.dim)\n                population[mutation_index] = np.clip(new_individual, self.lower_bound, self.upper_bound)\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm for black box optimization with adaptive mutation.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "cf075338-a489-4fca-8a51-35f7f4fb4ee7", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.line_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        for i in range(self.budget):\n            fitness = np.array([func(x) for x in population])\n            best_individual = population[np.argmin(fitness)]\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n            if np.random.rand() < self.line_search_probability:\n                new_individual = self.line_search(func, new_population, best_individual)\n                population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n            else:\n                population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n        return population[np.argmin(fitness)]\n\n    def line_search(self, func, new_population, best_individual):\n        initial_guess = best_individual\n        initial_fitness = func(initial_guess)\n        best_guess = initial_guess\n        best_fitness = initial_fitness\n        for _ in range(10):\n            guess = initial_guess + 0.1 * np.random.uniform(-1, 1, self.dim)\n            fitness = func(guess)\n            if fitness < best_fitness:\n                best_guess = guess\n                best_fitness = fitness\n        return best_guess\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Line Search\" algorithm for black box optimization with line search.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 96 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 96 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "53c2a513-14fc-496b-b918-1a11a5898a13", "solution": "import numpy as np\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_prob = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Mutation with probabilistic change\n            mutation_mask = np.random.rand(self.population_size, self.dim) < self.mutation_prob\n            new_population[mutation_mask] += np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with probabilistic mutation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (93,) (100,10) (93,) ').", "error": "ValueError('operands could not be broadcast together with shapes (93,) (100,10) (93,) ')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "a7321e0e-fa50-454c-b8fc-0a2416680161", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.mutation_probability = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Mutation\n            mutated_population = np.copy(population)\n            for j in range(self.population_size):\n                if np.random.rand() < self.mutation_probability:\n                    mutated_population[j] = mutated_population[j] + np.random.uniform(-1, 1, self.dim)\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], mutated_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Mutation Probability\" algorithm for black box optimization.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "c9587248-04b1-4128-a98e-8d1a3dcb8311", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.adaptive_mutation_rate = 0.1\n        self.adaptive_crossover_rate = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Adaptive mutation rate\n            mutation_mask = np.random.rand(self.population_size) < self.adaptive_mutation_rate\n            new_population[mutation_mask] += np.random.uniform(-1, 1, (mutation_mask.sum(), self.dim))\n\n            # Adaptive crossover rate\n            crossover_mask = np.random.rand(self.population_size) < self.adaptive_crossover_rate\n            new_population[crossover_mask] = np.random.choice(new_population[crossover_mask], size=(crossover_mask.sum(), self.dim), replace=False)\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with adaptive mutation and crossover rates.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('boolean index did not match indexed array along dimension 0; dimension is 50 but corresponding boolean dimension is 100').", "error": "IndexError('boolean index did not match indexed array along dimension 0; dimension is 50 but corresponding boolean dimension is 100')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "c7c11f09-f161-4f6b-8a27-e8ba91e72dd2", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Probabilistic mutation refinement\n            if np.random.rand() < self.mutation_probability:\n                for j in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        # Randomly select two parents\n                        parent1 = population[np.random.randint(0, self.population_size)]\n                        parent2 = population[np.random.randint(0, self.population_size)]\n\n                        # Create a new individual by crossover\n                        child = (parent1 + parent2) / 2\n\n                        # Mutate the child\n                        child += np.random.uniform(-1, 1, self.dim)\n\n                        # Replace the worst individual with the child\n                        population[np.argmin(fitness)] = child\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with probabilistic mutation refinement.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 51 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 51 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "204294b6-83d0-4c58-9e28-8dcbd41b4824", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_prob = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            fitness = np.array([func(x) for x in population])\n\n            best_individual = population[np.argmin(fitness)]\n\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            for j in range(self.population_size):\n                if np.random.rand() < self.mutation_prob:\n                    mutation_index = np.random.randint(0, self.dim)\n                    new_population[j, mutation_index] += np.random.uniform(-1, 1)\n\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with probabilistic mutation.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 61 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 61 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "e85e44e3-2587-4bf4-a054-824d7c648942", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Mutation with probability\n            if np.random.rand() < self.mutation_probability:\n                mutated_indices = np.random.choice(self.population_size, size=int(self.population_size * self.mutation_probability), replace=False)\n                new_population[mutated_indices] += np.random.uniform(-1, 1, size=(int(self.population_size * self.mutation_probability), self.dim))\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with probability-based mutation for black box optimization.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 91 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 91 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "8896b3bf-878d-402a-bea1-babe186361f6", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.line_search_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Line search\n            if np.random.rand() < self.line_search_probability:\n                new_population = self.line_search(new_population, func, best_individual)\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n    def line_search(self, new_population, func, best_individual):\n        # Calculate gradient of the function at the best individual\n        gradient = np.zeros(self.dim)\n        step_size = 1e-6\n        for i in range(self.dim):\n            gradient[i] = (func(best_individual + step_size * np.eye(self.dim)[i]) - func(best_individual)) / step_size\n\n        # Line search\n        for i in range(self.dim):\n            new_population[:, i] += self.adaptive_step_size * gradient[i]\n\n        return new_population\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Line Search\" algorithm for black box optimization.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "31b63735-90ae-4c6b-8ce4-4a7d789bf2c7", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.refine_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Refine individuals with probability 0.1\n            if np.random.rand() < self.refine_probability:\n                new_population = np.array([new_population[j] for j in range(self.population_size) if np.random.rand() < 0.9])\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with refinement probability.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "5246d8f8-d711-4516-be61-d3df40c5abb8", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.mutation_probability = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        for i in range(self.budget):\n            fitness = np.array([func(x) for x in population])\n            best_individual = population[np.argmin(fitness)]\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n            for j in range(self.population_size):\n                if np.random.rand() < self.mutation_probability:\n                    new_individual = new_population[j]\n                    for k in range(self.dim):\n                        new_individual[k] += np.random.uniform(-1, 1)\n                    new_individual = np.clip(new_individual, self.lower_bound, self.upper_bound)\n                    new_population[j] = new_individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Probability of Mutation\" algorithm for black box optimization.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 84 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 84 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "a8d85ddd-d73c-4a6e-9885-c38893e20c99", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.line_search_prob = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            fitness = np.array([func(x) for x in population])\n\n            best_individual = population[np.argmin(fitness)]\n\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            line_search_prob = self.line_search_prob if np.random.rand() < self.line_search_prob else 0\n\n            for j in range(self.population_size):\n                if line_search_prob > 0:\n                    # Perform line search to find the optimal step size\n                    step_size = self.line_search(func, population[j], self.lower_bound, self.upper_bound)\n                    new_population[j] = population[j] + step_size\n\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        return population[np.argmin(fitness)]\n\n    def line_search(self, func, x, lower_bound, upper_bound):\n        # Perform line search using the Armijo rule\n        step_size = 1\n        while True:\n            new_x = x + step_size * (upper_bound - lower_bound) / 10\n            if func(new_x) <= func(x) * (1 - 0.1):\n                return new_x\n            step_size *= 0.9\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Line Search\" algorithm for black box optimization with probability-based line search.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 74 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 74 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "250ac74f-c324-4892-a045-d8f6a775e4f0", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.refine_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Refine individual lines with 10% probability\n            if np.random.rand() < self.refine_probability:\n                refined_population = []\n                for individual in population:\n                    refined_individual = individual + np.random.uniform(-0.1, 0.1, self.dim)\n                    refined_population.append(refined_individual)\n                population = refined_population\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with 10% probability to refine individual lines", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('only integer scalar arrays can be converted to a scalar index').", "error": "TypeError('only integer scalar arrays can be converted to a scalar index')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "fb99c472-efbc-4475-a29f-ebace6bdd5ef", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_prob = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Probabilistic mutation\n            for j in range(self.population_size):\n                if np.random.rand() < self.mutation_prob:\n                    mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    population[j] += mutation\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm for black box optimization with probabilistic mutation.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "c2085d01-a052-4f88-b66d-cac774176307", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.mutation_probability = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Mutation\n            for j in range(self.population_size):\n                if np.random.rand() < self.mutation_probability:\n                    new_individual = population[j] + np.random.uniform(-1, 1, self.dim)\n                    new_individual = np.clip(new_individual, self.lower_bound, self.upper_bound)\n                    population[j] = new_individual\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Mutation Probability\" algorithm for black box optimization.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "22123253-1e7a-4392-972b-4b714d27918a", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.mutation_rate = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Apply mutation\n            mutated_population = population.copy()\n            for j in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutated_population[j] = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.uniform(0, 1, self.dim)\n            population = mutated_population\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Mutation Rate\" algorithm for black box optimization.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "118f4666-bca4-4de1-9b66-0ee876fc284e", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.line_mutation_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            fitness = np.array([func(x) for x in population])\n\n            best_individual = population[np.argmin(fitness)]\n\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Line mutation\n            for j in range(self.population_size):\n                if np.random.rand() < self.line_mutation_probability:\n                    mutation_point = np.random.randint(1, self.dim)\n                    new_population[j, mutation_point] += np.random.uniform(-1, 1)\n\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Line Mutation\" algorithm for black box optimization.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "71ca6a3d-c162-4db9-8a8f-50969ea6017a", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm for black box optimization.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 92 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 92 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "76a3220c-5c90-452b-9bca-4d6427c98580", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Refine strategy with 10% probability\n            if np.random.rand() < 0.1:\n                for j in range(self.population_size):\n                    # Randomly select two individuals\n                    individual1 = population[j]\n                    individual2 = population[np.random.randint(0, self.population_size)]\n                    # Create a new individual by taking the average of the two individuals\n                    new_individual = (individual1 + individual2) / 2\n                    # Replace the worst individual with the new individual\n                    population[np.argmin(fitness)] = new_individual\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm for black box optimization.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "7f934c39-c644-40c3-8603-3e797b4b7261", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.mutation_probability = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Mutation\n            mutated_population = np.copy(new_population)\n            for j in range(self.population_size):\n                if np.random.rand() < self.mutation_probability:\n                    mutated_population[j] = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.uniform()\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], mutated_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Mutation Probability\" algorithm for black box optimization.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "d1734975-e18e-494c-8c75-6d48e1eedb21", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.adaptive_probability = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Refine strategy with 10% probability\n            if np.random.rand() < self.adaptive_probability:\n                for j in range(self.population_size):\n                    new_individual = population[j] + np.random.uniform(-0.1, 0.1, self.dim)\n                    population[j] = new_individual\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Probability\" algorithm for black box optimization.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 54 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 54 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "59bf902a-d724-4563-9b24-6d467a506851", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.mutation_probability = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            fitness = np.array([func(x) for x in population])\n            best_individual = population[np.argmin(fitness)]\n\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            for j in range(self.population_size):\n                if np.random.rand() < self.mutation_probability:\n                    new_individual = new_population[j]\n                    for k in range(self.dim):\n                        new_individual[k] += np.random.uniform(-1, 1)\n                    new_individual = np.clip(new_individual, self.lower_bound, self.upper_bound)\n\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Mutation Probability\" algorithm for black box optimization.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 54 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 54 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "3fc5b17a-cde0-4f0e-baee-fdf7b975d8cd", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            fitness = np.array([func(x) for x in population])\n\n            best_individual = population[np.argmin(fitness)]\n\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Refine strategy with probability\n            if np.random.rand() < self.probability:\n                refined_population = []\n                for individual in population:\n                    refined_individual = individual + self.adaptive_step_size * np.random.uniform(-1, 1, self.dim)\n                    refined_population.append(refined_individual)\n\n                population = refined_population\n\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Probability\" algorithm for black box optimization.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 90 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 90 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "3ec94e7a-2f29-46aa-a227-f8116bd6528c", "solution": "import numpy as np\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.mutation_probability = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Apply mutation with probability\n            mutated_population = population.copy()\n            for j in range(self.population_size):\n                if np.random.rand() < self.mutation_probability:\n                    mutated_population[j] += np.random.uniform(-self.mutation_probability, self.mutation_probability, self.dim)\n\n            # Replace worst individual with mutated individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], mutated_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Mutation Probability\" algorithm for black box optimization.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "40dcf080-369d-42ae-9e51-97931604fabd", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.mutation_probability = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Mutation\n            for j in range(self.population_size):\n                if np.random.rand() < self.mutation_probability:\n                    new_population[j] = self.mutation(new_population[j])\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n    def mutation(self, individual):\n        mutation_index = np.random.randint(0, self.dim)\n        mutation_value = np.random.uniform(self.lower_bound, self.upper_bound)\n        individual[mutation_index] += mutation_value\n        return individual\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Mutation Probability\" algorithm for black box optimization.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 57 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 57 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "2ec414c7-c030-4dbe-8c98-0548db4567f4", "solution": "import numpy as np\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.refine_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Refine individual lines with 0.1 probability\n            if np.random.rand() < self.refine_probability:\n                new_population = np.where(np.random.rand(self.population_size, self.dim) < self.refine_probability, new_population, population)\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with 0.1 probability to refine individual lines.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 91 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 91 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "5354cb0f-dc48-4532-9cf7-85dbabcae372", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Probabilistic mutation\n            mutated_population = new_population\n            for j in range(self.population_size):\n                if np.random.rand() < self.mutation_probability:\n                    mutated_population[j] = new_population[j] + np.random.uniform(-1, 1, self.dim)\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], mutated_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with probabilistic mutation for black box optimization.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "22f650ec-d144-4a96-b89a-72fc490bd353", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.probability_of_mutation = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Apply mutation with probability\n            mutated_indices = np.random.choice(self.population_size, size=int(self.population_size * self.probability_of_mutation), replace=False)\n            for j in mutated_indices:\n                new_individual = population[j]\n                new_individual[j] = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.uniform()\n                population[j] = new_individual\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Probability of Mutation\" algorithm for black box optimization.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "c21742a4-34b5-47ce-89cb-909f2cc19971", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_prob = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Apply mutation with 10% probability\n            mutated_population = np.copy(population)\n            indices_to_mutate = np.random.choice(self.population_size, size=int(self.population_size * self.mutation_prob), replace=False)\n            mutated_population[indices_to_mutate] += np.random.uniform(-1, 1, size=(len(indices_to_mutate), self.dim))\n            population = np.minimum(np.maximum(population, self.lower_bound), self.upper_bound)\n            population[indices_to_mutate] = mutated_population[indices_to_mutate]\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm for black box optimization with 10% probability mutation.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "3ef30839-a711-4f76-a2b3-a4ae72bf8f1d", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.line_search_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Line search\n            if np.random.rand() < self.line_search_probability:\n                # Use minimize function to find the optimal solution in the current population\n                result = minimize(lambda x: func(x), best_individual, method='SLSQP', bounds=[(self.lower_bound, self.upper_bound)] * self.dim)\n                best_individual = result.x\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Line Search\" algorithm for black box optimization.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "105eabbb-81d3-4e27-8e20-c1375d9a2b07", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_prob = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Perform probabilistic mutation\n            for j in range(self.population_size):\n                if np.random.rand() < self.mutation_prob:\n                    new_population[j] = self.mutate(new_population[j])\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n    def mutate(self, individual):\n        # Perform single-point mutation\n        index = np.random.randint(0, self.dim)\n        new_individual = individual.copy()\n        new_individual[index] = np.random.uniform(self.lower_bound, self.upper_bound)\n        return new_individual\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Probabilistic Mutation\" algorithm for black box optimization", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 51 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 51 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "631c056d-2956-45f1-9572-03114922a180", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.mutation_probability = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Apply mutation with probability\n            mask = np.random.rand(self.population_size) < self.mutation_probability\n            population[mask] = np.random.uniform(self.lower_bound, self.upper_bound, size=mask.sum())\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Mutation Probability\" algorithm for black box optimization.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 86 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 86 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "e294ae71-70cf-4207-a2fb-4d62c85aadac", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.mutation_probability = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Apply mutation with probability\n            if np.random.rand() < self.mutation_probability:\n                indices = np.random.choice(self.population_size, size=self.dim, replace=False)\n                new_population[indices, :] += np.random.uniform(-1, 1, (self.dim,))\n\n            # Ensure bounds are not exceeded\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Mutation Probability\" algorithm for black box optimization.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 92 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 92 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "91e54f5a-78a5-4d11-bfb4-1a53ac660d33", "solution": "import numpy as np\nimport random\nimport scipy.optimize as optimize\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.line_search_prob = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Line search\n            if np.random.rand() < self.line_search_prob:\n                new_individual = optimize.minimize(func, best_individual, method=\"SLSQP\").x\n                population[np.argmin(fitness)] = new_individual\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Line Search\" algorithm for black box optimization.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "967ccad7-d262-4419-9b74-e68ea37f3f9c", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Change individual lines with probability\n            if np.random.rand() < self.probability:\n                idx = np.random.choice(self.population_size, size=self.dim, replace=False)\n                new_population[:, idx] = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm for black box optimization.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 66 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 66 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "98cb5795-be26-4487-aa8a-74b86cdb877d", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        for i in range(self.budget):\n            fitness = np.array([func(x) for x in population])\n            best_individual = population[np.argmin(fitness)]\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n            for j in range(self.population_size):\n                if np.random.rand() < self.probability:\n                    new_individual = new_population[j]\n                    for k in range(self.dim):\n                        new_individual[k] = np.random.uniform(self.lower_bound, self.upper_bound)\n                    new_population[j] = new_individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm for black box optimization with 10% probability of changing individual lines.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 68 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 68 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "c6080c93-2c9f-4136-9d18-89f9aa7a7a1e", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.line_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        for i in range(self.budget):\n            fitness = np.array([func(x) for x in population])\n            best_individual = population[np.argmin(fitness)]\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n            if np.random.rand() < self.line_search_probability:\n                # Perform line search to find the optimal step size\n                step_size = self.line_search(func, best_individual, self.upper_bound)\n                new_population = new_population + step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n        return population[np.argmin(fitness)]\n\n    def line_search(self, func, individual, upper_bound):\n        # Perform line search to find the optimal step size\n        step_size = 0.1\n        while True:\n            new_individual = individual + step_size * np.random.uniform(-1, 1, self.dim)\n            if func(new_individual) < func(individual):\n                return new_individual + step_size * np.random.uniform(-1, 1, self.dim)\n            step_size *= 0.9\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Line Search\" algorithm for black box optimization.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "2cd65b0d-7282-4797-b22c-4d94edefed4c", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.mutation_probability = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Apply mutation with probability\n            for j in range(self.population_size):\n                if np.random.rand() < self.mutation_probability:\n                    mutation = np.random.uniform(-1, 1, self.dim)\n                    population[j] += mutation\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Mutation Probability\" algorithm for black box optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "614912dd-df96-459b-b283-132feb36add6", "solution": "import numpy as np\nimport random\nimport scipy.optimize as optimize\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.line_search_prob = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Line search\n            if np.random.rand() < self.line_search_prob:\n                new_population = self.line_search(new_population, func)\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n    def line_search(self, population, func):\n        new_population = []\n        for individual in population:\n            x0 = individual\n            cons = ({'type': 'ineq', 'fun': lambda x: x[0] - self.lower_bound},\n                    {'type': 'ineq', 'fun': lambda x: x[0] - self.upper_bound})\n            res = optimize.differential_evolution(func, cons, x0=x0, full_output=True, maxiter=10)\n            new_population.append(res.x)\n        return np.array(new_population)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Line Search\" algorithm for black box optimization.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 54 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 54 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "56b9eb7c-3a30-442f-8737-d0647480841d", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.changing_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Change individual lines with 10% probability\n            if np.random.rand() < self.changing_probability:\n                indices = np.random.choice(self.population_size, size=self.dim, replace=False)\n                new_population[indices] = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.dim,))\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with 10% probability to change individual lines.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "473e5af2-0f5c-4b4b-932b-24942953f267", "solution": "import numpy as np\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.probability = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            fitness = np.array([func(x) for x in population])\n\n            best_individual = population[np.argmin(fitness)]\n\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            for j in range(self.population_size):\n                if np.random.rand() < self.probability:\n                    mutation_index = np.random.choice(self.population_size, 1, replace=False)\n                    new_population[j] += np.random.uniform(-1, 1, self.dim)\n\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Probabilistic Mutation\" algorithm for black box optimization.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 59 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 59 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "98c80f23-e873-4940-aa95-271a8c1b3a96", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_prob = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        for i in range(self.budget):\n            fitness = np.array([func(x) for x in population])\n            best_individual = population[np.argmin(fitness)]\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n            if np.random.rand() < self.mutation_prob:\n                mutation_index = np.random.choice(self.population_size, size=self.dim, replace=False)\n                new_population[mutation_index] = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with probabilistic mutation.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "e9c7a330-6b58-46e2-9a5e-be7852b57cf2", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.refine_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Refine individual lines with probability 0.1\n            if np.random.rand() < self.refine_probability:\n                for j in range(self.population_size):\n                    new_individual = new_population[j] + np.random.uniform(-0.1, 0.1, self.dim)\n                    if np.any(new_individual < self.lower_bound):\n                        new_individual[self.new_individual < self.lower_bound] = self.lower_bound\n                    if np.any(new_individual > self.upper_bound):\n                        new_individual[self.new_individual > self.upper_bound] = self.upper_bound\n                    new_population[j] = new_individual\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm for black box optimization with probability refinement.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'DEASPS' object has no attribute 'new_individual'\").", "error": "AttributeError(\"'DEASPS' object has no attribute 'new_individual'\")", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "ffb935d6-e3fb-45df-9254-6e9a65001a37", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_prob = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Adaptive mutation probability\n            if np.random.rand() < self.mutation_prob:\n                # Randomly select individuals to mutate\n                indices = np.random.choice(self.population_size, int(self.population_size * self.mutation_prob), replace=False)\n                # Mutate selected individuals\n                for index in indices:\n                    # Randomly select a dimension to mutate\n                    dim_index = np.random.randint(0, self.dim)\n                    # Generate a random mutation value\n                    mutation = np.random.uniform(-1, 1)\n                    # Apply the mutation\n                    population[index, dim_index] += mutation\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with adaptive mutation probability for black box optimization.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "7d74b435-3919-43ef-9278-06adcc9c2714", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Mutation\n            for j in range(self.population_size):\n                if np.random.rand() < self.mutation_probability:\n                    for k in range(self.dim):\n                        new_individual = population[j]\n                        new_individual[k] += np.random.uniform(-1, 1)\n                        population[j] = new_individual\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with 0.1 probability of line mutation for black box optimization.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "d1cf905e-59b0-451f-9ba1-436142c297cb", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_prob = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Mutation with probability 0.1\n            if np.random.rand() < self.mutation_prob:\n                mutated_individual = self.mutate(population[np.random.randint(0, self.population_size)], self.dim)\n                population[np.random.randint(0, self.population_size)] = mutated_individual\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n    def mutate(self, individual, dim):\n        mutated_individual = individual.copy()\n        for i in range(dim):\n            if np.random.rand() < self.mutation_prob:\n                mutated_individual[i] += np.random.uniform(-1, 1)\n                if mutated_individual[i] < self.lower_bound:\n                    mutated_individual[i] = self.lower_bound\n                elif mutated_individual[i] > self.upper_bound:\n                    mutated_individual[i] = self.upper_bound\n        return mutated_individual\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with probability 0.1 mutation for black box optimization.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "aa8a70c2-abf8-4d0b-96d6-e41cdb4b7f6c", "solution": "import numpy as np\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Refine strategy with probability 0.1\n            if np.random.rand() < 0.1:\n                # Randomly select two individuals\n                idx1, idx2 = np.random.choice(self.population_size, 2, replace=False)\n                # Create a new individual by taking the average of the two selected individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new individual\n                population[np.argmin(fitness)] = new_individual\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with probability 0.1 to refine its strategy.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 66 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 66 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "eca0839f-02ff-45e9-a578-aee7570de44c", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_refinement_prob = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Refine strategy with probability 0.1\n            if np.random.rand() < self.mutation_refinement_prob:\n                for j in range(self.population_size):\n                    if np.random.rand() < 0.1:\n                        new_individual = population[j] + np.random.uniform(-1, 1, self.dim)\n                        if np.min(func(new_individual)) < np.min(func(population[j])):\n                            population[j] = new_individual\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with probability 0.1 mutation refinement.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "f913e747-8e46-4587-8254-410dccc962bd", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.refine_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Refine the best individual with a probability of 0.1\n            if np.random.rand() < self.refine_probability:\n                best_individual = best_individual + self.adaptive_step_size * np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm for black box optimization with refinement probability.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "476dbfde-51f6-4159-817d-ca682013694c", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Probabilistic mutation\n            if np.random.rand() < self.probability:\n                mutated_population = new_population + np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n                new_population = np.concatenate((new_population, mutated_population))\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Probabilistic Mutation\" algorithm for black box optimization.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (50,10) (100,10) ').", "error": "ValueError('operands could not be broadcast together with shapes (50,10) (100,10) ')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "937a04c2-7ac8-4503-a890-8910a5297d84", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.change_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Change individual lines with 10% probability\n            if np.random.rand() < self.change_probability:\n                for j in range(self.population_size):\n                    new_individual = np.copy(population[j])\n                    for k in range(self.dim):\n                        if np.random.rand() < 0.1:\n                            new_individual[k] = np.random.uniform(self.lower_bound, self.upper_bound)\n                    population[j] = new_individual\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with 10% probability of changing individual lines for black box optimization.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 83 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 83 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "ff1571b1-36f1-4254-b936-3ab0b245c163", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.refinement_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Refine strategy with probability\n            if np.random.rand() < self.refinement_probability:\n                # Select a random individual to refine\n                individual_to_refine = population[np.random.randint(0, self.population_size)]\n\n                # Generate a new individual by perturbing the selected individual\n                new_individual = individual_to_refine + np.random.uniform(-0.1, 0.1, self.dim)\n\n                # Replace the individual with the new one\n                population[np.argmin(fitness)] = new_individual\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm for black box optimization with probability-based refinement.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 71 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 71 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "8a462e70-52db-4312-bf9d-3a2a3439a6fd", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.refine_prob = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        for i in range(self.budget):\n            fitness = np.array([func(x) for x in population])\n            best_individual = population[np.argmin(fitness)]\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n            for j in range(self.population_size):\n                if np.random.rand() < self.refine_prob:\n                    new_individual = self.refine_individual(population[j], new_population)\n                    population[j] = new_individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n        return population[np.argmin(fitness)]\n\n    def refine_individual(self, individual, new_population):\n        new_individual = individual + (new_population - individual) * np.random.uniform(0, 1, self.dim)\n        return new_individual\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Individual Line Refinement\" algorithm for black box optimization.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (50,10) into shape (10,)').", "error": "ValueError('could not broadcast input array from shape (50,10) into shape (10,)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "b25b27df-d815-4ca5-be25-d1f7ae199529", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_prob = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Mutation strategy\n            mutation_mask = np.random.rand(self.population_size, self.dim) < self.mutation_prob\n            new_population[mutation_mask] += np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with adaptive mutation strategy.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('boolean index did not match indexed array along dimension 0; dimension is 50 but corresponding boolean dimension is 100').", "error": "IndexError('boolean index did not match indexed array along dimension 0; dimension is 50 but corresponding boolean dimension is 100')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "aa7042aa-1192-47a3-8f6c-926cc42b7e6a", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Adaptive mutation probability\n            if np.random.rand() < self.mutation_probability:\n                mutation_mask = np.random.choice([0, 1], size=(self.population_size, self.dim), p=[1-self.mutation_probability, self.mutation_probability])\n                population[mutation_mask] = new_population[mutation_mask]\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with adaptive mutation probability for black box optimization.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "09837560-5492-4196-8a12-8491ee6b951e", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Probabilistic mutation\n            for j in range(self.population_size):\n                if np.random.rand() < self.mutation_probability:\n                    mutation_index = np.random.choice(self.population_size)\n                    mutation_vector = np.random.uniform(-1, 1, (self.dim,))\n                    new_population[j] += mutation_vector\n\n            # Ensure bounds are not exceeded\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with probabilistic mutation for black box optimization.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "41bc195c-33d7-44dc-8700-fe0e692034f4", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.refine_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Refine strategy with probability 0.1\n            if np.random.rand() < self.refine_probability:\n                # Randomly select an individual to refine\n                refine_individual = population[np.random.randint(0, self.population_size)]\n                # Refine its strategy\n                refine_individual = refine_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Ensure bounds are not exceeded\n                refine_individual = np.clip(refine_individual, self.lower_bound, self.upper_bound)\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm for black box optimization with probability 0.1 to refine its strategy.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 79 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 79 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "376c41dd-039c-4516-8feb-eb584126e21d", "solution": "import numpy as np\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.mutation_probability = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Mutation\n            mutation_mask = np.random.rand(self.population_size, self.dim) < self.mutation_probability\n            new_population[mutation_mask] += np.random.uniform(-self.adaptive_step_size, self.adaptive_step_size, (self.population_size, self.dim))\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Mutation Probability\" algorithm for black box optimization.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (90,) (100,10) (90,) ').", "error": "ValueError('operands could not be broadcast together with shapes (90,) (100,10) (90,) ')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "eb5917e7-a190-44ef-ae1b-8ce6a1dde795", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.mutation_probability = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Mutation\n            mutation_mask = np.random.rand(self.population_size, self.dim) < self.mutation_probability\n            population[mutation_mask] = population[mutation_mask] + np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Mutation Probability\" algorithm for black box optimization.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "55cc1b18-f80b-4d0e-8b56-0dc71fe00831", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # 10% probability of line mutation\n            if np.random.rand() < 0.1:\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        new_population[:, j] += np.random.uniform(-1, 1)\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm for black box optimization with 10% probability of line mutation.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 75 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 75 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "dd574968-cf71-4149-9757-fbb445b56f15", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # 10% probability to change individual lines\n            if np.random.rand() < 0.1:\n                for j in range(self.population_size):\n                    # Randomly select two individuals\n                    individual1 = population[j]\n                    individual2 = population[np.random.randint(0, self.population_size)]\n\n                    # Create a new individual by taking a weighted average\n                    new_individual = 0.9 * individual1 + 0.1 * individual2\n                    new_individual = np.clip(new_individual, self.lower_bound, self.upper_bound)\n                    new_individual = new_individual / np.linalg.norm(new_individual)\n                    new_individual = new_individual * np.linalg.norm(individual1)\n\n                    # Replace the worst individual with the new one\n                    population[np.argsort(fitness)[j]] = new_individual\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with 10% probability to change individual lines for black box optimization.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "d8dd3f43-f750-4048-8a91-ecddda1d21db", "solution": "import numpy as np\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.mutation_probability = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Apply mutation with probability\n            mask = np.random.rand(self.population_size, self.dim) < self.mutation_probability\n            population[mask] += np.random.uniform(-1, 1, mask.shape)\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Mutation Probability\" algorithm for black box optimization.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "2c8e45ad-bef1-42de-8d0d-3c602d9305be", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.probability = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Probabilistic mutation\n            if np.random.rand() < self.probability:\n                mutated_population = np.copy(new_population)\n                for j in range(self.population_size):\n                    mutated_population[j, :] = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.uniform(0, 1, self.dim)\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], mutated_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Probabilistic Mutation\" algorithm for black box optimization.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"cannot access local variable 'mutated_population' where it is not associated with a value\").", "error": "UnboundLocalError(\"cannot access local variable 'mutated_population' where it is not associated with a value\")", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "049334f0-d2d8-433e-9864-62ea095011d9", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_prob = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            fitness = np.array([func(x) for x in population])\n            best_individual = population[np.argmin(fitness)]\n\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Adaptive mutation\n            mutated_population = []\n            for individual in population:\n                if np.random.rand() < self.mutation_prob:\n                    mutated_individual = individual + np.random.uniform(-1, 1, self.dim)\n                    mutated_population.append(mutated_individual)\n                else:\n                    mutated_population.append(individual)\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], mutated_population[np.argsort(fitness)]))\n\n        best_x = population[np.argmin(fitness)]\n        return best_x\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with adaptive mutation and probability adjustment.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('only integer scalar arrays can be converted to a scalar index').", "error": "TypeError('only integer scalar arrays can be converted to a scalar index')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "46018bcb-b659-449c-ae0c-a3a87727e613", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Probabilistic mutation\n            if np.random.rand() < 0.1:\n                mutation_index = np.random.choice(self.population_size, size=self.dim, replace=False)\n                population[mutation_index] += np.random.uniform(-1, 1, size=self.dim)\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm for black box optimization with probabilistic mutation.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "5be30364-6c17-4763-9feb-bec86de4ac12", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.refine_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Refine best individual with 10% probability\n            if np.random.rand() < self.refine_probability:\n                best_individual = best_individual + self.adaptive_step_size * np.random.uniform(-0.1, 0.1, (1, self.dim))\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm for black box optimization with refinement probability.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "9f1b98e7-6299-4257-a0ed-850a75c1db82", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.change_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Change individual lines with probability 10%\n            if np.random.rand() < self.change_probability:\n                for j in range(self.population_size):\n                    new_individual = new_population[j]\n                    for k in range(self.dim):\n                        if np.random.rand() < 0.1:\n                            new_individual[k] = np.random.uniform(self.lower_bound, self.upper_bound)\n                    new_population[j] = new_individual\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm for black box optimization with 10% probability of changing individual lines.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "595199c1-48f6-4a0a-9b4e-073baadef90f", "solution": "import numpy as np\nimport random\nimport time\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.line_search_probability = 0.1\n        self.line_search_step_size = 0.01\n        self.line_search_max_iter = 10\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Line search\n            if np.random.rand() < self.line_search_probability:\n                line_search_start = time.time()\n                best_individual = self.line_search(best_individual, func, self.line_search_step_size, self.line_search_max_iter)\n                print(f\"Line search took {time.time() - line_search_start} seconds\")\n                if np.isnan(best_individual).any():\n                    break\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n    def line_search(self, individual, func, step_size, max_iter):\n        best_individual = individual\n        best_fitness = func(best_individual)\n        for _ in range(max_iter):\n            new_individual = best_individual + step_size * np.sign(np.random.uniform(-1, 1, self.dim))\n            new_fitness = func(new_individual)\n            if new_fitness < best_fitness:\n                best_individual = new_individual\n                best_fitness = new_fitness\n        return best_individual\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Line Search\" algorithm for black box optimization.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 67 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 67 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "b0f1dadb-e122-40c4-be3a-558cd82c84ff", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Refine strategy with 10% probability\n            if np.random.rand() < 0.1:\n                for j in range(self.population_size):\n                    x = population[j]\n                    new_x = x + np.random.uniform(-0.5, 0.5, self.dim)\n                    new_x = np.clip(new_x, self.lower_bound, self.upper_bound)\n                    population[j] = new_x\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm for black box optimization.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 88 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 88 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "029d69d2-488c-4bf1-8b76-67e81db57f22", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.line_search_prob = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Line search\n            if np.random.rand() < self.line_search_prob:\n                # Evaluate function at best individual\n                f_best = func(best_individual)\n\n                # Generate new population with line search\n                new_population = np.array([best_individual + self.adaptive_step_size * np.random.uniform(-1, 1, (1, self.dim)) for _ in range(self.population_size)])\n\n                # Replace worst individual with best individual\n                population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Line Search\" algorithm for black box optimization.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "3db438e1-c338-4f33-97fc-8febce8717a8", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.mutation_probability = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Mutation\n            mutation_mask = np.random.rand(self.population_size, self.dim) < self.mutation_probability\n            new_population[mutation_mask] += np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Mutation Probability\" algorithm for black box optimization.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (103,) (100,10) (103,) ').", "error": "ValueError('operands could not be broadcast together with shapes (103,) (100,10) (103,) ')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "9bb30c43-f02d-4407-8c10-6c02556d05a1", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Line mutation with 10% probability\n            if np.random.rand() < 0.1:\n                mutated_indices = np.random.choice(self.population_size, size=self.dim, replace=False)\n                new_population[mutated_indices] = population[mutated_indices] + np.random.uniform(-1, 1, (self.dim,))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm for black box optimization with 10% probability of line mutation.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 86 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 86 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "b8aad753-9a2a-487e-ac72-0b31d29e388b", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.refine_probability = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Refine the best individual with probability 0.1\n            if np.random.rand() < self.refine_probability:\n                best_individual = self.refine_individual(best_individual, func, self.lower_bound, self.upper_bound)\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n    def refine_individual(self, individual, func, lower_bound, upper_bound):\n        # Perform line search to find the optimal value\n        step_size = 0.1\n        while True:\n            new_individual = individual + step_size * np.sign(individual)\n            if func(new_individual) < func(individual):\n                individual = new_individual\n            else:\n                step_size *= 0.9\n                if step_size < 0.01:\n                    break\n\n        # Ensure the individual stays within the bounds\n        individual = np.clip(individual, lower_bound, upper_bound)\n\n        return individual\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Line Search\" algorithm for black box optimization with probability-based refinement.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "f6fceed1-6ae8-4dda-8083-bb26947e9683", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.refine_prob = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Refine strategy with probability\n            if np.random.rand() < self.refine_prob:\n                for j in range(self.population_size):\n                    new_individual = population[j] + np.random.uniform(-1, 1, self.dim)\n                    if np.random.rand() < 0.5:\n                        new_individual = new_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                    population[j] = new_individual\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with probability refinement.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 75 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 75 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "2e2a6d08-a6a4-4759-8450-a1abfb3d8cb2", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.mutation_probability = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        for i in range(self.budget):\n            fitness = np.array([func(x) for x in population])\n            best_individual = population[np.argmin(fitness)]\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n            for j in range(self.population_size):\n                if np.random.rand() < self.mutation_probability:\n                    mutation = np.random.uniform(-1, 1, self.dim)\n                    new_population[j] += mutation\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Mutation Probability\" algorithm for black box optimization.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "bc70e173-0d50-42bd-9684-95d1854d9122", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.mutation_probability = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        for i in range(self.budget):\n            fitness = np.array([func(x) for x in population])\n            best_individual = population[np.argmin(fitness)]\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n            for j in range(self.population_size):\n                if np.random.rand() < self.mutation_probability:\n                    new_population[j] += np.random.uniform(-1, 1, self.dim)\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Mutation Probability\" algorithm for black box optimization.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 66 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 66 is out of bounds for axis 0 with size 50')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "cc0bf9c1-3e2b-4af8-84dc-90eb2e7059a8", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_prob = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Mutation\n            for j in range(self.population_size):\n                if np.random.rand() < self.mutation_prob:\n                    new_individual = population[j]\n                    for k in range(self.dim):\n                        new_individual[k] += np.random.uniform(-1, 1)\n                    new_individual = np.clip(new_individual, self.lower_bound, self.upper_bound)\n                    population[j] = new_individual\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size and Population Size\" algorithm with 10% probability of line mutation.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
{"id": "74201326-8f7e-4522-af33-ea5257b3051a", "solution": "import numpy as np\nimport random\n\nclass DEASPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.adaptive_step_size = 0.5\n        self.adaptive_population_size = 0.5\n        self.adaptive_probability = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        for i in range(self.budget):\n            # Calculate fitness values\n            fitness = np.array([func(x) for x in population])\n\n            # Select best individual\n            best_individual = population[np.argmin(fitness)]\n\n            # Create new population\n            new_population = population + self.adaptive_step_size * np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            # Adaptive population size\n            if np.random.rand() < self.adaptive_population_size:\n                new_population = new_population[:int(self.population_size * self.adaptive_population_size)]\n\n            # Replace worst individual with best individual\n            population[np.argsort(fitness)] = np.concatenate((population[np.argsort(fitness)], new_population[np.argsort(fitness)]))\n\n            # Refine strategy by changing individual lines with a probability of 0.1\n            if np.random.rand() < self.adaptive_probability:\n                for j in range(self.population_size):\n                    if np.random.rand() < 0.1:\n                        new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                        population[j] = new_individual\n\n        # Return best individual\n        return population[np.argmin(fitness)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nde = DEASPS(budget=100, dim=10)\nbest_x = de(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "DEASPS", "description": "Novel \"Differential Evolution with Adaptive Step Size, Population Size, and Probability\" algorithm for black box optimization.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)').", "error": "ValueError('shape mismatch: value array of shape (200,10) could not be broadcast to indexing result of shape (100,10)')", "parent_id": "e3aa0b85-071c-4141-8ef5-6b710d507b3f", "metadata": {}, "mutation_prompt": null}
