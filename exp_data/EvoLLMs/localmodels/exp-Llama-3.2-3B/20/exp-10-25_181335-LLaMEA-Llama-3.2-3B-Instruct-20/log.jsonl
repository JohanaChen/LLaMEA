{"id": "ded3874e-bc20-4a35-9648-37685ac68861", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" (SEEA) with dimensionality adaptation.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 70, in <module>\nTypeError: 'SEEA' object is not callable\n.", "error": "TypeError(\"'SEEA' object is not callable\")Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 70, in <module>\nTypeError: 'SEEA' object is not callable\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "c3fab358-5534-401e-ad60-9423b6fbc092", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_prob = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.refine_prob:\n                parent1, parent2 = random.sample(population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                new_population.append(child)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic refinement.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "23e73499-e30a-4c5f-a3fb-1c258b1e31f2", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x, prob=0.2):\n        new_x = x.copy()\n        for i in range(self.dim):\n            if random.random() < prob:\n                new_x[i] += np.random.uniform(-1, 1)\n                new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n        return new_x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "849d6fb4-00fd-4453-8d75-9091d56cc3ea", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refinement_rate = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        refined_population = []\n        for individual in population:\n            if random.random() < self.refinement_rate:\n                for i in range(self.dim):\n                    individual[i] += np.random.uniform(-0.1, 0.1)\n                    individual[i] = np.clip(individual[i], self.lower_bound, self.upper_bound)\n            refined_population.append(individual)\n        return refined_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and refinement.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "55af49cc-dad1-4537-8124-5e6d65a457a8", "solution": "import numpy as np\nimport random\nimport time\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population, func):\n        refined_population = []\n        for individual in population:\n            # Refine the individual by changing 20% of its lines\n            refined_individual = individual.copy()\n            for i in range(self.dim):\n                if random.random() < 0.2:\n                    refined_individual[i] = func(refined_individual)\n            refined_population.append(refined_individual)\n        return refined_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.refine(population, func)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and refinement", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "413fe6e9-1659-4c58-b14d-042b8981cd0f", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_prob = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < self.refine_prob:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\ndef main():\n    def func(x):\n        return np.sum(x ** 2)\n\n    seea = SEEA(budget=100, dim=10)\n    best = seea(func)\n    print(f'Best Solution: {best}')\n\nif __name__ == \"__main__\":\n    main()", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probability-based mutation refinement.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "36c4ac1a-1021-4bef-a44e-148a76191f99", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            if random.random() < self.refine_probability:\n                # Refine the child by changing individual lines with probability 0.2\n                for i in range(self.dim):\n                    if random.random() < 0.2:\n                        child[i] = parent1[i]\n                child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        # Refine the population by changing individual lines with probability 0.2\n        refined_population = []\n        for x in population:\n            new_x = x.copy()\n            for i in range(self.dim):\n                if random.random() < 0.2:\n                    new_x[i] = x[i]\n            refined_population.append(new_x)\n        return refined_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.refine(population)\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probability-based refinement.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "fa377354-5f38-43ed-bdfe-2b2ffc17c9c9", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refinement_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.refinement_probability:\n                new_individual = individual + np.random.uniform(-1, 1, self.dim)\n                new_individual = np.clip(new_individual, self.lower_bound, self.upper_bound)\n                new_population.append(new_individual)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic refinement.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "c7990eaf-61ab-4273-8bbd-3302b1bf8c95", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < self.mutation_probability:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" (SEEA) with dimensionality adaptation and adaptive mutation probability", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "851dd989-1a8d-4902-a354-fb77fe249d41", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        refined_population = []\n        for individual in population:\n            if random.random() < 0.2:\n                i = random.randint(0, self.dim-1)\n                individual[i] += np.random.uniform(-1, 1)\n                individual[i] = np.clip(individual[i], self.lower_bound, self.upper_bound)\n            refined_population.append(individual)\n        return refined_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic refinement.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "19e4c5cc-4137-46c2-917f-fa67c523c8a1", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < 0.2:\n                index = np.random.randint(0, self.dim)\n                new_individual = individual.copy()\n                new_individual[index] = np.random.uniform(self.lower_bound, self.upper_bound)\n                new_population.append(new_individual)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and refinement.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "cc2b6619-2354-405e-94b6-6f9d14c51ca0", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_prob = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        mutated = np.zeros_like(x)\n        for i in range(self.dim):\n            if random.random() < self.mutation_prob:\n                mutated[i] = x[i] + np.random.uniform(-1, 1)\n                mutated[i] = np.clip(mutated[i], self.lower_bound, self.upper_bound)\n        return mutated\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation refinement.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "79f4d40d-9ece-4732-8deb-41f6dff6f5ce", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refinement_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        refined_population = []\n        for individual in population:\n            if random.random() < self.refinement_probability:\n                parent1, parent2 = random.sample(population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                refined_population.append(child)\n            else:\n                refined_population.append(individual)\n        return refined_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probability-based refinement.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "7bb80303-fd96-45b8-907c-7b733a89b917", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        mutated_individual = x.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                mutated_individual[i] += np.random.uniform(-1, 1)\n                mutated_individual[i] = np.clip(mutated_individual[i], self.lower_bound, self.upper_bound)\n        return mutated_individual\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "77568230-99b0-49c6-a9d2-55cf93d9a466", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_prob = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.refine_prob:\n                parent1, parent2 = random.sample(population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                new_population.append(child)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and mutation strategy refinement.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "302668a6-d380-445d-9f90-3970fffeacf8", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population, probability):\n        refined_population = []\n        for individual in population:\n            if random.random() < probability:\n                # Refine the individual by changing one line at a time\n                # with a probability of 0.2\n                i = random.randint(0, self.dim - 1)\n                new_individual = np.copy(individual)\n                new_individual[i] += np.random.uniform(-1, 1)\n                new_individual[i] = np.clip(new_individual[i], self.lower_bound, self.upper_bound)\n                refined_population.append(new_individual)\n            else:\n                refined_population.append(individual)\n        return refined_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population, 0.2)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" (SEEA) with dimensionality adaptation and probability-based refinement.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "2269603b-cbdd-474d-88be-ca1e6a0c8ad1", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refinement_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.refinement_probability:\n                # Randomly select two parent individuals\n                parent1, parent2 = random.sample(population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                new_population.append(child)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and line-by-line probability refinement.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "b5b5dc58-97a0-4078-ad75-c9ca5ca73fb6", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        mutation_prob = 0.2\n        for i in range(self.dim):\n            if random.random() < mutation_prob:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "072ac9f3-09f6-4205-a4c4-25a9d8cd488e", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_prob = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.refine_prob:\n                i = np.random.randint(0, self.dim)\n                new_individual = individual.copy()\n                new_individual[i] += np.random.uniform(-0.5, 0.5)\n                new_individual = np.clip(new_individual, self.lower_bound, self.upper_bound)\n                new_population.append(new_individual)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.refine(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic refinement.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "faaf1b31-26f9-4ae4-ad8a-cc4b4c7402c5", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        refined_population = []\n        for individual in population:\n            if random.random() < 0.2:\n                refined_individual = individual + np.random.uniform(-1, 1, self.dim)\n                refined_individual = np.clip(refined_individual, self.lower_bound, self.upper_bound)\n                refined_population.append(refined_individual)\n            else:\n                refined_population.append(individual)\n        return refined_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic refinement", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "ace68531-cd67-4642-8708-4b368a033222", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_prob = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.refine_prob:\n                parent1, parent2 = random.sample(population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                new_population.append(child)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" (SEEA) with dimensionality adaptation and probabilistic refinement.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "5723008f-93c5-4398-a1a4-2ffc8542c3c8", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        refined_population = []\n        for individual in population:\n            if random.random() < 0.2:\n                i = random.randint(0, self.dim - 1)\n                individual[i] += np.random.uniform(-1, 1)\n                individual[i] = np.clip(individual[i], self.lower_bound, self.upper_bound)\n            refined_population.append(individual)\n        return refined_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.refine(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and refinement.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "76e68e74-5888-49f8-b140-6b7be019c283", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_prob = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.refine_prob:\n                i = random.randint(0, self.dim - 1)\n                new_individual = individual.copy()\n                new_individual[i] += np.random.uniform(-1, 1)\n                new_individual = np.clip(new_individual, self.lower_bound, self.upper_bound)\n                new_population.append(new_individual)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.refine(population)\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" (SEEA) with dimensionality adaptation and probabilistic refinement.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "f7bf1002-63d7-4633-a6ac-524ad66d1493", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_prob = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutate(self, x):\n        new_x = x.copy()\n        for i in range(self.dim):\n            if random.random() < self.mutation_prob:\n                new_x[i] += np.random.uniform(-1, 1)\n                new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n        return new_x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutate(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "3f8a03e7-3a0e-4295-9243-b0154adf3625", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refinement_prob = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            if random.random() < self.refinement_prob:\n                child = self.refine(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, x):\n        new_x = x.copy()\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                new_x[i] += np.random.uniform(-0.1, 0.1)\n                new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n        return new_x\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic refinement.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "41d16e65-0eda-4605-8754-0bd144a64d10", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_rate = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.mutation_rate:\n                individual = self.mutation(individual)\n            new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and mutation refinement.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "1dc93e82-6c64-4707-97ae-1c0000e6c48a", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            if random.random() < self.refine_probability:\n                child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.refine_probability:\n                index = random.randint(0, self.dim - 1)\n                new_individual = individual.copy()\n                new_individual[index] += np.random.uniform(-1, 1)\n                new_individual[index] = np.clip(new_individual[index], self.lower_bound, self.upper_bound)\n                new_population.append(new_individual)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.refine(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probability refinement.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "7c763407-b6b5-44b4-8c9b-f3e6d7a1303e", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        refined_population = []\n        for individual in population:\n            if random.random() < 0.2:\n                refined_individual = individual.copy()\n                for i in range(self.dim):\n                    refined_individual[i] += np.random.uniform(-0.1, 0.1)\n                    refined_individual[i] = np.clip(refined_individual[i], self.lower_bound, self.upper_bound)\n                refined_population.append(refined_individual)\n            else:\n                refined_population.append(individual)\n        return refined_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic refinement.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "f595c721-c337-42ea-8665-656d7b755a4f", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        refined_population = []\n        for individual in population:\n            for i in range(self.dim):\n                if random.random() < 0.2:\n                    individual[i] += np.random.uniform(-0.1, 0.1)\n                    individual[i] = np.clip(individual[i], self.lower_bound, self.upper_bound)\n            refined_population.append(individual)\n        return refined_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.refine(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic refinement", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "6c797f7a-f1eb-401a-a46f-c4b60599f2f1", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < 0.2:\n                index = np.random.randint(0, self.dim)\n                individual[index] += np.random.uniform(-1, 1)\n                individual = np.clip(individual, self.lower_bound, self.upper_bound)\n            new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation refinement.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "3f03ee6c-c207-4bd5-a298-ff8eab7d0a97", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_prob = 0.1\n        self.mutation_step = 0.1\n        self.adaptation_prob = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < self.mutation_prob:\n                x[i] += np.random.uniform(-self.mutation_step, self.mutation_step)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def adapt(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            if random.random() < self.adaptation_prob:\n                parent1, parent2 = random.sample(population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                new_population.append(child)\n            else:\n                parent = random.choice(population)\n                child = parent\n                new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.adapt(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and mutation probability adjustment.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "9eebef61-d605-4a96-9b05-bfe2d8beb0be", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation refinement.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "44b02fe3-88b6-4946-b163-417c48048612", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n    def optimize(self, func):\n        def line_search(x):\n            return minimize(func, x, method=\"SLSQP\", bounds=[(self.lower_bound, self.upper_bound)] * self.dim)\n\n        for _ in range(self.population_size):\n            individual = self.population[_]\n            result = line_search(individual)\n            new_individual = result.x\n            new_individual = self.mutation(new_individual)\n            new_individual = self.crossover(new_individual, individual)\n            new_individual = np.clip(new_individual, self.lower_bound, self.upper_bound)\n            self.population[_] = new_individual\n        return min(self.population, key=self.evaluate)\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea.optimize(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and line search optimization.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "64c561f7-27ce-4ad1-9838-e41e6ee3c018", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refinement_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            if random.random() < self.refinement_probability:\n                child = self.refine(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, x):\n        new_x = x.copy()\n        for i in range(self.dim):\n            if random.random() < 0.2:\n                new_x[i] += np.random.uniform(-0.1, 0.1)\n                new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n        return new_x\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and refinement probability.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "cbab2f28-ab37-4103-87a9-f7cd851a363c", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        mutation_prob = 0.2\n        for i in range(self.dim):\n            if random.random() < mutation_prob:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation refinement", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "fc83cb94-77c1-42b3-834f-7b512b8420b3", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n    def line_search(self, func, x0, bounds):\n        res = minimize(lambda x: func(x), x0, method='SLSQP', bounds=bounds)\n        return res.x\n\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea.run(func)\nprint(f'Best Solution: {best}')\n\n# To refine the strategy, we can use the line search method to find the optimal solution\n# We will randomly select 20% of the individuals and use the line search method to refine their strategy\nrefined_population = []\nfor i in range(int(0.2 * seea.population_size)):\n    individual = seea.population[i]\n    refined_individual = seea.line_search(func, individual, [(self.lower_bound, self.upper_bound) for _ in range(seea.dim)])\n    refined_population.append(refined_individual)\n\n# We will use the refined population to replace the original population\nseea.population = refined_population\n\nbest = seea.run(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and line search.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"cannot access local variable 'best' where it is not associated with a value\").", "error": "UnboundLocalError(\"cannot access local variable 'best' where it is not associated with a value\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "90b4a215-8cde-4167-a79e-0c4f06ea4497", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refinement_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < self.refinement_probability:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.refinement_probability:\n                parent1, parent2 = random.sample(population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                new_population.append(child)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation refinement.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "47347563-3193-4faf-b2f4-9e3f740df76a", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.refine_probability:\n                i = np.random.randint(0, self.dim)\n                j = np.random.randint(0, self.dim)\n                new_individual = individual.copy()\n                new_individual[i], new_individual[j] = new_individual[j], new_individual[i]\n            new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probability-based refinement.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "5aadc137-57c8-4f74-a90b-f622fe21504a", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        mutated_x = x.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                mutated_x[i] += np.random.uniform(-1, 1)\n                mutated_x[i] = np.clip(mutated_x[i], self.lower_bound, self.upper_bound)\n        return mutated_x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation refinement", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "76d1b813-b574-416e-b802-76d78f4f7257", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < 0.2:\n                index = np.random.randint(0, self.dim)\n                new_individual = individual.copy()\n                new_individual[index] += np.random.uniform(-1, 1)\n                new_individual = np.clip(new_individual, self.lower_bound, self.upper_bound)\n                new_population.append(new_individual)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probability-based refinement.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "f70f453e-5b1f-4e97-a2f1-02500382d3e3", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refinement_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.refinement_probability:\n                parent1, parent2 = random.sample(population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                new_population.append(child)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and refinement probability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "68fd9b71-7230-47ba-8b16-4773348481f9", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refinement_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.refinement_probability:\n                parent1, parent2 = random.sample(population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                new_population.append(child)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" (SEEA) with dimensionality adaptation and probabilistic refinement.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "8c1d1561-ecc0-4c93-9cd7-a473933b88a6", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population, func):\n        refined_population = []\n        for individual in population:\n            if random.random() < 0.2:\n                i = np.random.randint(0, self.dim)\n                individual[i] += np.random.uniform(-1, 1)\n                individual[i] = np.clip(individual[i], self.lower_bound, self.upper_bound)\n            refined_population.append(individual)\n        return refined_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.refine(population, func)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic refinement", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "e3ece433-f94b-4615-8550-556cb1e1da22", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_prob = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            if random.random() < self.refine_prob:\n                parent1, parent2 = random.sample(population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n            else:\n                child = random.choice(population)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        refined_population = []\n        for individual in population:\n            if random.random() < self.refine_prob:\n                parent1, parent2 = random.sample(population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n            refined_population.append(child)\n        return refined_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            if self.budget <= generation * self.dim:\n                break\n            if generation % 10 == 0:\n                population = self.refine(population)\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic refinement", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "289356b8-417c-4122-b61c-e11b991449af", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population, func):\n        refined_population = []\n        for individual in population:\n            for i in range(self.dim):\n                if random.random() < 0.2:\n                    new_individual = individual.copy()\n                    new_individual[i] += np.random.uniform(-0.1, 0.1)\n                    new_individual = np.clip(new_individual, self.lower_bound, self.upper_bound)\n                    refined_population.append(new_individual)\n                    break\n        return refined_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.refine(population, func)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic refinement.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "84f56ec7-c91b-4826-8429-9bc1e0ec8aef", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_rate = 0.1\n        self.selection_rate = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n    def refine(self, population):\n        refined_population = []\n        for individual in population:\n            if random.random() < self.selection_rate:\n                parent1, parent2 = random.sample(population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                refined_population.append(child)\n            else:\n                refined_population.append(individual)\n        return refined_population\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea.run(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" (SEEA) with dimensionality adaptation and adaptive mutation.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"cannot access local variable 'best' where it is not associated with a value\").", "error": "UnboundLocalError(\"cannot access local variable 'best' where it is not associated with a value\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "bf592b4b-a712-4b9c-a64b-684f4a49ed9c", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        mutated = x.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                mutated[i] += np.random.uniform(-1, 1)\n                mutated[i] = np.clip(mutated[i], self.lower_bound, self.upper_bound)\n        return mutated\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "f4de7910-6e76-4b6b-bff7-680766b960e9", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.refine_probability:\n                i = random.randint(0, self.dim - 1)\n                new_individual = np.copy(individual)\n                new_individual[i] += np.random.uniform(-1, 1)\n                new_individual[i] = np.clip(new_individual[i], self.lower_bound, self.upper_bound)\n                new_population.append(new_individual)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic refinement.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "cd14aa22-f0a1-45fd-bc43-af21647c0441", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            if random.random() < self.refine_probability:\n                # Refine the child with 20% probability\n                child = self.refine_child(child)\n            new_population.append(child)\n        return new_population\n\n    def refine_child(self, child):\n        # Refine the child by changing 20% of its lines\n        refined_child = child.copy()\n        for i in range(self.dim):\n            if random.random() < 0.2:\n                refined_child[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        return refined_child\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probability-based refinement.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "dbc9ffa2-0c3c-460a-be43-77e724488b8e", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        refined_population = []\n        for individual in population:\n            if random.random() < 0.2:\n                # Refine the individual by changing one of its lines\n                i = random.randint(0, self.dim - 1)\n                individual[i] += np.random.uniform(-1, 1)\n                individual[i] = np.clip(individual[i], self.lower_bound, self.upper_bound)\n                refined_population.append(individual)\n            else:\n                refined_population.append(individual)\n        return refined_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.refine(population)\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and refinement.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "84d38420-1e98-4d38-aade-f60af5b2f3e9", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refinement_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            if random.random() < self.refinement_probability:\n                child = self.refine(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, individual):\n        refinement_indices = np.random.choice(self.dim, size=5, replace=False)\n        for i in refinement_indices:\n            individual[i] += np.random.uniform(-0.1, 0.1)\n            individual[i] = np.clip(individual[i], self.lower_bound, self.upper_bound)\n        return individual\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and refinement.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "ec976a20-4909-438a-8387-8eaeef16b42c", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < 0.2:\n                index = np.random.randint(0, self.dim)\n                individual[index] += np.random.uniform(-1, 1)\n                individual = np.clip(individual, self.lower_bound, self.upper_bound)\n            new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic refinement.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "bff692e2-2085-47af-afa0-b59ac5103944", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < 0.2:\n                for i in range(self.dim):\n                    individual[i] += np.random.uniform(-1, 1)\n                    individual[i] = np.clip(individual[i], self.lower_bound, self.upper_bound)\n            new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" (SEEA) with dimensionality adaptation and refinement.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "36486608-276e-474d-9091-6ebbe0d0583d", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population, func):\n        new_population = []\n        for individual in population:\n            if random.random() < 0.2:\n                # Refine the individual by perturbing its coordinates\n                refined_individual = individual + np.random.uniform(-0.1, 0.1, size=self.dim)\n                refined_individual = np.clip(refined_individual, self.lower_bound, self.upper_bound)\n                new_population.append(refined_individual)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.refine(population, func)\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic refinement", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "8e5c0437-35f8-422c-a960-2a72c796874e", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x, prob):\n        for i in range(self.dim):\n            if random.random() < prob:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population, prob):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child, prob)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population, prob=0.2)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probability-based mutation.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "4f6b9378-1772-4862-a989-b06b6d040fb4", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_prob = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < self.mutation_prob:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "f64bade3-07c4-4118-b3eb-221bd2079dce", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_rate = 0.1\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        mutated_x = x.copy()\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                mutated_x[i] += np.random.uniform(-1, 1)\n                mutated_x[i] = np.clip(mutated_x[i], self.lower_bound, self.upper_bound)\n        return mutated_x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine_strategy(self, population):\n        refined_population = []\n        for individual in population:\n            if random.random() < 0.2:\n                i = np.random.randint(0, self.dim)\n                individual[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            refined_population.append(individual)\n        return refined_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.refine_strategy(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and mutation refinement", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "718e67b3-928d-43ce-b968-ca9f28730d22", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_prob = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < self.mutation_prob:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probability-based mutation.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "afadda99-1795-4b5f-bb3e-55e8e4858c2f", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "6a0bc316-ce6e-4ed1-a7dd-a065141e48ae", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.refine_probability:\n                parent1, parent2 = random.sample(population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                new_population.append(child)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic refinement.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "1654d541-6cf8-475c-a425-247c921cd270", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probability-based mutation.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "4c596d34-324a-4bb5-9d24-19a12939c14b", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            if random.random() < self.refine_probability:\n                child = self.refine(child, parent1, parent2)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, child, parent1, parent2):\n        for i in range(self.dim):\n            if random.random() < 0.2:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and refinement probability.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "55abc435-fc15-49d2-8080-e42214f60bae", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\nclass ProbabilisticSEEA(SEEA):\n    def __init__(self, budget, dim):\n        super().__init__(budget, dim)\n\n    def mutation(self, x):\n        mutated = np.zeros_like(x)\n        for i in range(self.dim):\n            if random.random() < 0.2:\n                mutated[i] = x[i] + np.random.uniform(-1, 1)\n                mutated[i] = np.clip(mutated[i], self.lower_bound, self.upper_bound)\n        return mutated\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nprob_seea = ProbabilisticSEEA(budget=100, dim=10)\nbest = prob_seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'ProbabilisticSEEA' object is not callable\").", "error": "TypeError(\"'ProbabilisticSEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "77bd1399-a0d4-4e20-8669-d958e2911ab1", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refinement_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.refinement_probability:\n                new_individual = individual + np.random.uniform(-1, 1, self.dim)\n                new_individual = np.clip(new_individual, self.lower_bound, self.upper_bound)\n                new_population.append(new_individual)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.refine(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and refinement probability.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "c49a0334-26cd-4bca-b4ae-abed37055380", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x, prob=0.2):\n        for i in range(self.dim):\n            if random.random() < prob:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "1e1c007a-00a5-4564-af38-341f0bc7a7fe", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < 0.2:\n                new_individual = individual + np.random.uniform(-1, 1, self.dim)\n                new_individual = np.clip(new_individual, self.lower_bound, self.upper_bound)\n                new_population.append(new_individual)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic refinement.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "6903475b-c03a-445a-a69f-db68cf00fa02", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population, func):\n        new_population = []\n        for individual in population:\n            if random.random() < 0.2:\n                new_individual = individual + np.random.uniform(-0.5, 0.5, self.dim)\n                new_individual = np.clip(new_individual, self.lower_bound, self.upper_bound)\n                new_population.append(new_individual)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.refine(population, func)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" (SEEA) with dimensionality adaptation and probabilistic mutation.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "b1a29c1a-d5de-4bfd-9fa7-188029f64ffd", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_rate = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        new_x = x.copy()\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                new_x[i] += np.random.uniform(-1, 1)\n                new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n        return new_x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine_strategy(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.mutation_rate:\n                new_individual = individual.copy()\n                for i in range(self.dim):\n                    if random.random() < 0.5:\n                        new_individual[i] = individual[i]\n                    else:\n                        new_individual[i] = individual[i] + np.random.uniform(-1, 1)\n                        new_individual[i] = np.clip(new_individual[i], self.lower_bound, self.upper_bound)\n                new_population.append(new_individual)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine_strategy(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation refinement.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "eaa4b1ef-894c-47aa-b40c-d2ab65a58990", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        refined_population = []\n        for individual in population:\n            if random.random() < 0.2:\n                index = np.random.randint(0, self.dim)\n                individual[index] += np.random.uniform(-0.1, 0.1)\n                individual = np.clip(individual, self.lower_bound, self.upper_bound)\n            refined_population.append(individual)\n        return refined_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probability-based refinement.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "5ae8c1a0-b744-4a41-85f1-82074ec601a7", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            if random.random() < self.refine_probability:\n                child = self.refine(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, x):\n        new_x = x.copy()\n        for i in range(self.dim):\n            if random.random() < 0.2:\n                new_x[i] += np.random.uniform(-0.5, 0.5)\n                new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n        return new_x\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic refinement.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "8b8ba1bb-e754-418b-9ad4-80155ec3f671", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        refined_population = []\n        for individual in population:\n            if random.random() < self.refine_probability:\n                refined_individual = individual + np.random.uniform(-0.1, 0.1, size=self.dim)\n                refined_individual = np.clip(refined_individual, self.lower_bound, self.upper_bound)\n                refined_population.append(refined_individual)\n            else:\n                refined_population.append(individual)\n        return refined_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and refinement.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "144abf4f-1c41-4280-9b35-9a58ecf2b47e", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.refine_probability:\n                new_individual = individual.copy()\n                for i in range(self.dim):\n                    if random.random() < 0.5:\n                        new_individual[i] += np.random.uniform(-0.1, 0.1)\n                        new_individual[i] = np.clip(new_individual[i], self.lower_bound, self.upper_bound)\n                new_population.append(new_individual)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic refinement.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "6918b0d8-d957-40f8-891b-74b76e02dc4e", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "2aaec5e9-24f2-4888-b404-83ce84c3960c", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.refine_probability:\n                # Refine the individual by changing one of its lines\n                line = random.randint(0, self.dim - 1)\n                new_individual = np.copy(individual)\n                new_individual[line] += np.random.uniform(-0.1, 0.1)\n                new_individual = np.clip(new_individual, self.lower_bound, self.upper_bound)\n                new_population.append(new_individual)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probability-based refinement.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "c3cfb6e9-e914-4c3b-8a13-19829ba5acd5", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        mutation_rate = 0.2\n        for i in range(self.dim):\n            if random.random() < mutation_rate:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "01c83409-3643-4532-ab43-cce9929d995a", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            if random.random() < self.refine_probability:\n                child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.refine_probability:\n                parent1, parent2 = random.sample(population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                new_population.append(child)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation refinement.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "a73067e4-153b-4b4c-8500-88a7129d0434", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            if random.random() < self.refine_probability:\n                child = self.refine(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.2:\n                x[i] += np.random.uniform(-0.1, 0.1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and refinement probability.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "de9272ab-b9c1-431a-9b7c-dc5ee3c1b6ae", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < 0.2:\n                new_individual = individual + np.random.uniform(-0.5, 0.5, self.dim)\n                new_individual = np.clip(new_individual, self.lower_bound, self.upper_bound)\n                new_population.append(new_individual)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and refinement strategy", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "17c20f73-cd30-45c9-9a14-faa07fb32cad", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < 0.2:\n                new_individual = self.mutation(individual)\n                new_population.append(new_individual)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" (SEEA) with dimensionality adaptation and probabilistic mutation.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "36198704-c038-4221-bf85-e135f98e100c", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_strategy = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.refine_strategy:\n                parent1, parent2 = random.sample(population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                new_population.append(child)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and refinement strategy.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "2298fbd0-47ea-4227-9afc-41fd0def1ecd", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_rate = 0.1\n        self.refine_strategy = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def refine_strategy(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            if random.random() < self.refine_strategy:\n                child = self.enhance(child)\n            new_population.append(child)\n        return new_population\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine_strategy(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and mutation strategy refinement.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "75759d68-8e9d-4075-881e-18f2015da9c1", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        mutation_rate = 0.1\n        mutated = np.zeros_like(x)\n        for i in range(self.dim):\n            if random.random() < mutation_rate:\n                mutated[i] = x[i] + np.random.uniform(-1, 1)\n                mutated[i] = np.clip(mutated[i], self.lower_bound, self.upper_bound)\n        return mutated\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.refine_probability:\n                parent1, parent2 = random.sample(population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                new_population.append(child)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "1e776f25-a94f-458e-8787-d6ed918baf46", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < 0.2:\n                index = np.random.randint(0, self.dim)\n                individual[index] += np.random.uniform(-1, 1)\n                individual = np.clip(individual, self.lower_bound, self.upper_bound)\n            new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.refine(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and refinement.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "bcd15c40-fa61-42fd-9d18-2218feca870f", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.refine_probability:\n                i = random.randint(0, self.dim - 1)\n                new_individual = individual.copy()\n                new_individual[i] = random.uniform(self.lower_bound, self.upper_bound)\n                new_population.append(new_individual)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" (SEEA) with dimensionality adaptation and probabilistic refinement.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "ee043fc2-3deb-4aaf-9781-5ba495cb4906", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < 0.2:\n                new_individual = individual.copy()\n                for i in range(self.dim):\n                    new_individual[i] += np.random.uniform(-1, 1)\n                    new_individual[i] = np.clip(new_individual[i], self.lower_bound, self.upper_bound)\n                new_population.append(new_individual)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probability-based mutation refinement.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "9acf9c5d-d0d2-493c-90c8-40b2331bfc69", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_prob = 0.2\n        self.fitnesses = []\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        mutated = x.copy()\n        for i in range(self.dim):\n            if random.random() < self.mutation_prob:\n                mutated[i] += np.random.uniform(-1, 1)\n                mutated[i] = np.clip(mutated[i], self.lower_bound, self.upper_bound)\n        return mutated\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            self.fitnesses.append(self.evaluate(best))\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" (SEEA) with dimensionality adaptation and adaptive mutation probability.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "3d1491df-8ccf-4f4b-b16e-333f4ccc04a5", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x, prob=0.2):\n        for i in range(self.dim):\n            if random.random() < prob:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" (SEEA) with dimensionality adaptation and probabilistic mutation.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "4f007bee-30fe-4f71-87b2-153d542fb9a9", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        new_x = x.copy()\n        for i in range(self.dim):\n            if random.random() < self.mutation_probability:\n                new_x[i] += np.random.uniform(-1, 1)\n                new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n        return new_x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probability-based mutation.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "a463ceb4-e5f5-46cb-a4c8-81f1f460062e", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < 0.2:\n                for i in range(self.dim):\n                    individual[i] += np.random.uniform(-0.5, 0.5)\n                    individual[i] = np.clip(individual[i], self.lower_bound, self.upper_bound)\n            new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic refinement", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "fdb24985-f26a-401a-bec2-849959ac1d08", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population, func):\n        new_population = []\n        for individual in population:\n            for i in range(self.dim):\n                if random.random() < 0.2:\n                    new_individual = individual.copy()\n                    new_individual[i] = func(new_individual)\n                    new_population.append(new_individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.refine(population, func)\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation refinement", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "71c2098b-5c7b-48fd-a173-9e2af8101910", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_prob = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.refine_prob:\n                parent1, parent2 = random.sample(population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                new_population.append(child)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic refinement.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "2dd15d06-f804-409a-8b6d-81768d9946fc", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def refine(self, population):\n        new_population = []\n        for i in range(self.population_size):\n            if random.random() < self.refine_probability:\n                parent1, parent2 = random.sample(population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                new_population.append(child)\n            else:\n                new_population.append(population[i])\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and refinement.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "cb108753-abed-4b1b-b37a-5aad501a490a", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "623bf38f-fabf-4dfd-8780-707aaeee76c4", "solution": "import numpy as np\nimport random\nimport time\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < 0.2:\n                mutation = self.mutation(individual)\n                new_population.append(mutation)\n            else:\n                new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and refinement.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "d33006e2-58ad-4e12-b7d8-cbfc0f52ee6a", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_probability = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < self.mutation_probability:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and mutation probability adjustment.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "9b980204-f8f3-4882-833e-aba69361e632", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x, prob=0.2):\n        for i in range(self.dim):\n            if random.random() < prob:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "1d45cb1e-d6c5-4557-8e79-db6b75409438", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        mutated_x = x.copy()\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                mutated_x[i] += np.random.uniform(-1, 1)\n                mutated_x[i] = np.clip(mutated_x[i], self.lower_bound, self.upper_bound)\n        return mutated_x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine_strategy(self, population):\n        refined_population = []\n        for individual in population:\n            if random.random() < 0.2:\n                refined_individual = individual.copy()\n                for i in range(self.dim):\n                    refined_individual[i] += np.random.uniform(-1, 1)\n                    refined_individual[i] = np.clip(refined_individual[i], self.lower_bound, self.upper_bound)\n                refined_population.append(refined_individual)\n            else:\n                refined_population.append(individual)\n        return refined_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine_strategy(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation refinement.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "8030cf1a-3503-4552-ab3a-cdbeccddbd09", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_prob = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutate(self, x):\n        mutated = x.copy()\n        for i in range(self.dim):\n            if random.random() < self.mutation_prob:\n                mutated[i] += np.random.uniform(-1, 1)\n                mutated[i] = np.clip(mutated[i], self.lower_bound, self.upper_bound)\n        return mutated\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutate(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "3c149b5a-db9d-4353-b169-adadd7fbdbc0", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_prob = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutate(self, x):\n        new_x = x.copy()\n        for i in range(self.dim):\n            if random.random() < self.mutation_prob:\n                new_x[i] += np.random.uniform(-1, 1)\n                new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n        return new_x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutate(child)\n            new_population.append(child)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.enhance(population)\n            population = self.initialize_population()\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
{"id": "d19b035a-ace2-4ae4-bfbb-5cc200f6af2f", "solution": "import numpy as np\nimport random\n\nclass SEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_generations = int(budget / (self.population_size * self.dim))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_prob = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def fitness(self, x):\n        return np.sum(x ** 2)\n\n    def evaluate(self, x):\n        return self.fitness(x)\n\n    def selection(self, population):\n        fitnesses = np.array([self.evaluate(x) for x in population])\n        indices = np.argsort(fitnesses)\n        return population[indices]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros_like(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutation(self, x):\n        for i in range(self.dim):\n            if random.random() < self.mutation_prob:\n                x[i] += np.random.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def enhance(self, population):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            new_population.append(child)\n        return new_population\n\n    def refine(self, population):\n        new_population = []\n        for individual in population:\n            if random.random() < self.mutation_prob:\n                individual = self.mutation(individual)\n            new_population.append(individual)\n        return new_population\n\n    def run(self, func):\n        for generation in range(self.num_generations):\n            population = self.evaluate(self.population)\n            population = self.selection(population)\n            population = self.refine(population)\n            best = min(population, key=self.evaluate)\n            print(f'Generation {generation+1}, Best Fitness: {self.evaluate(best)}')\n            if self.budget <= generation * self.dim:\n                break\n        return best\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nseea = SEEA(budget=100, dim=10)\nbest = seea(func)\nprint(f'Best Solution: {best}')", "name": "SEEA", "description": "Novel \"Swarm-Enhanced Evolutionary Algorithm\" with dimensionality adaptation and probabilistic mutation refinement", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SEEA' object is not callable\").", "error": "TypeError(\"'SEEA' object is not callable\")", "parent_id": "ded3874e-bc20-4a35-9648-37685ac68861", "metadata": {}, "mutation_prompt": null}
