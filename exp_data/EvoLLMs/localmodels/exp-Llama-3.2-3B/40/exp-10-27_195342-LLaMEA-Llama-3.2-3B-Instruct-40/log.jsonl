{"id": "09585ecd-f20c-40eb-bc69-33bae392ab5c", "solution": "", "name": "", "description": "", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "No code was extracted.", "error": "", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "5b449c32-5735-414d-b00b-9663f253100e", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass PAHE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.search_space = (-5.0, 5.0)\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = {\n                'params': np.random.uniform(self.search_space[0], self.search_space[1], self.dim),\n                'fitness': self.evaluate_func(self.evaluate_func, individual['params'])\n            }\n            population.append(individual)\n        return population\n\n    def evaluate_func(self, func, params):\n        return func(params)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Select the best individual\n            best_individual = max(self.population, key=lambda x: x['fitness'])\n\n            # Refine the strategy of the best individual\n            if random.random() < 0.4:\n                for i in range(self.dim):\n                    new_param = random.uniform(self.search_space[0], self.search_space[1])\n                    if random.random() < 0.4:\n                        best_individual['params'][i] = new_param\n                    else:\n                        best_individual['params'][i] = best_individual['params'][i] + random.uniform(-0.1, 0.1)\n\n            # Evaluate the new individual\n            best_individual['fitness'] = self.evaluate_func(func, best_individual['params'])\n\n            # Replace the worst individual with the new one\n            self.population.remove(min(self.population, key=lambda x: x['fitness']))\n            self.population.append(best_individual)\n\n        return min(self.population, key=lambda x: x['fitness'])\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nbbo = PAHE(50, 5)\nbest_individual = bbo(func)\nprint(best_individual['params'])\nprint(best_individual['fitness'])", "name": "PAHE", "description": "Novel \"Probability-Adaptive Hyper-Evolution\" (PAHE) algorithm", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"cannot access local variable 'individual' where it is not associated with a value\").", "error": "UnboundLocalError(\"cannot access local variable 'individual' where it is not associated with a value\")", "parent_id": "09585ecd-f20c-40eb-bc69-33bae392ab5c", "metadata": {}, "mutation_prompt": null}
{"id": "302d9060-620b-45f0-baad-f471b9823cf0", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEA(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA", "description": "Novel \"Crossover-Elitism-Adaptation\" (CEA) algorithm combining crossover, elitism, and adaptation to handle black box optimization problems.", "configspace": "", "generation": 2, "fitness": 0.052038360132783686, "feedback": "The algorithm CEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "09585ecd-f20c-40eb-bc69-33bae392ab5c", "metadata": {"aucs": [0.11869729595922507, 0.08269555679369223, 0.11926173084520764, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.008239714075619298, 0.00869301372004283, 0.022587758990378126, 0.01959972157639278, 0.0004952459975243739, 0.018075393015621777, 0.014763392921912755, 9.999999999998899e-05, 0.010809199885924659, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.05834989649846811, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10171571102352206, 0.09141477819664201, 0.11830781833051607, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0017901386843400813, 0.0025712693283350685, 0.03498472865031821, 9.999999999998899e-05, 9.999999999998899e-05, 0.01037140587757679, 9.999999999998899e-05, 9.999999999998899e-05, 0.013100713419623156, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02685300756072151, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.1462019206317029, 0.20499761623267976, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.021941347472017703, 0.023244722697200237, 0.040846886701373264, 0.003871209781588947, 0.0267656688986897, 0.08921158065422274, 0.08609370886951351, 0.11842175776965747, 0.13309198542354084, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.09241484460435057, 0.10820985779664971, 0.10129103634474745, 0.1202975771402458, 0.1613932299901245, 0.1427520131297464, 0.1226705614457484, 0.12269294519270679, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.06158668998215977, 0.03973031259486837, 0.08398582550377798, 0.07631035699861244, 0.07412494361789612, 0.09305662202761156, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.13111992714980247, 0.14359556787874028, 0.13345086981233123, 0.14299902572704537, 0.11113182248826148, 0.12052665218506586, 0.13021107279712574, 0.11993135107376562, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 0.07646948265609277, 9.999999999998899e-05, 9.999999999998899e-05, 0.14565818743850145, 9.999999999998899e-05, 0.1373631695896611, 9.999999999998899e-05, 0.11038134831150948, 0.07634020855071688, 0.08167024703901915, 0.10240435520724822, 0.1207914665021157, 0.13425210128851683, 0.1070176662487543, 0.10511484148144368, 0.15289029317872027, 0.11040265245322212, 0.10299499138871093, 0.0830863240693972, 0.0506857903344724, 0.04676039199241877, 0.06300922594618863, 0.048891192759423774, 0.0681427037084803, 0.14076369017220147, 0.1581083475383993, 0.15067299874205797, 0.14763022729669195, 0.11744712740397156, 0.1420346514143146, 0.13233279814316334, 0.14969714796693134, 0.14289129437403425, 0.14689007985489466, 0.038841183226393294, 0.0213707687617265, 0.03318456582171292, 0.029654596881496964, 0.03425093938292756, 0.020045516730027746, 0.0375775881235646, 0.03803354422653826, 0.029147421371172877]}, "mutation_prompt": null}
{"id": "ed5ceb44-f7da-429e-a9ee-858bb9809db2", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability 0.6\n                if random.random() < 0.6:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEA(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA", "description": "Novel \"Crossover-Elitism-Adaptation\" (CEA) algorithm with probability-based adaptation, crossover, and elitism.", "configspace": "", "generation": 3, "fitness": 0.048979650281089, "feedback": "The algorithm CEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.08108763387163931, 0.12384636440412955, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018262387458650498, 0.007792397052521438, 0.010674738340807233, 0.005404401544452764, 9.999999999998899e-05, 0.006939000500792658, 0.01959972157639278, 0.0019419406320193566, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 0.004456688975062573, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10238370330215019, 0.08224659834595494, 0.060856901835361854, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03221885482478615, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0066120213208791245, 9.999999999998899e-05, 0.012073984825494932, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11250030360934071, 0.15756555760738078, 0.14838054695461433, 0.10429874127817562, 0.10274288241579344, 0.1000457065257877, 0.16112956940342849, 0.1276871071037332, 0.13189456368467978, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.003622744883443718, 0.01759993274736349, 0.02248417273798131, 9.999999999998899e-05, 0.0267656688986897, 0.08494000004272728, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.08099219012337167, 0.09547639303985456, 0.12714069366343228, 0.12142588519569275, 0.1613932299901245, 0.13800672315110074, 0.14114869629314764, 0.1250475082222352, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.03811708617901843, 0.08398582550377798, 0.0726934468825533, 0.06762764212849548, 0.07134632430318, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.11943364695601921, 0.11664162645046383, 0.13640603251606076, 0.12034323296813276, 0.11965320639006605, 0.14577675484819685, 0.13438231430858028, 0.11986925650232971, 0.13031627719881744, 9.999999999998899e-05, 0.11157336075743352, 9.999999999998899e-05, 9.999999999998899e-05, 0.11126827625257285, 9.999999999998899e-05, 9.999999999998899e-05, 0.10123737424921475, 9.999999999998899e-05, 0.08358953827291282, 0.10388324816980221, 0.08167024703901915, 0.07330865125621, 0.1207914665021157, 0.09872506323239982, 0.1070176662487543, 0.13200041734367263, 0.07677654869168204, 0.11040265245322212, 0.10267165755511809, 0.0706593224083959, 0.07089067966465323, 0.06644374373621542, 0.06560600126290683, 0.04690376827171172, 0.06504415902268157, 0.046278659079674433, 0.13483605428846424, 0.129887677089628, 0.15480036784232976, 0.12573004014777578, 0.1489561617260846, 0.13976391153586631, 0.1546497081323771, 0.13141129947120567, 0.1469474034360876, 0.026687015585907803, 0.025685568863729524, 0.031393493129599714, 0.027015293023570086, 0.0434182544105417, 0.020045516730027746, 0.028344024549055158, 0.03803354422653826, 0.029263765653179896]}, "mutation_prompt": null}
{"id": "dc0981cd-1102-43c4-80f4-671a0ac8b9b7", "solution": "import numpy as np\nimport random\n\nclass CEAP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.prob_adjustment = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Probability adjustment\n            if random.random() < self.prob_adjustment:\n                # Randomly adjust the probability of adaptation, crossover, and elitism\n                self.adapt_prob *= (1 + random.random() * 0.2 - 0.1)\n                self.crossover_prob *= (1 + random.random() * 0.2 - 0.1)\n                self.elite_size *= (1 + random.random() * 0.2 - 0.1)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAP(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAP", "description": "Novel \"Crossover-Elitism-Adaptation-Probability\" (CEAP) algorithm combining crossover, elitism, adaptation, and probability adjustment to handle black box optimization problems.", "configspace": "", "generation": 4, "fitness": 0.05013743959865862, "feedback": "The algorithm CEAP got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.09498388645581068, 0.11854010900560663, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006395915445946199, 0.019622450997510033, 0.005375109906600173, 0.024195348757323876, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.020085466773983374, 0.007818147955095611, 0.020873187072038446, 0.01959972157639278, 0.011308405954020606, 0.0062485615349447965, 0.014763392921912755, 9.999999999998899e-05, 0.005725621702432404, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 0.006313282441443024, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.1033026477015081, 0.0861477096132216, 0.10552168816779972, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009113235761147531, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0231189869414673, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10837724849470798, 0.10490769173606318, 0.09580441870675127, 0.16112956940342849, 0.158507200436946, 0.15200401011755316, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.004877382464404056, 0.01759993274736349, 0.027725477866802795, 0.007967805381524529, 0.0267656688986897, 0.08494000004272728, 0.08683412106907074, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10905600624559553, 0.09781957249811568, 0.09617184309917903, 0.08006233151019149, 0.10400383319544215, 0.11507694983506245, 0.1613932299901245, 0.1395002459340482, 0.1383082894002191, 0.13270175253308825, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.08234111893800378, 0.07270772139785497, 0.08174635489364934, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.1288837758747977, 0.12141961459552253, 0.13546674118333646, 0.13605479553161604, 0.12095422267634426, 0.13358659704064668, 0.1379444586095615, 0.14173342427560764, 0.1261963614278906, 9.999999999998899e-05, 0.018437663113740954, 0.11858808308485058, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0638278941320779, 0.09420094993418549, 0.08203209038654746, 0.08545698030709592, 0.1207914665021157, 0.13253854129724696, 0.1070176662487543, 0.1378076596009714, 0.07957281547182282, 0.11040265245322212, 0.1128716078947336, 0.06932034027342138, 0.11222965461711576, 0.07113923575275005, 0.05903250263678039, 0.04690376827171172, 0.0802679916429575, 0.062272767566654674, 0.13480174570059533, 0.1522964604321423, 0.15138732403088617, 0.12480418254224968, 0.15316963064159939, 0.14085582235079086, 0.15156442600664288, 0.14835012239420808, 0.14689007985489466, 0.03325553919368429, 0.037225813349620496, 0.031393493129599714, 0.02966170454258299, 0.03425093938292756, 0.04654917499829658, 0.04081266841804265, 0.03803354422653826, 0.037715045645825174]}, "mutation_prompt": null}
{"id": "c3627827-590a-4e4e-959f-d0eacfea16b1", "solution": "import numpy as np\nimport random\n\nclass CEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEA(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA", "description": "Novel \"Crossover-Elitism-Adaptation\" with probability adaptation", "configspace": "", "generation": 5, "fitness": 0.05190890753287015, "feedback": "The algorithm CEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.08108763387163931, 0.09169502728636048, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008145538622695514, 0.01467079663371329, 0.005375109906600173, 0.02205184473628119, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.01677838411039434, 0.010674738340807233, 0.010124919575897784, 0.0268436543372933, 0.0064757611795684955, 0.01959972157639278, 0.012187032066288017, 0.0018643556615350887, 0.014763392921912755, 0.002710694629439958, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 0.0131696695539949, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.17635001959238084, 0.09422271777442204, 0.09131203201070748, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 0.03851438563321896, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004090848901491251, 9.999999999998899e-05, 0.008258734566312542, 9.999999999998899e-05, 9.999999999998899e-05, 0.010394464041800555, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07469349106690204, 9.999999999998899e-05, 9.999999999998899e-05, 0.005923345016134451, 9.999999999998899e-05, 0.012604655243504181, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.11880227748845207, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.18268561162890662, 0.14363618450363247, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.022569810745250662, 0.00042476743769004344, 0.0267656688986897, 0.09445014037532729, 0.08627106939215445, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10829578812424456, 0.08932775948258531, 0.08518935675852246, 0.08871066488077539, 0.09890011870838411, 0.11361405442873096, 0.1613932299901245, 0.13912902582933184, 0.15101782135383124, 0.11499666107676842, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.09583377882518485, 0.06406947898089654, 0.06410604869748804, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.12960884446893428, 0.11408986691511769, 0.13345086981233123, 0.14244342574903224, 0.13029994194541938, 0.13316754535436226, 0.12681145274012284, 0.12501502267357723, 0.1261963614278906, 0.14210766103511474, 9.999999999998899e-05, 9.999999999998899e-05, 0.13246022490599463, 9.999999999998899e-05, 0.12373914262508423, 9.999999999998899e-05, 0.12157970113156913, 9.999999999998899e-05, 0.05568623559107733, 0.08750205164426084, 0.08353979966582814, 0.08781072437293314, 0.1207914665021157, 0.10017604786189149, 0.1070176662487543, 0.10630038203099379, 0.09674028102443721, 0.11040265245322212, 0.10267165755511809, 0.08404470203066883, 0.0506857903344724, 0.07805148895581004, 0.06354845139338883, 0.052284365877657946, 0.060705651714176745, 0.06511441601846601, 0.15961914370119723, 0.14019634208617027, 0.14763022729669195, 0.13241997156573238, 0.14116881551875304, 0.14078519222505037, 0.15621234193562572, 0.15099555632282646, 0.15263529538686704, 0.02726612599380729, 0.03721805274864032, 0.04151717247961262, 0.027477301478948668, 0.053163529067159154, 0.04066000269938086, 0.02556245160946835, 0.03803354422653826, 0.034084617822088714]}, "mutation_prompt": null}
{"id": "584e9b35-48fe-4d91-910b-1de70fd911f0", "solution": "import numpy as np\nimport random\n\nclass CEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation with probability adjustment\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover with probability adjustment\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability 0.6\n                if random.random() < 0.6:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEA(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA", "description": "Novel \"Crossover-Elitism-Adaptation\" (CEA) algorithm combining crossover, elitism, and adaptation with probability adjustment.", "configspace": "", "generation": 6, "fitness": 0.04981005433099391, "feedback": "The algorithm CEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.13915599469536932, 0.0979037603502344, 0.0996558313861089, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.0844163526823759, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017300186425632247, 0.008720301463439273, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.011577401559903056, 0.018612926634576477, 0.003830039982879674, 0.01959972157639278, 0.005425436477906387, 0.015054101224340255, 0.014763392921912755, 9.999999999998899e-05, 0.002646818602265011, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.018464590439962958, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.08224659834595494, 0.08386932457592988, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003948730087831587, 9.999999999998899e-05, 0.004866409261199078, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012501465451517646, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02193071641480182, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11892567968576662, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.12048823866090319, 0.13704759359945873, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.013855322913665646, 9.999999999998899e-05, 0.0267656688986897, 0.11126983520385492, 0.08664955033177435, 0.11842175776965747, 0.10286992194189282, 0.10852972522114013, 0.11009348267295083, 0.08808199726801991, 0.08099219012337167, 0.07726393575557644, 0.10436587207658377, 0.10473569295543406, 0.1613932299901245, 0.14712578044202507, 0.12064419758200673, 0.12565733074693908, 0.12028165949079228, 0.17377774300845283, 0.11401267788411351, 0.05985564337097804, 0.05730232201202057, 0.08398582550377798, 0.06730998582028791, 0.0670899473965374, 0.08387731197833714, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.13417845498395087, 0.11974237092852158, 0.14362660711850128, 0.11967257318611679, 0.13235027690516576, 0.12243519629639354, 0.16323377956476592, 0.13805742074578486, 0.13413999720569814, 9.999999999998899e-05, 9.999999999998899e-05, 0.11456389045662596, 9.999999999998899e-05, 0.02476806589129088, 9.999999999998899e-05, 0.09331861684674081, 9.999999999998899e-05, 0.11999898252443253, 0.05888687259449232, 0.09753866292598379, 0.08990990862147608, 0.08004220424896302, 0.1207914665021157, 0.08757250099481684, 0.12178740127538401, 0.10511484148144368, 0.0693612576838919, 0.11040265245322212, 0.12949958715253074, 0.06932034027342138, 0.0506857903344724, 0.04412180713431901, 0.07098349121509506, 0.04690376827171172, 0.07199062495820474, 0.05385546888358095, 0.13480174570059533, 0.13436990489673484, 0.14763022729669195, 0.174028891099005, 0.1417375685273552, 0.14577899661448412, 0.14969714796693134, 0.1284632503022447, 0.14689007985489466, 0.031015379604932836, 0.021945015644169508, 0.03399102247963004, 0.0349007874742574, 0.035468627150883725, 0.03763858080624538, 0.025307919745970908, 0.03803354422653826, 0.043975663788824004]}, "mutation_prompt": null}
{"id": "4e3fd3a2-bbf3-41ca-b054-9b6501ef3f55", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA_P:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.prob_adj = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability (1 - self.prob_adj)\n                if random.random() > self.prob_adj:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability (1 - self.prob_adj)\n                if random.random() > self.prob_adj:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Adjust probability based on the number of successful adaptations and crossovers\n        self.prob_adj = min(self.prob_adj + self.adapt_prob * (self.adapt_prob / self.budget), 1)\n        self.prob_adj = max(self.prob_adj - self.adapt_prob * (self.adapt_prob / self.budget), 0)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea_p = CEA_P(budget=100, dim=10)\nbest, score = cea_p(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA_P", "description": "Novel \"Crossover-Elitism-Adaptation-Probability\" (CEA-P) algorithm combining crossover, elitism, adaptation, and probability adjustment to handle black box optimization problems.", "configspace": "", "generation": 7, "fitness": 0.0488279716155207, "feedback": "The algorithm CEA_P got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.08108763387163931, 0.10082614856525485, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.012890692854626962, 0.013121652207035539, 0.007001899198008643, 0.01959972157639278, 0.008236973313804574, 0.007661644511157695, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.09611102415483697, 0.1076792848067003, 0.0667108215001172, 0.07285119553694963, 0.01595448492891194, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013510916309754428, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10847569618016784, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.10308193425771384, 0.13163976985599224, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.0020914028189026324, 0.01759993274736349, 0.02274326037012797, 0.029355358400091403, 0.0267656688986897, 0.09832617848695968, 0.08609370886951351, 0.11842175776965747, 0.11470604807490614, 0.10852972522114013, 0.10798713552628325, 0.08975140465930143, 0.08099219012337167, 0.08658171348905364, 0.09606267484187503, 0.09663331791761609, 0.1613932299901245, 0.13800672315110074, 0.14091307156963795, 0.13595545043164914, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.03613296994298343, 0.08398582550377798, 0.056957211629895754, 0.10004592188949957, 0.0696035632528832, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.11943364695601921, 0.12094496758206041, 0.13519712737561496, 0.11117461469200529, 0.10785943140920229, 0.13717473251081247, 0.13327880884194232, 0.12991976357259538, 0.13232920810491144, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01631668504647099, 9.999999999998899e-05, 9.999999999998899e-05, 0.11617946987723649, 9.999999999998899e-05, 0.12039003806183612, 0.08345736389555058, 0.10765676449845563, 0.08679623972741479, 0.1207914665021157, 0.07112298813299489, 0.1070176662487543, 0.10511484148144368, 0.08892380744384243, 0.11040265245322212, 0.10267165755511809, 0.11989856540966215, 0.06579639959995531, 0.08476324073685515, 0.06031826608819724, 0.04690376827171172, 0.05096410289505726, 0.07175529672808012, 0.1452772107397181, 0.1391024461748428, 0.18039041829981595, 0.12651031584895778, 0.13476044617222271, 0.15417451594775244, 0.14969714796693134, 0.1334519491241739, 0.14689007985489466, 0.03816073965939126, 0.02720701479704224, 0.031393493129599714, 0.028565298958043828, 0.03432862923543156, 0.030444736731635946, 0.029329257203868808, 0.03831104738762292, 0.027236447751211035]}, "mutation_prompt": null}
{"id": "b39a9cfb-f1b0-4f25-b9ca-c6e1bc99770d", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEAP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.prob_change = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 1 - self.prob_change\n                if random.random() > self.prob_change:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability 1 - self.prob_change\n                if random.random() > self.prob_change:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAP(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAP", "description": "Novel \"Crossover-Elitism-Adaptation-Probability\" (CEAP) algorithm combining crossover, elitism, adaptation, and probabilistic changes to handle black box optimization problems.", "configspace": "", "generation": 8, "fitness": 0.04919079829393773, "feedback": "The algorithm CEAP got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.08245115088923671, 0.1085698173857067, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006515972460746311, 0.0274910893267859, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.009105574672914063, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.0044275839069858325, 9.999999999998899e-05, 0.011835745339515258, 0.01959972157639278, 0.0004952459975243739, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 0.007458185905256154, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.11721664047550262, 0.09484898954370113, 0.10164616788927361, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008729331212034452, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01048063973914648, 0.023574440652895823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.09716408355800721, 0.1621807164470953, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.023376164868795568, 0.012185885232364302, 0.017443650067131777, 0.0267656688986897, 0.08494000004272728, 0.09020127807439293, 0.12495395582661473, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.09186897356779389, 0.08099219012337167, 0.07726393575557644, 0.12933427574068224, 0.12356988199888541, 0.1613932299901245, 0.13800672315110074, 0.13918198735291865, 0.1422921600868693, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.07797731116008544, 0.08398582550377798, 0.0784961284052158, 0.09210658903877378, 0.06441531490155739, 0.0837317855149382, 0.0997711199450243, 0.07606893524690383, 0.11943364695601921, 0.14126440922618055, 0.13408645575769296, 0.1149212710997306, 0.11759184317898874, 0.14546008074406513, 0.18993399731865634, 0.1236171218306128, 0.13281817086310532, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12408070334265198, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08949657980022097, 0.07466602457976645, 0.10284995383513562, 0.07441727391800035, 0.1207914665021157, 0.08345849724597953, 0.12189370424808132, 0.10511484148144368, 0.084441798714041, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.0506857903344724, 0.03738259240699027, 0.05903250263678039, 0.04690376827171172, 0.058968387885452334, 0.08998000327177702, 0.14388685925691969, 0.13264820091342733, 0.14763022729669195, 0.127221936817419, 0.1426170791099468, 0.1410784641852839, 0.14969714796693134, 0.16085271330899653, 0.14689007985489466, 0.024239839824279796, 0.029218826488091487, 0.03200210043357854, 0.03110370711201249, 0.03425093938292756, 0.03677940988643624, 0.024629560696836417, 0.03803354422653826, 0.03937443644521432]}, "mutation_prompt": null}
{"id": "c18f363d-2b58-4e4c-b660-9b238b860ad6", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.adapt_threshold = 0.4  # New probability threshold for adaptation\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one if probability threshold is met\n                if random.random() < self.adapt_threshold:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals with a higher mutation rate\n                child = (population[idx1] + population[idx2]) / 2 + np.random.uniform(-0.5, 0.5, self.dim) * 0.2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEA(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA", "description": "Novel \"Crossover-Elitism-Adaptation\" with probabilistic adaptation and crossover refinement", "configspace": "", "generation": 9, "fitness": 0.051609788980222004, "feedback": "The algorithm CEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11935273416671766, 0.08480335228271618, 0.10368162445087015, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07608371971840389, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.016768379640508257, 0.013541637018994357, 0.012322076513480495, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.0020401915882468646, 9.999999999998899e-05, 0.007966114796482127, 0.01959972157639278, 0.0004952459975243739, 0.0032294168116139277, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027515185409538345, 0.036239733862798884, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.11201099316251006, 0.09466518859554418, 0.09594775403624312, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.042149878789905615, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004966004124223877, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014921369667151185, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01975586443341104, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.11842371338968605, 0.09580441870675127, 0.16112956940342849, 0.1715882995959198, 0.12108810770431122, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.006491666193180756, 0.01759993274736349, 0.002012537662537617, 0.0007024309047579669, 0.0267656688986897, 0.09203425333158488, 0.094172287018918, 0.11842175776965747, 0.10667494425036528, 0.10852972522114013, 0.10798713552628325, 0.1149220380976902, 0.08099219012337167, 0.09145106270660286, 0.10977687293739125, 0.10592346383258466, 0.1613932299901245, 0.13800672315110074, 0.11488705332438354, 0.1336869781491722, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.0670545929920685, 0.07439645622377444, 0.09598921834039176, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.16853270984108837, 0.12995224342824585, 0.13345086981233123, 0.13631575943759067, 0.13153290212373614, 0.11870915729708087, 0.12620707696950617, 0.15814708141211664, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 0.11249418118002052, 0.10582574815732748, 9.999999999998899e-05, 9.999999999998899e-05, 0.13311092084397047, 0.12859014454299356, 0.11953055229725307, 0.08326768983777877, 0.07466602457976645, 0.10798952311265642, 0.07327841830047488, 0.1207914665021157, 0.06661401029160186, 0.1070176662487543, 0.10511484148144368, 0.0693612576838919, 0.11040265245322212, 0.10267165755511809, 0.0706387958728687, 0.08410972576525, 0.06189910787717545, 0.12168202700069652, 0.05755532717934819, 0.048711544429188125, 0.06811026692640576, 0.13910857584892733, 0.13593146885299534, 0.14763022729669195, 0.13195457897579677, 0.13138900638358664, 0.137490886176303, 0.14969714796693134, 0.1461160130728496, 0.15102537362308488, 0.049692074576963785, 0.033777498949887685, 0.031393493129599714, 0.02783157200343289, 0.03425093938292756, 0.029003796382723213, 0.023372144503433057, 0.038684584492766017, 0.033931170172221914]}, "mutation_prompt": null}
{"id": "8936c685-613c-43e4-96f4-15a073392de9", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEA(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA", "description": "Novel \"Crossover-Elitism-Adaptation\" algorithm with probability adaptation for black box optimization problems", "configspace": "", "generation": 10, "fitness": 0.047957103386242275, "feedback": "The algorithm CEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.10008960635118769, 0.1259630059004958, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.015312042533882408, 0.018404133750850482, 0.003613126905296249, 0.01959972157639278, 0.02361294210617182, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.08538487131205041, 0.06387157493193807, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0197866170835288, 0.02745121705154363, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.1502110127782995, 0.15476034257906135, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.01574501202219636, 9.999999999998899e-05, 0.0267656688986897, 0.08494000004272728, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.12596860159445022, 0.10798713552628325, 0.08808199726801991, 0.08099219012337167, 0.08697437278887776, 0.10399471267654226, 0.09734449984110283, 0.1613932299901245, 0.14777688458385219, 0.1333614377611928, 0.10683097318527268, 0.12028165949079228, 0.17377774300845283, 0.12281098093385168, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.06254949905046492, 0.09608949495388153, 0.0636902320050744, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.11943364695601921, 0.1380549534693195, 0.13604835405530324, 0.12455115645293702, 0.11920957477279648, 0.14069629934008265, 0.1412510162053925, 0.10630181521571636, 0.1261963614278906, 9.999999999998899e-05, 0.01406377877646714, 9.999999999998899e-05, 9.999999999998899e-05, 0.01730885409505023, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10788077275651775, 0.09122704727932796, 0.0817974787349145, 0.0746220259028445, 0.1207914665021157, 0.07431975117656986, 0.1070176662487543, 0.10511484148144368, 0.07169333830587732, 0.11040265245322212, 0.10267165755511809, 0.07890104279940602, 0.05219259795024267, 0.06432306082809425, 0.06365289628104898, 0.12361341800706849, 0.04883014016444154, 0.059002634737101656, 0.13480174570059533, 0.12862610548346765, 0.1477443016847514, 0.13454330508224943, 0.1410353505386358, 0.14042318899827755, 0.14969714796693134, 0.13909427858036705, 0.14689007985489466, 0.02134893192938181, 0.032576866800097415, 0.03361018507250124, 0.027015293023570086, 0.046152863388570275, 0.03329931727379265, 0.01826456019590894, 0.03803354422653826, 0.02058492492097541]}, "mutation_prompt": null}
{"id": "21ea42bb-918d-406b-b970-fb47c35b50db", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals with probability 0.4\n                if random.random() < 0.4:\n                    child = (population[idx1] + population[idx2]) / 2\n                    # Replace the worst individual with the child\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEA(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA", "description": "Novel \"Crossover-Elitism-Adaptation\" (CEA) algorithm with probability-based adaptation and crossover", "configspace": "", "generation": 11, "fitness": 0.04874439329962465, "feedback": "The algorithm CEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.08108763387163931, 0.09169502728636048, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01740982591062834, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.0030378444309728803, 9.999999999998899e-05, 0.00157648657342635, 0.01959972157639278, 0.0015368929664988373, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.029400053206858123, 0.00031549654350837564, 0.0367620194979732, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10319388155871023, 0.08468741690286208, 0.06008688802144424, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03158317834506674, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.021588620913666867, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00818409855854152, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10338767481496747, 0.09580441870675127, 0.16632480289829332, 0.16771934963119473, 0.14620252896168517, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.008652399219800433, 0.01759993274736349, 0.01325385500624543, 9.999999999998899e-05, 0.0267656688986897, 0.08494000004272728, 0.08609370886951351, 0.11842175776965747, 0.09905635417673198, 0.10852972522114013, 0.10798713552628325, 0.09028610307138496, 0.08099219012337167, 0.07726393575557644, 0.10377724641132913, 0.0962505644704219, 0.1613932299901245, 0.13800672315110074, 0.15512234985742912, 0.1059368268802311, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.052541379929399445, 0.08398582550377798, 0.11143356823157669, 0.09333151928820915, 0.08499642634984306, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.1350230993996101, 0.13710914980765232, 0.13345086981233123, 0.12145440537983598, 0.10610379681796656, 0.1339340352705669, 0.13525851922905863, 0.12477127505038133, 0.12625434751740616, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019227132329384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10947149143921231, 0.1200706088198884, 0.08167024703901915, 0.08703936865525097, 0.1207914665021157, 0.07074122176553488, 0.1070176662487543, 0.11889912885254394, 0.08749311679629279, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.0506857903344724, 0.03738259240699027, 0.18738587888920866, 0.04690376827171172, 0.07634937658514429, 0.06559322940348722, 0.13550792707692472, 0.1320248404709795, 0.14763022729669195, 0.14339221276592884, 0.13217600790591877, 0.13233279814316334, 0.14969714796693134, 0.1537614773638436, 0.14689007985489466, 0.01819799611540862, 0.02102092083281515, 0.031393493129599714, 0.03397147300271863, 0.03425093938292756, 0.023253204059856758, 0.024517379437885234, 0.03803354422653826, 0.04796515486609165]}, "mutation_prompt": null}
{"id": "1982951d-1c67-4e58-aa07-8cf0556ba421", "solution": "import numpy as np\nimport random\n\nclass CEA_P:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.prob_mut = 0.4  # probabilistic mutation\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with a probability of 0.4\n                if random.random() < self.prob_mut:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with a probability of 0.4\n                if random.random() < self.prob_mut:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea_p = CEA_P(budget=100, dim=10)\nbest, score = cea_p(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA_P", "description": "Novel \"Crossover-Elitism-Adaptation-Probabilistic\" (CEA-P) algorithm combining crossover, elitism, adaptation, and probabilistic mutation to handle black box optimization problems.", "configspace": "", "generation": 12, "fitness": 0.04847687650425666, "feedback": "The algorithm CEA_P got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.08108763387163931, 0.11594831889749624, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.09419741444005736, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.01821369543455842, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.010524394191006259, 9.999999999998899e-05, 0.005752002083499019, 0.01959972157639278, 0.006720804972427108, 0.0011568622913273874, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.007219833538784082, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.08224659834595494, 0.06496579714586237, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008330485454547287, 0.012153302820702594, 9.999999999998899e-05, 0.0012720230390341758, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10849409393799792, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.14782953118368225, 0.1291324085887563, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.020415560643992414, 0.01759993274736349, 0.012615547703921814, 0.010971005752554053, 0.0267656688986897, 0.0914553006281843, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.08099219012337167, 0.07726393575557644, 0.10486720213993828, 0.09947680679676485, 0.1613932299901245, 0.1422569413022977, 0.12886314681693933, 0.16172969141627036, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.08671192431393704, 0.07162851377474222, 0.08195133936835719, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.11943364695601921, 0.12014031518879453, 0.13345086981233123, 0.1219694002979782, 0.11225363692129109, 0.11611282186973981, 0.12250811362837999, 0.13482479753017562, 0.1304158417715725, 9.999999999998899e-05, 0.019400421284850755, 9.999999999998899e-05, 0.14595063123590424, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10422564768653886, 0.09438417051203829, 0.10934871127454682, 0.08147385015531727, 0.1207914665021157, 0.12074655630660713, 0.1070176662487543, 0.12157235724479998, 0.11150643646401637, 0.11040265245322212, 0.10267165755511809, 0.10051682947656959, 0.059722706636133105, 0.03738259240699027, 0.05903250263678039, 0.04986409872172348, 0.04856269515137246, 0.0550578334248778, 0.13910193954782013, 0.14089838584350223, 0.14763022729669195, 0.1229118392597397, 0.13640706888043552, 0.1386557181091319, 0.1510491937264664, 0.1338730635690969, 0.14689007985489466, 0.026242613256620806, 0.01954280583859236, 0.031393493129599714, 0.027066931639943892, 0.03456745556870555, 0.03624715072353102, 0.016642752328186905, 0.03803354422653826, 0.02616017304169216]}, "mutation_prompt": null}
{"id": "9ab8bd07-5b97-4d3c-9e03-acda0fc243e2", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.mut_var = 0.1\n        self.crossover_var = 0.2\n        self.elite_var = 0.3\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals with probability 0.2\n                if random.random() < 0.2:\n                    child = (population[idx1] + population[idx2]) / 2\n                    # Replace the worst individual with the child with probability 0.3\n                    if random.random() < 0.3:\n                        population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual with probability 0.3\n                if random.random() < 0.3:\n                    population[np.argmin(scores)] = best\n\n            # Mutation\n            if random.random() < self.mut_prob:\n                # Randomly select an individual\n                idx = random.sample(range(self.population_size), 1)\n                # Compute the mutation of the individual with probability 0.1\n                if random.random() < 0.1:\n                    mutation = np.random.uniform(-self.mut_var, self.mut_var, self.dim)\n                    population[idx] += mutation\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEA(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA", "description": "Refine the CEA algorithm by adapting the mutation, crossover, and elitism probabilities.", "configspace": "", "generation": 13, "fitness": 0.046745971356625296, "feedback": "The algorithm CEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.13379076736372442, 0.08108763387163931, 0.12004068644952637, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.018608810095415707, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.010715405829568536, 0.00225114005936633, 0.0038740062734820002, 0.01959972157639278, 0.0004952459975243739, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026014370000390752, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.08224659834595494, 0.064669212843395, 0.0667108215001172, 0.07285119553694963, 0.06418993843513321, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003769686080964507, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023032299927599142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10929201011660628, 0.10274288241579344, 0.10678626240190803, 0.16112956940342849, 0.12725682511160763, 0.15267942712144045, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.00023699052980996616, 0.0028647066797450327, 0.0267656688986897, 0.09831178589322209, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.08099219012337167, 0.07726393575557644, 0.11086819634725076, 0.09887030108312522, 0.1613932299901245, 0.13908671247334092, 0.12458555153695894, 0.1138990961977856, 0.12028165949079228, 0.17377774300845283, 0.11549727610554505, 0.05985564337097804, 0.07426248340224151, 0.08398582550377798, 0.08118600534781906, 0.06406947898089654, 0.06405148741502487, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.11943364695601921, 0.10898969910455758, 0.13345086981233123, 0.1334233869003708, 0.10853841420303889, 0.10896891037713907, 0.12245976138762271, 0.09642742165985474, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 0.020949125568794802, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06683090661720303, 0.0625756949245051, 0.07466602457976645, 0.08167024703901915, 0.07327841830047488, 0.1207914665021157, 0.06910271763952647, 0.1070176662487543, 0.10511484148144368, 0.0988355878280166, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.05134548638224956, 0.038541622869197045, 0.05991249671073562, 0.057774810312100966, 0.041834975806566366, 0.04143420019681854, 0.13480174570059533, 0.128372137474824, 0.14763022729669195, 0.12376673981572128, 0.1251012898857734, 0.13233279814316334, 0.14969714796693134, 0.12919841976409918, 0.14689007985489466, 0.02140789787026698, 0.027957163523189, 0.031393493129599714, 0.029516342426784692, 0.03425093938292756, 0.024959777134097583, 0.026766527464833545, 0.03803354422653826, 0.01861713140615806]}, "mutation_prompt": null}
{"id": "b06c094f-91bc-400c-b23f-de2e6142436a", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability 0.6\n                if random.random() < 0.6:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEA(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA", "description": "Novel \"Crossover-Elitism-Adaptation\" (CEA) algorithm combining crossover, elitism, and adaptation to handle black box optimization problems with probability-based adaptation.", "configspace": "", "generation": 14, "fitness": 0.049532332481756265, "feedback": "The algorithm CEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.08322808230406009, 0.12265313105249986, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.015312140344570069, 0.006592353378601756, 0.02027002962720159, 0.018248263482334326, 0.007792397052521438, 0.019177465351678857, 0.0008793434420287793, 0.010079018919166072, 0.01618123749299305, 0.01959972157639278, 0.005822933389688978, 9.999999999998899e-05, 0.014763392921912755, 0.011264239984337676, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012880997168824293, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10314094856400369, 0.08224659834595494, 0.07652859252953659, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011902658802400712, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010305306934067948, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005767171861669307, 0.035762645165005935, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.10632955778006803, 0.16112956940342849, 0.15657718346864746, 0.1210557193025883, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.013117433801982825, 0.01759993274736349, 0.011396776644568285, 0.010197589027397758, 0.0267656688986897, 0.08494000004272728, 0.10015700220118362, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.092178061372306, 0.08099219012337167, 0.07726393575557644, 0.10752572925163162, 0.0962505644704219, 0.1613932299901245, 0.14518459160750208, 0.1365051809408695, 0.12131425684927, 0.12028165949079228, 0.17377774300845283, 0.11439061424500929, 0.05985564337097804, 0.03478619481106704, 0.08398582550377798, 0.07945850859197967, 0.06406947898089654, 0.07959276726068087, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.15853382024412965, 0.11401814408347122, 0.13345086981233123, 0.1103568689991713, 0.11009958687056842, 0.14921148083172542, 0.12245976138762271, 0.12057929214290164, 0.13770587320054906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0361620621613723, 0.12687228257298044, 9.999999999998899e-05, 9.999999999998899e-05, 0.07209679209813802, 0.08140318026798199, 0.08167024703901915, 0.08629185100240178, 0.1207914665021157, 0.06717886165204123, 0.12275981011758852, 0.1369642087085705, 0.07156009000010455, 0.1416798037253424, 0.10267165755511809, 0.09104584499174273, 0.061058517540500956, 0.06926360017101929, 0.09537939630580661, 0.09406923971771175, 0.06678828636326561, 0.06190946345096093, 0.13494988925182405, 0.1672157088292805, 0.15359011016742896, 0.16234594199949848, 0.15055602182607164, 0.14181518008907734, 0.14969714796693134, 0.12558819870055427, 0.16435810414761365, 0.021888395003663574, 0.023417027654691114, 0.031393493129599714, 0.028258377730743578, 0.03425093938292756, 0.03542010133117035, 0.030559654851479046, 0.03803354422653826, 0.03388647135454537]}, "mutation_prompt": null}
{"id": "576b47fc-da71-42e1-8bb9-1e0506d9967d", "solution": "import numpy as np\nimport random\n\nclass CEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEA(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA", "description": "Novel \"Crossover-Elitism-Adaptation\" (CEA) algorithm combining crossover, elitism, and adaptation to handle black box optimization problems with probability adaptation.", "configspace": "", "generation": 15, "fitness": 0.04896334394723483, "feedback": "The algorithm CEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.12563382721968086, 0.08646079339767054, 0.09169502728636048, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.005063165140211656, 9.999999999998899e-05, 0.0033994132852241954, 0.01959972157639278, 0.0036384195802705577, 0.00034428785499529546, 0.014763392921912755, 0.0019447209388095965, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.08403256719534236, 0.10193514978958573, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.0902722152309614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001768369574176587, 0.0012398179549716337, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003839282816485823, 9.999999999998899e-05, 0.01002929034913791, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.1691881107547173, 0.13645055389691463, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.15474421213317635, 0.15044858754710244, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.01641641354889234, 0.01759993274736349, 0.012242833255332708, 0.006707191442359539, 0.0267656688986897, 0.08494000004272728, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.12149149335170406, 0.10798713552628325, 0.09407967414231533, 0.08099219012337167, 0.09094007341901034, 0.1473137106045459, 0.10282996804042521, 0.1613932299901245, 0.1475090632671654, 0.13870246672428022, 0.13515265285774025, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.06454414601062686, 0.06434187001174085, 0.06342850570876157, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.12496135472749481, 0.1293308549018708, 0.13345086981233123, 0.14287783608622917, 0.1241132248324156, 0.13341591227809224, 0.12245976138762271, 0.12693262847592945, 0.18200653213423001, 0.051488877976052616, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0845267064653683, 9.999999999998899e-05, 9.999999999998899e-05, 0.06842840679116924, 0.08070255740498289, 0.09019686836173846, 0.07327841830047488, 0.1207914665021157, 0.07814680976598598, 0.1070176662487543, 0.10511484148144368, 0.0693612576838919, 0.12672087462623915, 0.10267165755511809, 0.07125923848792393, 0.06683549679548795, 0.03738259240699027, 0.07057551186898436, 0.04690376827171172, 0.04019044166964181, 0.05721278393082452, 0.13480174570059533, 0.13023643818726505, 0.14763022729669195, 0.1433699659051012, 0.15939052900742767, 0.14434363146877405, 0.14969714796693134, 0.12505228174140337, 0.14689007985489466, 0.026816364753318833, 0.02685393115994772, 0.03502005271115194, 0.045279071918188474, 0.03425093938292756, 0.024391209104374645, 0.03479170811450916, 0.03803354422653826, 0.03535410144176021]}, "mutation_prompt": null}
{"id": "bb562432-c4da-49b8-91a6-6bd819005487", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover refinement\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals with probability 0.6\n                if random.random() < 0.6:\n                    child = (population[idx1] + population[idx2]) / 2\n                    # Replace the worst individual with the child\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEA(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA", "description": "Novel \"Crossover-Elitism-Adaptation\" (CEA) algorithm with probability-based adaptation and crossover refinement.", "configspace": "", "generation": 16, "fitness": 0.048973045582547864, "feedback": "The algorithm CEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.13379987376436497, 0.1184775726002174, 0.13061626344666488, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07618201756617005, 0.06989568255750578, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.012468849787793057, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.011218834296988112, 0.004347552144704281, 0.002874579451310977, 0.01959972157639278, 0.0004952459975243739, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.023963927691078468, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10667418180162425, 0.08224659834595494, 0.07878345864154779, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029193067039999354, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01068981480750919, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005694567799715333, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09934817795419693, 0.16112956940342849, 0.11777113457967447, 0.13975740075667198, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.001078861732370373, 0.01759993274736349, 0.013610654133299649, 0.001554158090412039, 0.0267656688986897, 0.08494000004272728, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.11576808771646518, 0.11026924951725237, 0.09470678728109472, 0.0823275386851221, 0.0952066918716935, 0.1130392838081904, 0.10359525309315254, 0.1613932299901245, 0.13800672315110074, 0.15862734571647974, 0.11616679305731537, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.05003528463459661, 0.08398582550377798, 0.11777692121465877, 0.07718118303943988, 0.0841768452529501, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.1297790985023748, 0.10144869308869797, 0.15968000663925175, 0.12344198593217848, 0.10615889558460567, 0.12864541206435187, 0.1342385405597648, 0.11112573666728953, 0.12771768774226644, 9.999999999998899e-05, 0.1239633916542976, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019071833120651194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09558704992092115, 0.08806097259970191, 0.08990506708770007, 0.07327841830047488, 0.1207914665021157, 0.09177694064952724, 0.12496586015904432, 0.10511484148144368, 0.09207512062213008, 0.11040265245322212, 0.10267165755511809, 0.07105547429219605, 0.05489305542594136, 0.059409720423962975, 0.0842269312498336, 0.04690376827171172, 0.08235883124568377, 0.042973807447537204, 0.13480174570059533, 0.15513518590906583, 0.14763022729669195, 0.12958403573471078, 0.13067314070536595, 0.14106294149086684, 0.14969714796693134, 0.14018517433827093, 0.14689007985489466, 0.03250500521628141, 0.021728802992712515, 0.034919401212111345, 0.048122535442523984, 0.03425093938292756, 0.028417331168602122, 0.018570840461293314, 0.03803354422653826, 0.02643008773777311]}, "mutation_prompt": null}
{"id": "33dbee55-6a5b-499b-a24a-758926627323", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEA(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA", "description": "Refine the CEA algorithm by changing the individual lines to adapt to the black box optimization problem with a probability of 0.4.", "configspace": "", "generation": 17, "fitness": 0.04997192982506141, "feedback": "The algorithm CEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.08836431957109858, 0.09720394737165972, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.0038515831425336433, 0.0006893567063720463, 0.0016012867048742496, 0.01959972157639278, 0.0004952459975243739, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.0305365452596692, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10115832916420464, 0.08224659834595494, 0.06854281647036442, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.0270087823804932, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007202225730254752, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020675653547285067, 0.009677816953333251, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10363884809097967, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.1312946840100292, 0.1391419671447791, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.000464404913391836, 0.01759993274736349, 9.999999999998899e-05, 9.999999999998899e-05, 0.0267656688986897, 0.10858029344919884, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.0914566608892825, 0.1035134652805989, 0.08347921111477574, 0.09754452566868899, 0.0962505644704219, 0.1613932299901245, 0.13800672315110074, 0.13792770196160398, 0.12938558881860185, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.052440240997266296, 0.08398582550377798, 0.08432142129464659, 0.06406947898089654, 0.0894068043331443, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.11943364695601921, 0.10190482654493971, 0.1412598532723376, 0.12053989024187961, 0.1266979879199407, 0.13585367084904487, 0.13803826111301265, 0.11175138562170539, 0.1261963614278906, 0.13747961521619745, 0.12573482710025763, 9.999999999998899e-05, 9.999999999998899e-05, 0.13862029617457505, 0.0914001108574608, 9.999999999998899e-05, 0.035718858887086036, 0.04839470477235697, 0.07720229761229114, 0.1351543705615038, 0.08167024703901915, 0.09607681586319394, 0.1207914665021157, 0.06661401029160186, 0.1070176662487543, 0.10511484148144368, 0.09829931810924286, 0.11040265245322212, 0.10267165755511809, 0.07513671799816946, 0.06954711488400134, 0.04335643642559117, 0.06358593107502553, 0.04690376827171172, 0.048921176623337836, 0.04172739275192272, 0.13480174570059533, 0.12883484958980895, 0.15223516976335028, 0.12583936995578227, 0.15052657117555446, 0.13925337582408615, 0.15930582122593517, 0.1251331313467926, 0.14689007985489466, 0.049011300874094776, 0.0222092571451894, 0.031393493129599714, 0.03573483136775846, 0.03425093938292756, 0.03137285010953472, 0.01731169868351501, 0.03803354422653826, 0.019416916110532312]}, "mutation_prompt": null}
{"id": "74dad88b-8b6f-4cb3-b38d-7fb491a2f34a", "solution": "import numpy as np\nimport random\n\nclass CEAProb:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.mut_prob_elite = 0.2\n        self.mut_prob_non_elite = 0.05\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                if random.random() < self.mut_prob_elite:\n                    population[np.argmin(scores)] = new_individual\n                else:\n                    population[np.argmin(scores)] = population[idx1]\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                if random.random() < self.mut_prob_non_elite:\n                    population[np.argmin(scores)] = child\n                else:\n                    population[np.argmin(scores)] = population[idx2]\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea_prob = CEAProb(budget=100, dim=10)\nbest, score = cea_prob(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAProb", "description": "Novel \"Crossover-Elitism-Adaptation-Probabilistic\" (CEA-Prob) algorithm combining crossover, elitism, adaptation, and probabilistic mutation to handle black box optimization problems.", "configspace": "", "generation": 18, "fitness": 0.04464831063180252, "feedback": "The algorithm CEAProb got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.08108763387163931, 0.09169502728636048, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01959972157639278, 0.0004952459975243739, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.08224659834595494, 0.06478077156164386, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011611363914036166, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.09716408355800721, 0.19061109168371293, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 9.999999999998899e-05, 9.999999999998899e-05, 0.0267656688986897, 0.08494000004272728, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.08099219012337167, 0.07726393575557644, 0.09606267484187503, 0.0962505644704219, 0.1613932299901245, 0.13800672315110074, 0.11760505063543025, 0.10649791087436644, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.056957211629895754, 0.071401138315907, 0.07779710931104633, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.11943364695601921, 0.09388200728521401, 0.13345086981233123, 0.1103568689991713, 0.11719854136863284, 0.10896891037713907, 0.12245976138762271, 0.08662074648107432, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05568623559107733, 0.07466602457976645, 0.08167024703901915, 0.07327841830047488, 0.1207914665021157, 0.06661401029160186, 0.1070176662487543, 0.10511484148144368, 0.0693612576838919, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.0506857903344724, 0.03738259240699027, 0.07375582378522105, 0.04690376827171172, 0.04019044166964181, 0.04143420019681854, 0.13480174570059533, 0.128372137474824, 0.1483240433203069, 0.1372604685316675, 0.12252259820195399, 0.13233279814316334, 0.14969714796693134, 0.14969996363776905, 0.14689007985489466, 0.013617939348936514, 0.01757019001773641, 0.031393493129599714, 0.027015293023570086, 0.03425093938292756, 0.020045516730027746, 0.016228383701229143, 0.03803354422653826, 0.017643830485487344]}, "mutation_prompt": null}
{"id": "4f0b8a79-5f0f-4e73-8dc7-1891ec480562", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEA(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA", "description": "Novel \"Crossover-Elitism-Adaptation\" (CEA) algorithm with probabilistic adaptation and crossover.", "configspace": "", "generation": 19, "fitness": 0.04776014012114061, "feedback": "The algorithm CEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.08108763387163931, 0.09169502728636048, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.014077870773724133, 0.004070974359383195, 0.004934528739429678, 0.01959972157639278, 0.002391817146005115, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.08224659834595494, 0.08552195770412163, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009443750677931906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.12198325703081647, 0.1210557193025883, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.023713928119738048, 0.00956022363253195, 0.0267656688986897, 0.09977072053123215, 0.0873915245694532, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.09059796006483578, 0.08099219012337167, 0.07726393575557644, 0.11960052657381037, 0.10209916703165223, 0.1613932299901245, 0.13800672315110074, 0.15660457222307378, 0.11867582656470366, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.09573782668596209, 0.06497650265022925, 0.06733378334652373, 0.09256509343268704, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.11943364695601921, 0.11603310494548968, 0.13345086981233123, 0.12090986589785191, 0.11340652804257989, 0.12441121833306046, 0.12245976138762271, 0.11906840587720746, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06937719764398476, 9.999999999998899e-05, 9.999999999998899e-05, 0.03448331117292325, 0.12347401473595343, 0.09513828055654827, 0.08167024703901915, 0.09018252396348947, 0.1207914665021157, 0.08753609850214739, 0.1070176662487543, 0.10511484148144368, 0.07721589920014016, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.07316249931762453, 0.03738259240699027, 0.05903250263678039, 0.08457157335332999, 0.04019044166964181, 0.0578880580132074, 0.15155893126439246, 0.13612554203842442, 0.14763022729669195, 0.12415769245791686, 0.13540504510700724, 0.13233279814316334, 0.1621588398793269, 0.17875153717066317, 0.1593670257450307, 0.025620062147056366, 0.035422190618627836, 0.031393493129599714, 0.027164704235511872, 0.03460274909820926, 0.03435073908954178, 0.018565422530380737, 0.04461484833503182, 0.021083172960029706]}, "mutation_prompt": null}
{"id": "57810710-a925-4dee-b158-8fdc47251ec9", "solution": "import numpy as np\nimport random\n\nclass RefinedCEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\nrefined_cea = RefinedCEA(budget=100, dim=10)\nbest, score = refined_cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "RefinedCEA", "description": "Refine CEA algorithm by changing individual lines with probability 0.4", "configspace": "", "generation": 20, "fitness": 0.04867339803128357, "feedback": "The algorithm RefinedCEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.1211187927244275, 0.08108763387163931, 0.09301346796054422, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0010875628487312383, 0.04293273969149525, 0.00781433456928593, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.006712679285108991, 0.014061114424081866, 0.006474264249729078, 0.01959972157639278, 0.007716654140094592, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 0.001943677276081912, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.08224659834595494, 0.061429084201499395, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005525086236648491, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08878103182903796, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.11139269949541053, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.1384181191731625, 0.15541714968869458, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.0009345897312336149, 0.0271511064923996, 0.011651812426709651, 0.004376168673542624, 0.0267656688986897, 0.08494000004272728, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.10933422540438897, 0.10798713552628325, 0.0907873845076409, 0.08099219012337167, 0.07726393575557644, 0.12401496442351911, 0.10195975103242094, 0.1613932299901245, 0.1472087473112217, 0.11996639481094284, 0.11234422322875903, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.09877217325270538, 0.06406947898089654, 0.06342850570876157, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.11943364695601921, 0.11152392165325742, 0.13345086981233123, 0.12241869758974122, 0.11291315241448519, 0.11209459562143187, 0.12245976138762271, 0.15551727145021577, 0.1703974739482157, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013141581586247786, 9.999999999998899e-05, 9.999999999998899e-05, 0.14045955845125757, 0.12828486919926618, 0.06671490694369331, 0.0924404736165847, 0.08167024703901915, 0.08528918849307687, 0.1207914665021157, 0.097254356235138, 0.1070176662487543, 0.10511484148144368, 0.0693612576838919, 0.11426612400253489, 0.10267165755511809, 0.07931457946705, 0.05467121370597072, 0.05054207547117695, 0.05903250263678039, 0.048669747187966794, 0.041290939491402834, 0.04747458665746085, 0.13480174570059533, 0.128372137474824, 0.14763022729669195, 0.13835588195550608, 0.1234420331220768, 0.14134684089344574, 0.14969714796693134, 0.13848235472754333, 0.14689007985489466, 0.020280243842782153, 0.015916393435176368, 0.033606264839354805, 0.027015293023570086, 0.03507791481618483, 0.04800975920179262, 0.02470562103819962, 0.06802001642574851, 0.03231780972058551]}, "mutation_prompt": null}
{"id": "2dc97f8d-904e-4351-81c4-6df5ef2aa061", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA_P:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.mut_prob_adapt = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability self.mut_prob_adapt\n                if random.random() < self.mut_prob_adapt:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability self.mut_prob_adapt\n                if random.random() < self.mut_prob_adapt:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea_pp = CEA_P(budget=100, dim=10)\nbest, score = cea_pp(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA_P", "description": "Novel \"Crossover-Elitism-Adaptation-Probabilistic\" (CEA-PP) algorithm combining crossover, elitism, adaptation, and probabilistic mutation to handle black box optimization problems.", "configspace": "", "generation": 21, "fitness": 0.04936676904275618, "feedback": "The algorithm CEA_P got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.1469188217882218, 0.10953341373984171, 0.10598740786999239, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.013814659350043224, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.0009981134593158858, 0.005800121005278935, 0.019473937103808514, 0.01959972157639278, 0.005200484269715755, 0.0005463471485287474, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.007924279624300645, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.08830143675418645, 0.07230632897820721, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000526389808422012, 0.0008925167401361289, 9.999999999998899e-05, 0.009956997617133645, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004388062927209058, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.11326680672081435, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.1439193150286323, 0.20540295272958953, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.00046985298161705824, 0.0001915116770953018, 0.0267656688986897, 0.09152709102516765, 0.10014999821246451, 0.11842175776965747, 0.09855305120349966, 0.1094965015598196, 0.10798713552628325, 0.09047898407833765, 0.11058047571209206, 0.07726393575557644, 0.12198020896986961, 0.10011387581974052, 0.1613932299901245, 0.14689782692421083, 0.1138073754026484, 0.1330624685394881, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.06482774613352726, 0.09059235353907458, 0.06342850570876157, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.1716130449738621, 0.12866738985068438, 0.13345086981233123, 0.11261179265533539, 0.10453452369738936, 0.11226255832573329, 0.13632486234016938, 0.18460155155725932, 0.1263128396455624, 9.999999999998899e-05, 0.001937402904386154, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09641446351525118, 9.999999999998899e-05, 9.999999999998899e-05, 0.12013401464402762, 0.07088004647488666, 0.10472292595718868, 0.08167024703901915, 0.07888537325598466, 0.1207914665021157, 0.10640380792774451, 0.1070176662487543, 0.10511484148144368, 0.08173755496777668, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.07579802256454282, 0.03738259240699027, 0.08850897018222581, 0.05958192016848518, 0.04019044166964181, 0.07660466861658366, 0.14048935581805744, 0.13370765466483225, 0.14763022729669195, 0.14891919000560505, 0.12908216511952775, 0.13233279814316334, 0.14969714796693134, 0.14495622343407433, 0.14689007985489466, 0.044129132237508584, 0.019306411813072577, 0.031393493129599714, 0.03285095020164064, 0.03425093938292756, 0.02975863851524896, 0.02743568294762444, 0.04064158904746529, 0.01995688594575662]}, "mutation_prompt": null}
{"id": "eb14375b-ef34-46cf-9f4c-4d0e934e746c", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.mut_prob_adapt = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with a probability of 0.4\n                if random.random() < self.mut_prob_adapt:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with a probability of 0.4\n                if random.random() < self.mut_prob_adapt:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEA(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA", "description": "Novel \"Crossover-Elitism-Adaptation\" (CEA) algorithm with adaptive mutation, crossover, and elitism.", "configspace": "", "generation": 22, "fitness": 0.04849483623410854, "feedback": "The algorithm CEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.0900254662497022, 0.09206166950016736, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.0006854643323673804, 0.00014749696603977291, 0.0065563424078535215, 0.01959972157639278, 0.0004952459975243739, 0.0390407802635474, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 0.023078655456611696, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.08224659834595494, 0.08196788271005895, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022241092610113422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03516524201363391, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.1869716336682563, 0.10274288241579344, 0.09580441870675127, 0.166420235606484, 0.15126975725564495, 0.1301938893652621, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.020010801357905228, 0.01759993274736349, 0.007194423111090531, 9.999999999998899e-05, 0.0267656688986897, 0.08494000004272728, 0.09348943462411441, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.09189164674941708, 0.08260919132034228, 0.08218905280843214, 0.11116713569748904, 0.10351907148093253, 0.1613932299901245, 0.13800672315110074, 0.14307855804078007, 0.1341387818151355, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.07932491364234173, 0.041361387767345326, 0.08398582550377798, 0.08943276547640511, 0.08318101130299094, 0.06342850570876157, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.12087941211198572, 0.10631791667954604, 0.1400654144243868, 0.1103568689991713, 0.11926567252544629, 0.11221723671299166, 0.1253197164626657, 0.0951302622853365, 0.12649721129039426, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08722216753133272, 0.09270710397159598, 0.09037423086941432, 0.08167024703901915, 0.0764761277848407, 0.1207914665021157, 0.06661401029160186, 0.12737893763928698, 0.10511484148144368, 0.0693612576838919, 0.11040265245322212, 0.10267165755511809, 0.1198354750097207, 0.05321715300741381, 0.0793405339163824, 0.06024402845774279, 0.04690376827171172, 0.08098911137264153, 0.06285086426231778, 0.13661448263050757, 0.14619168386061743, 0.14763022729669195, 0.1302701688614738, 0.13666300031548284, 0.13233279814316334, 0.14969714796693134, 0.1356735500083983, 0.14689007985489466, 0.034080992001312316, 0.017192502564179257, 0.031393493129599714, 0.033187721685754124, 0.03515706760760273, 0.05396651382059703, 0.027198381021635076, 0.03803354422653826, 0.018472062368497966]}, "mutation_prompt": null}
{"id": "219e9492-c25a-4e96-ac53-50bd35eb015d", "solution": "import numpy as np\nimport random\n\nclass CEA_P:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.prob_adj = 0.4  # Probability adjustment for adaptation\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob * self.prob_adj:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob * self.prob_adj:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size * self.prob_adj:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea_p = CEA_P(budget=100, dim=10)\nbest, score = cea_p(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA_P", "description": "Novel \"Crossover-Elitism-Adaptation-Probability\" (CEA-P) algorithm combining crossover, elitism, adaptation, and probability adjustment to handle black box optimization problems.", "configspace": "", "generation": 23, "fitness": 0.04920485988764035, "feedback": "The algorithm CEA_P got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.08622955116472786, 0.1321581523859381, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.008589236878715378, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.033361161646146, 0.007792397052521438, 0.010674738340807233, 0.009056347294588152, 0.0055942540829527765, 0.005530856755603275, 0.01959972157639278, 0.0013546092558224254, 0.0005906172330072401, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.024499572125370794, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10659256219466273, 0.08224659834595494, 0.08390450857222209, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 0.002061436368508973, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.058474033719137175, 0.004012962079352089, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006486784522042877, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.11205154231340697, 0.10274288241579344, 0.10347014096657692, 0.16112956940342849, 0.16711197210385476, 0.12946082470745313, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.004172139992802082, 0.009195643275209275, 0.0267656688986897, 0.09684334306216402, 0.08609370886951351, 0.11842175776965747, 0.10278184778392419, 0.10852972522114013, 0.10798713552628325, 0.09981713516287838, 0.08526061696970977, 0.07726393575557644, 0.14009916246796106, 0.11012970126339805, 0.1613932299901245, 0.13800672315110074, 0.12311235387757546, 0.1490336571120624, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.038461293329320356, 0.08398582550377798, 0.07199106539100575, 0.06406947898089654, 0.06540683328052821, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.15251380019989125, 0.12074238155767925, 0.13345086981233123, 0.11907857631656826, 0.12060422876960442, 0.129577054772394, 0.1835989688077334, 0.13579735847403462, 0.12632604840752315, 9.999999999998899e-05, 0.06285953295793334, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04389538166964613, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05593315713088176, 0.08645968212960853, 0.09356692537322675, 0.07327841830047488, 0.1207914665021157, 0.11687582083602888, 0.1070176662487543, 0.10511484148144368, 0.06988240305594029, 0.11040265245322212, 0.10267165755511809, 0.07290739920571798, 0.0506857903344724, 0.05018330661524306, 0.05903250263678039, 0.09502539298357537, 0.07222412040997228, 0.0895381369969731, 0.13480174570059533, 0.1286958149016849, 0.14763022729669195, 0.13037481679415364, 0.14856193214926827, 0.13238781521635012, 0.14969714796693134, 0.15913036286664228, 0.15040804785325768, 0.019187330132640845, 0.02434737521388375, 0.036950120043574675, 0.027015293023570086, 0.03425093938292756, 0.0406737628716457, 0.02508900905102074, 0.03803354422653826, 0.043320110684477386]}, "mutation_prompt": null}
{"id": "7fddc04a-1da5-4586-82d7-68825fb4b193", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEA(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA", "description": "Novel \"Crossover-Elitism-Adaptation\" (CEA) algorithm combining crossover, elitism, and adaptation to handle black box optimization problems.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.08269555679369223, 0.11926173084520764, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.008239714075619298, 0.00869301372004283, 0.022587758990378126, 0.01959972157639278, 0.0004952459975243739, 0.018075393015621777, 0.014763392921912755, 9.999999999998899e-05, 0.010809199885924659, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.05834989649846811, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10171571102352206, 0.09141477819664201, 0.11830781833051607, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0017901386843400813, 0.0025712693283350685, 0.03498472865031821, 9.999999999998899e-05, 9.999999999998899e-05, 0.01037140587757679, 9.999999999998899e-05, 9.999999999998899e-05, 0.013100713419623156, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02685300756072151, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.1462019206317029, 0.20499761623267976, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.021941347472017703, 0.023244722697200237, 0.040846886701373264, 0.003871209781588947, 0.0267656688986897, 0.08921158065422274, 0.08609370886951351, 0.11842175776965747, 0.13309198542354084, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.09241484460435057, 0.10820985779664971, 0.10129103634474745, 0.1202975771402458, 0.1613932299901245, 0.1427520131297464, 0.1226705614457484, 0.12269294519270679, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.06158668998215977, 0.03973031259486837, 0.08398582550377798, 0.07631035699861244, 0.07412494361789612, 0.09305662202761156, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.13111992714980247, 0.14359556787874028, 0.13345086981233123, 0.14299902572704537, 0.11113182248826148, 0.12052665218506586, 0.13021107279712574, 0.11993135107376562, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 0.07646948265609277, 9.999999999998899e-05, 9.999999999998899e-05, 0.14565818743850145, 9.999999999998899e-05, 0.1373631695896611, 9.999999999998899e-05, 0.11038134831150948, 0.07634020855071688, 0.08167024703901915, 0.10240435520724822, 0.1207914665021157, 0.13425210128851683, 0.1070176662487543, 0.10511484148144368, 0.15289029317872027, 0.11040265245322212, 0.10299499138871093, 0.0830863240693972, 0.0506857903344724, 0.04676039199241877, 0.06300922594618863, 0.048891192759423774, 0.0681427037084803, 0.14076369017220147, 0.1581083475383993, 0.15067299874205797, 0.14763022729669195, 0.11744712740397156, 0.1420346514143146, 0.13233279814316334, 0.14969714796693134, 0.14289129437403425, 0.14689007985489466, 0.038841183226393294, 0.0213707687617265, 0.03318456582171292, 0.029654596881496964, 0.03425093938292756, 0.020045516730027746, 0.0375775881235646, 0.03803354422653826, 0.029147421371172877]}, "mutation_prompt": null}
{"id": "93d5514d-7e92-4be0-8f60-edf917f35655", "solution": "import numpy as np\nimport random\n\nclass CEA_P:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.mut_prob_elite = 0.1\n        self.crossover_prob_elite = 0.5\n        self.adapt_prob_elite = 0.6\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with a probability of 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with a probability of 0.5\n                if random.random() < 0.5:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual with a probability of 0.1\n                if random.random() < 0.1:\n                    population[np.argmin(scores)] = best\n\n            # Mutation\n            if random.random() < self.mut_prob:\n                # Randomly select an individual\n                idx = random.sample(range(self.population_size), 1)\n                # Mutate the individual with a probability of 0.1\n                if random.random() < 0.1:\n                    population[idx] += np.random.uniform(-1.0, 1.0, self.dim)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea_P = CEA_P(budget=100, dim=10)\nbest, score = cea_P(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA_P", "description": "Novel \"Crossover-Elitism-Adaptation-Probabilistic\" algorithm combining crossover, elitism, and adaptation with probabilistic mutation and crossover.", "configspace": "", "generation": 25, "fitness": 0.050580472556445696, "feedback": "The algorithm CEA_P got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.1670677311665566, 0.09413355150655955, 0.09169502728636048, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.08131212635532015, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011193629194374832, 0.01467079663371329, 0.007783790698912552, 0.010643411704069683, 0.006592353378601756, 0.007079848508821263, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.0049234137216939144, 0.00033010192231663904, 0.004379138421920836, 0.01959972157639278, 0.010491772585013548, 0.005529005675475873, 0.022573970730133786, 9.999999999998899e-05, 0.006267881816156895, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.08512107456076679, 0.08937422492651803, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 0.03693112942250487, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002137976605284142, 9.999999999998899e-05, 0.01252009938580434, 0.007619106468079728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00872285111012916, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026316275116893717, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09616116142468145, 0.16112956940342849, 0.12878660001738718, 0.17385610071243596, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.008000304698809857, 0.01759993274736349, 0.01089272681153508, 0.0028818055366793827, 0.0267656688986897, 0.11634967777672789, 0.08609370886951351, 0.11842175776965747, 0.09990065874986032, 0.10887457403921963, 0.10798713552628325, 0.09722790484171695, 0.0888990146114278, 0.07726393575557644, 0.11281375100746771, 0.10410327008718923, 0.1613932299901245, 0.15356564426339303, 0.1256216869651695, 0.1315582354432523, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.07645901522431608, 0.09681202049435711, 0.07061621818417552, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.14782666574374692, 0.13794615878042027, 0.13345086981233123, 0.12044398148671331, 0.12119480352460155, 0.13219641555197637, 0.12697122399399197, 0.1225523307432197, 0.129685504790376, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12591277427918335, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12179639582274127, 9.999999999998899e-05, 0.06627909579476199, 0.09497824889183049, 0.08167024703901915, 0.08187210435971448, 0.1207914665021157, 0.11337322427276886, 0.1070176662487543, 0.10511484148144368, 0.07525224109490503, 0.11040265245322212, 0.10267165755511809, 0.13425330442963113, 0.0506857903344724, 0.08526766654196016, 0.06777101548915088, 0.12228280829787286, 0.056555730969735984, 0.05090470377232437, 0.14172460247311047, 0.13790256062962614, 0.14763022729669195, 0.15327550612431173, 0.14274849074118612, 0.14580578611495365, 0.14969714796693134, 0.13330791369325068, 0.14689007985489466, 0.02628452331126574, 0.029180109583223257, 0.031393493129599714, 0.04064130500467289, 0.03425093938292756, 0.035026063346532466, 0.04669889941464789, 0.03803354422653826, 0.03665570621098557]}, "mutation_prompt": null}
{"id": "441e6d70-601e-4eb8-a3ad-78b477e8d2cb", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA_P:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.prob_adjust = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Probability adjustment\n            if random.random() < self.prob_adjust:\n                # Randomly adjust the probability of each operation\n                self.mut_prob *= (1 + random.random() * 0.2 - 0.1)\n                self.crossover_prob *= (1 + random.random() * 0.2 - 0.1)\n                self.adapt_prob *= (1 + random.random() * 0.2 - 0.1)\n                self.elite_size *= (1 + random.random() * 0.2 - 0.1)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea_p = CEA_P(budget=100, dim=10)\nbest, score = cea_p(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA_P", "description": "Novel \"Crossover-Elitism-Adaptation-Probability\" (CEA-P) algorithm combining crossover, elitism, adaptation, and probability adjustment to handle black box optimization problems.", "configspace": "", "generation": 26, "fitness": 0.05114693929980433, "feedback": "The algorithm CEA_P got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.14482529306954273, 0.10015819940513082, 0.09169502728636048, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07666066813716155, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01923288176061455, 0.005375109906600173, 0.025642455687028498, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.005972817921024998, 0.0004292391922885441, 0.009262371270433833, 0.01959972157639278, 0.008214753397389307, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022420706863353734, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.14832690174784802, 0.10193879841293985, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02513875876132099, 9.999999999998899e-05, 0.0071993107415306845, 0.02382374298201062, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01243717636871644, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039655036929774345, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12192360416011838, 0.15756555760738078, 0.14838054695461433, 0.11400128386588171, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.12492676847575135, 0.24185378008026426, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.015912142415452912, 0.001994005447326752, 0.0267656688986897, 0.08823795577116378, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.09158801672290373, 0.09861288131100077, 0.08261876756404085, 0.1000601840327543, 0.1173565728534941, 0.1613932299901245, 0.14078693750261861, 0.1252395939465274, 0.13083726855613897, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.042452249921991814, 0.08398582550377798, 0.06945435988871762, 0.06776995238775563, 0.06742222912598284, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.14673990916816926, 0.12840710640191988, 0.13962994399292106, 0.11958775968602164, 0.1127247962929705, 0.1272230515247127, 0.1428088655817057, 0.12470524464333299, 0.13496978541507065, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0996172689307343, 9.999999999998899e-05, 9.999999999998899e-05, 0.137087042080408, 0.12331471809132744, 0.0932357462186234, 0.07466602457976645, 0.09315367745398706, 0.09553807161652916, 0.1207914665021157, 0.09042776036745048, 0.1070176662487543, 0.10511484148144368, 0.07941103509057534, 0.12573008628882176, 0.10267165755511809, 0.10001496958845324, 0.06127541860781671, 0.03738259240699027, 0.05903250263678039, 0.06176267918426015, 0.07050411097396025, 0.05515439140078593, 0.14296295427164496, 0.14774984433596605, 0.1635123078692674, 0.11861123511127625, 0.14226579785068028, 0.15321924147122867, 0.151267168590555, 0.1475237645663663, 0.14689007985489466, 0.03171602842975885, 0.03068324041033721, 0.035066938941048065, 0.037062058997245684, 0.03530927834555586, 0.03160087196188033, 0.02518814612366116, 0.03803354422653826, 0.03754188942582226]}, "mutation_prompt": null}
{"id": "18b213a1-d652-4fbd-9da8-0d1c47a09a64", "solution": "import numpy as np\nimport random\n\nclass CEA_P:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.prob_mut = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                if random.random() < self.prob_mut:\n                    population[np.argmin(scores)] = new_individual\n                else:\n                    population[np.argmin(scores)] = population[np.argmin(scores)]\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                if random.random() < self.prob_mut:\n                    population[np.argmin(scores)] = child\n                else:\n                    population[np.argmin(scores)] = population[np.argmin(scores)]\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea_p = CEA_P(budget=100, dim=10)\nbest, score = cea_p(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA_P", "description": "Novel \"Crossover-Elitism-Adaptation-Probabilistic\" (CEA-P) algorithm combining crossover, elitism, adaptation, and probabilistic mutation to handle black box optimization problems.", "configspace": "", "generation": 27, "fitness": 0.049737009035089076, "feedback": "The algorithm CEA_P got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.1685917924032856, 0.08108763387163931, 0.09169502728636048, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.028867232814581256, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.014670453314812426, 0.003894602531928082, 0.014881404209753812, 0.01959972157639278, 0.004552349424261193, 0.002314472415595681, 0.020033194184721492, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012085341896968527, 0.033830863165074, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.08224659834595494, 0.09429072134424699, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005095807822470988, 9.999999999998899e-05, 0.0001606070206767729, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.19247638963784197, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.0989851747958077, 0.16112956940342849, 0.17718244074198608, 0.15838531072097817, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.023403237640394425, 0.01759993274736349, 0.05573084244229831, 0.013404976078707609, 0.0267656688986897, 0.08494000004272728, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.08904396521951807, 0.08099219012337167, 0.0871559228890868, 0.11450009745904699, 0.10488205528592787, 0.1613932299901245, 0.13800672315110074, 0.14016170665159622, 0.13573178549117926, 0.12028165949079228, 0.17377774300845283, 0.11577990066930566, 0.05985564337097804, 0.06580677318556394, 0.08398582550377798, 0.056957211629895754, 0.07814304690057727, 0.07242958521118159, 0.0837317855149382, 0.0997711199450243, 0.06947703352836176, 0.12148649341890472, 0.11956319760648837, 0.13345086981233123, 0.13044268836865902, 0.1275494475537554, 0.11385445928742977, 0.12406357426812353, 0.13298367034153302, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11320337905362887, 9.999999999998899e-05, 9.999999999998899e-05, 0.12348580596714076, 0.060152668828842404, 0.08468030763415868, 0.08167024703901915, 0.09211202129397589, 0.1207914665021157, 0.09302958140504902, 0.1070176662487543, 0.10511484148144368, 0.09106206515098059, 0.15702541545987003, 0.10267165755511809, 0.06932034027342138, 0.0506857903344724, 0.03738259240699027, 0.05903250263678039, 0.06896380895382281, 0.05139244610747573, 0.05386499249955523, 0.13936980387938003, 0.13565439535358714, 0.14763022729669195, 0.13745152747816414, 0.13078343087882172, 0.15439983674774083, 0.14969714796693134, 0.12684644530366185, 0.15068933319680256, 0.03459798517771995, 0.048194121828342595, 0.0329275486477818, 0.027015293023570086, 0.03425093938292756, 0.020045516730027746, 0.0231238815690058, 0.03803354422653826, 0.03267244183415241]}, "mutation_prompt": null}
{"id": "736b6c3e-fce3-46fb-9c17-da2c8e4af96e", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA_P:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.prob_adjust = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Probability adjustment\n            if random.random() < self.prob_adjust:\n                # Randomly adjust the probability of adaptation, crossover, and elitism\n                self.adapt_prob = np.random.uniform(0.3, 0.5)\n                self.crossover_prob = np.random.uniform(0.6, 0.9)\n                self.elite_size = np.random.uniform(5, 15)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea_p = CEA_P(budget=100, dim=10)\nbest, score = cea_p(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA_P", "description": "Novel \"Crossover-Elitism-Adaptation-Probability\" (CEA-P) algorithm combining crossover, elitism, adaptation, and probability adjustment to handle black box optimization problems.", "configspace": "", "generation": 28, "fitness": 0.05067025690667629, "feedback": "The algorithm CEA_P got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.09502759990276388, 0.09647823610551354, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.09401518962003896, 0.07597095646549801, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.013900771529028466, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.02098826741406934, 9.999999999998899e-05, 0.018661351736555476, 0.01959972157639278, 0.004397840744349346, 0.0036942012855788464, 0.014763392921912755, 9.999999999998899e-05, 0.002951146277193062, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10044001302629801, 0.08224659834595494, 0.09419057701918332, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.03961817628320641, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02840613662824909, 9.999999999998899e-05, 0.006902789538433041, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031910588953065755, 9.999999999998899e-05, 0.03454035846183323, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.12116784814788539, 0.21798585387931013, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.004848735513139357, 0.01759993274736349, 0.011780248315693798, 9.999999999998899e-05, 0.0267656688986897, 0.08494000004272728, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.09835340181074737, 0.08099219012337167, 0.08054800852068311, 0.11462611040941229, 0.0962505644704219, 0.1613932299901245, 0.15276342048548308, 0.13564454770421652, 0.11919205265845834, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.09458572525426767, 0.06865677896725098, 0.11958125696392585, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.13598124982600968, 0.11118184627290117, 0.13345086981233123, 0.1650004817640216, 0.14075807620518532, 0.15022354221026268, 0.12975817464105244, 0.12663395081150042, 0.13804904177427002, 9.999999999998899e-05, 9.999999999998899e-05, 0.1268320383546594, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1205684833381181, 0.11966060373051701, 0.1102503589550401, 0.08479533190861899, 0.0858783374692057, 0.1207914665021157, 0.09443252366757149, 0.11521072290790013, 0.10511484148144368, 0.07802076173137229, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.06908845941114994, 0.07917941891276092, 0.05903250263678039, 0.04690376827171172, 0.07548158365739821, 0.06948413853312108, 0.14088292886697273, 0.1339828425499232, 0.14763022729669195, 0.14561992379263666, 0.14959667791082776, 0.15181032934554117, 0.15067683979164703, 0.14217332570851338, 0.14841988222213842, 0.03034235212709302, 0.049577028740940166, 0.032419938321720854, 0.03281959929516454, 0.03425093938292756, 0.029725365745083, 0.020442866136979876, 0.03803354422653826, 0.037523326538564494]}, "mutation_prompt": null}
{"id": "de4633b8-2f38-4278-a8d6-63773e5f5939", "solution": "import numpy as np\nimport random\n\nclass CEAP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.prob_adapt = 0.4\n        self.prob_mut = 0.1\n        self.prob_crossover = 0.8\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.prob_adapt:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.prob_crossover:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Mutation\n            if random.random() < self.prob_mut:\n                # Randomly select an individual\n                idx = random.randint(0, self.population_size - 1)\n                # Mutate the individual\n                population[idx] += np.random.uniform(-1.0, 1.0, self.dim)\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAP(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAP", "description": "Novel \"Crossover-Elitism-Adaptation-Probability\" (CEAP) algorithm combining crossover, elitism, adaptation, and probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 29, "fitness": 0.05123959373036572, "feedback": "The algorithm CEAP got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.16812661451717925, 0.09172695237942663, 0.1096662819561488, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.10355086109130007, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02452865330737153, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.008420211210528605, 0.017684794180439556, 0.019436176476258504, 0.01959972157639278, 0.02392430580378535, 0.0034557843647755604, 0.028970267257115823, 9.999999999998899e-05, 0.009291697484062, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.028155276407965335, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10687305383139356, 0.0857214519892443, 0.10131032314548538, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.09672752757371239, 0.03310012715912869, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0022989217872078083, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019517144022835442, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11654139544954778, 0.15756555760738078, 0.14838054695461433, 0.1146397415780892, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.14749711544973176, 0.1659196112594642, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.007497753745455915, 0.01808009172149927, 9.999999999998899e-05, 9.999999999998899e-05, 0.0267656688986897, 0.09045897354558752, 0.09820661030325795, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.09274576143306368, 0.08099219012337167, 0.07858697146962246, 0.09606267484187503, 0.11528594687815907, 0.1613932299901245, 0.15564866275877665, 0.14494716980230637, 0.11394240824531188, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.08743126285163016, 0.07629352584526883, 0.065249232332794, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.15779355597287426, 0.11473313651569583, 0.13365542788306362, 0.11966293039827902, 0.12822208145093994, 0.12541849062794486, 0.12245976138762271, 0.10755822253769443, 0.12664038792964527, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13446445499961535, 9.999999999998899e-05, 9.999999999998899e-05, 0.12857168535335972, 9.999999999998899e-05, 9.999999999998899e-05, 0.08073841189629438, 0.07660117323766957, 0.10909445346028201, 0.08411515347299425, 0.1207914665021157, 0.11948746077352645, 0.1070176662487543, 0.10511484148144368, 0.08867914119961096, 0.11040265245322212, 0.10267165755511809, 0.09982069416814587, 0.06713261413530613, 0.04853258846521946, 0.09784144095620972, 0.06406312468177366, 0.07180029108109087, 0.07824576732673827, 0.1361047477299011, 0.1333949046934806, 0.15222188806487325, 0.14446935444593323, 0.15467389552154998, 0.1458947172362749, 0.1532506248992801, 0.15091631223059032, 0.15178280831981628, 0.03537242622824399, 0.027974687147078847, 0.03491784628147454, 0.027094594452969023, 0.03425093938292756, 0.03136564517696494, 0.021468562404239333, 0.03803354422653826, 0.04254415346951779]}, "mutation_prompt": null}
{"id": "778a3d17-9ba6-428a-829a-bd607bce5c6f", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA_Probabilistic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.prob_threshold = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 0.4\n                if random.random() < self.prob_threshold:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability 0.4\n                if random.random() < self.prob_threshold:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea_prob = CEA_Probabilistic(budget=100, dim=10)\nbest, score = cea_prob(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA_Probabilistic", "description": "Novel \"Crossover-Elitism-Adaptation-Probabilistic\" algorithm combining crossover, elitism, and adaptation with probabilistic modifications to handle black box optimization problems.", "configspace": "", "generation": 30, "fitness": 0.0472673565681208, "feedback": "The algorithm CEA_Probabilistic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.14982160226375363, 0.08108763387163931, 0.11305389842285496, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02460359899926534, 0.005375109906600173, 0.01955358795383455, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.021150319531248685, 0.010674738340807233, 0.008161698047968291, 0.004370427802528831, 0.010981469575936376, 0.01959972157639278, 0.0004952459975243739, 9.999999999998899e-05, 0.02954684353613246, 0.0009222790380414292, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 0.007354542616885951, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.08337210233015413, 0.06909307132208797, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01637410162732089, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.13223331298085672, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.12229450893260418, 0.1261336558415489, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.004900075800189696, 9.999999999998899e-05, 0.0267656688986897, 0.0886638497558242, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10902732340870247, 0.089467935195921, 0.08475664851204079, 0.07726393575557644, 0.11544687275710841, 0.11626053677880732, 0.1613932299901245, 0.13800672315110074, 0.1305104700318761, 0.14518080793594268, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.03779573042495177, 0.08398582550377798, 0.08790664236750168, 0.06514553152166869, 0.06793593108082241, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.11943364695601921, 0.10757569876818796, 0.13472718145382423, 0.11977598527806765, 0.14465101980762063, 0.11189290013657649, 0.12420457307946231, 0.11129731956021827, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07560944845061912, 0.08529305917088059, 0.08167024703901915, 0.0755993585821294, 0.1207914665021157, 0.06661401029160186, 0.1070176662487543, 0.10511484148144368, 0.0693612576838919, 0.1249166976150502, 0.10267165755511809, 0.06932034027342138, 0.05238397378571058, 0.03913841843812338, 0.05903250263678039, 0.09929118715674434, 0.04378544777120008, 0.09385171116391233, 0.13480174570059533, 0.14064046295487964, 0.14763022729669195, 0.14050404513312442, 0.12843136379130848, 0.1353823468776454, 0.14969714796693134, 0.13516161570704244, 0.14689007985489466, 0.0172592829629169, 0.03594367025494338, 0.03536338374948378, 0.027015293023570086, 0.03425093938292756, 0.026443554041316597, 0.022046052525070414, 0.03803354422653826, 0.05484587216911985]}, "mutation_prompt": null}
{"id": "a3a6211c-0f81-45de-a6b2-3887432760b6", "solution": "import numpy as np\nimport random\n\nclass CEA_P:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.prob_adjust = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Probability adjustment\n            if random.random() < self.prob_adjust:\n                # Randomly select an individual\n                idx = random.randint(0, self.population_size - 1)\n                # Randomly adjust its mutation, crossover, and adaptation probabilities\n                self.mut_prob = np.random.uniform(0.0, 0.2)\n                self.crossover_prob = np.random.uniform(0.0, 0.9)\n                self.adapt_prob = np.random.uniform(0.0, 0.5)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea_p = CEA_P(budget=100, dim=10)\nbest, score = cea_p(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA_P", "description": "Novel \"Crossover-Elitism-Adaptation-Probability\" algorithm combining crossover, elitism, and adaptation with probability adjustment.", "configspace": "", "generation": 31, "fitness": 0.0516695079871916, "feedback": "The algorithm CEA_P got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11973508912116904, 0.08108763387163931, 0.10593360984352218, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07617759455220563, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014482999328349067, 0.022900230304674696, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.009185567056039456, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.007497376422652469, 0.0077868504443520115, 0.014422483586781887, 0.03569136864440392, 0.003029367187865839, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.03810987689134948, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.1013250330543013, 0.10420760673063245, 0.10547808189673957, 0.0667108215001172, 0.07285119553694963, 0.030440126545241752, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04012194616834386, 9.999999999998899e-05, 0.005037402922138945, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010094077730296025, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.14250101391801928, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.17472558650052794, 0.21640192863204222, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.0004888810374150676, 0.01759993274736349, 0.0029043855006901653, 0.012494343359006566, 0.0267656688986897, 0.09188514096414313, 0.09539784249404115, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.0978448602472588, 0.08099219012337167, 0.0881067648853252, 0.1177212997251239, 0.0962505644704219, 0.1613932299901245, 0.13800672315110074, 0.14729445290387633, 0.15388149441654586, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.0610031396088736, 0.0664245133487712, 0.07363924317121195, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.13817633784912486, 0.1346624588789297, 0.13951007259268922, 0.12514056026033926, 0.11162924636187599, 0.11853488568393566, 0.12245976138762271, 0.13240696948338082, 0.1263378137812844, 9.999999999998899e-05, 0.002020153188454832, 0.1175933664505654, 9.999999999998899e-05, 9.999999999998899e-05, 0.1179554705333623, 0.131978979442667, 9.999999999998899e-05, 0.10758888476565875, 0.12465887670735742, 0.07466602457976645, 0.08167024703901915, 0.07327841830047488, 0.1207914665021157, 0.07178601368715476, 0.1070176662487543, 0.10511484148144368, 0.09111563508066356, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.0717297762519229, 0.044576217094110526, 0.05903250263678039, 0.07843855563911528, 0.06547255034827648, 0.050103868714291844, 0.13488974430752465, 0.1778978835609658, 0.14763022729669195, 0.13015323769963816, 0.1519271840579004, 0.1391558471544202, 0.14969714796693134, 0.15526863209610542, 0.146904442807252, 0.03027763342880785, 0.03308856845048758, 0.033162012822644304, 0.027015293023570086, 0.03425093938292756, 0.03680169783852505, 0.039515634640386654, 0.042244722958541536, 0.04865786479391754]}, "mutation_prompt": null}
{"id": "97e51859-16f6-481d-be2a-ec18a2c6c362", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA_P:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.prob_adapt = 0.4\n        self.prob_crossover = 0.8\n        self.prob_elite = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.prob_adapt:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.prob_crossover:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability 0.8\n                if random.random() < 0.8:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.prob_elite:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea_p = CEA_P(budget=100, dim=10)\nbest, score = cea_p(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA_P", "description": "Novel \"Crossover-Elitism-Adaptation-Probability\" algorithm combining crossover, elitism, and adaptation with probability-based decision making.", "configspace": "", "generation": 32, "fitness": 0.04966245715592516, "feedback": "The algorithm CEA_P got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.14282234671026306, 0.0977871948526734, 0.15033154046284491, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07992211817148343, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0071874787969195, 0.016084370920641744, 0.008485256261643204, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.02685322732639428, 0.022090326345523992, 0.01726437652665136, 0.023693928473653814, 0.018705153478719705, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015355996173942454, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10295491438346527, 0.0847471079008979, 0.08731019372428184, 0.0667108215001172, 0.07285119553694963, 0.010073877631196604, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013971876006392825, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011591136862883489, 9.999999999998899e-05, 0.037863805628794545, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.15211019008887672, 0.10907270137789071, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.11127761470871589, 0.16074016929849388, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.0074472030569348036, 0.01759993274736349, 0.019723839989641778, 9.999999999998899e-05, 0.0267656688986897, 0.09908981949003715, 0.09656573697838833, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.08099219012337167, 0.08286473346432699, 0.1073118709733839, 0.12384884436267807, 0.1613932299901245, 0.13800672315110074, 0.12718785179124914, 0.12686349765058202, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.08828456086515435, 0.08361615112017584, 0.07817443979653804, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.11943364695601921, 0.13942803063725673, 0.1521778089004574, 0.1103568689991713, 0.12816477387965075, 0.11755242467196914, 0.17176522505140512, 0.12712230056205276, 0.14276570647422848, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.032150071093323684, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05938094461724197, 0.09923599815709983, 0.08167024703901915, 0.09943952087404084, 0.1207914665021157, 0.07465395138979858, 0.1070176662487543, 0.16570558507050048, 0.0929759142287554, 0.11040265245322212, 0.10900657435560568, 0.06932034027342138, 0.07067515056452178, 0.05020852264131792, 0.05903250263678039, 0.04983905949430212, 0.07325489591292478, 0.08835225163259897, 0.1561535958414002, 0.1449234964679954, 0.15630579459975347, 0.1448670761908485, 0.1337563584462672, 0.14703136222629398, 0.14969714796693134, 0.13502506774390333, 0.14689007985489466, 0.024071380550379162, 0.029063264700964986, 0.03464048735959602, 0.03300823696512345, 0.03425093938292756, 0.026845614086018266, 0.03910525352543137, 0.03803354422653826, 0.039032924355007714]}, "mutation_prompt": null}
{"id": "0daefbcd-f119-4bd2-97ef-b0b1fb7ed42c", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability 0.6\n                if random.random() < 0.6:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEA(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA", "description": "Novel \"Crossover-Elitism-Adaptation\" algorithm with probability-based adaptation and elitism.", "configspace": "", "generation": 33, "fitness": 0.048526631775478, "feedback": "The algorithm CEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.12822186540582536, 0.10068665590972015, 0.11363263497521892, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011264892404947213, 0.01467079663371329, 0.005375109906600173, 0.04073901660044743, 0.006592353378601756, 0.006669962766643223, 0.023735557581642364, 0.007792397052521438, 0.010674738340807233, 0.009189875679053161, 0.006512548118035699, 0.01723326939100045, 0.01959972157639278, 0.0016438105358421717, 0.0013173424317348692, 0.02722808434553503, 9.999999999998899e-05, 0.004153237088199591, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.0345006290036145, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10687756570081342, 0.08224659834595494, 0.0945016090209756, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007312674342297987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00732239344517327, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.11635686912968302, 0.24787683636859348, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.0286434171291976, 0.00915022168135493, 0.028888231771335815, 0.08494000004272728, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.09230648992590063, 0.08099219012337167, 0.07759730318946989, 0.11702220433176336, 0.09740998580447335, 0.1613932299901245, 0.13800672315110074, 0.136712057184309, 0.10735640357344434, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.055860147761545575, 0.08398582550377798, 0.07161036884232785, 0.06707689234119119, 0.0918984875308575, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.12624533255451775, 0.12677390743495764, 0.13345086981233123, 0.13536901097473653, 0.13135711423847662, 0.11337741138110091, 0.12245976138762271, 0.10213794212052074, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0753948309966137, 0.07828379813025677, 0.08167024703901915, 0.07327841830047488, 0.1207914665021157, 0.1250643116498592, 0.1070176662487543, 0.10511484148144368, 0.0693612576838919, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.05110328590415303, 0.07921392372275438, 0.05903250263678039, 0.10835529598778271, 0.05808206216157197, 0.04919318541070972, 0.13480174570059533, 0.128372137474824, 0.14763022729669195, 0.1415815849887978, 0.14246826474023788, 0.14372898232714637, 0.15351124382118175, 0.14026833713839548, 0.14689007985489466, 0.019881383748769466, 0.021994134839283475, 0.03717968824990514, 0.048355712747066404, 0.03425093938292756, 0.03374872917967586, 0.033002971447022134, 0.03803354422653826, 0.03043971437225934]}, "mutation_prompt": null}
{"id": "f113ead9-7293-444a-8904-c136ca5e8bde", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA_P:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.prob_adjustment = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability (1 - self.prob_adjustment)\n                if random.random() > self.prob_adjustment:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability (1 - self.prob_adjustment)\n                if random.random() > self.prob_adjustment:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea_p = CEA_P(budget=100, dim=10)\nbest, score = cea_p(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA_P", "description": "Novel \"Crossover-Elitism-Adaptation-Probability\" (CEA-P) algorithm combining crossover, elitism, adaptation, and probability adjustment to handle black box optimization problems.", "configspace": "", "generation": 34, "fitness": 0.04900497666940132, "feedback": "The algorithm CEA_P got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.08210055655739268, 0.09169502728636048, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.014889224464474271, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.011966410228331337, 0.007368508621454883, 0.00015474719937502712, 0.01959972157639278, 0.0004952459975243739, 9.999999999998899e-05, 0.014763392921912755, 0.008906517061664454, 0.000104105179955849, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004163357234313714, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10078962026664662, 0.08484798933097204, 0.07091472904915808, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 0.012072732827398958, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0029473026164498206, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01191717854307428, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10404858449045351, 0.09580441870675127, 0.16112956940342849, 0.1366253025400923, 0.14607055599212493, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.02089029847439583, 0.01759993274736349, 9.999999999998899e-05, 9.999999999998899e-05, 0.0267656688986897, 0.09060691021153233, 0.10725459005989246, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.1238944091170946, 0.08217163662397398, 0.07726393575557644, 0.11784287398399995, 0.10891033339262979, 0.1613932299901245, 0.13800672315110074, 0.13029158885793823, 0.13142970236966034, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034712368381773384, 0.08398582550377798, 0.07924141040159616, 0.09058093023983071, 0.0653102069121474, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.13671799505891324, 0.11333455187580477, 0.13345086981233123, 0.11798017461063415, 0.12019052324913759, 0.16804876658686574, 0.1424939077236087, 0.1274242887787579, 0.13099985397908387, 0.1323084455925163, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13868032610396075, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07040063344075786, 0.07582344584014022, 0.08167024703901915, 0.07820929011341271, 0.1207914665021157, 0.08056841323216557, 0.1070176662487543, 0.10511484148144368, 0.0969845676240173, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.0506857903344724, 0.041934152583037565, 0.066451157565937, 0.04690376827171172, 0.06809090794845418, 0.04240088492431349, 0.15652078988118523, 0.17245297969705864, 0.14763022729669195, 0.11599487746987158, 0.1450135222102008, 0.13233279814316334, 0.14969714796693134, 0.14455884497581717, 0.14689007985489466, 0.045617089087054974, 0.0410079592481577, 0.038461436502038704, 0.030236794508011866, 0.03425093938292756, 0.03463464029599839, 0.02348032114047871, 0.04084113236178433, 0.03170515062331958]}, "mutation_prompt": null}
{"id": "09e4699d-d645-4507-b97c-a9252ea0dec3", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEAP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.adapt_threshold = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 1-self.adapt_threshold\n                if random.random() < (1-self.adapt_threshold):\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                if random.random() < (1-self.adapt_threshold):\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAP(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAP", "description": "Novel \"Crossover-Elitism-Adaptation-Probability\" (CEAP) algorithm combining crossover, elitism, and adaptation with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 35, "fitness": 0.04976440378569266, "feedback": "The algorithm CEAP got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.0854861097218732, 0.10253221976202276, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07924334972960678, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.030608780468581065, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.006628388520212303, 9.999999999998899e-05, 0.007027406458937513, 0.01959972157639278, 0.0004952459975243739, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.01807038931492677, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10640160942426102, 0.08224659834595494, 0.12108009818746635, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015895779590912595, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0052061693478759885, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005472240824730745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.14005174244525564, 0.15756555760738078, 0.14838054695461433, 0.10382909207599567, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.12919310375819093, 0.1425030362242694, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.004942059350930728, 0.01759993274736349, 0.02028439402959359, 9.999999999998899e-05, 0.0267656688986897, 0.08538494091631166, 0.10734822290913293, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.09669362187388175, 0.09255689596304306, 0.10191529208269146, 0.10580605489465311, 0.11746107916015958, 0.1613932299901245, 0.13800672315110074, 0.13585579471676723, 0.12848424146461568, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.042076719220929926, 0.08398582550377798, 0.06916648118565427, 0.08487469074092968, 0.08372723193719211, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.12920792238456036, 0.13846834704174815, 0.13345086981233123, 0.12018741831770463, 0.11104013983715688, 0.11052691088185351, 0.12245976138762271, 0.12150945411225345, 0.18262234104775876, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08082846412921829, 9.999999999998899e-05, 9.999999999998899e-05, 0.10726262071146697, 0.07921672477732578, 9.999999999998899e-05, 0.10819660406830844, 0.08172171252226268, 0.08167024703901915, 0.08603497097509372, 0.1207914665021157, 0.08024641732624749, 0.1070176662487543, 0.10511484148144368, 0.09233654353377008, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.0506857903344724, 0.0949141352145374, 0.08379909328581103, 0.05750591336856792, 0.07964960548339128, 0.04543407222990503, 0.14328069183236147, 0.13943422191201538, 0.14763022729669195, 0.11599487746987158, 0.13530096814518822, 0.1335788939682392, 0.153911487991801, 0.13326845386095754, 0.1523744534957472, 0.03531880248488872, 0.03859765055108311, 0.031393493129599714, 0.027015293023570086, 0.03425093938292756, 0.0358895278507263, 0.02550434389113232, 0.03803354422653826, 0.02894987825287576]}, "mutation_prompt": null}
{"id": "7f9f097a-f4ab-48e0-a107-34991417a995", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEAProbabilistic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.prob_mut = 0.4\n        self.prob_crossover = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability prob_mut\n                if random.random() < self.prob_mut:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.prob_crossover:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability prob_crossover\n                if random.random() < self.prob_crossover:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea_prob = CEAProbabilistic(budget=100, dim=10)\nbest, score = cea_prob(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAProbabilistic", "description": "Novel \"Crossover-Elitism-Adaptation-Probabilistic\" algorithm combining crossover, elitism, adaptation, and probabilistic mutation to handle black box optimization problems.", "configspace": "", "generation": 36, "fitness": 0.0468724520132969, "feedback": "The algorithm CEAProbabilistic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.08108763387163931, 0.09400513645644992, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 9.999999999998899e-05, 0.0007205707615974832, 0.013336081799273036, 0.01959972157639278, 0.0033071387507099814, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 0.011535526851781497, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.08224659834595494, 0.07359578824157453, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028353926982265354, 9.999999999998899e-05, 0.003265178647093525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.09716408355800721, 0.15822841807559762, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 9.999999999998899e-05, 0.019836529438963635, 0.0267656688986897, 0.08494000004272728, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.09115220781071143, 0.08099219012337167, 0.09576384219511269, 0.13213725404448307, 0.1015288790563107, 0.1613932299901245, 0.13800672315110074, 0.1356986128939901, 0.15775650316085899, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.07383260618126186, 0.06701386991792102, 0.06342850570876157, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.11968408316761192, 0.1127564314980527, 0.13345086981233123, 0.1124374981209576, 0.10257105380115006, 0.11265084281650217, 0.1458907378154949, 0.14060298802121474, 0.12890464357819142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027555788334894138, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07126186368594734, 0.10008822920264449, 0.09314307429944746, 0.07696075886427867, 0.1207914665021157, 0.09443356983450646, 0.1070176662487543, 0.10511484148144368, 0.0693612576838919, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.0506857903344724, 0.03738259240699027, 0.06004076881274545, 0.05532005762506087, 0.046554204081573736, 0.047130825398362, 0.14246615451315303, 0.13341158072221493, 0.14763022729669195, 0.14560141956780548, 0.132299831665746, 0.13233279814316334, 0.14969714796693134, 0.13193285443286074, 0.14689007985489466, 0.03261638481569262, 0.02523555124529664, 0.03980731024870987, 0.044263950593841805, 0.03425093938292756, 0.04271364133926325, 0.017084475105304642, 0.03803354422653826, 0.024389871780470807]}, "mutation_prompt": null}
{"id": "cce5615b-9989-4ab0-ba80-bb5f6f2b830a", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.adapt_thresh = 0.4\n        self.crossover_thresh = 0.8\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability adapt_thresh\n                if random.random() < self.adapt_thresh:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals with probability crossover_thresh\n                if random.random() < self.crossover_thresh:\n                    child = (population[idx1] + population[idx2]) / 2\n                    # Replace the worst individual with the child\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEA(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA", "description": "Novel \"Crossover-Elitism-Adaptation\" (CEA) algorithm with probabilistic adaptation and crossover refinement.", "configspace": "", "generation": 37, "fitness": 0.050722246922037355, "feedback": "The algorithm CEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.10317203143307252, 0.11883920141905013, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.0799370751552031, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.012651086131750477, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.0329876937027328, 0.007792397052521438, 0.010674738340807233, 0.01462292204940896, 0.001402851553774065, 0.02744886488124243, 0.01959972157639278, 0.0004952459975243739, 0.0011620447518969623, 0.014763392921912755, 0.0101200326479568, 0.006825764431151349, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.1035993961694136, 0.08224659834595494, 0.09500480979344372, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003660120337050321, 9.999999999998899e-05, 0.012374663062086566, 9.999999999998899e-05, 9.999999999998899e-05, 0.002771794525991078, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001883488274238343, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.12038661425054109, 0.10274288241579344, 0.14089110872727395, 0.16112956940342849, 0.12627216771227434, 0.13420192968928646, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.0417009090816991, 0.003968563399762259, 0.0267656688986897, 0.09148426208509985, 0.08875426187751978, 0.11842175776965747, 0.10345923867798412, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.09890030988858889, 0.07971571199833183, 0.12708796957329427, 0.0962505644704219, 0.1613932299901245, 0.13800672315110074, 0.12484032408681056, 0.1179046423272776, 0.12028165949079228, 0.17377774300845283, 0.11390037368870087, 0.0669752250585619, 0.043723164915237756, 0.09772304505751472, 0.09108703547822972, 0.09200938471758979, 0.07288189980052007, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.12622276097284935, 0.11041782069079564, 0.1413236900251209, 0.15233081655367953, 0.12322937679462809, 0.13077220029323344, 0.12300195256277235, 0.13756635910851656, 0.12781552126380413, 9.999999999998899e-05, 9.999999999998899e-05, 0.07087587339099066, 0.12611862835566623, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.018880987612318156, 0.07423886932301194, 0.10929913658577584, 0.08167024703901915, 0.07580497948236553, 0.1207914665021157, 0.11365228872168776, 0.1070176662487543, 0.10511484148144368, 0.1059932082020768, 0.11040265245322212, 0.10267165755511809, 0.07413049223837131, 0.0506857903344724, 0.09099849573823138, 0.05903250263678039, 0.23164618743071363, 0.04946571986083437, 0.05439725742007995, 0.13480174570059533, 0.15193132460609216, 0.17171679995510536, 0.12741656877614915, 0.14034239652657687, 0.14965854959025604, 0.15095143624577523, 0.13977741891186268, 0.15142675898255364, 0.024177755552488134, 0.031174366128946196, 0.031393493129599714, 0.027316040226650906, 0.03425093938292756, 0.026740425958214797, 0.032449513459951285, 0.03803354422653826, 0.028728762183876877]}, "mutation_prompt": null}
{"id": "e1ad8141-ef00-4b6e-aaea-51c589182dff", "solution": "import numpy as np\nimport random\n\nclass CEAProbabilistic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.update_prob = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability self.update_prob\n                if random.random() < self.update_prob:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability self.update_prob\n                if random.random() < self.update_prob:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea_prob = CEAProbabilistic(budget=100, dim=10)\nbest, score = cea_prob(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAProbabilistic", "description": "Novel \"Crossover-Elitism-Adaptation-Probabilistic\" algorithm combining crossover, elitism, and adaptation with probabilistic updates.", "configspace": "", "generation": 38, "fitness": 0.04930695518210224, "feedback": "The algorithm CEAProbabilistic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.08108763387163931, 0.17173062077646628, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010910623571957156, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.016881077693220115, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.004081111475307431, 0.02177122795850306, 0.000828316189749656, 0.01959972157639278, 0.002692536962589309, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.08224659834595494, 0.0922373585741858, 0.0667108215001172, 0.07285119553694963, 0.007582992215879103, 0.026279303607937843, 0.05931056463008866, 0.02904263989304745, 0.03395015061804352, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011496390841494564, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09986496143874124, 0.16112956940342849, 0.11562190307236653, 0.16397066762871548, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.007909003602347364, 0.01759993274736349, 0.003474879494376415, 9.999999999998899e-05, 0.03454365846089347, 0.08494000004272728, 0.09537340723307297, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10981335723828056, 0.09520446829362028, 0.08099219012337167, 0.07726393575557644, 0.12440083211283948, 0.12614751757853515, 0.1613932299901245, 0.13800672315110074, 0.13590607913502484, 0.12504821141152567, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034667612319536634, 0.08398582550377798, 0.05792484860614899, 0.08509686488794799, 0.07761458338871052, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.11943364695601921, 0.1350482313167637, 0.17765751951272812, 0.12312818671031689, 0.12288921350397886, 0.1365272476528362, 0.16735047268313263, 0.12817110167362533, 0.1651068956559768, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12140683848723877, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09882895071352482, 0.08397595628470111, 0.11293187061719467, 0.07675799624685353, 0.1207914665021157, 0.06813317215826087, 0.1070176662487543, 0.10561079251071515, 0.0693612576838919, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.058308436174769995, 0.03738259240699027, 0.0642115792686132, 0.0616071576642333, 0.08246726122056625, 0.06629097403175488, 0.13529409917562407, 0.1349747064165132, 0.14763022729669195, 0.1327756091471407, 0.13847851988636628, 0.13233279814316334, 0.15407738187204578, 0.13062717509575794, 0.14689007985489466, 0.044419937719712865, 0.029021999326039216, 0.034069717363921836, 0.029955998749926938, 0.03425093938292756, 0.02604312612893933, 0.03550555848110637, 0.03803354422653826, 0.039670779224235786]}, "mutation_prompt": null}
{"id": "d25d21d3-df7a-4226-a7ba-4b95fbccc3b9", "solution": "import numpy as np\nimport random\n\nclass CEA_P:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.prob_mut = 0.4\n        self.prob_crossover = 0.8\n        self.prob_elite = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                if random.random() < self.prob_mut:\n                    population[np.argmin(scores)] = new_individual + np.random.uniform(-0.5, 0.5, self.dim)\n                else:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.prob_crossover:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                if random.random() < self.prob_mut:\n                    population[np.argmin(scores)] = child + np.random.uniform(-0.5, 0.5, self.dim)\n                else:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.prob_elite:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea_p = CEA_P(budget=100, dim=10)\nbest, score = cea_p(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA_P", "description": "Novel \"Crossover-Elitism-Adaptation-Probabilistic\" algorithm combining crossover, elitism, adaptation, and probabilistic mutation to handle black box optimization problems.", "configspace": "", "generation": 39, "fitness": 0.05002945092626923, "feedback": "The algorithm CEA_P got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.08777132462711257, 0.09785955698827653, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006141929512778477, 0.01467079663371329, 0.013523098438157466, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.01123442041895617, 0.017292968856466917, 0.021371091515337448, 0.01959972157639278, 0.0030843761938722514, 0.005390955608349235, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.0347418246357063, 0.00031549654350837564, 0.025564036341869323, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10190735541266882, 0.09287863038672217, 0.08575121642155359, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034509970984734184, 0.036702845514943516, 0.021029640325402, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.10317354281761526, 0.16112956940342849, 0.1417306694255085, 0.17929008785914324, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.002132769124115863, 0.01759993274736349, 0.008059736622888836, 9.999999999998899e-05, 0.0267656688986897, 0.08540674093752365, 0.10611680760209363, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.10437468468717304, 0.09029162714197847, 0.09470816924603154, 0.09829668859086849, 0.1259277273519026, 0.1613932299901245, 0.13800672315110074, 0.1598119180005586, 0.11846345235554945, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.087471675479326, 0.07700959923655704, 0.09365718462750505, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.14092015800970115, 0.13126630520579619, 0.13345086981233123, 0.13444507504078096, 0.11997085694858, 0.13888879904053242, 0.13485630466146903, 0.12026265641432254, 0.1301083969084157, 9.999999999998899e-05, 0.04753770405217472, 9.999999999998899e-05, 0.059254766855407426, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06722767111526262, 0.10096964698236666, 0.08167024703901915, 0.07739762985429954, 0.1207914665021157, 0.12617045588453857, 0.1070176662487543, 0.10511484148144368, 0.0693612576838919, 0.11040265245322212, 0.10267165755511809, 0.09919919591339421, 0.05144907696783796, 0.0671071644524387, 0.05903250263678039, 0.052914780549411455, 0.06178264218112195, 0.061589327486840206, 0.15563356863068423, 0.1432637454044956, 0.15352165016273978, 0.14884323914302788, 0.13291336855301616, 0.1687080996603716, 0.14969714796693134, 0.14276242500961944, 0.1685656502313745, 0.02627720529581057, 0.02252872994707722, 0.03240264827083428, 0.0358614510759524, 0.03861241063665244, 0.028355146688641586, 0.03803432559958109, 0.03803354422653826, 0.031936518296523]}, "mutation_prompt": null}
{"id": "1d0c6bcd-af12-44e1-b5d4-24adc8ff0d11", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA_P:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.prob_adj = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 1 - self.prob_adj\n                if random.random() > self.prob_adj:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability 1 - self.prob_adj\n                if random.random() > self.prob_adj:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual with probability 1 - self.prob_adj\n                if random.random() > self.prob_adj:\n                    population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea_P = CEA_P(budget=100, dim=10)\nbest, score = cea_P(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA_P", "description": "Novel \"Crossover-Elitism-Adaptation-Probability\" algorithm combining crossover, elitism, and adaptation with probability adjustment to handle black box optimization problems.", "configspace": "", "generation": 40, "fitness": 0.04863818204690748, "feedback": "The algorithm CEA_P got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.14985778155859875, 0.12875343969975983, 0.10081017821959937, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.019682575248846645, 0.005661616389739388, 0.003965347653119733, 0.01959972157639278, 0.0109919730312662, 0.0031277040807748957, 0.026629557819293992, 0.016838306844111917, 0.0034309467642651414, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.09554688179877269, 0.08476854770100395, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 0.020290832740220144, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008290487917996692, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023099080780454306, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02976105768040138, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.13482538606332095, 0.09580441870675127, 0.16112956940342849, 0.13111471590040835, 0.1210557193025883, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.0024167542233637374, 0.01759993274736349, 0.016823480269855806, 0.0057077311725821644, 0.0267656688986897, 0.08494000004272728, 0.09366414146218849, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.12368188968758709, 0.08808199726801991, 0.08904312032538675, 0.08563993484631816, 0.09994914935036392, 0.10449101090717972, 0.1613932299901245, 0.13800672315110074, 0.11401133946854825, 0.16622193143240316, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.04684105563184371, 0.08398582550377798, 0.07488015184129204, 0.0779498088259114, 0.08019416612837216, 0.0837317855149382, 0.0997711199450243, 0.07182841041677201, 0.12261339510127633, 0.10711581458909258, 0.13345086981233123, 0.11159922336432682, 0.1155784441072516, 0.12352020828237187, 0.12245976138762271, 0.12288366242815263, 0.13453360680225124, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10944346925681003, 0.10550058271466511, 0.08281726591464922, 0.08003713652118671, 0.1207914665021157, 0.07438436755151889, 0.1070176662487543, 0.10511484148144368, 0.10771349796486807, 0.11040265245322212, 0.10737311630440616, 0.10159392510658616, 0.059656379486262456, 0.06112108599736388, 0.05903250263678039, 0.09812650361567465, 0.07030000412856985, 0.043111827117695456, 0.13480174570059533, 0.12909710835880395, 0.14763022729669195, 0.14573989844304636, 0.12788626468994857, 0.13636129562228505, 0.15221248179249958, 0.1285350661163257, 0.15302471244721838, 0.027107858466162926, 0.03345806166245835, 0.031393493129599714, 0.02949205672073618, 0.03425093938292756, 0.029047929039359044, 0.01842500423697435, 0.04163827271236753, 0.033923010935870246]}, "mutation_prompt": null}
{"id": "0c5c2b26-e4f5-4e0d-9204-b2500e12be08", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEA(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA", "description": "Refine CEA algorithm by changing individual lines with probability 0.4", "configspace": "", "generation": 41, "fitness": 0.04900746343958587, "feedback": "The algorithm CEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.16099938011040327, 0.08108763387163931, 0.10604028300854029, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07510719766753993, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015676206293531503, 0.005375109906600173, 0.037310078809689395, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 9.999999999998899e-05, 0.019228998147351795, 0.005742107945471031, 0.020178851284525234, 0.0004952459975243739, 0.0029392792466438333, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.13861211399287854, 0.09339318268368901, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.013721443360898977, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009261983327718215, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019438502196028606, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.166080883981781, 0.10279143709805372, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.13742630169631354, 0.1551210350987995, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.005588124910789194, 0.01759993274736349, 0.021269774217577253, 0.001699639665087349, 0.0267656688986897, 0.08494000004272728, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.08823569455528546, 0.08209096546771655, 0.08439250268138365, 0.10052671717064054, 0.0962505644704219, 0.1613932299901245, 0.14307142108573256, 0.1558497919213394, 0.1410287139636497, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.05089071622571717, 0.08821301290177741, 0.06342719174439593, 0.09184967833476532, 0.08145008989007052, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.1465104257664096, 0.11480911823498774, 0.13345086981233123, 0.11363327881733931, 0.11434667138183707, 0.13920474331853383, 0.1310533601663687, 0.10496823622041396, 0.15544091585551467, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.059049267542155226, 0.10562219674829287, 0.08621084484499497, 0.07644863531661772, 0.1207914665021157, 0.06985107333452523, 0.1070176662487543, 0.11334858169237305, 0.10169400270254336, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.07924387902786689, 0.038775232531274906, 0.05903250263678039, 0.1849592529652928, 0.062000242058338206, 0.06330104780853052, 0.1394169700741903, 0.14849491086408217, 0.14763022729669195, 0.1249818435460105, 0.12252259820195399, 0.1336139838240219, 0.1591942039623937, 0.13696056583963034, 0.14689007985489466, 0.03210635532452999, 0.026250044737413547, 0.037849376565048054, 0.028015136914048666, 0.03425093938292756, 0.053436553445260326, 0.03343886215854597, 0.03803354422653826, 0.03436814250765252]}, "mutation_prompt": null}
{"id": "961a165e-9b2f-442f-84d3-f9338df33fa1", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.adapt_threshold = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one if the average score is above the threshold\n                if np.mean(scores) > self.adapt_threshold:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child if the average score is above the threshold\n                if np.mean(scores) > self.adapt_threshold:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEA(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA", "description": "Novel \"Crossover-Elitism-Adaptation\" (CEA) algorithm with probability-based adaptation and crossover.", "configspace": "", "generation": 42, "fitness": 0.05070948006804251, "feedback": "The algorithm CEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.08108763387163931, 0.10728406214208097, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.033180704446597487, 0.007792397052521438, 0.010674738340807233, 0.011841120013317608, 0.012857130714306164, 0.0074071153334375195, 0.01959972157639278, 0.003966925444115588, 0.00487753485356901, 0.014763392921912755, 9.999999999998899e-05, 0.00408779634655454, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.008844967118357805, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10395569031783003, 0.09779246037799927, 0.09670676052015259, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014138868555322537, 0.009242280453084617, 0.011691612930379791, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008889488135871426, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04385215660856412, 9.999999999998899e-05, 0.010205551432814763, 0.04473490676026903, 0.013835883343878197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12205184463468122, 0.15756555760738078, 0.16626061932933478, 0.10279143709805372, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.11949149690506888, 0.16260985112322646, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.006105618886783626, 0.01759993274736349, 0.01630586286779745, 0.004793191740485758, 0.0267656688986897, 0.09470638116120356, 0.09992909119999005, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.09768041006141248, 0.09323739469074366, 0.07726393575557644, 0.12594032838503155, 0.10785725165733073, 0.1613932299901245, 0.13800672315110074, 0.1560334905544718, 0.1312221800507123, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.061649917116368136, 0.060786811826759934, 0.08398582550377798, 0.0596256864795085, 0.10851010595066435, 0.11948329368467914, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.11943364695601921, 0.09388200728521401, 0.13345086981233123, 0.11312715831672393, 0.12304037934526457, 0.1485936422088473, 0.12245976138762271, 0.12691049298144463, 0.14987190614964763, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1337157909892165, 0.11758455538003376, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08432344810466452, 0.07466602457976645, 0.10923315141797407, 0.07327841830047488, 0.1207914665021157, 0.1007975098261028, 0.1070176662487543, 0.10511484148144368, 0.0693612576838919, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.06412480460122738, 0.03738259240699027, 0.08300216364264579, 0.07745038994949227, 0.08554417293103556, 0.07849591607867079, 0.13696453513737428, 0.1425056545216361, 0.15618172101194527, 0.15061785752321555, 0.12856518414994988, 0.1377931438090445, 0.14969714796693134, 0.12505228174140337, 0.14689007985489466, 0.03827365364283175, 0.032808355089565366, 0.03998140345930601, 0.033068558019799243, 0.03425093938292756, 0.03396588563859482, 0.03732868059364913, 0.03803354422653826, 0.032460187428550724]}, "mutation_prompt": null}
{"id": "18b08fd9-4e08-436d-8b62-804a08216e3e", "solution": "import numpy as np\nimport random\n\nclass CEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4  # Changed to 0.4 as per the probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEA(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA", "description": "Refine the CEA algorithm by changing the probability of adapting, crossing over, and selecting the elite.", "configspace": "", "generation": 43, "fitness": 0.050601905759318985, "feedback": "The algorithm CEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.09596520669739761, 0.15367181505521954, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.08165679954449556, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00016399923855547893, 0.03511434248127221, 0.01290727383402046, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.007518012054557377, 0.007715816701096445, 0.015002840698806197, 0.01959972157639278, 0.0004952459975243739, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 0.03336125475027163, 9.999999999998899e-05, 0.00031549654350837564, 0.015563635203305837, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.1068966050115625, 0.09097236966240907, 0.14619440580485532, 0.0667108215001172, 0.07285119553694963, 0.0026410362232609508, 0.026279303607937843, 0.05931056463008866, 0.013652159202375835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019935448209933537, 9.999999999998899e-05, 0.0052741477783060375, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004052223815690592, 9.999999999998899e-05, 0.033583872431763306, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.13403051979227099, 0.09580441870675127, 0.16112956940342849, 0.13932346734544443, 0.12983754153965088, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.016139179833421946, 9.999999999998899e-05, 0.0267656688986897, 0.08928276955108538, 0.09295378803818732, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.08921409486537546, 0.08099219012337167, 0.09117711690940145, 0.1468767930200282, 0.0962505644704219, 0.1613932299901245, 0.14861703377005964, 0.12662668172528269, 0.12837630482252538, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.07251694821546795, 0.08385826376604333, 0.08617224602685114, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.14329922387919758, 0.12441524786794611, 0.15297969736165684, 0.11274264978362958, 0.13230207234127234, 0.1305119196983876, 0.13178208071843933, 0.1353079928219122, 0.12875343333471923, 9.999999999998899e-05, 0.08929492501375647, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04984099380550322, 0.06909322223377601, 0.11880278104343489, 0.08167024703901915, 0.09443035049212978, 0.1207914665021157, 0.09670717536363937, 0.1070176662487543, 0.10511484148144368, 0.0923641256296065, 0.15074019812095807, 0.11875701745604017, 0.06932034027342138, 0.0506857903344724, 0.04833864622854167, 0.07991632530703319, 0.07465541348005067, 0.08909613746158718, 0.0659479221946151, 0.14159165340923396, 0.1381688726000757, 0.15293302635274775, 0.14308739455002562, 0.14356193995537503, 0.13233279814316334, 0.14969714796693134, 0.14763305598649024, 0.14689007985489466, 0.042076341582016674, 0.02373348004971687, 0.031393493129599714, 0.03188582189017963, 0.03425093938292756, 0.04914086454129052, 0.026661185786133634, 0.0381154971145683, 0.03100342660934652]}, "mutation_prompt": null}
{"id": "e7291ca0-9842-46df-aa42-237185f99131", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.mut_prob_change = 0.2\n        self.crossover_prob_change = 0.2\n        self.adapt_prob_change = 0.2\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Change mutation, crossover, and adaptation probabilities\n            self.mut_prob = max(0, self.mut_prob - self.mut_prob_change)\n            self.crossover_prob = max(0, self.crossover_prob - self.crossover_prob_change)\n            self.adapt_prob = max(0, self.adapt_prob - self.adapt_prob_change)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEA(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA", "description": "Novel \"Crossover-Elitism-Adaptation\" (CEA) algorithm combining crossover, elitism, and adaptation to handle black box optimization problems with probability-based individual line changes.", "configspace": "", "generation": 44, "fitness": 0.0440066136954706, "feedback": "The algorithm CEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.08108763387163931, 0.1394286416030358, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01959972157639278, 0.0004952459975243739, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.08224659834595494, 0.059824388882108726, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.09716408355800721, 0.1210557193025883, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 9.999999999998899e-05, 9.999999999998899e-05, 0.0267656688986897, 0.08494000004272728, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.08099219012337167, 0.07726393575557644, 0.09606267484187503, 0.0962505644704219, 0.1613932299901245, 0.13800672315110074, 0.11855009200713573, 0.10444782645124173, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.056957211629895754, 0.06406947898089654, 0.06342850570876157, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.11943364695601921, 0.09388200728521401, 0.13345086981233123, 0.1103568689991713, 0.08780202581330288, 0.10896891037713907, 0.12245976138762271, 0.09469860817068076, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05568623559107733, 0.07466602457976645, 0.08167024703901915, 0.07327841830047488, 0.1207914665021157, 0.06661401029160186, 0.1070176662487543, 0.10511484148144368, 0.0693612576838919, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.0506857903344724, 0.03738259240699027, 0.05903250263678039, 0.04690376827171172, 0.04019044166964181, 0.04143420019681854, 0.13480174570059533, 0.128372137474824, 0.14763022729669195, 0.11599487746987158, 0.12252259820195399, 0.13233279814316334, 0.14969714796693134, 0.12505228174140337, 0.14689007985489466, 0.013617939348936514, 0.015916393435176368, 0.031393493129599714, 0.027015293023570086, 0.03425093938292756, 0.020045516730027746, 0.016228383701229143, 0.03803354422653826, 0.024434963463026316]}, "mutation_prompt": null}
{"id": "4d1ada0f-33f5-4ad7-9c15-1a9d80591260", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA_P:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.prob_adj = 0.4  # Probability adjustment for individual adaptation\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob * self.prob_adj:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob * self.prob_adj:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size * self.prob_adj:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea_p = CEA_P(budget=100, dim=10)\nbest, score = cea_p(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA_P", "description": "Novel \"Crossover-Elitism-Adaptation-Probability\" algorithm combining crossover, elitism, adaptation, and probability adjustment to handle black box optimization problems.", "configspace": "", "generation": 45, "fitness": 0.04908120776906195, "feedback": "The algorithm CEA_P got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.08108763387163931, 0.10181932041598885, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022477472296956735, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.013610551708267526, 0.010674738340807233, 0.017470607460759124, 0.017487350609906804, 0.026846750431525845, 0.01959972157639278, 0.005531874223339561, 9.999999999998899e-05, 0.014763392921912755, 0.002593518379657711, 0.011120409958139676, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.08224659834595494, 0.0746600185599322, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07876882707806365, 9.999999999998899e-05, 9.999999999998899e-05, 0.022948530799967504, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009643936722545154, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.11902902136766425, 0.12925004935305884, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.0031361186681375663, 0.004959610315924845, 0.0267656688986897, 0.09029496751530475, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.08670326694141806, 0.07726393575557644, 0.11279088441592044, 0.0962505644704219, 0.1613932299901245, 0.13800672315110074, 0.1313919078438428, 0.11680734576933594, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.0428483845301616, 0.08398582550377798, 0.056957211629895754, 0.06406947898089654, 0.07813871622956303, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.1469652952121594, 0.12947865916366175, 0.13345086981233123, 0.13401108275566598, 0.11795252795706457, 0.13463082664833315, 0.16177104553530497, 0.11630539339556711, 0.12985236881594064, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05886243902293209, 0.10767399974077507, 0.014872733911213465, 9.999999999998899e-05, 9.999999999998899e-05, 0.13164315605165888, 0.059924214745111004, 0.08147926662079286, 0.08167024703901915, 0.0968000554996592, 0.1207914665021157, 0.07122275321909344, 0.12474900209473982, 0.10511484148144368, 0.08745422832022054, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.0506857903344724, 0.05983820985692001, 0.06479586503474799, 0.04690376827171172, 0.06653680807511808, 0.05888723507755911, 0.15613933258771429, 0.128372137474824, 0.14816883134472902, 0.12568101632446482, 0.13546124347170097, 0.14500977376025326, 0.15206496465004893, 0.1462155999086019, 0.14782432829098857, 0.03849775737342387, 0.02261279876901734, 0.03555849120182375, 0.027015293023570086, 0.03459952483321016, 0.03237344513684126, 0.018794306923510695, 0.03803354422653826, 0.02460593245010345]}, "mutation_prompt": null}
{"id": "3c437338-dafd-483b-89b9-c91ba2ff9fb6", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.mut_adapt_prob = 0.4\n        self.crossover_adapt_prob = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with 40% probability\n                if random.random() < self.mut_adapt_prob:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals with 40% probability\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with 40% probability\n                if random.random() < self.crossover_adapt_prob:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEA(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA", "description": "Novel \"Crossover-Elitism-Adaptation\" (CEA) algorithm combined with adaptive mutation and crossover probabilities.", "configspace": "", "generation": 46, "fitness": 0.048091354648416865, "feedback": "The algorithm CEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.17836359433467264, 0.12189066150135808, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.009419226356780608, 0.01722056542828576, 9.999999999998899e-05, 0.01959972157639278, 0.00711855846088516, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.08224659834595494, 0.06202658672128869, 0.0667108215001172, 0.07285119553694963, 0.0027536194859815177, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07561933411540522, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.16821118385355238, 0.10279143709805372, 0.10820856591959205, 0.09580441870675127, 0.16112956940342849, 0.13460755707472416, 0.14790483613502525, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.01913278638776794, 0.0011674762452065224, 0.028326263887351932, 0.08494000004272728, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.08476390439415427, 0.10508118136248612, 0.1029489625603679, 0.09995983093075445, 0.1613932299901245, 0.14277135019179554, 0.12826342203201568, 0.137494463037931, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.08088473094540294, 0.07235721701210696, 0.06415450670789102, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.11944232911652886, 0.11419283624501153, 0.1418283916160673, 0.1281300500965432, 0.11658774536187888, 0.13345498629324082, 0.1230437592635879, 0.119840464625389, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06596999014204263, 0.08479696432153017, 0.08626403432218865, 0.0851728475208362, 0.1207914665021157, 0.06661401029160186, 0.1070176662487543, 0.10511484148144368, 0.0693612576838919, 0.11040265245322212, 0.10267165755511809, 0.08539482994637437, 0.0506857903344724, 0.07028062768013732, 0.05903250263678039, 0.09910990073818682, 0.045586570762475076, 0.07452924577437803, 0.1399322444729234, 0.16230462972758064, 0.14763022729669195, 0.14751122281175433, 0.14829135304428387, 0.13233279814316334, 0.14969714796693134, 0.13233241940011797, 0.14689007985489466, 0.03102784000450265, 0.019735036773868897, 0.03535177949123247, 0.03225304695656783, 0.03425093938292756, 0.030945237379298107, 0.02088154143243426, 0.03803354422653826, 0.028016340587546762]}, "mutation_prompt": null}
{"id": "e26c031e-d3cf-4f6c-9521-d0edecafc4a8", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEAP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.prob_adjust = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Probability adjustment\n            if random.random() < self.prob_adjust:\n                # Randomly adjust the mutation, crossover, and adaptation probabilities\n                self.mut_prob = random.uniform(0.0, 0.2)\n                self.crossover_prob = random.uniform(0.6, 1.0)\n                self.adapt_prob = random.uniform(0.2, 0.8)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAP(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAP", "description": "Novel \"Crossover-Elitism-Adaptation-Probability\" (CEAP) algorithm combining crossover, elitism, and adaptation with probability adjustment.", "configspace": "", "generation": 47, "fitness": 0.051715830915575765, "feedback": "The algorithm CEAP got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.10000063117910452, 0.09862225166511507, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.008832750134025957, 0.024122743663135715, 0.0026858693784300725, 0.01959972157639278, 0.0004952459975243739, 9.999999999998899e-05, 0.028727161996205397, 0.015059741087757206, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.03640529760741207, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.10999328776896622, 0.08969780447140752, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 0.010579733454362916, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020922934000483284, 0.0064122974972317115, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005354695198824588, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12120458330603034, 0.15756555760738078, 0.14838054695461433, 0.13777290094448758, 0.10345180467913329, 0.09580441870675127, 0.16112956940342849, 0.18847280072097128, 0.15250371465943902, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.0043131157895948125, 0.01759993274736349, 0.039258991780444896, 9.999999999998899e-05, 0.0267656688986897, 0.08494000004272728, 0.09612689562317533, 0.11842175776965747, 0.1106019225181295, 0.10852972522114013, 0.1085366475336974, 0.08808199726801991, 0.08099219012337167, 0.0800902659315228, 0.10224271757842274, 0.0962505644704219, 0.1613932299901245, 0.13800672315110074, 0.1307725393168344, 0.12702658838665626, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.04272514360870705, 0.08398582550377798, 0.07745629118636843, 0.06896651022032052, 0.07814796850542793, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.1702845381623561, 0.12274068704871222, 0.13524475085012433, 0.12932247908868666, 0.10823444423289041, 0.1290640913252018, 0.12596457959386675, 0.1291378082224497, 0.13291751856321565, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04978509549988719, 0.04856192237492274, 9.999999999998899e-05, 0.12862719378901855, 0.07033842648388888, 0.1181352434447881, 0.1582595502217271, 0.09939603752232729, 0.17967232999866722, 0.0790144968626495, 0.1070176662487543, 0.10511484148144368, 0.08213261780470615, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.055291119954553825, 0.09503938510845056, 0.05903250263678039, 0.22489040500390034, 0.04352294495385234, 0.07115957221813973, 0.14658070396574419, 0.13899775746108922, 0.14763022729669195, 0.13069683314725644, 0.12794331536691805, 0.15388795806329103, 0.1624437522860166, 0.15949566788631309, 0.1683177068879077, 0.024510892202455947, 0.021021446713213487, 0.05073366081963193, 0.02989116218770882, 0.03425093938292756, 0.04810760476080411, 0.03918498893706923, 0.03803354422653826, 0.028587645139340534]}, "mutation_prompt": null}
{"id": "8a7e40fa-25c1-4348-af27-88344cc00860", "solution": "import numpy as np\nimport random\n\nclass CEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.probability = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Adaptive probability\n            if random.random() < self.probability:\n                # Randomly change the probability of adaptation, crossover, and elitism\n                self.mut_prob = np.random.uniform(0.0, 0.2)\n                self.crossover_prob = np.random.uniform(0.5, 0.9)\n                self.adapt_prob = np.random.uniform(0.1, 0.5)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEA(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA", "description": "Novel \"Crossover-Elitism-Adaptation-Probability\" algorithm combining crossover, elitism, and adaptation with adaptive probability to handle black box optimization problems.", "configspace": "", "generation": 48, "fitness": 0.049318091188149414, "feedback": "The algorithm CEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.14292260330445916, 0.08309264416191542, 0.1188691167825815, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017258512233631285, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.009721445528871997, 9.999999999998899e-05, 0.010497832716469535, 0.01959972157639278, 0.025568743947284034, 0.005146572521311454, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 0.021326076966812102, 9.999999999998899e-05, 0.020757816913100968, 0.00031549654350837564, 0.019683465394754074, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10719259106949919, 0.09591138306915603, 0.07567997320554443, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017871555776421744, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0033535944438268794, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.15213951148645388, 0.16633836919946332, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.0026841173364855475, 9.999999999998899e-05, 0.0267656688986897, 0.1074783294645224, 0.08609370886951351, 0.11842175776965747, 0.11052042334786671, 0.10852972522114013, 0.10798713552628325, 0.09094585828274215, 0.0837553942233471, 0.08041720738679525, 0.1237155741455459, 0.0962505644704219, 0.1613932299901245, 0.13800672315110074, 0.13571242636974434, 0.14088690575308715, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.06930547998423431, 0.07213757731163006, 0.11219698198236783, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.13768890271667933, 0.11604079431113623, 0.13345086981233123, 0.12321612700442497, 0.13729172059396455, 0.13923984330236128, 0.12245976138762271, 0.11769437132147464, 0.12695221519051358, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10246872380018501, 9.999999999998899e-05, 9.999999999998899e-05, 0.0978653193010437, 0.11473268640641143, 0.08479331228666265, 0.09654937528017804, 0.1207914665021157, 0.09042070412245407, 0.1070176662487543, 0.10511484148144368, 0.09898378748622638, 0.11081808433192086, 0.10267165755511809, 0.07015793316957519, 0.0506857903344724, 0.04421840713105518, 0.05978293695813952, 0.04690376827171172, 0.07916828346198379, 0.04763663139613805, 0.1393435262141769, 0.13442598027910935, 0.15691010307384823, 0.1645817364006429, 0.13229831611176757, 0.13804653237845577, 0.15336766677908198, 0.14494111437316792, 0.14689007985489466, 0.0431832256340251, 0.03167189243398827, 0.033046015293340836, 0.029024256664257342, 0.03425093938292756, 0.03536404278086214, 0.028632113214775434, 0.038590804525697964, 0.03780446500321055]}, "mutation_prompt": null}
{"id": "b78890ff-e975-4a02-aabc-d2009ddcace8", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEAProbabilistic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.prob_change = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 0.4\n                if random.random() < self.prob_change:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability 0.4\n                if random.random() < self.prob_change:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea_prob = CEAProbabilistic(budget=100, dim=10)\nbest, score = cea_prob(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAProbabilistic", "description": "Novel \"Crossover-Elitism-Adaptation-Probabilistic\" algorithm combining crossover, elitism, and adaptation with probabilistic changes.", "configspace": "", "generation": 49, "fitness": 0.04945736679017168, "feedback": "The algorithm CEAProbabilistic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.0863305053288379, 0.14255238509439327, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003601689212775483, 0.01467079663371329, 0.010005662502701296, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.008564757856451832, 0.015315253535368889, 0.009197099363531525, 0.01959972157639278, 0.0004952459975243739, 0.0013248562386055651, 0.014763392921912755, 0.0011934747327501105, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.019835676463239693, 0.003681202472661238, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.08224659834595494, 0.07987370512071956, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001930697498426115, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02368331385286948, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1224400243697088, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.10404789850238316, 0.1723342002514604, 0.1093773049574085, 0.1496115400685163, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.024423711155092898, 9.999999999998899e-05, 0.0267656688986897, 0.08494000004272728, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.09706257295193077, 0.08099219012337167, 0.08165544049387607, 0.09606267484187503, 0.13407401676509922, 0.1613932299901245, 0.13800672315110074, 0.13108442732714354, 0.1410738193240222, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.09130636946881565, 0.08398582550377798, 0.06691941674732138, 0.06483515099572357, 0.09198875697299136, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.11943364695601921, 0.14328416576843317, 0.13345086981233123, 0.11898783858333917, 0.10594660633869857, 0.11376942044415295, 0.12279294517027461, 0.10751902417807413, 0.12881629695858043, 9.999999999998899e-05, 9.999999999998899e-05, 0.13650579955854825, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07832591038270109, 0.006411533536146652, 0.09680399524987315, 0.09389138325504287, 0.12039815068290716, 0.08167024703901915, 0.09690187154944674, 0.1207914665021157, 0.06661401029160186, 0.1070176662487543, 0.10511484148144368, 0.07340831274725079, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.05310946745610712, 0.06504829475291385, 0.09322759092719823, 0.04817385730656443, 0.07524256961032516, 0.05948801100484802, 0.1434456055408455, 0.15382703818909427, 0.14763022729669195, 0.12620023656169632, 0.13651837511255505, 0.13233279814316334, 0.14969714796693134, 0.12505228174140337, 0.14689007985489466, 0.022697616954782784, 0.02588456020772556, 0.03295789382674297, 0.031468966331635984, 0.03425093938292756, 0.039841913527518424, 0.024447330131027623, 0.03803354422653826, 0.03378892268505185]}, "mutation_prompt": null}
{"id": "5fc17a07-9b95-4040-a04c-d4ed1d57cae9", "solution": "import numpy as np\nimport random\n\nclass RefinedCEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Refine individual lines with a probability of 0.4\n            if random.random() < 0.4:\n                # Randomly select an individual\n                idx = random.randint(0, self.population_size - 1)\n                # Randomly select a dimension\n                dim_idx = random.randint(0, self.dim - 1)\n                # Randomly change the value of the selected dimension\n                population[idx, dim_idx] += np.random.uniform(-1.0, 1.0)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\nrefined_cea = RefinedCEA(budget=100, dim=10)\nbest, score = refined_cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "RefinedCEA", "description": "Refine CEA algorithm by changing individual lines with a probability of 0.4", "configspace": "", "generation": 50, "fitness": 0.0507440211670304, "feedback": "The algorithm RefinedCEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.08108763387163931, 0.10163603432527812, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017154466599909712, 0.005375109906600173, 0.020253027146108993, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.013198402159828815, 0.0012770922030487242, 0.016351816621451465, 0.01959972157639278, 0.0004952459975243739, 0.005998656834241944, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.12016834745090366, 0.08224659834595494, 0.10144925835359231, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 0.005049364522202615, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009719654483631879, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00507360772040788, 9.999999999998899e-05, 0.03901040501614739, 0.013531410979156888, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.11988719532891157, 0.13307612268675273, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.003375256143380634, 9.999999999998899e-05, 0.0267656688986897, 0.08802236637152783, 0.08629834420199745, 0.11842175776965747, 0.11139286019405314, 0.10852972522114013, 0.10798713552628325, 0.08836636537665687, 0.09976999112008467, 0.08729531015631453, 0.1154110667588144, 0.0962505644704219, 0.1613932299901245, 0.13800672315110074, 0.1265937651831609, 0.15090225313979266, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.04865552364695336, 0.08398582550377798, 0.07027766099601462, 0.06583577179343425, 0.07094175693649463, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.12251414312633646, 0.10679008223540509, 0.1362965783865766, 0.13040525705984563, 0.1268894637503588, 0.13318892152576356, 0.1307906949869292, 0.153897198686889, 0.12705722552863552, 9.999999999998899e-05, 0.0724036571216713, 0.12392563622494057, 0.08941543101135763, 9.999999999998899e-05, 9.999999999998899e-05, 0.1345433930104506, 9.999999999998899e-05, 9.999999999998899e-05, 0.09576855613973656, 0.08372859894306839, 0.08167024703901915, 0.0911551145278543, 0.1207914665021157, 0.07792076080373556, 0.13850312292665845, 0.10511484148144368, 0.075892830724691, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.05820096527918828, 0.06581141338153229, 0.06519716151829102, 0.11124850578146439, 0.06532459284813652, 0.0770394985584486, 0.16893349263419277, 0.14041238446003268, 0.163856220262235, 0.15029694246342895, 0.14468424112384604, 0.1647438658814151, 0.14974695943554472, 0.1389442782215078, 0.15162550383666784, 0.03256704752180106, 0.041381088482946526, 0.031393493129599714, 0.029115050407817922, 0.03425093938292756, 0.022959359204317686, 0.023254335776301205, 0.03803354422653826, 0.0408443351045471]}, "mutation_prompt": null}
{"id": "6db82f29-c8bf-401f-8327-1fa1729bced0", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA_P:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.elite_adapt_prob = 0.6\n        self.elite_crossover_prob = 0.2\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with 60% probability\n                if random.random() < self.elite_adapt_prob:\n                    population[np.argmin(scores)] = new_individual\n                else:\n                    population[np.argmin(scores)] = population[np.argmin(scores)]\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with 20% probability\n                if random.random() < self.elite_crossover_prob:\n                    population[np.argmin(scores)] = child\n                else:\n                    population[np.argmin(scores)] = population[np.argmin(scores)]\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual with 60% probability\n                if random.random() < self.elite_adapt_prob:\n                    population[np.argmin(scores)] = best\n                else:\n                    population[np.argmin(scores)] = population[np.argmin(scores)]\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea_p = CEA_P(budget=100, dim=10)\nbest, score = cea_p(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA_P", "description": "Novel \"Crossover-Elitism-Adaptation-Probabilistic\" algorithm combining crossover, elitism, and adaptation with probabilistic adaptation and elitism.", "configspace": "", "generation": 51, "fitness": 0.04890635272320207, "feedback": "The algorithm CEA_P got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.13756742027793678, 0.08108763387163931, 0.09195568033170898, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016169871975063366, 0.01467079663371329, 0.020065139103742524, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.001852845015175797, 0.013389785491087824, 0.004435941807802379, 0.01959972157639278, 0.0004952459975243739, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 0.00309769816490002, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.0409550164838034, 0.009656447451318106, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.08653704720505195, 0.06767781720009824, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026196157049073743, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.11528005334910107, 0.14585687675844727, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.011787488581576189, 0.006497612948515918, 0.0267656688986897, 0.08494000004272728, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.08099219012337167, 0.07726393575557644, 0.10484390278917377, 0.10734480148651782, 0.1613932299901245, 0.14216596093672051, 0.1351579061730257, 0.13339656525115184, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.06452952794461475, 0.06446803115381794, 0.06345030415209074, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.11943364695601921, 0.1211254220479977, 0.13345086981233123, 0.12038070190286976, 0.10968447580407081, 0.1222268578959349, 0.12256030030995513, 0.12427604420198035, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08338997947270366, 9.999999999998899e-05, 0.08339455697165632, 9.999999999998899e-05, 9.999999999998899e-05, 0.0963653982295204, 0.06417017667567992, 0.07466602457976645, 0.08167024703901915, 0.09907611716282139, 0.1207914665021157, 0.06661401029160186, 0.1070176662487543, 0.10511484148144368, 0.07126828906554694, 0.11040265245322212, 0.2550779261158145, 0.07595115006075015, 0.06098222349747051, 0.03738259240699027, 0.05903250263678039, 0.06896787210932742, 0.061812625292734236, 0.07029333376708169, 0.13638665671822892, 0.14375728304946334, 0.14763022729669195, 0.12603375373127168, 0.1371849274004171, 0.14431504543419993, 0.149821317032651, 0.1432379442446733, 0.14689007985489466, 0.028334280538089618, 0.028189450091942847, 0.031393493129599714, 0.027288134678499, 0.03425093938292756, 0.03576801886786163, 0.06235725934354397, 0.04162895052648852, 0.023547582546601165]}, "mutation_prompt": null}
{"id": "ce1884aa-cef5-4889-be2d-f0625fc5b7a1", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEA_P:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.prob_mut = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Probabilistic mutation\n            if random.random() < self.prob_mut:\n                # Randomly select an individual\n                idx = random.randint(0, self.population_size - 1)\n                # Generate a new individual by adding a random value to the selected individual\n                new_individual = population[idx] + np.random.uniform(-1.0, 1.0, self.dim)\n                # Replace the individual with the new one\n                population[idx] = new_individual\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea_p = CEA_P(budget=100, dim=10)\nbest, score = cea_p(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEA_P", "description": "Novel \"Crossover-Elitism-Adaptation-Probability\" (CEA-P) algorithm combining crossover, elitism, adaptation, and probabilistic mutation to handle black box optimization problems.", "configspace": "", "generation": 52, "fitness": 0.04987492134585148, "feedback": "The algorithm CEA_P got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.08108763387163931, 0.13205319805958848, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.006221316117301701, 0.010643411704069683, 0.006592353378601756, 0.013782456661185494, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.020580341676956215, 0.002018776633897712, 0.002078241284695137, 0.01959972157639278, 0.0071744723226223606, 0.005240676333758354, 0.014763392921912755, 9.999999999998899e-05, 0.002581231182586685, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10151660888010394, 0.08885910102131278, 0.09458576713061506, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00011118187491609977, 9.999999999998899e-05, 0.0029972260601968115, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014474466173596712, 9.999999999998899e-05, 0.0008350424279371937, 0.042107331223126265, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.11211521452470219, 0.10513979768616677, 0.11605767835820557, 0.16112956940342849, 0.12004007616600065, 0.15098344697453925, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.002947194804393427, 0.019525069538397277, 0.01672341218455098, 0.0004077016604676631, 0.0267656688986897, 0.12414248504063308, 0.09555458711567522, 0.11842175776965747, 0.10412692483945996, 0.10852972522114013, 0.10798713552628325, 0.09446871106744825, 0.08780904794230171, 0.08319069211114316, 0.10505397995548138, 0.1288442033549385, 0.1613932299901245, 0.13800672315110074, 0.15008379237774627, 0.11453998121356601, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.0632136132693093, 0.034008147686441226, 0.0926107095729336, 0.07274484714234897, 0.06406947898089654, 0.07016871477699582, 0.0837317855149382, 0.0997711199450243, 0.07231429104041853, 0.11943364695601921, 0.13122563165180634, 0.13650605091154444, 0.1378996133561171, 0.11396271303953887, 0.13118381923966294, 0.13981936969892428, 0.11707940477534717, 0.1361026367559991, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12500955351865173, 9.999999999998899e-05, 0.036550768849129445, 9.999999999998899e-05, 0.05115622596919889, 9.999999999998899e-05, 0.10529113805861656, 0.07466602457976645, 0.08167024703901915, 0.11905866970561074, 0.12550732436596423, 0.06661401029160186, 0.1070176662487543, 0.10511484148144368, 0.0798503532535556, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.09405308012613656, 0.06565115887843953, 0.06930749798567015, 0.05928230817394231, 0.06512323619738036, 0.04797622021910408, 0.16507461413130842, 0.13814863158019397, 0.15205777184558233, 0.13363239576966957, 0.1345926090782914, 0.13589274589736666, 0.15506619883778894, 0.1463085918888939, 0.15392064035227027, 0.04054131062064603, 0.027872720618117075, 0.05207386844879325, 0.027015293023570086, 0.03425093938292756, 0.03880462570511267, 0.025731306007443333, 0.03803354422653826, 0.030372457501886663]}, "mutation_prompt": null}
{"id": "b91d9595-ad8e-4ba9-abce-8e8759afc370", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" (CEAI) algorithm combining crossover, elitism, adaptation, and improvement to handle black box optimization problems.", "configspace": "", "generation": 53, "fitness": 0.05250463338803261, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_id": "302d9060-620b-45f0-baad-f471b9823cf0", "metadata": {"aucs": [0.11869729595922507, 0.08232409735688839, 0.10579575879272907, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009903677542121625, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.01398499289212507, 0.0025549793353326633, 0.011936463338460324, 0.01959972157639278, 0.006231326553443939, 0.0032791895910567748, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.12685574170510794, 0.09375011210092399, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07543583343407467, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03789797641397796, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003949131116245508, 9.999999999998899e-05, 0.054145860102754684, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10307831360822983, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.1874355258950242, 0.13097285644244294, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.02152127029299189, 0.004519908882321011, 0.0267656688986897, 0.09815373794462723, 0.10073582281892957, 0.11842175776965747, 0.13996514753289535, 0.12097284864149183, 0.10798713552628325, 0.08808199726801991, 0.08469875589187326, 0.09176078350718131, 0.10444288376112365, 0.11189107120709718, 0.1613932299901245, 0.145745624256309, 0.1569754001343543, 0.13339643981633198, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.04808561563838154, 0.08398582550377798, 0.08764878115078678, 0.06587704467848032, 0.08389141367391473, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.1755010307888628, 0.12132724573053033, 0.13345086981233123, 0.12233886583081743, 0.12468770176802924, 0.14062621233214778, 0.12245976138762271, 0.13023671546509397, 0.13547285302275924, 0.1251955176223053, 0.12616905542573698, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13406718420914399, 9.999999999998899e-05, 0.002407029544606143, 0.0653725469374945, 0.09799653498424754, 0.08167024703901915, 0.0874612653051221, 0.1207914665021157, 0.09132961662436734, 0.15725615719150354, 0.10511484148144368, 0.11951537239960086, 0.11040265245322212, 0.10267165755511809, 0.09298898056277194, 0.09981812283319813, 0.09130210882383549, 0.05903250263678039, 0.04690376827171172, 0.11164562442456538, 0.06492286899189659, 0.14697413742271015, 0.1361090468159124, 0.16206949727545927, 0.12908685796382946, 0.1501196669481245, 0.16484025176247064, 0.14969714796693134, 0.13812853585838947, 0.16552157719523364, 0.020077220509544857, 0.02462577510032149, 0.031393493129599714, 0.04004823427477189, 0.035741132737458825, 0.0280936003110146, 0.024377517371678037, 0.03803354422653826, 0.02813537155494128]}, "mutation_prompt": null}
{"id": "9ac7dcd6-2cc0-4432-ad7d-3a51bf483fea", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.change_prob = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Change individual lines with probability 0.4\n            if random.random() < self.change_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" with probability 0.4 to change individual lines", "configspace": "", "generation": 54, "fitness": 0.04950883949050735, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "b91d9595-ad8e-4ba9-abce-8e8759afc370", "metadata": {"aucs": [0.12220171356911447, 0.09689613912394235, 0.10590613039061358, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008466403633047292, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.0030264705759142085, 0.009726120559779283, 0.0016968518781738107, 0.01959972157639278, 0.015627247925426135, 0.013337543437116128, 0.030000179409761407, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.0057784580545449105, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10218670764259785, 0.08366970578883104, 0.11031528249977707, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.047649436534504264, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00046398877198516875, 9.999999999998899e-05, 9.999999999998899e-05, 0.00029757406838926137, 9.999999999998899e-05, 0.005244461703847403, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.057348704483061064, 9.999999999998899e-05, 0.015114207258514978, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.1338635788134418, 0.13645106389218875, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.02851210569303364, 0.01759993274736349, 0.011853184596830268, 9.999999999998899e-05, 0.0267656688986897, 0.09075462801235956, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.10865088092319597, 0.10798713552628325, 0.11263325542673197, 0.08364678910392198, 0.07749774869361026, 0.14460775335486908, 0.0962505644704219, 0.1613932299901245, 0.13800672315110074, 0.13599456372245655, 0.12688399051823285, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.03856262312819947, 0.08398582550377798, 0.07079145107990459, 0.07890499861054667, 0.08192037922964668, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.14370037496168675, 0.1329762990348865, 0.15273939741093634, 0.12567282628977194, 0.15880823820925383, 0.12203729906444638, 0.13326021925372755, 0.1398666965335118, 0.13315403054234431, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015706795232792725, 9.999999999998899e-05, 9.999999999998899e-05, 0.0806687487449591, 9.999999999998899e-05, 9.999999999998899e-05, 0.05765147281221272, 0.0836831118560516, 0.10434879077043901, 0.08953778030903903, 0.1207914665021157, 0.08792341317413921, 0.1070176662487543, 0.10511484148144368, 0.09998511635398832, 0.11040265245322212, 0.1094902013293011, 0.06932034027342138, 0.07253572164717792, 0.044317157260805096, 0.06544427152393806, 0.049281407626571294, 0.06821369141878564, 0.052061786720601466, 0.14697015692894289, 0.13053210304810003, 0.14763022729669195, 0.12896142791441323, 0.13576674532160504, 0.14973443553477428, 0.16037982006653306, 0.1561925614209958, 0.17034662519151134, 0.027753121590013197, 0.022322807792140575, 0.03475230281938346, 0.04435098669777238, 0.03425093938292756, 0.0242400799712712, 0.028262011121105046, 0.04154267951937585, 0.033771825287537305]}, "mutation_prompt": null}
{"id": "2798e953-d6b1-4557-80fe-c35a09e8e5ff", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.mut_prob Adapt = 0.4\n        self.crossover_prob Adapt = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Adaptive mutation\n            if random.random() < self.mut_prob Adapt:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.05, 0.05, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Adaptive crossover\n            if random.random() < self.crossover_prob Adapt:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" (CEAI) algorithm combined with adaptive mutation and crossover probabilities.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 15, 23, '        self.mut_prob Adapt = 0.4\\n', 15, 28)).", "error": "SyntaxError('invalid syntax', ('<string>', 15, 23, '        self.mut_prob Adapt = 0.4\\n', 15, 28))", "parent_id": "b91d9595-ad8e-4ba9-abce-8e8759afc370", "metadata": {}, "mutation_prompt": null}
{"id": "93153f93-7247-4846-917a-0a27550ff481", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" (CEAI) algorithm combining crossover, elitism, adaptation, and improvement to handle black box optimization problems.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b91d9595-ad8e-4ba9-abce-8e8759afc370", "metadata": {"aucs": [0.11869729595922507, 0.08232409735688839, 0.10579575879272907, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009903677542121625, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.01398499289212507, 0.0025549793353326633, 0.011936463338460324, 0.01959972157639278, 0.006231326553443939, 0.0032791895910567748, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.12685574170510794, 0.09375011210092399, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07543583343407467, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03789797641397796, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003949131116245508, 9.999999999998899e-05, 0.054145860102754684, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10307831360822983, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.1874355258950242, 0.13097285644244294, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.02152127029299189, 0.004519908882321011, 0.0267656688986897, 0.09815373794462723, 0.10073582281892957, 0.11842175776965747, 0.13996514753289535, 0.12097284864149183, 0.10798713552628325, 0.08808199726801991, 0.08469875589187326, 0.09176078350718131, 0.10444288376112365, 0.11189107120709718, 0.1613932299901245, 0.145745624256309, 0.1569754001343543, 0.13339643981633198, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.04808561563838154, 0.08398582550377798, 0.08764878115078678, 0.06587704467848032, 0.08389141367391473, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.1755010307888628, 0.12132724573053033, 0.13345086981233123, 0.12233886583081743, 0.12468770176802924, 0.14062621233214778, 0.12245976138762271, 0.13023671546509397, 0.13547285302275924, 0.1251955176223053, 0.12616905542573698, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13406718420914399, 9.999999999998899e-05, 0.002407029544606143, 0.0653725469374945, 0.09799653498424754, 0.08167024703901915, 0.0874612653051221, 0.1207914665021157, 0.09132961662436734, 0.15725615719150354, 0.10511484148144368, 0.11951537239960086, 0.11040265245322212, 0.10267165755511809, 0.09298898056277194, 0.09981812283319813, 0.09130210882383549, 0.05903250263678039, 0.04690376827171172, 0.11164562442456538, 0.06492286899189659, 0.14697413742271015, 0.1361090468159124, 0.16206949727545927, 0.12908685796382946, 0.1501196669481245, 0.16484025176247064, 0.14969714796693134, 0.13812853585838947, 0.16552157719523364, 0.020077220509544857, 0.02462577510032149, 0.031393493129599714, 0.04004823427477189, 0.035741132737458825, 0.0280936003110146, 0.024377517371678037, 0.03803354422653826, 0.02813537155494128]}, "mutation_prompt": null}
{"id": "315e0e31-4ce6-4e18-b455-7e8f1091ff5d", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_prob = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 0.4\n                if random.random() < self.adaptation_prob:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability 0.8\n                if random.random() < self.crossover_prob:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one with probability 0.2\n                if random.random() < self.improve_prob:\n                    population[np.argmin(scores)] = new_individual\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" with probability adaptation", "configspace": "", "generation": 57, "fitness": 0.051848241442632226, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "b91d9595-ad8e-4ba9-abce-8e8759afc370", "metadata": {"aucs": [0.13404918443913882, 0.10982465751856685, 0.09169502728636048, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.10008492343131692, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.006810842735460398, 0.004689433021353384, 0.03058623235843294, 0.01959972157639278, 0.0013279484453802004, 0.0032295727611512115, 0.014763392921912755, 0.003687305692012921, 0.0033857618821493407, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.0911452978928261, 0.10747448582431895, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 0.01954843696810471, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006044494074496698, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01471254186682891, 9.999999999998899e-05, 9.999999999998899e-05, 0.0036679243669710537, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016887027828862533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.11423696577163356, 0.10274288241579344, 0.1054685026923049, 0.16661848936156542, 0.11967666764001261, 0.15385706155602652, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.012076709227673232, 0.01759993274736349, 0.03375411907264714, 9.999999999998899e-05, 0.04850399586184717, 0.08494000004272728, 0.12456805046496244, 0.11842175776965747, 0.09855305120349966, 0.11300002202377091, 0.10798713552628325, 0.08808199726801991, 0.08099219012337167, 0.07726393575557644, 0.10134920917171308, 0.10249862561024325, 0.1613932299901245, 0.13800672315110074, 0.13019175092011992, 0.11035244545021483, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.07352756580603204, 0.06406947898089654, 0.08168322087909274, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.11943364695601921, 0.11540216773660827, 0.1350868528132524, 0.12294382863700426, 0.1294331524197332, 0.12472965173358663, 0.12397154069053995, 0.12961079504417028, 0.12773111025530925, 9.999999999998899e-05, 9.999999999998899e-05, 0.13408496455579477, 0.12234221889256258, 0.10553059375561569, 0.1270634591055234, 9.999999999998899e-05, 0.05981484371773349, 9.999999999998899e-05, 0.09123966351501422, 0.10999780453578734, 0.09623523251103161, 0.09243201461489303, 0.1207914665021157, 0.09475538080072488, 0.14341728994508662, 0.10511484148144368, 0.09853515090410614, 0.11040265245322212, 0.10267165755511809, 0.20253290560087311, 0.0506857903344724, 0.03738259240699027, 0.05903250263678039, 0.057937606583277734, 0.06380405422230195, 0.0759514751956456, 0.1353367649042011, 0.13636943280245284, 0.14763022729669195, 0.14690403625863002, 0.1443648415901424, 0.17018951382188063, 0.14969714796693134, 0.14047779525334025, 0.14689007985489466, 0.049118886239045034, 0.026540657419539038, 0.03648232395743167, 0.0345653003851103, 0.03425093938292756, 0.02313253185391151, 0.021607896718651154, 0.03803354422653826, 0.03404816784396936]}, "mutation_prompt": null}
{"id": "fe301097-c1f5-4904-a556-a9d7ec2b90ab", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability 0.6\n                if random.random() < 0.6:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one with probability 0.3\n                if random.random() < 0.3:\n                    population[np.argmin(scores)] = new_individual\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" with probability-based adaptation, crossover, and elitism.", "configspace": "", "generation": 58, "fitness": 0.05000752203282768, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "b91d9595-ad8e-4ba9-abce-8e8759afc370", "metadata": {"aucs": [0.11869729595922507, 0.0894318608040332, 0.09169502728636048, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.08142048305848626, 0.07848612844651592, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.01397218791140642, 0.018248263482334326, 0.013059611349111044, 0.010674738340807233, 0.010873874766057945, 0.00851933009331829, 0.010159845208480456, 0.01959972157639278, 0.009891521887223975, 0.014495070453599657, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.08224659834595494, 0.08594416188586051, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007005398172698407, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012799045154450184, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002098495965296765, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1224102985824933, 0.15756555760738078, 0.14908037381092565, 0.10279143709805372, 0.11777211758752038, 0.09799856402420426, 0.16112956940342849, 0.11322713901448878, 0.1301616895654626, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.010247362670134152, 9.999999999998899e-05, 0.0267656688986897, 0.08494000004272728, 0.1017469867467482, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.12233130134647086, 0.08808199726801991, 0.08099219012337167, 0.09103811781608362, 0.10583352664979051, 0.0962505644704219, 0.1613932299901245, 0.13800672315110074, 0.15314455393594284, 0.1383470732309926, 0.12028165949079228, 0.17377774300845283, 0.11441318894993202, 0.05985564337097804, 0.038123046773715585, 0.08398582550377798, 0.06632196441938487, 0.07513655115567985, 0.08211297936233664, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.1392441724352882, 0.10828858335142033, 0.13512730954436447, 0.12812881456017455, 0.133262505142973, 0.10896891037713907, 0.12245976138762271, 0.1331831521465816, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026719144236213466, 0.027884070745360257, 0.11553872960938827, 9.999999999998899e-05, 0.13536808719485927, 0.059949113139125654, 0.0796489001917573, 0.09590406515747851, 0.08853114402550488, 0.1207914665021157, 0.1288184693991452, 0.1070176662487543, 0.10511484148144368, 0.07924148865341107, 0.11040265245322212, 0.10267165755511809, 0.07513382822185699, 0.05140077037358204, 0.07190861955239891, 0.07063852904574364, 0.22988906414353938, 0.05954251369989616, 0.08946532955157815, 0.13480174570059533, 0.128372137474824, 0.16073756828520214, 0.15440460878185114, 0.13084046407757544, 0.13271027861757811, 0.14969714796693134, 0.14712361759694337, 0.14689007985489466, 0.026896474156862138, 0.035751294974280756, 0.031393493129599714, 0.027015293023570086, 0.03425093938292756, 0.025427040839521964, 0.021228921479718332, 0.03803354422653826, 0.02627939247176203]}, "mutation_prompt": null}
{"id": "f932296e-d239-4186-b271-822db3d96945", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.4\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                # Adapt mutation probability\n                if random.random() < self.mut_prob:\n                    new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                else:\n                    new_individual = worst_individual + np.random.uniform(-0.05, 0.05, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with adaptive mutation probability.", "configspace": "", "generation": 59, "fitness": 0.050792248101677685, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_id": "b91d9595-ad8e-4ba9-abce-8e8759afc370", "metadata": {"aucs": [0.11869729595922507, 0.08804094973033838, 0.14489641658360475, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004896098457085607, 0.01467079663371329, 0.009410445247564736, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.0057832360323378795, 0.008367448616706463, 0.012490743625505951, 0.01959972157639278, 0.0004952459975243739, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.11123710359100847, 0.09221678131223887, 0.09087415795371945, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0074599821580096926, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004056380053847564, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.14487248291984833, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09580441870675127, 0.16572706723041286, 0.12342189098732559, 0.1598138401157908, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.007242547530927568, 0.01759993274736349, 0.0064697533159830956, 0.009454440077421133, 0.0267656688986897, 0.08494000004272728, 0.09144812508144373, 0.11842175776965747, 0.1120041725811114, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.09528127630593886, 0.08306856089569259, 0.1293842849794914, 0.0962505644704219, 0.1613932299901245, 0.13800672315110074, 0.1327965643294836, 0.1176424615256334, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.03845413574143164, 0.08398582550377798, 0.06451404266127136, 0.0881799115911297, 0.07986687664059222, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.1350682756579965, 0.12585343339190913, 0.13345086981233123, 0.1379084038049183, 0.12919763918097282, 0.11530906991600753, 0.14385844359621947, 0.12163570902247467, 0.14743855455286903, 9.999999999998899e-05, 9.999999999998899e-05, 0.1359242293211801, 9.999999999998899e-05, 9.999999999998899e-05, 0.11789924890207204, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10369074592407812, 0.10684620461602823, 0.10398973397924205, 0.09984389852057629, 0.1207914665021157, 0.10035930056339115, 0.1442861357136146, 0.10511484148144368, 0.08398473549530905, 0.11040265245322212, 0.10267165755511809, 0.10760079765044395, 0.06200386279294268, 0.05340498622304368, 0.0916811974284456, 0.13614966233869963, 0.04019044166964181, 0.05544244245050434, 0.14039353016599343, 0.14295369762535703, 0.1822148536694833, 0.13760991586511517, 0.14893924966624983, 0.1432245556945314, 0.15879721783847967, 0.1533458963626173, 0.15081573023935457, 0.026520495833671553, 0.02456267384263011, 0.03297190830374752, 0.03052761449328867, 0.03425093938292756, 0.030986237172502262, 0.03894145993137532, 0.03803354422653826, 0.025342425929419377]}, "mutation_prompt": null}
{"id": "5be542d0-f89d-49b2-9c14-addc233208d3", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4 * random.random()  # Adjusted adaptation probability\n        self.improve_prob = 0.2 * random.random()  # Adjusted improvement probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adjustment for adaptation, crossover, and improvement.", "configspace": "", "generation": 60, "fitness": 0.05122943780629113, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "b91d9595-ad8e-4ba9-abce-8e8759afc370", "metadata": {"aucs": [0.11970380570999295, 0.08108763387163931, 0.12703995020699987, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0027506780182866564, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.0050305716674309275, 0.0151158615875846, 0.006729865477909325, 0.01959972157639278, 0.02313922619948916, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 0.011840972124077975, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10724574169186507, 0.10561837094364146, 0.09903358212859525, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005155171627616029, 9.999999999998899e-05, 0.03305774484205981, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.12041737169603761, 0.09580441870675127, 0.16112956940342849, 0.1375385854788903, 0.1852280434245449, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.021992856499886138, 0.014382976174089013, 0.0267656688986897, 0.10765522461610622, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.09419915749399621, 0.0785946309874902, 0.10138551640382976, 0.10903731050770371, 0.1613932299901245, 0.13800672315110074, 0.13781370345619437, 0.12441928510137679, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.03702221100427794, 0.08398582550377798, 0.09024783697776817, 0.07172226524475334, 0.07434507086743614, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.13943415204981102, 0.11198031036268641, 0.16623725680472123, 0.13917787042355212, 0.11948868026600235, 0.1124714614487442, 0.14400266513800308, 0.13264850961896024, 0.12647314620735628, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04148535416258581, 0.03450292129586574, 0.021139651983975827, 0.11995348535973482, 9.999999999998899e-05, 0.07316419918797801, 0.10262608559775654, 0.08167024703901915, 0.0999212225526952, 0.1207914665021157, 0.09043162072500255, 0.1070176662487543, 0.13313089106001008, 0.07560216880074733, 0.11040265245322212, 0.11242071909771056, 0.19428837693472023, 0.07797427677067226, 0.07898841481293517, 0.05903250263678039, 0.061635162636489604, 0.08649583944305139, 0.09651699965234806, 0.13968925823628708, 0.15376365104292655, 0.1567551771439526, 0.1707287828410461, 0.13458098766506688, 0.14318274089974836, 0.15021381059491745, 0.13921750832610813, 0.14689007985489466, 0.0359458876447909, 0.026928309648895588, 0.0435799654306831, 0.027015293023570086, 0.03425093938292756, 0.037601734453233115, 0.041168317280985134, 0.03803354422653826, 0.03592030785813971]}, "mutation_prompt": null}
{"id": "07f1b332-dd99-4bd5-a8a8-d2a9e5d85b26", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with adaptation probability adjusted to 0.4", "configspace": "", "generation": 61, "fitness": 0.05141774027057623, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_id": "b91d9595-ad8e-4ba9-abce-8e8759afc370", "metadata": {"aucs": [0.11869729595922507, 0.10717643777027153, 0.09169502728636048, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011885184055301368, 0.01467079663371329, 0.005375109906600173, 0.013785826169206317, 0.006800128511433079, 0.006669962766643223, 0.025404628361758275, 0.007792397052521438, 0.010674738340807233, 0.016420105625351566, 0.01507525837611079, 0.016370233518797406, 0.01959972157639278, 0.008203014550062449, 9.999999999998899e-05, 0.023409566950403082, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.013328780066940049, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10141135453314509, 0.08730328073294535, 0.1168553634715459, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009253563806922993, 0.010922791812250532, 0.00890389156272997, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012851117535383483, 0.01703175795014844, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10687986229710955, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.1493148506965314, 0.22579459158000847, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.013758950365287959, 9.999999999998899e-05, 0.0267656688986897, 0.09365873868897945, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.09184084549847249, 0.08099219012337167, 0.07726393575557644, 0.11491146751492487, 0.10524129846853503, 0.1613932299901245, 0.14560028268499914, 0.13651512191199122, 0.14102868279804992, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.05617526686956131, 0.08398582550377798, 0.09611796879023426, 0.06735645868799178, 0.08685404453885237, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.13037387894523633, 0.12669025371800058, 0.13345086981233123, 0.11605402607015769, 0.14412303613515143, 0.12583915437636184, 0.12455751929058201, 0.15516425916076138, 0.13873927468086622, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10512532599206204, 0.11855760891779077, 9.999999999998899e-05, 9.999999999998899e-05, 0.08814690983409879, 0.08526388661001205, 0.08167024703901915, 0.08220460305059873, 0.1207914665021157, 0.1611868990371026, 0.1070176662487543, 0.1103370778106113, 0.09435907895615803, 0.11040265245322212, 0.10509034851958077, 0.0702948828687191, 0.0506857903344724, 0.08847853088391744, 0.09377403090806968, 0.10424329874764193, 0.05069619404148851, 0.0724762644107797, 0.13910039453195444, 0.14964808117751605, 0.15627018421364935, 0.13680821066585924, 0.1560266711553513, 0.13475171262039332, 0.14969714796693134, 0.14804818945450005, 0.15832218188136227, 0.019790083340250564, 0.039081526842648984, 0.05642631742770865, 0.04003444301633896, 0.0360393209688189, 0.032805197733318026, 0.023444922782549615, 0.05574565721071778, 0.04225707951186819]}, "mutation_prompt": null}
{"id": "4eca3fe2-bac6-431a-915b-334cffa1dbf8", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEAIAda:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adapt_adapt_prob = 0.2  # New adaptation probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Adaptation (new)\n            if random.random() < self.adapt_adapt_prob:\n                # Select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\nceaAda = CEAIAda(budget=100, dim=10)\nbest, score = ceaAda(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAIAda", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement-Adaptation\" (CEAI-Ada) algorithm combining crossover, elitism, adaptation, improvement, and adaptation to handle black box optimization problems.", "configspace": "", "generation": 62, "fitness": 0.04996123667621518, "feedback": "The algorithm CEAIAda got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_id": "b91d9595-ad8e-4ba9-abce-8e8759afc370", "metadata": {"aucs": [0.11869729595922507, 0.09684416546030117, 0.09169502728636048, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014455990827158871, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.01972227834843565, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.003625245612906669, 0.007600292339503545, 0.012928420787645667, 0.028733521480440283, 0.0004952459975243739, 0.0013479198942893955, 0.014763392921912755, 9.999999999998899e-05, 0.008143129569369578, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008021081358843274, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.11255381992105618, 0.10685887158132246, 0.07939360868587175, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004200852629837937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003191022706762303, 9.999999999998899e-05, 0.009644095228007021, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.16240851536796475, 0.12067038167468003, 0.10274288241579344, 0.10677769439178353, 0.16112956940342849, 0.1895497595436182, 0.14716775574830265, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.005355522703927806, 0.01759993274736349, 0.015075334570993082, 9.999999999998899e-05, 0.0267656688986897, 0.08614500536029812, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.10187873642619072, 0.09159125883954189, 0.09921749931622581, 0.11127833719520219, 0.0962505644704219, 0.1613932299901245, 0.14730833275056243, 0.1660102050187563, 0.11901764652211311, 0.12028165949079228, 0.17377774300845283, 0.13018077241936332, 0.05985564337097804, 0.05392942006881929, 0.08398582550377798, 0.05905232021953266, 0.07434732391367838, 0.07135420913246093, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.1442221240274847, 0.1614320839720771, 0.13345086981233123, 0.1346214690743993, 0.1343714128996114, 0.14212813203150343, 0.1227275150810967, 0.13078324694938714, 0.1313941942175183, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1201930760229476, 9.999999999998899e-05, 9.999999999998899e-05, 0.06685111504465713, 0.11731448816363521, 0.08167024703901915, 0.08094426959244716, 0.1207914665021157, 0.07664484732202503, 0.12857785342020545, 0.10511484148144368, 0.10649489386376476, 0.11040265245322212, 0.10267165755511809, 0.14412892410628209, 0.0506857903344724, 0.03738259240699027, 0.05964337138461817, 0.04690376827171172, 0.046349939320765254, 0.07244821035466609, 0.13480174570059533, 0.15037613216876566, 0.16000285504552447, 0.15076503269156105, 0.1447120740112947, 0.15285187485681961, 0.15115298679946554, 0.13612898186146505, 0.15109241365871984, 0.030683530521809388, 0.02592664124910793, 0.03572962661611456, 0.030571562730472346, 0.03425093938292756, 0.032670471105233245, 0.03521468005392725, 0.04149178908597573, 0.027347205829045373]}, "mutation_prompt": null}
{"id": "6d5c3d28-eda1-4c4c-abfc-9ef090e6a265", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = new_individual\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability 0.4 adaptation and improvement.", "configspace": "", "generation": 63, "fitness": 0.04750630039172575, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "b91d9595-ad8e-4ba9-abce-8e8759afc370", "metadata": {"aucs": [0.11869729595922507, 0.08785704937474215, 0.09283843522911428, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.09632208117164631, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.016318242178476994, 0.018248263482334326, 0.012835742216866453, 0.014316233549160784, 0.002624186649611726, 9.999999999998899e-05, 9.999999999998899e-05, 0.01959972157639278, 0.006260150521552932, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.03943838456829707, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.03239554672845557, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.08224659834595494, 0.10886598972256711, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000341633356064297, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.1825813218737189, 0.15248819071052477, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.026234647099028896, 0.0001354602466281385, 0.0267656688986897, 0.08494000004272728, 0.09122443801749702, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.08461624278867164, 0.0872038476328083, 0.10864185287354067, 0.0962505644704219, 0.1613932299901245, 0.13800672315110074, 0.12112723504683764, 0.1265417120162854, 0.12268484265935353, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.06595918310584004, 0.0642367096242562, 0.09492560969286767, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.14291354958488023, 0.12558442585832763, 0.14235989609556599, 0.12242082036754143, 0.10534384666626662, 0.14259342119942453, 0.14392176172533977, 0.11898782313597422, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07729889080144092, 0.08356251429390171, 0.08625946711745547, 0.07327841830047488, 0.1207914665021157, 0.09309202915521142, 0.1070176662487543, 0.10511484148144368, 0.07751595157702429, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.051086854827047, 0.03738259240699027, 0.05903250263678039, 0.06111475401889621, 0.06600013621937761, 0.044870733204928515, 0.13997179532453596, 0.1373772077700065, 0.16781384380418152, 0.12974208748179494, 0.14034168886350162, 0.13358543733934602, 0.14969714796693134, 0.13623760077118074, 0.14984880399544998, 0.025848546631173863, 0.025900213730791988, 0.03564511028988526, 0.027015293023570086, 0.03425093938292756, 0.03283279238940884, 0.020109574239839834, 0.03803354422653826, 0.0365888735658767]}, "mutation_prompt": null}
{"id": "97d05d63-e9ae-4299-bb29-fd7c1db38b75", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 0.4\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals with probability 0.4\n                child = (population[idx1] + population[idx2]) / 2\n                if random.random() < 0.4:\n                    population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" (CEAI) algorithm with probability 0.4 to adapt, crossover, and improve individuals.", "configspace": "", "generation": 64, "fitness": 0.04878043805323056, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "b91d9595-ad8e-4ba9-abce-8e8759afc370", "metadata": {"aucs": [0.11869729595922507, 0.08108763387163931, 0.09169502728636048, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.09249637874489092, 0.06918380018243464, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.023169342571280338, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.02393159342343698, 0.009186359622246898, 0.010999339870462421, 0.01959972157639278, 0.0004952459975243739, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005561723728214618, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.11117107785768643, 0.08224659834595494, 0.09605634202224578, 0.0667108215001172, 0.07637294708121023, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001287216577509409, 9.999999999998899e-05, 0.00977179557352792, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09580441870675127, 0.16250658765137105, 0.09958650257534607, 0.15874369022614299, 9.999999999998899e-05, 9.999999999998899e-05, 0.024493652460050863, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.02516141711663744, 9.999999999998899e-05, 0.0267656688986897, 0.08494000004272728, 0.08609370886951351, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.11872885641838349, 0.12014274968994887, 0.08099219012337167, 0.1068279660029271, 0.106087608650825, 0.10763956204130354, 0.1613932299901245, 0.13800672315110074, 0.1288624280923576, 0.12294498408622423, 0.12028165949079228, 0.17377774300845283, 0.12999930711426422, 0.05985564337097804, 0.038168770928303064, 0.08398582550377798, 0.06670723076102181, 0.06979943772500741, 0.06342850570876157, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.11943364695601921, 0.12234646115158154, 0.13345086981233123, 0.11456303225271203, 0.12300482282509906, 0.1287529647306639, 0.13689382867444344, 0.1303773522052032, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13782943417912286, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06344746003826696, 0.07466602457976645, 0.10758454177447851, 0.09693275673769364, 0.12453719270889418, 0.07732658895920363, 0.1070176662487543, 0.10511484148144368, 0.07713403419478093, 0.11040265245322212, 0.10267165755511809, 0.183569228702404, 0.0506857903344724, 0.060764076018170465, 0.05903250263678039, 0.096026942048409, 0.049757123971801764, 0.07954760173116793, 0.14153584375049577, 0.14848380692908447, 0.14763022729669195, 0.12492982893201277, 0.14022395664040888, 0.1368083375086322, 0.15034262439209256, 0.12629338967477177, 0.16004126812065245, 0.02407645604221975, 0.028844712321231203, 0.031393493129599714, 0.03174400677278222, 0.03425093938292756, 0.03215814936997852, 0.02139828180457881, 0.03803354422653826, 0.03114647969781348]}, "mutation_prompt": null}
{"id": "dd6ab9be-9742-47a4-ab0e-c54fe2b78a67", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4  # Changed to 0.4\n        self.improve_prob = 0.2\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" with probability adaptation", "configspace": "", "generation": 65, "fitness": 0.049931210618701885, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "b91d9595-ad8e-4ba9-abce-8e8759afc370", "metadata": {"aucs": [0.11869729595922507, 0.08271527398005352, 0.09169502728636048, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.07523870024997992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01712996431903524, 0.01831302383520994, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.009929654870141746, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.0066899881306209386, 0.0010508157391192485, 0.012882331583053408, 0.01959972157639278, 0.0318608191617028, 0.006954559056468468, 0.014763392921912755, 0.014415165924541729, 0.008016099874955218, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10431384054530046, 0.09277024473986217, 0.09468495542956534, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0281296873293555, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.14796672713095138, 0.12898964058524254, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.00261630178974559, 9.999999999998899e-05, 0.0267656688986897, 0.08494000004272728, 0.09716486280385539, 0.11842175776965747, 0.11391674217766945, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.10141991313018428, 0.08011671691647004, 0.1075345702095496, 0.12243219000309835, 0.1613932299901245, 0.14141585226525677, 0.13457525079961974, 0.11295799937509421, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.0751019440786751, 0.07618982284982578, 0.07549700522608982, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.12091854265440982, 0.13213449415605305, 0.14604349010931839, 0.15826866832973296, 0.11421675298418699, 0.10908816215078865, 0.12245976138762271, 0.14100452508596006, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05971207299922443, 0.02051256504330634, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1141662753577044, 0.09531238936617481, 0.08423320595194095, 0.08974846099565426, 0.1207914665021157, 0.06661401029160186, 0.1070176662487543, 0.10511484148144368, 0.10016837528576128, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.07386613277711729, 0.06403877870610941, 0.08261143058360831, 0.16781536881945336, 0.1118860777340226, 0.11736097181726235, 0.13765502414964426, 0.14808105717093534, 0.14811736137846787, 0.1657830743306664, 0.13725078863935303, 0.1444861188343468, 0.14969714796693134, 0.14941187395868094, 0.14895955903452818, 0.028863855579190578, 0.031453211235969336, 0.035476539505410076, 0.030889494327587808, 0.03425093938292756, 0.028819234028517493, 0.03407049663978179, 0.03803354422653826, 0.027066515232890054]}, "mutation_prompt": null}
{"id": "ec7d7c72-5e75-4c23-b48d-cfa0a5e8415c", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEAIEntropy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.entropy_prob = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n            # Entropy-based mutation\n            if random.random() < self.entropy_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Compute the entropy of the worst individual\n                entropy = np.sum(worst_individual * np.log2(worst_individual))\n                # Generate a new individual by adding a small random perturbation to the worst individual based on its entropy\n                new_individual = worst_individual + np.random.uniform(-entropy, entropy, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAIEntropy(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAIEntropy", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement-Entropy\" algorithm combining crossover, elitism, adaptation, improvement, and entropy to handle black box optimization problems.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: OverflowError('Range exceeds valid bounds').", "error": "OverflowError('Range exceeds valid bounds')", "parent_id": "b91d9595-ad8e-4ba9-abce-8e8759afc370", "metadata": {}, "mutation_prompt": null}
{"id": "fb381756-d922-4188-bcc7-27c74820f0d5", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n                # Check if the child is better than the current best\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" (CEAI) algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 67, "fitness": 0.05377167242404456, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_id": "b91d9595-ad8e-4ba9-abce-8e8759afc370", "metadata": {"aucs": [0.11869729595922507, 0.1047624871445827, 0.12033436681504572, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.10285389337673845, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02591834184870767, 0.01382955528165164, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.029067278918917472, 0.015880643928855687, 0.01155583130513349, 0.016919800074200797, 0.021425552996678032, 0.01551194584426907, 0.0017477569528847603, 0.014763392921912755, 0.014016207474145448, 0.001952985770919402, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.01822993321974431, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10774136676868906, 0.08530256001513348, 0.0899320308694761, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 0.00019821394584307317, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0009717814094490906, 0.0015340256496534366, 0.008276236112810142, 0.018574684337797742, 0.0008794243051015727, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0010222599702425228, 0.029453497713209265, 0.00877739548584855, 0.025026933326993128, 0.027165752632428486, 0.013937891399225522, 0.0024816596267926982, 0.014230031355671469, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.11494561335242837, 0.10274288241579344, 0.0993307814241069, 0.16112956940342849, 0.1877823319759795, 0.19102401979297212, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.000856509989715204, 0.01759993274736349, 0.02903463275973006, 9.999999999998899e-05, 0.0267656688986897, 0.09327566539210508, 0.10759514021831906, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.08099219012337167, 0.09920338649070837, 0.11761827437293015, 0.0962505644704219, 0.1613932299901245, 0.15568601417670092, 0.13808970394937536, 0.16529953291726673, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.04940227167438227, 0.08398582550377798, 0.07920326714665082, 0.09149211758564546, 0.08253267240049023, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.16032323871324428, 0.12615999055183524, 0.13530497020642163, 0.14125337323127662, 0.12209256963438109, 0.12492829751269074, 0.1542398535199604, 0.12798512971782894, 0.12680841445939728, 9.999999999998899e-05, 0.020667048693804424, 0.005539965654497991, 0.014582448693771566, 0.10645014590362223, 0.13318809693653888, 0.018378418052870438, 0.002818440614151929, 9.999999999998899e-05, 0.10341591860730492, 0.1515841448131472, 0.08826097429570423, 0.10545905206858497, 0.1207914665021157, 0.129515597545391, 0.1070176662487543, 0.12437529068311126, 0.10338525569428603, 0.11040265245322212, 0.10267165755511809, 0.07661320422101103, 0.06707730388257582, 0.09249131203535543, 0.11386510091501745, 0.0912747757942316, 0.09886765198490288, 0.05940246111567671, 0.14045012225774023, 0.13497938474502558, 0.1542781698172535, 0.125784700071215, 0.15647220429576414, 0.16139829362967617, 0.1509957640888433, 0.15686942005589022, 0.15370655612687734, 0.03271827883023504, 0.03688489590493027, 0.031393493129599714, 0.04046368485347285, 0.034863681573389815, 0.04258436043922775, 0.03089022796341867, 0.03803354422653826, 0.058284319133164675]}, "mutation_prompt": null}
{"id": "d6f89d25-9e67-4956-ac34-42111dca4fbb", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n                # Check if the child is better than the current best\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 68, "fitness": 0.05517259613410625, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.06.", "error": "", "parent_id": "fb381756-d922-4188-bcc7-27c74820f0d5", "metadata": {"aucs": [0.11869729595922507, 0.09167903318227055, 0.12593698086928418, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0162266848041831, 0.005375109906600173, 0.029303207013133048, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.018813774141551276, 0.026501425293469993, 0.03006209289323647, 0.01959972157639278, 0.008751248981697102, 0.004131014360010288, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.009794072827477573, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.12465300037349847, 0.11275860169586138, 0.11864380172772149, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006255856436367724, 9.999999999998899e-05, 0.024247357515908674, 9.999999999998899e-05, 9.999999999998899e-05, 0.007755457500234653, 9.999999999998899e-05, 9.999999999998899e-05, 0.011079044223526013, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01741164992032429, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12498718391526487, 0.15756555760738078, 0.14838054695461433, 0.11098800506102402, 0.10274288241579344, 0.1257255063110959, 0.18596232948863411, 0.17545360876227312, 0.175881289232503, 0.020443382008615063, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.028988564657213778, 0.019794063417262087, 0.04839909592274594, 0.11387909830435206, 0.1359101113309975, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.1090766489368028, 0.09726498764925617, 0.08623854668347719, 0.08645432933772268, 0.12393381404786197, 0.12165135629243218, 0.1613932299901245, 0.146205272960943, 0.1607662110382565, 0.19242358740783239, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.06492736993771997, 0.08398582550377798, 0.0713879730645749, 0.10121379132133312, 0.08661450897624146, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.16398744240731788, 0.1361667339915308, 0.13345086981233123, 0.14137954787217677, 0.12845800709274258, 0.14090233184936474, 0.14167112476523047, 0.16233075457088986, 0.15301340781535, 9.999999999998899e-05, 0.0433089356078995, 9.999999999998899e-05, 9.999999999998899e-05, 0.02411596608451494, 0.1321833436460158, 9.999999999998899e-05, 0.1179714854606505, 9.999999999998899e-05, 0.07672265942007273, 0.1200982004259129, 0.1419032771908849, 0.1007570782122017, 0.1207914665021157, 0.10261913085813834, 0.1070176662487543, 0.10511484148144368, 0.0976571599809185, 0.11040265245322212, 0.10267165755511809, 0.20342767048531352, 0.07659352453727664, 0.08522178485222098, 0.10788990401014875, 0.07067558569988464, 0.07113951032506516, 0.059139596026833385, 0.14109796408721742, 0.13307320915918175, 0.15298719890940737, 0.15761095856400065, 0.14602364106596943, 0.14986795780434692, 0.17098481648639385, 0.14786896449433495, 0.15145631648742475, 0.035397150997180105, 0.028942988447488105, 0.03539357921597397, 0.04254345516077995, 0.040433756986896885, 0.02618174413985397, 0.03853065021396451, 0.03803354422653826, 0.03287453589875111]}, "mutation_prompt": null}
{"id": "97833ef5-55ce-4560-9cf9-855fcce3875d", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.adaptation_probability = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n                # Check if the child is better than the current best\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Adaptation with probability\n            if random.random() < self.adapt_probability:\n                # Randomly select an individual\n                idx = random.randint(0, self.population_size - 1)\n                # Generate a new individual by adding a small random perturbation to the selected individual\n                new_individual = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the selected individual with the new one\n                population[idx] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'CEAI' object has no attribute 'adapt_probability'\").", "error": "AttributeError(\"'CEAI' object has no attribute 'adapt_probability'\")", "parent_id": "d6f89d25-9e67-4956-ac34-42111dca4fbb", "metadata": {}, "mutation_prompt": null}
{"id": "80402a85-99ae-4b1a-9b46-2def5de34a23", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n                # Check if the child is better than the current best\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Adaptation with probability\n            if random.random() < 0.4:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 70, "fitness": 0.05845937341845126, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.06.", "error": "", "parent_id": "d6f89d25-9e67-4956-ac34-42111dca4fbb", "metadata": {"aucs": [0.12277851979685528, 0.08108763387163931, 0.10678544102788456, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015595849537132334, 0.01467079663371329, 0.005375109906600173, 0.05043313173633612, 0.006592353378601756, 0.02497699478498594, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.036546905215810166, 0.015540793387052276, 0.027830730681689397, 0.021902892123088713, 0.0005439493603683898, 0.02265113807258823, 0.014763392921912755, 0.011132916464644982, 0.008989018514101721, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 0.05694102079130481, 9.999999999998899e-05, 0.00031549654350837564, 0.03761913301905717, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10051809702619519, 0.09441810150796714, 0.09515931249793774, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.03819182937054866, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02606563086992919, 0.003227430479865512, 0.007599356605708429, 0.024263665777699894, 9.999999999998899e-05, 0.1254760440116055, 0.0012350611595851602, 0.0047783248225943264, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011495142935192382, 9.999999999998899e-05, 0.02162531182181049, 9.999999999998899e-05, 0.015044918583727696, 9.999999999998899e-05, 0.0004983777935237965, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.12323855930346161, 0.10274288241579344, 0.11603666303137128, 0.16567798353731655, 0.2094619423619365, 0.17053441719839324, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.04648313430042639, 0.01759993274736349, 0.03641123833112303, 9.999999999998899e-05, 0.0267656688986897, 0.08995067792702915, 0.0914141533493339, 0.11842175776965747, 0.09855305120349966, 0.12654631099226665, 0.109645700127879, 0.0937408410214412, 0.10275199028539916, 0.08824608696296599, 0.13434831042227635, 0.1171735903363631, 0.1613932299901245, 0.1584755081174939, 0.13510555310788963, 0.14707290214338486, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.09811721565667353, 0.08549837636051416, 0.09768439727325551, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.1264933136777665, 0.14395112066954407, 0.13345086981233123, 0.1424501769791494, 0.1241532824570375, 0.13334412214473412, 0.14421089195611891, 0.18236397876700106, 0.14284479727345645, 9.999999999998899e-05, 0.0013476597313503147, 0.1223762402691354, 9.999999999998899e-05, 0.015205455367277465, 9.999999999998899e-05, 0.13111257232614293, 0.1281936627305762, 0.12821888191903485, 0.10712910038767731, 0.11424664666542306, 0.09827826276710916, 0.12959735460415323, 0.1219144091764558, 0.09426270605585996, 0.1070176662487543, 0.10511484148144368, 0.1052970500284004, 0.11040265245322212, 0.10267165755511809, 0.12346632732149943, 0.15892821837822446, 0.04959895756133226, 0.08439816254960752, 0.2608871529351444, 0.09571903696722639, 0.13314604396171692, 0.15865288019424284, 0.13596527646893242, 0.1528943525182307, 0.1476059548312374, 0.16919433547996465, 0.15125304428118047, 0.15322373546693602, 0.16594308012093117, 0.17400899551815052, 0.03601482945923851, 0.04860073263364051, 0.04344884599253507, 0.05652892939812282, 0.03425093938292756, 0.037033559250290504, 0.04173257200911051, 0.04126378343357939, 0.03280748888780327]}, "mutation_prompt": null}
{"id": "56a958b6-94e7-4eb8-9e32-ad144ac197eb", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob Adapt = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability Adapt\n                if random.random() < self.prob Adapt:\n                    population[np.argmin(scores)] = new_individual\n                    # Check if the new individual is better than the current best\n                    if func(new_individual) < best_func:\n                        best = new_individual\n                        best_func = func(new_individual)\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability Adapt\n                if random.random() < self.prob Adapt:\n                    population[np.argmin(scores)] = child\n                    # Check if the child is better than the current best\n                    if func(child) < best_func:\n                        best = child\n                        best_func = func(child)\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one with probability Adapt\n                if random.random() < self.prob Adapt:\n                    population[np.argmin(scores)] = new_individual\n                    # Check if the new individual is better than the current best\n                    if func(new_individual) < best_func:\n                        best = new_individual\n                        best_func = func(new_individual)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")\n", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 17, 19, '        self.prob Adapt = 0.4\\n', 17, 24)).", "error": "SyntaxError('invalid syntax', ('<string>', 17, 19, '        self.prob Adapt = 0.4\\n', 17, 24))", "parent_id": "80402a85-99ae-4b1a-9b46-2def5de34a23", "metadata": {}, "mutation_prompt": null}
{"id": "5cbc5c79-c6cf-4832-9e41-de2745650e58", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one with probability 0.4\n                if random.random() < self.prob_adapt:\n                    population[np.argmin(scores)] = new_individual\n                    # Check if the new individual is better than the current best\n                    if func(new_individual) < best_func:\n                        best = new_individual\n                        best_func = func(new_individual)\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child with probability 0.4\n                if random.random() < self.prob_adapt:\n                    population[np.argmin(scores)] = child\n                    # Check if the child is better than the current best\n                    if func(child) < best_func:\n                        best = child\n                        best_func = func(child)\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one with probability 0.4\n                if random.random() < self.prob_adapt:\n                    population[np.argmin(scores)] = new_individual\n                    # Check if the new individual is better than the current best\n                    if func(new_individual) < best_func:\n                        best = new_individual\n                        best_func = func(new_individual)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 72, "fitness": 0.05092895104051353, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "80402a85-99ae-4b1a-9b46-2def5de34a23", "metadata": {"aucs": [0.150761819165672, 0.08738820809868797, 0.14665730116602171, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.08185474949344118, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0032347213855716817, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.01187550701689466, 0.003460695293322158, 0.00922181017296586, 0.01959972157639278, 0.0038319093862136944, 0.008456952769823722, 0.014763392921912755, 9.999999999998899e-05, 0.002852242785752468, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.01585809738463917, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10454252021732668, 0.10612483527082639, 0.09311788467582305, 0.07365220801618944, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009926132119116526, 9.999999999998899e-05, 9.999999999998899e-05, 0.013361008968132082, 9.999999999998899e-05, 9.999999999998899e-05, 0.0020175872858795296, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06298697473539383, 0.02505247719510184, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.15075116991376436, 0.10274288241579344, 0.13660030024816427, 0.16112956940342849, 0.15476181702332814, 0.15598440200219266, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.0014190509502286508, 0.00790775715802361, 0.0267656688986897, 0.08494000004272728, 0.09966441089786349, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.09074859586299022, 0.08604242722225952, 0.08304547774968907, 0.10918372511415508, 0.10514295249283712, 0.1613932299901245, 0.1452601200952286, 0.14450738387323891, 0.15018199485429717, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.059126242704976906, 0.08398582550377798, 0.10287503125413155, 0.08150241693816573, 0.08167739631465376, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.11943364695601921, 0.12054292252527232, 0.13345086981233123, 0.12007706467930435, 0.13600367521990897, 0.12248860131517814, 0.12245976138762271, 0.12643211195768111, 0.12781097951611176, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06943277903720335, 0.03282724442439067, 9.999999999998899e-05, 9.999999999998899e-05, 0.029035493604443574, 0.10196585239588984, 0.10610844990922996, 0.08167024703901915, 0.09938504731069842, 0.1207914665021157, 0.08442605302241502, 0.1070176662487543, 0.10511484148144368, 0.08467670719977816, 0.11040265245322212, 0.10267165755511809, 0.07340812212048353, 0.050820953493731946, 0.08866959389575113, 0.09252514584579241, 0.05139856437054591, 0.07296190008210779, 0.048711542782491235, 0.13645229655146085, 0.1410410045973114, 0.1544555450893773, 0.14095590216411225, 0.13633382371910752, 0.14247966165482662, 0.15015982708488063, 0.17020205248477227, 0.14880020303572694, 0.02985752146995979, 0.06057347929530099, 0.031393493129599714, 0.028384520752091524, 0.05018708452257048, 0.031164835640268063, 0.03519953605454762, 0.03803354422653826, 0.043723322406966525]}, "mutation_prompt": null}
{"id": "10cc177a-e77f-451e-bd5e-cbc13eca3f30", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n                # Check if the child is better than the current best\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Adaptation with probability\n            if random.random() < self.prob_adapt_individual:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 73, "fitness": 0.05940156604676047, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.06.", "error": "", "parent_id": "80402a85-99ae-4b1a-9b46-2def5de34a23", "metadata": {"aucs": [0.15861964302225207, 0.10173597274806323, 0.1021190786457783, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019931092360101155, 0.01467079663371329, 0.015375556065547968, 0.022271558522667156, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.026104356120163152, 0.009225047544626941, 0.018704329218948268, 0.01959972157639278, 0.012764445993663887, 0.010525181757503166, 0.014763392921912755, 0.026043687758654954, 0.015247342298613464, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.028008781952200135, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10646714341190455, 0.136670191863143, 0.11228433366637813, 0.0667108215001172, 0.07285119553694963, 0.06705986097728234, 0.026279303607937843, 0.05931056463008866, 0.033530712068280955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00293180374059665, 0.027095532785099907, 9.999999999998899e-05, 0.025846274346330023, 9.999999999998899e-05, 0.0008861407543184763, 9.999999999998899e-05, 9.999999999998899e-05, 0.04216713642304115, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013895334449099628, 9.999999999998899e-05, 0.03424955336954938, 0.012214539326184659, 0.043654657345021386, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.1148957829965006, 0.16112956940342849, 0.15432111874029342, 0.2399031635286295, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.021835396690382147, 0.024855239751054303, 0.03776937306864925, 9.999999999998899e-05, 0.0267656688986897, 0.12446265541475698, 0.09219603804367038, 0.13257580333840324, 0.11659061166317242, 0.10852972522114013, 0.11148601754148679, 0.1012827213169254, 0.11653331225570873, 0.09574369293569018, 0.12463517252752698, 0.1153164964380734, 0.1613932299901245, 0.14064325562377522, 0.15138495235525495, 0.14721018555613608, 0.12028165949079228, 0.17377774300845283, 0.11786910777544912, 0.05985564337097804, 0.048083255602095254, 0.08398582550377798, 0.10798776587376613, 0.10194248143704177, 0.09868634547220534, 0.0837317855149382, 0.0997711199450243, 0.14151548315750384, 0.14629196101094089, 0.15107187203404793, 0.13345086981233123, 0.1469272276511805, 0.16765878139299695, 0.14213084081902072, 0.17031722490474277, 0.14220061219296454, 0.19036235279471037, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1278130036288594, 0.14322426910459485, 0.0336776340202285, 0.0663405404508407, 0.017673575362798677, 0.018988903247201816, 0.07787855074884686, 0.12056320570643331, 0.09725477211527245, 0.471755296458476, 0.1207914665021157, 0.09743168667801216, 0.1070176662487543, 0.11636378359856026, 0.1354194677665047, 0.11040265245322212, 0.10267165755511809, 0.09410025171595848, 0.06836468728728506, 0.06932313678051727, 0.06290231735467, 0.10050468075149765, 0.10620271513762769, 0.07725873292847973, 0.1407379781135082, 0.15709731067237553, 0.16332888187962413, 0.14581471038477412, 0.15672597143821276, 0.14551701937460582, 0.14969714796693134, 0.15526264106315235, 0.14697920130411835, 0.04965834479706466, 0.03515870681527977, 0.03269106278710898, 0.04001846569878109, 0.03425093938292756, 0.044715854377034736, 0.05450841553592678, 0.04261255062845026, 0.058826101461557534]}, "mutation_prompt": null}
{"id": "349659fd-92ac-4ccf-865f-9aa6d99b1f4d", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n        self.prob_adapt_line = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n                # Check if the child is better than the current best\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Adaptation with probability\n            if random.random() < self.prob_adapt_individual:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Adaptation with probability to change individual lines\n            if random.random() < self.prob_adapt_line:\n                # Randomly select an individual\n                idx = random.sample(range(self.population_size), 1)[0]\n                # Generate a new individual by changing a random line\n                new_individual = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the individual with the new one\n                population[idx] = new_individual\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 74, "fitness": 0.05679953619284794, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.06.", "error": "", "parent_id": "10cc177a-e77f-451e-bd5e-cbc13eca3f30", "metadata": {"aucs": [0.1678239587603162, 0.08533272640449885, 0.1366624928990111, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02058405975378408, 0.008919515999610717, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.021009363336072617, 0.02154434409359185, 0.022494984760837555, 0.021918325595901456, 0.005721099070066016, 0.009955864696020167, 0.014763392921912755, 0.002777005674019395, 0.0029023050862464483, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.0017966937666055172, 0.002463053228719425, 0.004485345024991871, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.1323032789063, 0.10146787570559823, 0.11319842967628824, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.05101344807986863, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01748514367115983, 0.01395347138757419, 0.0001291331351923608, 0.013345285914715843, 0.009632137855925427, 0.01085060749330602, 0.0014519818134911544, 0.009037389853236655, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030840357926577466, 0.04508560589661936, 0.010648489475064027, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12099237496333826, 0.15756555760738078, 0.14838054695461433, 0.11521537823376615, 0.10274288241579344, 0.09580441870675127, 0.16471577750097555, 0.1589526252633725, 0.1210557193025883, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.008102191647332613, 0.01759993274736349, 0.024539072373302218, 0.0005688558318633907, 0.0267656688986897, 0.089127601012844, 0.11104388768123685, 0.11842175776965747, 0.12771167662771332, 0.15337638249171104, 0.10890176417584185, 0.09129880033231697, 0.08938585955544964, 0.0904801916665241, 0.11295000956589807, 0.1111670412250938, 0.1613932299901245, 0.14294343741768556, 0.16299130155322672, 0.1604139633858055, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.09012689518301376, 0.0870055399690507, 0.08841640511836235, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.1349627260000814, 0.14022357206487646, 0.1455062132406032, 0.12171183650181605, 0.1358373522197759, 0.14378607285414602, 0.13772441691667903, 0.13570833180980113, 0.13013688785135014, 9.999999999998899e-05, 0.006949257939517728, 9.999999999998899e-05, 0.13766480558576155, 0.13168482718752295, 9.999999999998899e-05, 0.0036904317683809085, 0.14166171089246693, 0.11569604116047794, 0.12808077530039286, 0.1203828467379564, 0.08631377479738989, 0.09497346878038626, 0.1207914665021157, 0.09188468215197587, 0.12598722990734712, 0.10511484148144368, 0.13244897385538457, 0.11040265245322212, 0.11714335939753928, 0.08844153295354007, 0.0766513966668454, 0.07380175652032706, 0.07257025733774503, 0.2720206450676462, 0.07659973042162382, 0.09201609013679712, 0.15767222804779635, 0.16442313618072935, 0.15329061848517544, 0.16780079030348405, 0.16112758503465574, 0.17334468365371902, 0.1748596410084774, 0.15419738235884595, 0.17109259043048564, 0.03414428895878263, 0.03224476551468847, 0.04387650120017084, 0.03289021193532338, 0.03425093938292756, 0.050092828270263845, 0.047983570476741955, 0.03803354422653826, 0.04109600217273024]}, "mutation_prompt": null}
{"id": "7bf783ff-337f-4d25-8463-4615007385e5", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n        self.prob_adapt_line = 0.4\n        self.prob_adapt_point = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Adaptation with line\n            if random.random() < self.prob_adapt_line:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Adaptation with point\n            if random.random() < self.prob_adapt_point:\n                # Randomly select an individual\n                idx = random.randint(0, self.population_size - 1)\n                # Generate a new individual by adding a small random perturbation to the selected individual\n                new_individual = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the selected individual with the new one\n                population[idx] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n                # Check if the child is better than the current best\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 75, "fitness": 0.057303475303144155, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.06.", "error": "", "parent_id": "10cc177a-e77f-451e-bd5e-cbc13eca3f30", "metadata": {"aucs": [0.13116420857588562, 0.13576312998897433, 0.11872550277075611, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.09462502682021745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026179490666560223, 0.026180864061336018, 0.015165646938588573, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.005187184060694072, 0.01688665100209019, 0.009848405732694299, 0.01959972157639278, 0.011985968414405801, 0.0016934053615388356, 0.014763392921912755, 0.002644938715753775, 0.01904069897339289, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.11897980765354932, 0.10825181461446287, 0.10053020986841787, 0.07235833456950536, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0045793973069974125, 9.999999999998899e-05, 0.00870079989647421, 9.999999999998899e-05, 9.999999999998899e-05, 0.01024418199962529, 9.999999999998899e-05, 0.008757236042492345, 0.01719077639917399, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009447396693969323, 9.999999999998899e-05, 0.013594257519015995, 0.014427031845730243, 9.999999999998899e-05, 0.044653576194455535, 9.999999999998899e-05, 0.007839028859585428, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.11158523036793033, 0.13376721860137109, 0.10392902657534575, 0.16112956940342849, 0.1537505600954262, 0.26710226914952995, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.02431999317748801, 0.01759993274736349, 0.02317739404321617, 0.006805861104910771, 0.0267656688986897, 0.10399381792922724, 0.09877979057247632, 0.11842175776965747, 0.10004028820238109, 0.10852972522114013, 0.10872051697888108, 0.09590104152422285, 0.11071520601701035, 0.10895227436981947, 0.11130668655148568, 0.12203602124521062, 0.1613932299901245, 0.14240581947449316, 0.17944896967575386, 0.12126009398911597, 0.12028165949079228, 0.17377774300845283, 0.12057827304950575, 0.08247326132075505, 0.06480404287464958, 0.08398582550377798, 0.08434121020724306, 0.10250149767373573, 0.08843296524723321, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.12697194214785867, 0.1280216536804013, 0.13729888749005537, 0.1731354931990865, 0.1285945486068707, 0.15112803481686843, 0.15015620475749225, 0.1539915355630206, 0.13862617999568083, 9.999999999998899e-05, 9.999999999998899e-05, 0.12524672292255623, 9.999999999998899e-05, 9.999999999998899e-05, 0.12892146373140678, 0.1306022360499306, 0.14123492888486855, 0.0001235289761886138, 0.08826321671505577, 0.11627569561942785, 0.08167024703901915, 0.11628241860412813, 0.1207914665021157, 0.09185069201042129, 0.1070176662487543, 0.2848673736260875, 0.09543743387006798, 0.11040265245322212, 0.10267165755511809, 0.11140650016657583, 0.069572796003739, 0.08462934783232834, 0.0832577833044903, 0.08618751990241869, 0.08987001074079837, 0.09394506001894676, 0.14971539844121762, 0.14853456497499795, 0.15699006639769575, 0.15925262252056005, 0.14981128392221998, 0.17029285319288123, 0.17614441423314786, 0.15897965314166507, 0.1579800798362777, 0.0384009891262127, 0.041677088110290805, 0.031393493129599714, 0.037886507445263895, 0.03425093938292756, 0.03953724339244913, 0.04232558315741175, 0.0403785929844791, 0.0374770901279029]}, "mutation_prompt": null}
{"id": "dca7bed9-01d2-4875-90ea-865cc0d85489", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n        self.prob_mut = 0.1\n        self.prob_improve = 0.2\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n                # Check if the child is better than the current best\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Adaptation with probability\n            if random.random() < self.prob_adapt_individual:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Mutation with probability\n            if random.random() < self.prob_mut:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Improvement with probability\n            if random.random() < self.prob_improve:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 76, "fitness": 0.05890153723894452, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.06.", "error": "", "parent_id": "10cc177a-e77f-451e-bd5e-cbc13eca3f30", "metadata": {"aucs": [0.11869729595922507, 0.0864444295640997, 0.1302566869646531, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012073414003124894, 0.01467079663371329, 0.02131523344770836, 0.010643411704069683, 0.006592353378601756, 0.025227802739348548, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.01704511376495632, 0.012676033107047235, 0.028884080594302364, 0.01959972157639278, 0.006837268284547449, 0.002866223322278927, 0.014763392921912755, 0.004123262051153542, 0.0070298829658682616, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.04429260318683481, 0.00031549654350837564, 0.039680994895048394, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.13050211734145756, 0.11555568785806136, 0.14122028339634962, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.03332534317554181, 0.05931056463008866, 0.01879017385092452, 0.05268005035995216, 0.0022650118497509197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006561193195893988, 0.000190096720425581, 0.0006300089256399133, 0.00012736412590674817, 0.008549773309190822, 0.01745819566278839, 0.0031057715265873087, 0.00924756425426021, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02105291023284117, 9.999999999998899e-05, 9.999999999998899e-05, 0.01122328113154214, 0.0029904949273122927, 9.999999999998899e-05, 0.02323542907159626, 0.07578602580629523, 0.0348494450468988, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1354631944095236, 0.15756555760738078, 0.14838054695461433, 0.11670175479891665, 0.10274288241579344, 0.09954188121714125, 0.16112956940342849, 0.15767455228641392, 0.21698603896080126, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.027700286124690998, 0.01759993274736349, 0.06029543167425222, 0.032433572323400606, 0.07460596630871008, 0.13932784068455417, 0.10001991566043911, 0.11842175776965747, 0.11625421513390388, 0.11528271370233545, 0.12499829390100259, 0.11470720748784391, 0.105016302654655, 0.09895781007700843, 0.12630912243065195, 0.11029646392551362, 0.1613932299901245, 0.13800672315110074, 0.1512327911626029, 0.14730824611467974, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.05704870014553276, 0.08398582550377798, 0.1250835437026553, 0.099117345440493, 0.12305205552058307, 0.0837317855149382, 0.0997711199450243, 0.07781022499278079, 0.13652623184159607, 0.16235634106275287, 0.13345086981233123, 0.13951962032211462, 0.13446197729907994, 0.16391015174131784, 0.14822350143152052, 0.12837181758659622, 0.14005440103288969, 0.0012024161936419198, 0.016421487157758374, 9.999999999998899e-05, 9.999999999998899e-05, 0.07022971889993568, 0.09855919870867602, 0.030387536551457206, 0.03663660058296214, 0.14048850655779277, 0.09428703606027922, 0.09935221207303091, 0.09011755295907786, 0.08799851316293039, 0.1207914665021157, 0.13697297184051982, 0.1489530420533327, 0.13545207323265784, 0.13421292578870603, 0.15524782321899455, 0.10267165755511809, 0.12528826979898844, 0.1188630404331894, 0.09683975021847802, 0.06845771194486516, 0.0858943541153061, 0.06656435397903515, 0.0934634147312754, 0.13673777852798807, 0.16038120580352766, 0.16055297612125685, 0.15443954370523427, 0.15937194971223068, 0.15410358561023496, 0.16908441895524773, 0.14010596881022652, 0.16669610584849925, 0.046553334535796465, 0.0374792127441288, 0.03841730736524018, 0.051379223406128216, 0.0418270920781777, 0.048670775207926065, 0.043611505517227256, 0.040976174681933486, 0.0549609232750774]}, "mutation_prompt": null}
{"id": "44331eff-51e6-4b1f-bd10-537d19df4ec8", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n        self.prob_mut_individual = 0.1\n        self.prob_improve_individual = 0.2\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Mutation\n            if random.random() < self.prob_mut_individual:\n                # Select a random individual\n                idx = random.randint(0, self.population_size - 1)\n                # Generate a new individual by adding a small random perturbation to the selected individual\n                new_individual = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the individual with the new one\n                population[idx] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n                # Check if the child is better than the current best\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Adaptation with probability\n            if random.random() < self.prob_adapt_individual:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 77, "fitness": 0.056151133511613334, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.06.", "error": "", "parent_id": "10cc177a-e77f-451e-bd5e-cbc13eca3f30", "metadata": {"aucs": [0.11869729595922507, 0.10478603412884513, 0.10583384728159051, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.07696727901484446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011702845483099966, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.020619319025587224, 0.02529330653466766, 0.0641619307554061, 0.01959972157639278, 0.008516322803187926, 0.0043762834624694325, 0.014763392921912755, 0.00549592022696721, 0.006233225991196245, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.1025753961125121, 0.09369538643972541, 0.11705608206402662, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.03314227224874888, 0.00018477097551872212, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0017253190449219025, 9.999999999998899e-05, 0.021493287805323225, 9.999999999998899e-05, 0.005682652790437337, 0.01675753077216946, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005846987911366841, 9.999999999998899e-05, 9.999999999998899e-05, 0.0021700699203458518, 9.999999999998899e-05, 0.013651612067094199, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12457153220584494, 0.15756555760738078, 0.14838054695461433, 0.12552714008713206, 0.10274288241579344, 0.10152199247311622, 0.16112956940342849, 0.14446079047729232, 0.1706904637325828, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.021844247121508342, 0.01759993274736349, 0.020201842328576136, 0.022223113969374375, 0.0267656688986897, 0.0851403903728506, 0.10233819037758529, 0.11842175776965747, 0.115797504401836, 0.10852972522114013, 0.11672929316930514, 0.10800547098036972, 0.09868738850231307, 0.1051031588332988, 0.13112931814473328, 0.11159112743507282, 0.1613932299901245, 0.13800672315110074, 0.14980024445032247, 0.14400552955080226, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.0874305899101595, 0.0889878202812503, 0.10440793302401385, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.15279627627407122, 0.14066775258223585, 0.1497822063861497, 0.1524737832727342, 0.13852359153431804, 0.14082356031012733, 0.134862942528579, 0.16103281002473036, 0.13911598863046748, 9.999999999998899e-05, 9.999999999998899e-05, 0.013194452661783762, 0.001328677124620814, 9.999999999998899e-05, 0.14086455399343245, 0.1063070719972451, 0.14757236752432634, 0.1131275689048733, 0.0667031259116817, 0.14638363970265977, 0.08393054822633239, 0.10460888517075895, 0.12583092034978394, 0.1064391943345081, 0.15469671223184633, 0.12087180523405916, 0.10533152344953456, 0.14899730953913737, 0.10267165755511809, 0.10488582053726225, 0.05881046760320807, 0.09007721072406039, 0.11496554301273687, 0.09866223549838704, 0.07463944395546218, 0.08311553568194507, 0.1732056542063043, 0.15883563302188175, 0.16311070847540543, 0.13940373553200747, 0.16113871278552439, 0.15184850835372876, 0.1646796918354514, 0.16219354329993385, 0.14823254446433387, 0.05610439264153533, 0.0284628075307779, 0.041275675706391124, 0.05211292668048373, 0.037758654333332364, 0.03434756279294071, 0.04223458218700182, 0.04114077129105331, 0.04225259709873863]}, "mutation_prompt": null}
{"id": "1cc9f379-0ff4-4103-8118-4311c9cc21c3", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n        self.prob_mut_individual = 0.2\n        self.prob_crossover_individual = 0.6\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Mutation\n            if random.random() < self.prob_mut_individual:\n                # Randomly select an individual\n                idx = random.randint(0, self.population_size - 1)\n                # Generate a new individual by adding a small random perturbation to the selected individual\n                new_individual = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the selected individual with the new one\n                population[idx] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Crossover\n            if random.random() < self.prob_crossover_individual:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n                # Check if the child is better than the current best\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        # Adaptation with probability\n        if random.random() < self.prob_adapt_individual:\n            # Randomly select two individuals\n            idx1, idx2 = random.sample(range(self.population_size), 2)\n            # Compute the average of the two individuals\n            new_individual = (population[idx1] + population[idx2]) / 2\n            # Replace the worst individual with the new one\n            population[np.argmin(scores)] = new_individual\n            # Check if the new individual is better than the current best\n            if func(new_individual) < best_func:\n                best = new_individual\n                best_func = func(new_individual)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 78, "fitness": 0.05497455119955061, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_id": "10cc177a-e77f-451e-bd5e-cbc13eca3f30", "metadata": {"aucs": [0.18246701137911092, 0.1190801243400057, 0.09977838875135603, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.08022939689696174, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008151511190650274, 0.01467079663371329, 0.005375109906600173, 0.016756123454735428, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.01576984084495925, 0.019627453896535862, 0.006163068737418009, 0.01959972157639278, 0.012800171725292797, 0.004080763611850724, 0.014763392921912755, 9.999999999998899e-05, 0.008167186605129273, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 0.018476417776383425, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.11337855905350702, 0.09904980277399267, 0.10423229566254721, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.04280051138708585, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009196223533837089, 0.01504534654764389, 0.00844473646775945, 0.01838926322437906, 0.031145257348778377, 0.0021933687969510895, 0.024772623794970583, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01807718432740002, 0.00024775540415578057, 0.01271673121207273, 0.008962135527076143, 9.999999999998899e-05, 0.024009248301419928, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.12466017548799724, 0.12214844023406746, 0.114930327577764, 0.16112956940342849, 0.1884043531079146, 0.13570665522240888, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.03006845704354133, 0.034877156074197724, 0.08396259329249511, 9.999999999998899e-05, 0.0267656688986897, 0.10771263086689653, 0.09871788476975962, 0.11842175776965747, 0.09855305120349966, 0.11248238792409593, 0.10798713552628325, 0.10003073252833183, 0.08099219012337167, 0.08962255817515974, 0.12267123393367763, 0.11003694343805781, 0.1613932299901245, 0.1427138668728608, 0.14202291969575742, 0.14138042591949018, 0.12488333203059332, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.06443397318077226, 0.08398582550377798, 0.0742749072426615, 0.09672943998297612, 0.07783852323281681, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.12221470915554256, 0.14796514330305877, 0.13367891555279876, 0.11999477544437231, 0.1590952390046454, 0.13825467881194198, 0.13186167544951788, 0.13907187235409457, 0.13702700754270025, 0.12754214527270125, 0.058971528961902164, 0.12110019104328018, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04031296385472527, 0.00024600168475841233, 9.999999999998899e-05, 0.06724760689615616, 0.10839828154360709, 0.1446000911702986, 0.1118534764605974, 0.1207914665021157, 0.10392893119782542, 0.1070176662487543, 0.10511484148144368, 0.07855416560360395, 0.13527973688010775, 0.10267165755511809, 0.08856746475628241, 0.06027215429977406, 0.08066640442683526, 0.05903250263678039, 0.10868862893805598, 0.08969767892925717, 0.09724167174411835, 0.19275938128080838, 0.14027472452942746, 0.14825007845734328, 0.14987601272106532, 0.1521611771280612, 0.15357345938809852, 0.15470629380541445, 0.15314622430639357, 0.14691246242660871, 0.04589926832012747, 0.03138700092423097, 0.04017167027964319, 0.04479098097486034, 0.03425093938292756, 0.04913432568825393, 0.028469615030247253, 0.03803354422653826, 0.04115342968844837]}, "mutation_prompt": null}
{"id": "da8dc31d-2b7e-4a15-9815-a1d79f77361c", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n        self.adaptive_elitism = True\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n                # Check if the child is better than the current best\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            # Elitism\n            if self.adaptive_elitism and random.random() < self.elite_threshold / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Adaptation with probability\n            if random.random() < self.prob_adapt_individual:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems and adaptive elitism.", "configspace": "", "generation": 79, "fitness": 0.05589764481522514, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.06.", "error": "", "parent_id": "10cc177a-e77f-451e-bd5e-cbc13eca3f30", "metadata": {"aucs": [0.1620637771742942, 0.11884953490441497, 0.12112548259668798, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026442667510525486, 0.019341063587964502, 0.020865678013188504, 0.013758176522796428, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.012301222269946455, 0.013872282419043369, 0.018797050893489153, 0.022706558024251366, 0.0004952459975243739, 0.004199691200689415, 0.015355748996521257, 0.02761831842424467, 0.011378595017841553, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.007020938224479134, 0.028783723082093093, 0.009868133257486478, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10345351177574591, 0.0955023479928584, 0.11503935020954437, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 0.006799609195669798, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007488634605675171, 0.0011692487066482515, 0.01969418787894628, 9.999999999998899e-05, 0.0038626936996304373, 0.01995955123144244, 9.999999999998899e-05, 9.999999999998899e-05, 0.014853916497073127, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01021782957692563, 0.012225520769845732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.13765446787626612, 0.17571184849213295, 0.10633207643060905, 0.16112956940342849, 0.15815022563273218, 0.18911088121916686, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.006169159418864534, 0.02754197085230281, 0.0637484305989221, 0.004581161924449795, 0.0267656688986897, 0.09828599070663491, 0.09082290032729012, 0.12085139590525618, 0.09968590291730339, 0.11148096996557033, 0.11375514501205708, 0.09188504764302963, 0.09920172664767046, 0.15404054359779096, 0.12478736338383967, 0.11864943509044712, 0.1613932299901245, 0.13800672315110074, 0.17072604285092152, 0.16730777457378065, 0.12917477411521472, 0.17377774300845283, 0.11685493338402464, 0.05985564337097804, 0.04592581798229767, 0.08398582550377798, 0.07074505613793536, 0.08995731275781815, 0.08688596033091822, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.15871018309147134, 0.1486108318330187, 0.14926804872885424, 0.13522972017252122, 0.12696717410145064, 0.15777912557506057, 0.1330706069694092, 0.14999874654622514, 0.14247796454234252, 9.999999999998899e-05, 9.999999999998899e-05, 0.05760421837227536, 9.999999999998899e-05, 9.999999999998899e-05, 0.09028855515980072, 0.13195461356063898, 0.028578667861090423, 0.0040265643363615045, 0.09588037466285892, 0.10322885663346149, 0.08439748694681526, 0.10063238217216808, 0.14588607256073916, 0.10729560187428833, 0.11965151312158451, 0.10511484148144368, 0.07488019028503246, 0.22081447626163608, 0.10267165755511809, 0.08729187363175894, 0.06641104548618137, 0.060824560506024916, 0.0665221838619322, 0.09590059094155201, 0.08046892023038765, 0.08793652011241959, 0.143223241281351, 0.14271598014707398, 0.16844242536669884, 0.15545123968287067, 0.16859483164769062, 0.14971737445439925, 0.16336693868714647, 0.1384148108869544, 0.16763429645086125, 0.03373050901150054, 0.046859019333029384, 0.03155125379897927, 0.036905465442011565, 0.03564024999317028, 0.047438214611815965, 0.04038836082851027, 0.03803354422653826, 0.04448355922906044]}, "mutation_prompt": null}
{"id": "b03cdd75-ef28-4a3d-aa8e-eb2fd279ccae", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n        self.mut_prob_adapt = 0.2\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n                # Check if the child is better than the current best\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Adaptation with probability\n            if random.random() < self.prob_adapt_individual:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Mutation with probability\n            if random.random() < self.mut_prob_adapt:\n                # Select a random individual\n                idx = random.randint(0, self.population_size - 1)\n                # Generate a new individual by adding a small random perturbation to the individual\n                new_individual = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the individual with the new one\n                population[idx] = new_individual\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation and mutation to handle black box optimization problems.", "configspace": "", "generation": 80, "fitness": 0.05748746100892529, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.06.", "error": "", "parent_id": "10cc177a-e77f-451e-bd5e-cbc13eca3f30", "metadata": {"aucs": [0.11869729595922507, 0.08108763387163931, 0.09169502728636048, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.07565541489321226, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04008495148584712, 0.01731561452313013, 0.020244826255915727, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.01344341282161332, 0.00847512268209627, 0.021122189341608144, 0.01959972157639278, 0.005356066199294407, 0.018455299039493167, 0.03949890595396155, 0.01109428431739723, 0.016031584071096616, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014038446033286522, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.13526595617635961, 0.11159068061758681, 0.12855332602785297, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.03403288883154454, 0.04725977409415483, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015183976575809721, 0.010444055709366018, 0.0008698392349290041, 9.999999999998899e-05, 9.999999999998899e-05, 0.015878907826029187, 0.0028329772296007416, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011052702675836579, 0.03273098660334073, 0.05590822184088717, 0.015464387709463678, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13639512445377133, 0.15756555760738078, 0.14838054695461433, 0.12609910599498508, 0.10274288241579344, 0.12289035802119219, 0.16112956940342849, 0.17648001634769805, 0.21423906722152453, 9.999999999998899e-05, 9.999999999998899e-05, 0.029781276288101788, 0.03266886175302153, 0.014066421775132176, 0.01759993274736349, 0.016894735452110066, 0.011628811160040775, 0.04300337402969967, 0.09516745930052006, 0.11629171084187606, 0.11842175776965747, 0.10376697525315082, 0.11512976352315651, 0.10798713552628325, 0.09440362147923442, 0.10316868283740077, 0.07991775323829842, 0.11209831391949099, 0.0962505644704219, 0.1613932299901245, 0.15496563071227376, 0.15491052038607522, 0.14941558531903354, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.06580289840890186, 0.08398582550377798, 0.06631905499746404, 0.08654987529937075, 0.13267274886663727, 0.0837317855149382, 0.0997711199450243, 0.07462521133042899, 0.1386951296746698, 0.13301857641126003, 0.1472916963572023, 0.14820455379757347, 0.13046139086097774, 0.16160804218060798, 0.13345589332711227, 0.13017600141715024, 0.1817447871578487, 9.999999999998899e-05, 0.08478610267148201, 9.999999999998899e-05, 9.999999999998899e-05, 0.12824977972027896, 0.13875932401132263, 9.999999999998899e-05, 0.110801302923073, 0.1363503964480446, 0.10886457173968445, 0.10136531055147513, 0.10176008057042385, 0.10049102868266746, 0.1207914665021157, 0.12594672661372242, 0.1070176662487543, 0.10511484148144368, 0.13357953771342912, 0.11040265245322212, 0.10267165755511809, 0.0859697269332057, 0.08827369474386182, 0.08228687229530529, 0.06887351084085336, 0.08828900460904676, 0.08930881476977504, 0.10450773146671055, 0.17332779152521982, 0.16544233213494985, 0.14992573812048993, 0.14719315938346356, 0.17377295872440224, 0.15429741563085175, 0.15014143691208992, 0.14685407008565676, 0.14689007985489466, 0.02741112866922668, 0.03543899893630209, 0.0378739940958992, 0.04167115084410178, 0.042854778313834, 0.052048588681404495, 0.03891510583638769, 0.047120388257375856, 0.03896410989280463]}, "mutation_prompt": null}
{"id": "d38780ff-70d0-46e7-ac89-e29dc9078b46", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n        self.prob_adapt_line = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n                # Check if the child is better than the current best\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Adaptation with probability\n            if random.random() < self.prob_adapt_individual:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Adaptation with probability on individual lines\n            if random.random() < self.prob_adapt_line:\n                # Randomly select an individual\n                idx = random.randint(0, self.population_size - 1)\n                # Generate a new individual by adding a small random perturbation to the individual\n                new_individual = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the individual with the new one\n                population[idx] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 81, "fitness": 0.05840104794653427, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.06.", "error": "", "parent_id": "10cc177a-e77f-451e-bd5e-cbc13eca3f30", "metadata": {"aucs": [0.11869729595922507, 0.09698786224547806, 0.1474775007714334, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.08563581798587516, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0016802006999497854, 0.01467079663371329, 0.010185476250470726, 0.010643411704069683, 0.006592353378601756, 0.02792386161435423, 0.018248263482334326, 0.022563617337614916, 0.010674738340807233, 0.03318036496586341, 0.025452259735881833, 0.023612523733332114, 0.021920128740157252, 0.015463888215406785, 0.010322076219592025, 0.014763392921912755, 9.999999999998899e-05, 0.012905978009568386, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.01775012962390432, 0.010219535133422886, 0.03696650704679472, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.11857326845835192, 0.10308425861523862, 0.11102976677913612, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013749990634576936, 0.011045781702866186, 0.010986472853511065, 0.0513267778431602, 0.0029125446625948292, 0.022231712680087945, 9.999999999998899e-05, 0.014062501788794757, 0.01744897143084778, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09075806800860386, 0.04226513058004844, 9.999999999998899e-05, 0.037328469155178734, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12382472064609118, 0.15756555760738078, 0.14838054695461433, 0.12096261758371296, 0.11172909589624469, 0.09580441870675127, 0.1827781811070649, 0.1633984505064302, 0.16904228190958215, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01988485321928679, 0.05356830445956018, 0.01566387955718529, 0.0267656688986897, 0.12408064154376297, 0.10554506388276585, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.11085854198280798, 0.10653676840972981, 0.11525053010975628, 0.09267656184319517, 0.11566417043601063, 0.12410016033030735, 0.1613932299901245, 0.1601351250348393, 0.14788486018109648, 0.1339797151733736, 0.12028165949079228, 0.17377774300845283, 0.12045054479787864, 0.05985564337097804, 0.04888540005286701, 0.08398582550377798, 0.08225574905290689, 0.06980175460622307, 0.10127683789802122, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.14470610159581188, 0.15737788672805586, 0.1424289857648826, 0.13842445178946494, 0.1862078711997267, 0.14128198034345496, 0.13621998601587693, 0.1461902599081435, 0.15043690600003878, 0.04132036241670578, 0.013497912806645807, 9.999999999998899e-05, 0.13293622668697624, 0.11973366428209575, 0.13554563828151767, 0.10938283185815634, 9.999999999998899e-05, 9.999999999998899e-05, 0.09352889812832077, 0.09688960454289786, 0.08167024703901915, 0.09489130394722867, 0.12696774398898347, 0.1311744351260119, 0.1070176662487543, 0.10511484148144368, 0.09695141015149988, 0.11040265245322212, 0.10267165755511809, 0.09891199786308369, 0.08305211893077724, 0.04863825498531915, 0.24558130498898634, 0.07273392229814235, 0.10328531628052329, 0.09050081986294534, 0.17816564603132923, 0.17525616418263124, 0.16626619170834334, 0.15778743125622974, 0.14654934752850401, 0.1475811771949075, 0.17351937152112828, 0.16408295638872827, 0.14920637107849455, 0.03375209770317378, 0.03236631464521755, 0.04887975531780753, 0.03573086840555917, 0.03425093938292756, 0.03277739863181328, 0.03561050475713379, 0.03810978479955884, 0.04250778615748263]}, "mutation_prompt": null}
{"id": "bf0af8b8-0826-40b7-9d1b-4134e1ae1c45", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n        self.prob_mut_individual = 0.4\n        self.prob_improve_individual = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.adapt_prob:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n                # Check if the child is better than the current best\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.improve_prob:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Mutation\n            if random.random() < self.prob_mut_individual:\n                # Select a random individual\n                idx = random.randint(0, self.population_size - 1)\n                # Generate a new individual by adding a small random perturbation to the selected individual\n                new_individual = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the selected individual with the new one\n                population[idx] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Improvement with probability\n            if random.random() < self.prob_improve_individual:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Adaptation with probability\n            if random.random() < self.prob_adapt_individual:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 82, "fitness": 0.06082772251434066, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.06.", "error": "", "parent_id": "10cc177a-e77f-451e-bd5e-cbc13eca3f30", "metadata": {"aucs": [0.13976876014237605, 0.08982152799244303, 0.11730475085765191, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.09680230176198823, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015551923437863824, 0.01467079663371329, 0.022754752992885874, 0.034009288738217625, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.018755338113494835, 0.033234603900107906, 0.03887046215062251, 0.01959972157639278, 0.02678500150900942, 0.004853135384870644, 0.014763392921912755, 9.999999999998899e-05, 0.023051011789668174, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013837516487822943, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.11936322804360922, 0.10018119266566505, 0.11846105807248064, 0.0667108215001172, 0.0798112177107505, 9.999999999998899e-05, 0.04125579203206797, 0.05931056463008866, 0.00990846602666351, 0.011432028487738721, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04449491774862613, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014666087373505943, 9.999999999998899e-05, 0.01190138006430319, 0.032846038201812866, 0.018778108099860025, 0.09569006744577346, 0.0007313269074030737, 0.012784065081422713, 0.023975755499329177, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014429173187993083, 9.999999999998899e-05, 9.999999999998899e-05, 0.01882190166123454, 0.015215645757239882, 9.999999999998899e-05, 0.03818556989505728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11731185870662175, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.10655857467061214, 0.16112956940342849, 0.1753882515662839, 0.26659309096275985, 0.027488378532280144, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.024521767569551267, 0.01759993274736349, 0.031079020823738368, 0.02254913255620672, 0.0267656688986897, 0.14176725085001995, 0.12143194761013398, 0.11842175776965747, 0.09855353638125275, 0.10852972522114013, 0.10798713552628325, 0.09601705533705174, 0.10766201041855872, 0.08883542302267, 0.1442095877487105, 0.10809998741236448, 0.1613932299901245, 0.15045699427014025, 0.14784970752092008, 0.16347907843734577, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.07776554023695992, 0.04815118882758529, 0.08398582550377798, 0.08261772082966912, 0.08263555758850272, 0.07625822880268684, 0.0837317855149382, 0.0997711199450243, 0.06843461329317979, 0.12298869247042477, 0.13528018295235344, 0.13531123239461562, 0.1543960161282586, 0.19476164277847396, 0.13549577497499887, 0.18241545497159284, 0.13349342809485132, 0.15656559978216378, 9.999999999998899e-05, 0.048662686460599125, 0.14943822128258766, 9.999999999998899e-05, 0.08407010160197337, 0.14644853158643123, 0.06969856250764628, 0.14040500503664566, 0.11159860281819678, 0.11233714906822456, 0.16252293658748806, 0.1087071013937031, 0.09646123558284103, 0.1207914665021157, 0.08781753019509142, 0.1070176662487543, 0.15389445640716726, 0.12002388468871672, 0.11040265245322212, 0.14085274775770817, 0.09148099599336967, 0.08118821705196311, 0.10292784460270799, 0.13390947724188795, 0.11137260203232968, 0.08588632759528592, 0.07871972143002803, 0.17079765146235604, 0.1474316124348155, 0.15212546452198517, 0.16798404843168624, 0.1615933229843346, 0.13700978707045164, 0.17865991408586357, 0.1541423654471722, 0.15441970464675303, 0.052284819766680646, 0.04597302357929767, 0.031496137455026885, 0.03947189323798683, 0.050265579644859115, 0.04458433814969198, 0.04743728518381518, 0.03833121273396667, 0.04408265896803243]}, "mutation_prompt": null}
{"id": "986b4133-d247-4cf8-948b-4cc5791ca736", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n        self.prob_mut_individual = 0.4\n        self.prob_improve_individual = 0.4\n        self.prob_adapt = 0.4\n        self.prob_mut = 0.4\n        self.prob_improve = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.prob_adapt:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Crossover\n            if random.random() < self.prob_crossover:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n                # Check if the child is better than the current best\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            # Elitism\n            if random.random() < self.prob_elite:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.prob_improve:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Mutation\n            if random.random() < self.prob_mut:\n                # Select a random individual\n                idx = random.randint(0, self.population_size - 1)\n                # Generate a new individual by adding a small random perturbation to the selected individual\n                new_individual = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the selected individual with the new one\n                population[idx] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'CEAI' object has no attribute 'prob_crossover'\").", "error": "AttributeError(\"'CEAI' object has no attribute 'prob_crossover'\")", "parent_id": "bf0af8b8-0826-40b7-9d1b-4134e1ae1c45", "metadata": {}, "mutation_prompt": null}
{"id": "f1f6446c-25a0-42b4-9ffe-8910516b9646", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n        self.prob_mut_individual = 0.4\n        self.prob_improve_individual = 0.4\n        self.prob_adapt = 0.4\n        self.prob_mut = 0.4\n        self.prob_improve = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.prob_adapt:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Crossover\n            if random.random() < self.prob_crossover:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n                # Check if the child is better than the current best\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            # Elitism\n            if random.random() < self.prob_elite:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.prob_improve:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Mutation\n            if random.random() < self.prob_mut:\n                # Select a random individual\n                idx = random.randint(0, self.population_size - 1)\n                # Generate a new individual by adding a small random perturbation to the selected individual\n                new_individual = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the selected individual with the new one\n                population[idx] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'CEAI' object has no attribute 'prob_crossover'\").", "error": "AttributeError(\"'CEAI' object has no attribute 'prob_crossover'\")", "parent_id": "bf0af8b8-0826-40b7-9d1b-4134e1ae1c45", "metadata": {}, "mutation_prompt": null}
{"id": "847fb89c-51d3-45a8-a015-27b84898dc29", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n        self.prob_mut_individual = 0.4\n        self.prob_improve_individual = 0.4\n        self.prob_adapt = 0.4\n        self.prob_mut = 0.4\n        self.prob_improve = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.prob_adapt:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Crossover\n            if random.random() < self.prob_crossover:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n                # Check if the child is better than the current best\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            # Elitism\n            if random.random() < self.prob_elitism:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.prob_improve:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Mutation\n            if random.random() < self.prob_mut:\n                # Select a random individual\n                idx = random.randint(0, self.population_size - 1)\n                # Generate a new individual by adding a small random perturbation to the selected individual\n                new_individual = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the selected individual with the new one\n                population[idx] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'CEAI' object has no attribute 'prob_crossover'\").", "error": "AttributeError(\"'CEAI' object has no attribute 'prob_crossover'\")", "parent_id": "bf0af8b8-0826-40b7-9d1b-4134e1ae1c45", "metadata": {}, "mutation_prompt": null}
{"id": "66e629b1-4600-4ef5-9c00-8366ad3e31e6", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n        self.prob_mut_individual = 0.4\n        self.prob_improve_individual = 0.4\n        self.prob_adapt = 0.4\n        self.prob_mut = 0.4\n        self.prob_improve = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.prob_adapt:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Crossover\n            if random.random() < self.prob_crossover:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n                # Check if the child is better than the current best\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            # Elitism\n            if random.random() < self.prob_elite:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.prob_improve:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Mutation\n            if random.random() < self.prob_mut:\n                # Select a random individual\n                idx = random.randint(0, self.population_size - 1)\n                # Generate a new individual by adding a small random perturbation to the selected individual\n                new_individual = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the selected individual with the new one\n                population[idx] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'CEAI' object has no attribute 'prob_crossover'\").", "error": "AttributeError(\"'CEAI' object has no attribute 'prob_crossover'\")", "parent_id": "bf0af8b8-0826-40b7-9d1b-4134e1ae1c45", "metadata": {}, "mutation_prompt": null}
{"id": "c654f4e7-5116-4658-b93d-d65cd736892b", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n        self.prob_mut_individual = 0.4\n        self.prob_improve_individual = 0.4\n        self.prob_adapt_individual = 0.4\n        self.prob_mut_individual = 0.4\n        self.prob_improve_individual = 0.4\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.prob_adapt_individual:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Crossover\n            if random.random() < self.prob_crossover_individual:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n                # Check if the child is better than the current best\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            # Elitism\n            if random.random() < self.prob_elite_individual:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.prob_improve_individual:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Mutation\n            if random.random() < self.prob_mut_individual:\n                # Select a random individual\n                idx = random.randint(0, self.population_size - 1)\n                # Generate a new individual by adding a small random perturbation to the selected individual\n                new_individual = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the selected individual with the new one\n                population[idx] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Improvement with probability\n            if random.random() < self.prob_improve_individual:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Adaptation with probability\n            if random.random() < self.prob_adapt_individual:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'CEAI' object has no attribute 'prob_crossover_individual'\").", "error": "AttributeError(\"'CEAI' object has no attribute 'prob_crossover_individual'\")", "parent_id": "bf0af8b8-0826-40b7-9d1b-4134e1ae1c45", "metadata": {}, "mutation_prompt": null}
{"id": "1b8f97b8-f86d-4a77-af56-4c915f4f92ca", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n        self.prob_mut_individual = 0.4\n        self.prob_improve_individual = 0.4\n        self.prob_adapt = 0.4  # Change individual lines to refine strategy\n        self.prob_mut = 0.4  # Change individual lines to refine strategy\n        self.prob_improve = 0.4  # Change individual lines to refine strategy\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.prob_adapt:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Crossover\n            if random.random() < self.prob_crossover:  # Change individual lines to refine strategy\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n                # Check if the child is better than the current best\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            # Elitism\n            if random.random() < self.prob_elitism:  # Change individual lines to refine strategy\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.prob_improve:  # Change individual lines to refine strategy\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Mutation\n            if random.random() < self.prob_mut:  # Change individual lines to refine strategy\n                # Select a random individual\n                idx = random.randint(0, self.population_size - 1)\n                # Generate a new individual by adding a small random perturbation to the selected individual\n                new_individual = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the selected individual with the new one\n                population[idx] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Improvement with probability\n            if random.random() < self.prob_improve:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Adaptation with probability\n            if random.random() < self.prob_adapt:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'CEAI' object has no attribute 'prob_crossover'\").", "error": "AttributeError(\"'CEAI' object has no attribute 'prob_crossover'\")", "parent_id": "bf0af8b8-0826-40b7-9d1b-4134e1ae1c45", "metadata": {}, "mutation_prompt": null}
{"id": "7906712c-8ec9-4073-b51b-59f9b2c3b8d6", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n        self.prob_mut_individual = 0.4\n        self.prob_improve_individual = 0.4\n        self.prob_adapt = 0.4  # probability of adaptation\n        self.prob_improve = 0.4  # probability of improvement\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        # Differential evolution for optimization\n        for _ in range(self.budget):\n            # Evaluate population\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            # Adaptation\n            if random.random() < self.prob_adapt:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the average of the two individuals\n                new_individual = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Randomly select two individuals\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                # Compute the crossover of the two individuals\n                child = (population[idx1] + population[idx2]) / 2\n                # Replace the worst individual with the child\n                population[np.argmin(scores)] = child\n                # Check if the child is better than the current best\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            # Elitism\n            if random.random() < self.elite_size / self.population_size:\n                # Replace the worst individual with the best individual\n                population[np.argmin(scores)] = best\n\n            # Improvement\n            if random.random() < self.prob_improve:\n                # Select the worst individual\n                worst_individual = population[np.argmin(scores)]\n                # Generate a new individual by adding a small random perturbation to the worst individual\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the worst individual with the new one\n                population[np.argmin(scores)] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            # Mutation\n            if random.random() < self.prob_mut_individual:\n                # Select a random individual\n                idx = random.randint(0, self.population_size - 1)\n                # Generate a new individual by adding a small random perturbation to the selected individual\n                new_individual = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                # Replace the selected individual with the new one\n                population[idx] = new_individual\n                # Check if the new individual is better than the current best\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        # Return the best individual\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")\n", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 89, "fitness": 0.05792739191850615, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.06.", "error": "", "parent_id": "bf0af8b8-0826-40b7-9d1b-4134e1ae1c45", "metadata": {"aucs": [0.11869729595922507, 0.09770391472087281, 0.11360832032487322, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014629200841611567, 0.01467079663371329, 0.02333249014539085, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.019707429510476326, 0.028402727675601258, 0.02083523350253813, 0.01959972157639278, 0.020206539415515312, 0.014149875493384978, 0.014763392921912755, 9.999999999998899e-05, 0.01041741898663473, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10389715808044986, 0.10095689736544045, 0.0891637866088908, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 0.0049086268176659065, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02018974605462731, 0.04497979530371454, 9.999999999998899e-05, 0.012627515540957535, 0.03292851596278501, 9.999999999998899e-05, 0.0015446487573759216, 0.008985910460311608, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.041931283834178434, 9.999999999998899e-05, 9.999999999998899e-05, 0.04095545722651073, 0.01794447382152975, 9.999999999998899e-05, 0.02206911573742909, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.19804367851554683, 0.17380317550088598, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.028808813989524396, 0.01759993274736349, 0.03518429542062462, 9.999999999998899e-05, 0.0267656688986897, 0.12114518294273635, 0.1032157747568837, 0.11842175776965747, 0.11111943380395173, 0.10852972522114013, 0.10891581970503883, 0.12423349786423654, 0.0989370208621222, 0.1331193671889228, 0.14757268532503787, 0.11780236943491018, 0.1613932299901245, 0.15841936983607663, 0.15991211156958585, 0.12390872879816384, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.05536317911348865, 0.08398582550377798, 0.07994649737297932, 0.1571019763024587, 0.11388835622531646, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.14070583816591586, 0.15554183526391296, 0.13345086981233123, 0.12892265499073052, 0.13361509781363112, 0.145651705784825, 0.13494181784807702, 0.1351243135046709, 0.14308741265795033, 9.999999999998899e-05, 0.00555932409130111, 9.999999999998899e-05, 0.08823837922639499, 9.999999999998899e-05, 0.00479576587026076, 0.12848097519719193, 0.12169888579961174, 9.999999999998899e-05, 0.09600033240912942, 0.09558570174093417, 0.08167024703901915, 0.10172599690949113, 0.22474524078661484, 0.15740155603373462, 0.15460200890123965, 0.16160066489048708, 0.1154500582698138, 0.15853159118158622, 0.13769212185130053, 0.06932034027342138, 0.08767982371963279, 0.09470211686867391, 0.1445968466732176, 0.12698958975826136, 0.10501017797239087, 0.10143454388948847, 0.16902719936206778, 0.14180547416167189, 0.14763022729669195, 0.17748728019087612, 0.1602272812978507, 0.13343177979512333, 0.15176936775486416, 0.16690711210896603, 0.15633005010370393, 0.028198611180983657, 0.04522609221578899, 0.042507702927674695, 0.03926624383927502, 0.04012360551086802, 0.03660007408081478, 0.03325080330150809, 0.03803354422653826, 0.04674542938096493]}, "mutation_prompt": null}
{"id": "b2843f80-532b-4bad-82ba-3f7e432f5a2c", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n        self.prob_mut_individual = 0.4\n        self.prob_improve_individual = 0.4\n        self.prob_adapt = 0.4  # Changed probability to 0.4\n\n    def __call__(self, func):\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        for _ in range(self.budget):\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            if random.random() < self.adapt_prob:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                new_individual = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.crossover_prob:\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                child = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = child\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            if random.random() < self.elite_size / self.population_size:\n                population[np.argmin(scores)] = best\n\n            if random.random() < self.improve_prob:\n                worst_individual = population[np.argmin(scores)]\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_mut_individual:\n                idx = random.randint(0, self.population_size - 1)\n                new_individual = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                population[idx] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_improve_individual:\n                worst_individual = population[np.argmin(scores)]\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_adapt:\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                new_individual = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")\n", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 90, "fitness": 0.06114233687146663, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.06.", "error": "", "parent_id": "bf0af8b8-0826-40b7-9d1b-4134e1ae1c45", "metadata": {"aucs": [0.1637107557284162, 0.10266543825966312, 0.10594034991500323, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02760305508421368, 0.01467079663371329, 0.005375109906600173, 0.03306887879107634, 0.006592353378601756, 0.018608946242475777, 0.018248263482334326, 0.020927185552332084, 0.010674738340807233, 0.0196910275027099, 0.02403366806858287, 0.025555536859001582, 0.02616704259914482, 0.013897486792026958, 0.014566143516021257, 0.029539120586298262, 9.999999999998899e-05, 0.004572490763486758, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.05205715104363584, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.027701858557423686, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.12952876938465885, 0.09472287670533164, 0.12181902358224594, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.05220765616797218, 0.05931056463008866, 0.00990846602666351, 0.013700620257041218, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03784476190640029, 0.020015470099013832, 0.08713508100852652, 0.07522240167281669, 0.028209266121344223, 0.04232649489069884, 9.999999999998899e-05, 0.001949742684485667, 0.0012021488757595344, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030499556198997357, 0.037495203746033656, 0.028712837275615133, 0.012205522283350034, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1652439563921776, 0.15756555760738078, 0.14838054695461433, 0.14649742457064785, 0.10274288241579344, 0.1278772107966092, 0.16112956940342849, 0.1269034438266724, 0.1824973025122235, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.02902738687630768, 0.01759993274736349, 0.031193162074031555, 0.0059965479552256395, 0.0267656688986897, 0.1280645906838519, 0.12331515334111298, 0.11842175776965747, 0.10324344808440655, 0.10852972522114013, 0.11451084645769083, 0.10139460137556344, 0.11351572622214334, 0.09138940421728892, 0.12357168973929855, 0.14269332786288236, 0.1613932299901245, 0.16994297769321343, 0.15611788116115932, 0.15744333399740695, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.09993180325655537, 0.05892588820368472, 0.08398582550377798, 0.09203177258689554, 0.11031483426423583, 0.10899289715524774, 0.0837317855149382, 0.0997711199450243, 0.06829385920968722, 0.14955838059594484, 0.1485133309413741, 0.1494581855913737, 0.17179145390322303, 0.13627943946922805, 0.16546979845558185, 0.14348651164946113, 0.16011976418393692, 0.17599152709469457, 9.999999999998899e-05, 0.12395615006104177, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002470343416256515, 0.12086677688780523, 0.052084603642285954, 0.16419388406248037, 9.999999999998899e-05, 0.07625809038991171, 0.10290737212771672, 0.11061207061931322, 0.13743990749472346, 0.1207914665021157, 0.10103420295509002, 0.15061452095902295, 0.23738049794670435, 0.08883093921824514, 0.11040265245322212, 0.10267165755511809, 0.17612596217989662, 0.05913997650805236, 0.13594477713163156, 0.07919633687153504, 0.11575564846161857, 0.12970918587779812, 0.10085262249621141, 0.17651611502116993, 0.16251150480380094, 0.1613542123453039, 0.14655687659005123, 0.15284291120608562, 0.17052501878023507, 0.15118606564725123, 0.1495826706619119, 0.15432630161402516, 0.048746950458669946, 0.04421161024100306, 0.04185023447094227, 0.0393303040241515, 0.03425093938292756, 0.041289125867057574, 0.042320635768220205, 0.04091372079268718, 0.03994747517414399]}, "mutation_prompt": null}
{"id": "dd718821-29f5-40f7-b103-7292a2bf2ffc", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.7\n        self.adapt_prob = 0.3\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.3  # Changed probability to 0.3\n        self.prob_mut_individual = 0.3  # Changed probability to 0.3\n        self.prob_improve_individual = 0.3  # Changed probability to 0.3\n        self.prob_adapt = 0.3  # Changed probability to 0.3\n\n    def __call__(self, func):\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        for _ in range(self.budget):\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            if random.random() < self.adapt_prob:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                new_individual = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.crossover_prob:\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                child = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = child\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            if random.random() < self.elite_size / self.population_size:\n                population[np.argmin(scores)] = best\n\n            if random.random() < self.improve_prob:\n                worst_individual = population[np.argmin(scores)]\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_mut_individual:\n                idx = random.randint(0, self.population_size - 1)\n                new_individual = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                population[idx] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_improve_individual:\n                worst_individual = population[np.argmin(scores)]\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_adapt:\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                new_individual = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation and crossover strategy refinement.", "configspace": "", "generation": 91, "fitness": 0.059703424433211215, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.06.", "error": "", "parent_id": "b2843f80-532b-4bad-82ba-3f7e432f5a2c", "metadata": {"aucs": [0.11869729595922507, 0.0977288365080764, 0.09543076123466765, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044342299441045174, 0.022982394021997088, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.021151769246475882, 0.028712484967714058, 0.014541282857726934, 0.01959972157639278, 0.004587442298145339, 0.004224771468684274, 0.014763392921912755, 9.999999999998899e-05, 0.02910251194123825, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006881720259643842, 0.044487434472462284, 9.999999999998899e-05, 9.999999999998899e-05, 0.016055476907626542, 9.999999999998899e-05, 0.10704794026706255, 0.08224659834595494, 0.11955451208962453, 0.0667108215001172, 0.07285119553694963, 0.010691720711329844, 0.026279303607937843, 0.05931056463008866, 0.01963995456316392, 0.007995143119959858, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03999564014077006, 0.057370845966095874, 0.0010735659421068355, 9.999999999998899e-05, 9.999999999998899e-05, 0.01089513189511615, 0.03353806601578757, 9.999999999998899e-05, 0.02185888094683175, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015580817905797018, 9.999999999998899e-05, 0.05791010314265965, 9.999999999998899e-05, 0.00016366518694044263, 0.03029202257775032, 9.999999999998899e-05, 0.012438853835644803, 0.018808082299736406, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.15608761054921838, 0.10952375881537013, 0.10274288241579344, 0.1311445420581555, 0.17995131584823976, 0.13411307670760375, 0.2556464596186667, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.033650496625643234, 0.01759993274736349, 0.006005606073592573, 0.007010089582612955, 0.0267656688986897, 0.11644279553505599, 0.10277644067034941, 0.11842175776965747, 0.11683714799898826, 0.10852972522114013, 0.11799257169504618, 0.08948338119937871, 0.09144004794207283, 0.10900112024435127, 0.1206847226624479, 0.1179194253607444, 0.1613932299901245, 0.14291692919658217, 0.16718978204848867, 0.13594984429626422, 0.12165375023078251, 0.17377774300845283, 0.11879692668851838, 0.05985564337097804, 0.07826200411266471, 0.08398582550377798, 0.09301749181648067, 0.08342445313093083, 0.11238539828269445, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.1419217758229715, 0.2048287530380256, 0.14939321396832894, 0.15309615551496047, 0.15496248531332935, 0.13653190099681578, 0.1307346945682386, 0.12868031582704775, 0.1367094613729789, 0.15231393285760242, 9.999999999998899e-05, 0.09275569431192487, 9.999999999998899e-05, 0.1361308896622222, 0.08923315822634703, 0.006662819982525936, 0.07399321969911177, 0.12393715926199023, 0.1006302063582214, 0.132478781595038, 0.11116629675921175, 0.10770604386567939, 0.1539346692972864, 0.1087385293224481, 0.1070176662487543, 0.10511484148144368, 0.10500103869799604, 0.15753742620939082, 0.10267165755511809, 0.1607975533467092, 0.09178872677541894, 0.08069999457153676, 0.0950572310443778, 0.07516570117346111, 0.0965397366630194, 0.12405928814299094, 0.15376533398441894, 0.17814839170473473, 0.16635682964886433, 0.13888566383458578, 0.14157201502380556, 0.1592910303719849, 0.15189354171632163, 0.152900931409925, 0.20237703615973546, 0.062499388842261805, 0.04935788522282669, 0.05673601613442425, 0.034894035786957156, 0.0388127222183452, 0.04643383684196467, 0.0361622424062078, 0.03849343105788616, 0.04527601957043348]}, "mutation_prompt": null}
{"id": "061de3a5-a14d-4be7-8316-4fe121c7a4b0", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n        self.prob_mut_individual = 0.4\n        self.prob_improve_individual = 0.4\n        self.prob_adapt = 0.4  # Changed probability to 0.4\n\n    def __call__(self, func):\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        for _ in range(self.budget):\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            if random.random() < self.prob_adapt:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                new_individual = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_mut_individual:\n                idx = random.randint(0, self.population_size - 1)\n                new_individual = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                population[idx] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_improve_individual:\n                worst_individual = population[np.argmin(scores)]\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_adapt:\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                new_individual = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.elite_size / self.population_size:\n                population[np.argmin(scores)] = best\n\n            if random.random() < self.crossover_prob:\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                child = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = child\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 92, "fitness": 0.05735558419208395, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.06.", "error": "", "parent_id": "b2843f80-532b-4bad-82ba-3f7e432f5a2c", "metadata": {"aucs": [0.12516273800562616, 0.08108763387163931, 0.11922358199017868, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.08956156047838382, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0018680488920741478, 0.020963797388447003, 0.010747452588473427, 0.01608666002970438, 0.006800798956553611, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.01614970881667921, 0.01728546771979056, 0.019851500253111554, 0.018250906306519044, 0.019608311392924738, 0.005747552954229795, 0.001815172600601933, 0.015066490389225917, 0.013297441806023547, 9.999999999998899e-05, 0.045179741609489454, 0.04669267437275393, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.049561125349611435, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.006272742337529391, 0.00092746066548266, 0.008018919619191878, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.12154062032345014, 0.10103252352547243, 0.11631575575214137, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.06293490312231209, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 0.000961875430281034, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.050961779426541565, 0.00023661613788716895, 9.999999999998899e-05, 0.0064430098591552465, 0.0014591075799853526, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02772544209503902, 9.999999999998899e-05, 9.999999999998899e-05, 0.009467258319893479, 0.08448106322280924, 0.0031381781440260603, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10485322203161518, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.1732218156254396, 0.13933240344834852, 9.999999999998899e-05, 9.999999999998899e-05, 0.036463855929998346, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.026621845134350952, 0.004698080567088758, 0.048508366692643134, 0.10946893356698018, 0.10798690730067906, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.12335137160280141, 0.09889687205917708, 0.11569434821623747, 0.07899924003918546, 0.12959721119203238, 0.12487535255820092, 0.1613932299901245, 0.16146938468574878, 0.14644684887816606, 0.140896172137024, 0.12542061151856865, 0.17377774300845283, 0.13028354260057584, 0.06928637187643949, 0.0663838994864061, 0.08398582550377798, 0.08997823618684886, 0.09395981114645169, 0.07940728533321528, 0.0837317855149382, 0.10204555444931229, 0.06412526395900253, 0.14063772018929066, 0.13840831555037492, 0.14241428466133732, 0.1340265235940573, 0.13052734746652261, 0.1438535081164699, 0.1871569311434761, 0.19928332159754014, 0.1392821244773409, 0.09215580448200922, 0.13901537901897887, 9.999999999998899e-05, 9.999999999998899e-05, 0.1280152185411102, 9.999999999998899e-05, 0.11025685799954099, 9.999999999998899e-05, 9.999999999998899e-05, 0.08913912624082532, 0.12197071604556708, 0.08713599161232832, 0.08810363830573209, 0.1207914665021157, 0.09358254333328897, 0.11170241436815431, 0.24150638527729174, 0.08635943276105351, 0.1413844979005191, 0.11334885021729735, 0.19435586609254774, 0.06898674150217099, 0.08733860953288863, 0.10145905201247096, 0.09136196623870252, 0.07308336020976836, 0.0984040502950767, 0.1505565870919816, 0.14210209993857792, 0.16474360233013652, 0.13663649696256341, 0.1571294905252424, 0.16328229578274933, 0.15024774520468565, 0.1727292063224246, 0.14689007985489466, 0.04458172211446021, 0.041464117745904305, 0.052661958615789595, 0.05438128666659792, 0.05143838637132925, 0.04091833808833467, 0.05658397052689501, 0.04042212915633503, 0.04599873025575829]}, "mutation_prompt": null}
{"id": "05362f2f-a4d4-4e9a-90db-471b7e5e861e", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n        self.prob_mut_individual = 0.4\n        self.prob_improve_individual = 0.4\n        self.prob_adapt = 0.4  # Changed probability to 0.4\n        self.mut_range = 0.05  # New mutation range\n\n    def __call__(self, func):\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        for _ in range(self.budget):\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            if random.random() < self.adapt_prob:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                new_individual = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.crossover_prob:\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                child = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = child\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            if random.random() < self.elite_size / self.population_size:\n                population[np.argmin(scores)] = best\n\n            if random.random() < self.improve_prob:\n                worst_individual = population[np.argmin(scores)]\n                new_individual = worst_individual + np.random.uniform(-self.mut_range, self.mut_range, self.dim)\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_mut_individual:\n                idx = random.randint(0, self.population_size - 1)\n                new_individual = population[idx] + np.random.uniform(-self.mut_range, self.mut_range, self.dim)\n                population[idx] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_improve_individual:\n                worst_individual = population[np.argmin(scores)]\n                new_individual = worst_individual + np.random.uniform(-self.mut_range, self.mut_range, self.dim)\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_adapt:\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                new_individual = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation and improved mutation strategy.", "configspace": "", "generation": 93, "fitness": 0.05773150536696033, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.06.", "error": "", "parent_id": "b2843f80-532b-4bad-82ba-3f7e432f5a2c", "metadata": {"aucs": [0.16051293382135678, 0.09652089851885537, 0.18344706363063723, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.08913596717227812, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009810619512510277, 0.027541673189717453, 0.01976679053868846, 0.029683050783417597, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.027492523308664252, 0.02565370909935827, 0.013869086429510236, 0.01959972157639278, 0.010846793092276319, 0.00954586122211809, 0.014763392921912755, 9.999999999998899e-05, 0.023785360790100074, 0.045179741609489454, 0.047463808713591016, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.11705668850147599, 0.10702369096977782, 0.08898394928774345, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 0.032302649042868836, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008913906533333127, 0.04679431530831257, 0.08949018985544221, 0.05020505553582988, 0.005691107956752206, 0.021582544354765587, 0.030731015983618826, 9.999999999998899e-05, 0.00016828981287031475, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006103680590882066, 0.0009669542317491953, 0.019656949513512934, 0.03218364737347523, 0.05218639152025184, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.15320479691740874, 0.11364201970703702, 0.10274288241579344, 0.12130200439469008, 0.16112956940342849, 0.16567031796175669, 0.14929224131568175, 0.009988402297498977, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.02855987614880684, 0.01759993274736349, 0.026669740724082347, 0.013635172138316332, 0.056418289824262335, 0.14056163417417955, 0.09224123670331086, 0.12997263540963322, 0.1042663169424155, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.09035504112543691, 0.08598016419884602, 0.12723536903406496, 0.1198826004921355, 0.1613932299901245, 0.13800672315110074, 0.16896457800334796, 0.1797190636335405, 0.12028165949079228, 0.17377774300845283, 0.1418499616356632, 0.05985564337097804, 0.074823040651388, 0.08398582550377798, 0.09107448948158803, 0.07892138724323683, 0.07961927722612128, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.13067887704427672, 0.1336924718889153, 0.15033382644780124, 0.15484231143344385, 0.13728814030156422, 0.1486930810102829, 0.14663140569367317, 0.1504235439078928, 0.16150918636689948, 9.999999999998899e-05, 0.029986204171335684, 0.14575397534926904, 0.16384388853865983, 9.999999999998899e-05, 0.032692342818364195, 0.12482085800434106, 9.999999999998899e-05, 9.999999999998899e-05, 0.09709708077286883, 0.1527313584114851, 0.12496141876977895, 0.1063600419237104, 0.1207914665021157, 0.0978543268300962, 0.11160178112797325, 0.10511484148144368, 0.09000964250712462, 0.11040265245322212, 0.10267165755511809, 0.13315327907789976, 0.054003007068266884, 0.07350647422034762, 0.05903250263678039, 0.05817015292016681, 0.07688912132863135, 0.07039996255659497, 0.15937571370684767, 0.15208549267423221, 0.14988183288769374, 0.14574077795301055, 0.15415230345425224, 0.16464390293756692, 0.15705309356289598, 0.14697520783228135, 0.14793735210088288, 0.03921099688746377, 0.0367404481867557, 0.04031935094013539, 0.03808551115334635, 0.03748187089265009, 0.04479082251959987, 0.04290659306743494, 0.03803354422653826, 0.044627828704336014]}, "mutation_prompt": null}
{"id": "8b99224c-f7fb-4bae-afab-b44330710123", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n        self.prob_mut_individual = 0.4\n        self.prob_improve_individual = 0.4\n        self.prob_adapt = 0.4\n\n    def __call__(self, func):\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        for _ in range(self.budget):\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            if random.random() < self.prob_adapt:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                new_individual = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_adapt * 0.2:\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                new_individual = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_adapt * 0.2:\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                new_individual = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_adapt * 0.2:\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                new_individual = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_mut_individual:\n                idx = random.randint(0, self.population_size - 1)\n                new_individual = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                population[idx] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_improve_individual:\n                worst_individual = population[np.argmin(scores)]\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_adapt:\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                new_individual = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 94, "fitness": 0.05384199762020339, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_id": "b2843f80-532b-4bad-82ba-3f7e432f5a2c", "metadata": {"aucs": [0.11869729595922507, 0.08832545836308747, 0.11082843556630528, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.10008667118755543, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0179155520862585, 0.027042548197352856, 0.02639256397195333, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.012982341988373225, 0.010674738340807233, 0.007314314051436455, 0.010574961684367334, 0.009472887235869698, 0.01959972157639278, 0.0004952459975243739, 0.003154442966285531, 0.01783688607972944, 9.999999999998899e-05, 9.999999999998899e-05, 0.04632204921097871, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028280097457138775, 0.006455501632143035, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10122490768381265, 0.09838673867373093, 0.09418708780286178, 0.0667108215001172, 0.07287898191305575, 9.999999999998899e-05, 0.043878433390216354, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01066210275287971, 0.007602489658205425, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016457115085818264, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10872179275056115, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.14134230263251024, 0.18357917711759353, 9.999999999998899e-05, 9.999999999998899e-05, 0.03478293171671798, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.018671760891630917, 0.019342435432503913, 0.0267656688986897, 0.09417811416255939, 0.0957857875475846, 0.11842175776965747, 0.14370949403483158, 0.10852972522114013, 0.10798713552628325, 0.09880672578852023, 0.0989776375258743, 0.07923832634483696, 0.12542447748960694, 0.11570080261365767, 0.1613932299901245, 0.13800672315110074, 0.14440630675512423, 0.1370124472269414, 0.12273415660560427, 0.17377774300845283, 0.11383112831101194, 0.0739406037849285, 0.03980062192872025, 0.08398582550377798, 0.09198801464065487, 0.0917188342083417, 0.1000826190391515, 0.0837317855149382, 0.0997711199450243, 0.0684664179379666, 0.13294174861679697, 0.1171584645890662, 0.13345086981233123, 0.17648083459931008, 0.12666544504386135, 0.14629755401788258, 0.19191189522901297, 0.13002243976580508, 0.1538064284153695, 0.1378024330050026, 9.999999999998899e-05, 9.999999999998899e-05, 0.019497801961975147, 9.999999999998899e-05, 0.13294121868944908, 9.999999999998899e-05, 0.026529241600607434, 0.07155386134888864, 0.10296305713508058, 0.09759291807582304, 0.10710818944744038, 0.09707642703709318, 0.1207914665021157, 0.10764315350220366, 0.1279465955134934, 0.13773937104424716, 0.08181682659887268, 0.11040265245322212, 0.10267165755511809, 0.09758409904932797, 0.05290661832276966, 0.0889477091465406, 0.09373715581807096, 0.11681010733890818, 0.06273481180170093, 0.06880062449957658, 0.13862480986985737, 0.14856101948542333, 0.14763022729669195, 0.15026634218449886, 0.13977674195276046, 0.14939442966849725, 0.16040091815521296, 0.15079059398025552, 0.1600610061153831, 0.03427731059066719, 0.046764915581587796, 0.037257964553862766, 0.02802882079773006, 0.03425093938292756, 0.033702226761820886, 0.040828330513379085, 0.03951802892209344, 0.04750000742645222]}, "mutation_prompt": null}
{"id": "25463a4d-f7f4-4f14-80e1-c9a9303d41d6", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n        self.prob_mut_individual = 0.4\n        self.prob_improve_individual = 0.4\n        self.prob_adapt = 0.4  # Changed probability to 0.4\n\n    def __call__(self, func):\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        for _ in range(self.budget):\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            if random.random() < self.prob_adapt_individual:  # Adapt probability for individual\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                new_individual = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_mut_individual:  # Mutation probability for individual\n                idx = random.randint(0, self.population_size - 1)\n                new_individual = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                population[idx] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_improve_individual:  # Improvement probability for individual\n                worst_individual = population[np.argmin(scores)]\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_adapt:  # Adaptation probability for population\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                new_individual = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.elite_size / self.population_size:  # Elite size probability\n                population[np.argmin(scores)] = best\n\n            if random.random() < self.crossover_prob:  # Crossover probability\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                child = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = child\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 95, "fitness": 0.05716139802516572, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.06.", "error": "", "parent_id": "b2843f80-532b-4bad-82ba-3f7e432f5a2c", "metadata": {"aucs": [0.1400069366369382, 0.10426472744695625, 0.12359327472962778, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06969283080847177, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011193077204514124, 0.01716732649983055, 0.005375109906600173, 0.023031724617552762, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.025849783279007, 0.010674738340807233, 0.019773617938488086, 0.014353618226557452, 0.029207120117854757, 0.01959972157639278, 0.00822523373408024, 0.012209946172857422, 0.014763392921912755, 9.999999999998899e-05, 0.003817703372152037, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10329735816658125, 0.12880921661908362, 0.10756262997596278, 0.07197234850496936, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 0.019103446234243537, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012601346893156284, 9.999999999998899e-05, 9.999999999998899e-05, 0.07762023616701896, 9.999999999998899e-05, 0.07419341355965603, 9.999999999998899e-05, 9.999999999998899e-05, 0.018049034228713623, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009442498464823479, 0.027459185381936035, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13735765536512734, 0.15756555760738078, 0.14838054695461433, 0.11304438863118083, 0.10274288241579344, 0.15605954465354321, 0.1625101956806415, 0.13469399284157968, 0.1756372987402054, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.020993316264037776, 0.008807745023172497, 0.0267656688986897, 0.09938575781257641, 0.09390777907447811, 0.11842175776965747, 0.09855305120349966, 0.12099548151433537, 0.14142182608267062, 0.10313484020627273, 0.08237427455506008, 0.11010769907918949, 0.1124679797587449, 0.11588202241033674, 0.1613932299901245, 0.13800672315110074, 0.1536045028259181, 0.13416892705239114, 0.12028165949079228, 0.17377774300845283, 0.13022526983845528, 0.05985564337097804, 0.05071879175248417, 0.08398582550377798, 0.08771022916759907, 0.09679478660692853, 0.09015766740058839, 0.0837317855149382, 0.0997711199450243, 0.06488349169827234, 0.15124223306428863, 0.17112175658245177, 0.154806099084822, 0.132531620994484, 0.13636959948108307, 0.1507371415400376, 0.14535985984668953, 0.14283947416814613, 0.1379556991386568, 9.999999999998899e-05, 9.999999999998899e-05, 0.1481165284165883, 0.04970566999260295, 0.08584447281422147, 0.12269157584610857, 0.11107701756384081, 0.12136323746303856, 9.999999999998899e-05, 0.10040724604302464, 0.09427073882141213, 0.12405002393059039, 0.10044519035578636, 0.1257246745284949, 0.08566202242945786, 0.1070176662487543, 0.10511484148144368, 0.1054993292836971, 0.11040265245322212, 0.10267165755511809, 0.18432587408520662, 0.05726209809312055, 0.06988207447868244, 0.05903250263678039, 0.12885947825850874, 0.05955603078765814, 0.09112180960244809, 0.1557090781162297, 0.1642994199665342, 0.15536287220164358, 0.1488633846071885, 0.1588789579723332, 0.16507055410883253, 0.16602680522424762, 0.14214386209898988, 0.1591693528065996, 0.03603257835220097, 0.03298089195520826, 0.0369821549910212, 0.03836306960560831, 0.03425093938292756, 0.032455340355244, 0.037809207465008376, 0.03803354422653826, 0.04648902720241421]}, "mutation_prompt": null}
{"id": "30b92155-f5ca-48e1-b94b-2d21e7138b64", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n        self.prob_mut_individual = 0.4\n        self.prob_improve_individual = 0.4\n        self.prob_adapt = 0.4  # Changed probability to 0.4\n\n    def __call__(self, func):\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        for _ in range(self.budget):\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            if random.random() < self.adapt_prob:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                new_individual = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.crossover_prob:\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                child = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = child\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            if random.random() < self.elite_size / self.population_size:\n                population[np.argmin(scores)] = best\n\n            if random.random() < self.improve_prob:\n                worst_individual = population[np.argmin(scores)]\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_mut_individual:\n                idx = random.randint(0, self.population_size - 1)\n                new_individual = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                population[idx] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_improve_individual:\n                worst_individual = population[np.argmin(scores)]\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_adapt:\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                new_individual = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation to handle black box optimization problems.", "configspace": "", "generation": 96, "fitness": 0.06029167983501509, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.06.", "error": "", "parent_id": "b2843f80-532b-4bad-82ba-3f7e432f5a2c", "metadata": {"aucs": [0.11869729595922507, 0.09303476464963278, 0.13053946358887591, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017864307344492958, 0.03541554778756273, 0.021211978136455034, 0.05115430760472861, 0.006592353378601756, 0.022547125377756272, 0.03342023635122893, 0.007792397052521438, 0.010674738340807233, 0.022233873479040267, 0.02153245168776452, 0.023725509251265597, 0.03312934831365599, 0.004779092958272835, 0.005412677059305482, 0.014763392921912755, 9.999999999998899e-05, 0.0360718768371735, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 0.0386448382921355, 9.999999999998899e-05, 0.021427718264302342, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.10123314610397227, 0.11825414751335539, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 0.06919961894045024, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013979656437977939, 0.020591852305738234, 0.028214856209337613, 0.00020318234443816863, 0.05200696603735999, 0.08514270246316025, 0.005677657244487655, 9.999999999998899e-05, 0.012279716822598319, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05245661482595587, 9.999999999998899e-05, 0.025762541392135407, 0.005907233927158306, 0.04499494892492584, 9.999999999998899e-05, 0.033254934089880006, 0.0013806556723769958, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11597818476360067, 0.15756555760738078, 0.15831226993502256, 0.10279143709805372, 0.10274288241579344, 0.1463836778331692, 0.16112956940342849, 0.18780430089581956, 0.16526464988660206, 0.029194193942210234, 9.999999999998899e-05, 0.03839746273458222, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.03402751107707869, 0.01240153321482007, 0.0267656688986897, 0.09302554581169298, 0.12115030751289035, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.14742253829613816, 0.13304725766158754, 0.12830755712717634, 0.13215777983053723, 0.11652796104963892, 0.1613932299901245, 0.1695822963909981, 0.14606678194070077, 0.1484783168400552, 0.12028165949079228, 0.17377774300845283, 0.11747005350704731, 0.05985564337097804, 0.07740557400645598, 0.08398582550377798, 0.08335856343994041, 0.1450037110255662, 0.08494257271471528, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.15748479920017944, 0.1456568369963075, 0.13345086981233123, 0.1357477300882769, 0.13871613927813964, 0.14045400649656692, 0.14114177684394513, 0.13007727649422363, 0.1435252613009127, 9.999999999998899e-05, 0.12708572938780127, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1144667843863848, 0.1292188699281478, 0.011049972879441539, 0.13269176091286794, 0.11178671358388692, 0.07804014236998735, 0.08167024703901915, 0.11680040559146199, 0.12092037639357245, 0.10056407940054246, 0.1070176662487543, 0.15427137821517445, 0.13487241067613942, 0.11040265245322212, 0.10267165755511809, 0.17846987243130863, 0.08097332025619475, 0.08937962337866212, 0.0791370395676193, 0.1140638280833417, 0.10308865816805501, 0.16579811777505016, 0.14596437793966233, 0.15158603164058482, 0.1482941870953013, 0.15720935635423317, 0.16353948371128646, 0.14021559599654776, 0.15756911989042477, 0.1629973810433627, 0.15979956190201772, 0.04990293586069239, 0.027202328392327058, 0.03495496619702876, 0.04885946922811801, 0.039623415098640535, 0.0493670794263773, 0.041168122166934884, 0.03803354422653826, 0.047541871274751846]}, "mutation_prompt": null}
{"id": "447563b7-27c8-415c-a270-bf249b76599b", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 10\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.elite_prob = 0.6\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.prob_mut_individual = 0.4\n        self.prob_improve_individual = 0.4\n        self.prob_adapt = 0.4\n\n    def __call__(self, func):\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        for _ in range(self.budget):\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            if random.random() < self.adapt_prob:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                new_individual = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.elite_prob:\n                population[np.argmin(scores)] = best\n\n            if random.random() < self.improve_prob:\n                worst_individual = population[np.argmin(scores)]\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_mut_individual:\n                idx = random.randint(0, self.population_size - 1)\n                new_individual = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                population[idx] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_improve_individual:\n                worst_individual = population[np.argmin(scores)]\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_adapt:\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                new_individual = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation and elitism.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'CEAI' object has no attribute 'adaptation_threshold_idx'\").", "error": "AttributeError(\"'CEAI' object has no attribute 'adaptation_threshold_idx'\")", "parent_id": "b2843f80-532b-4bad-82ba-3f7e432f5a2c", "metadata": {}, "mutation_prompt": null}
{"id": "c680ab5b-8c20-4eab-97b5-3e1000c82664", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 20  # Increased elite size\n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n        self.prob_mut_individual = 0.4\n        self.prob_improve_individual = 0.4\n        self.prob_adapt = 0.4  # Changed probability to 0.4\n        self.elite_prob = 0.5  # Increased elite probability\n\n    def __call__(self, func):\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        for _ in range(self.budget):\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            if random.random() < self.adapt_prob:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                new_individual = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.crossover_prob:\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                child = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = child\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            if random.random() < self.elite_prob:\n                population[np.argmin(scores)] = best\n\n            if random.random() < self.improve_prob:\n                worst_individual = population[np.argmin(scores)]\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_mut_individual:\n                idx = random.randint(0, self.population_size - 1)\n                new_individual = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                population[idx] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_improve_individual:\n                worst_individual = population[np.argmin(scores)]\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_adapt:\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                new_individual = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation and improved elitism to handle black box optimization problems.", "configspace": "", "generation": 98, "fitness": 0.06519266655830043, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.06.", "error": "", "parent_id": "b2843f80-532b-4bad-82ba-3f7e432f5a2c", "metadata": {"aucs": [0.14148891100409433, 0.11042520562696923, 0.15588307206504504, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01662642327487651, 0.033156110494028, 0.021962622289850353, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.04409588399685893, 0.015177728046255279, 0.0321916116593669, 0.01959972157639278, 0.0072762649503769206, 0.020920212861591736, 0.014763392921912755, 0.003458690930800312, 0.029452205369225548, 0.045179741609489454, 0.055207847946311284, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.03984929464881004, 0.00031549654350837564, 0.04671236252197086, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10672518276905973, 0.11007543073692672, 0.11807601249589716, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 0.030934707062005184, 0.04783808226319308, 9.999999999998899e-05, 0.00024778587568108357, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.054380802278020335, 0.03099993544485513, 0.06401023848702703, 0.0072372800342683785, 0.002924225874950337, 0.022742106472559698, 0.008085880548887703, 0.09539076340483532, 0.01946786657445576, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04818138650048154, 9.999999999998899e-05, 9.999999999998899e-05, 0.03272052119529856, 0.019053386929689053, 9.999999999998899e-05, 0.0009923867584826773, 9.999999999998899e-05, 0.03331378127534956, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.16865979279149856, 0.11751799873586255, 0.09580441870675127, 0.16112956940342849, 0.19282934140571084, 0.1570338995300492, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 0.031878177894274606, 0.024170964601296863, 0.0267656688986897, 0.12774034119786049, 0.13021866063679832, 0.11842175776965747, 0.10994744124891365, 0.10852972522114013, 0.12721527122466791, 0.19928989509987438, 0.16197322445696105, 0.12146223211769425, 0.12569025186441685, 0.12457379120503842, 0.1613932299901245, 0.13800672315110074, 0.16261450796397947, 0.16133249018293994, 0.12028165949079228, 0.17377774300845283, 0.14470182118368013, 0.05985564337097804, 0.05282852635375346, 0.08398582550377798, 0.10975693647433293, 0.10035689466520703, 0.0893696944375082, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.13369717048696872, 0.14365688390462095, 0.13345086981233123, 0.13332824900313844, 0.13952353670074413, 0.13937766734661783, 0.19477833641369324, 0.21502090279148256, 0.14982319831982527, 9.999999999998899e-05, 0.13716403665412857, 0.11441944955652217, 0.1384907135823873, 0.12801293582255746, 0.125370450502431, 0.06513719531763495, 0.13578049650688662, 0.12997475600368358, 0.1551561347573841, 0.15869723753886011, 0.10631103134288078, 0.11507036154589678, 0.1207914665021157, 0.13043782485887845, 0.2315988268190704, 0.1642808705140284, 0.12199033389445846, 0.11040265245322212, 0.14241000181093966, 0.0829870647574642, 0.09272222916619399, 0.1443288086779856, 0.0684226731011246, 0.1158993704173279, 0.06886837323030792, 0.12279028682733661, 0.15776190709424331, 0.14548643095680214, 0.16366633893603888, 0.1529815011293989, 0.14327368236247184, 0.1429756683982123, 0.1526393295794971, 0.14093558117829075, 0.1541737360455645, 0.041741272718988864, 0.04508944951857752, 0.03866877337596397, 0.048872417283097325, 0.045692911123077606, 0.04026330961095881, 0.04521767272731214, 0.060867113230439696, 0.057327200502606646]}, "mutation_prompt": null}
{"id": "333fd5b6-f2c5-4140-bfa5-cc363e5016fb", "solution": "import numpy as np\nimport random\n\nclass CEAI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_size = 20  \n        self.mut_prob = 0.1\n        self.crossover_prob = 0.8\n        self.adapt_prob = 0.4\n        self.improve_prob = 0.2\n        self.adaptation_threshold = 0.4\n        self.adaptation_threshold_idx = 0\n        self.elite_threshold = 0.4\n        self.prob_adapt_individual = 0.4\n        self.prob_mut_individual = 0.4\n        self.prob_improve_individual = 0.4\n        self.prob_adapt = 0.4  \n        self.elite_prob = 0.5  \n\n    def __call__(self, func):\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        best = np.zeros(self.dim)\n        best_func = np.inf\n\n        for _ in range(self.budget):\n            scores = [func(x) for x in population]\n            for i, score in enumerate(scores):\n                if score < best_func:\n                    best_func = score\n                    best = population[i]\n\n            if random.random() < self.adapt_prob:\n                self.adaptation_threshold_idx = (self.adaptation_threshold_idx + 1) % self.population_size\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                new_individual = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.crossover_prob:\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                child = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = child\n                if func(child) < best_func:\n                    best = child\n                    best_func = func(child)\n\n            if random.random() < self.elite_prob:\n                population[np.argmin(scores)] = best\n\n            if random.random() < self.improve_prob:\n                worst_individual = population[np.argmin(scores)]\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_mut_individual:\n                idx = random.randint(0, self.population_size - 1)\n                new_individual = population[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                population[idx] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_improve_individual:\n                worst_individual = population[np.argmin(scores)]\n                new_individual = worst_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n            if random.random() < self.prob_adapt:\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                new_individual = (population[idx1] + population[idx2]) / 2\n                population[np.argmin(scores)] = new_individual\n                if func(new_individual) < best_func:\n                    best = new_individual\n                    best_func = func(new_individual)\n\n        return best, best_func\n\n# Usage\ndef func(x):\n    return sum([i**2 for i in x])\n\ncea = CEAI(budget=100, dim=10)\nbest, score = cea(func)\nprint(f\"Best individual: {best}\")\nprint(f\"Best score: {score}\")\n", "name": "CEAI", "description": "Novel \"Crossover-Elitism-Adaptation-Improvement\" algorithm with probability adaptation and improved elitism to handle black box optimization problems.", "configspace": "", "generation": 99, "fitness": 0.06765378656628848, "feedback": "The algorithm CEAI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.06.", "error": "", "parent_id": "c680ab5b-8c20-4eab-97b5-3e1000c82664", "metadata": {"aucs": [0.11869729595922507, 0.11445135787514116, 0.1533664975325404, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.10218659910943462, 0.10442865543584323, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0205005766666001, 0.031842113116196336, 0.033931730300179486, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 0.03162849753422192, 0.016240239529748957, 0.06333855562108948, 0.01959972157639278, 0.012111468544666826, 0.049739341714354346, 0.0447965275965142, 9.999999999998899e-05, 0.013752270030146563, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.01824258421639391, 0.00031549654350837564, 0.06957802428857973, 9.999999999998899e-05, 0.011293333694524565, 0.003679110451947909, 0.10027683525177622, 0.0892074570694904, 0.10773268709344197, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.05329820231957039, 0.05931056463008866, 0.00990846602666351, 0.006837305606936739, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.025076921363676785, 0.050063996566985014, 0.01726403983069902, 0.019903165684261537, 0.04853450131531678, 0.003072447347365226, 0.016302536729077333, 0.036414847066085665, 0.08399569566996634, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05068444490108448, 9.999999999998899e-05, 0.025385743067859234, 0.032393483432846315, 0.0636705560140235, 0.05218455644042319, 0.037870014963098164, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.14525956219549718, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.1047054516877779, 0.17972208183052296, 0.194471581701958, 0.1868523292369959, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.002264039542531515, 0.023290670639498745, 0.04813711553482969, 0.020036861968701802, 0.0267656688986897, 0.1271378565661173, 0.1029830657576094, 0.12842496014498972, 0.09855305120349966, 0.11049125551133288, 0.10798713552628325, 0.14621056646779884, 0.15692016954579924, 0.12615543960425535, 0.1236190839444371, 0.11598504984253344, 0.1613932299901245, 0.13800672315110074, 0.17592718579144928, 0.13245664600305918, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.07360162802327319, 0.10122065791757939, 0.07677933626591693, 0.11003576563372719, 0.12602686685045994, 0.0837317855149382, 0.0997711199450243, 0.07439221240758964, 0.14267384543021266, 0.1692870798061149, 0.16101820069783657, 0.14407589253405695, 0.14765473367939996, 0.14703160014483097, 0.15607864567208474, 0.13752211750598453, 0.15946378630529112, 0.15723830646712433, 0.10528391080959754, 0.12046463168548704, 9.999999999998899e-05, 0.14126536230475217, 0.11772024153879179, 0.14282989759861942, 0.14305662922631546, 0.14366526258243684, 0.12559346642265412, 0.15023723558211477, 0.13127642675169915, 0.11626759460020952, 0.12798651808550254, 0.18304254868283554, 0.2671317185152998, 0.19987186566886506, 0.14444531964744822, 0.11040265245322212, 0.10267165755511809, 0.11541178869063273, 0.09819123251181572, 0.08987215688846095, 0.10482925420697342, 0.15258357557637714, 0.11110618495573477, 0.14205993727617006, 0.155930879333122, 0.1643859639137779, 0.16212443278333177, 0.15970700887283762, 0.18907290755972317, 0.16058816894423666, 0.15538670024797885, 0.15505109452641241, 0.15306086498833216, 0.05074330275361938, 0.02651400963563688, 0.054555908162090105, 0.05458069916187924, 0.03491277089059708, 0.06826431181217452, 0.0684043218377981, 0.039986313107342575, 0.06065948591501369]}, "mutation_prompt": null}
