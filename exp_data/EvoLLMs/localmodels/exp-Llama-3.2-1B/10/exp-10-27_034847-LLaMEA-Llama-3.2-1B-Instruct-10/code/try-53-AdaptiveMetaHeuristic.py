import numpy as np
import random

class AdaptiveMetaHeuristic:
    """
    An adaptive metaheuristic algorithm for solving black box optimization problems.
    
    The algorithm uses a combination of genetic algorithm and gradient-based optimization to find the optimal solution.
    
    Attributes:
    budget (int): The maximum number of function evaluations allowed.
    dim (int): The dimensionality of the search space.
    func (function): The black box function to optimize.
    search_space (list): The range of the search space.
    bounds (list): The bounds of the search space.
    population_size (int): The size of the population.
    mutation_rate (float): The rate at which the population is mutated.
    """

    def __init__(self, budget, dim, population_size, mutation_rate):
        """
        Initializes the AdaptiveMetaHeuristic algorithm.
        
        Args:
        budget (int): The maximum number of function evaluations allowed.
        dim (int): The dimensionality of the search space.
        population_size (int): The size of the population.
        mutation_rate (float): The rate at which the population is mutated.
        """
        self.budget = budget
        self.dim = dim
        self.population_size = population_size
        self.mutation_rate = mutation_rate
        self.func = None
        self.search_space = None
        self.bounds = None
        self.population = None

    def __call__(self, func):
        """
        Optimizes the black box function using AdaptiveMetaHeuristic.
        
        Args:
        func (function): The black box function to optimize.
        
        Returns:
        tuple: A tuple containing the optimal solution and its cost.
        """
        if self.func is None:
            raise ValueError("The black box function must be initialized before calling this method.")
        
        # Initialize the search space
        self.search_space = [self.bounds] * self.dim
        self.bounds = [(-5.0, 5.0)] * self.dim
        
        # Initialize the population
        self.population = [self.perturb(self.search_space, self.bounds) for _ in range(self.population_size)]
        
        # Initialize the optimal solution and its cost
        opt_solution = None
        opt_cost = float('inf')
        
        # Perform genetic algorithm
        while self.population:
            # Evaluate the fitness of each individual
            fitness = [self.evaluate_fitness(individual, func) for individual in self.population]
            
            # Select the fittest individuals
            self.population = self.select_fittest(self.population, fitness)
            
            # Crossover (reproduce) the fittest individuals
            self.population = self.crossover(self.population)
            
            # Mutate the fittest individuals
            self.population = self.mutate(self.population, self.mutation_rate)
            
            # Update the optimal solution and its cost if necessary
            if self.population:
                opt_solution = self.population[0]
                opt_cost = self.func(opt_solution)
        
        # Return the optimal solution and its cost
        return opt_solution, opt_cost

    def perturb(self, search_space, bounds):
        """
        Generates a new solution by perturbing the current solution.
        
        Args:
        search_space (list): The current search space.
        bounds (list): The current bounds of the search space.
        
        Returns:
        list: A new solution generated by perturbing the current solution.
        """
        # Generate a new solution by randomly perturbing the current solution
        new_solution = [bounds[0] + np.random.uniform(-1, 1) * (bounds[1] - bounds[0]) for _ in range(self.dim)]
        
        # Ensure the new solution is within the bounds
        new_solution = [max(bounds[i], min(new_solution[i], bounds[i])) for i in range(self.dim)]
        
        return new_solution

    def evaluate_fitness(self, individual, func):
        """
        Evaluates the fitness of an individual.
        
        Args:
        individual (list): The individual to evaluate.
        func (function): The black box function to evaluate the individual with.
        
        Returns:
        float: The fitness of the individual.
        """
        # Evaluate the fitness of the individual using the black box function
        return func(individual)

    def select_fittest(self, population, fitness):
        """
        Selects the fittest individuals from the population.
        
        Args:
        population (list): The population of individuals.
        fitness (list): The fitness of each individual.
        
        Returns:
        list: The fittest individuals.
        """
        # Select the fittest individuals based on their fitness
        return sorted(population, key=fitness, reverse=True)[:self.population_size // 2]

    def crossover(self, population):
        """
        Crossover (reproduce) the fittest individuals.
        
        Args:
        population (list): The population of individuals.
        
        Returns:
        list: The fittest individuals.
        """
        # Perform crossover (reproduce) the fittest individuals
        offspring = []
        for _ in range(self.population_size // 2):
            parent1, parent2 = random.sample(population, 2)
            child = [self.perturb(parent1, self.bounds), self.perturb(parent2, self.bounds)]
            offspring.append(child)
        return offspring

    def mutate(self, population, mutation_rate):
        """
        Mutates the fittest individuals.
        
        Args:
        population (list): The population of individuals.
        mutation_rate (float): The rate at which the population is mutated.
        
        Returns:
        list: The mutated population.
        """
        # Perform mutation on the fittest individuals
        mutated_population = []
        for individual in population:
            if random.random() < mutation_rate:
                mutated_individual = individual.copy()
                mutated_individual[random.randint(0, self.dim) - 1] += np.random.uniform(-1, 1)
                mutated_individual[random.randint(0, self.dim) - 1] *= np.random.uniform(-1, 1)
                mutated_population.append(mutated_individual)
            else:
                mutated_population.append(individual)
        return mutated_population

# Description: Adaptive Black Box Optimization using Genetic Algorithm
# Code: 
# ```python
# Adaptive Black Box Optimization using Genetic Algorithm
# 
# The algorithm uses a combination of genetic algorithm and gradient-based optimization to find the optimal solution.
# 
# Attributes:
# budget (int): The maximum number of function evaluations allowed.
# dim (int): The dimensionality of the search space.
# population_size (int): The size of the population.
# mutation_rate (float): The rate at which the population is mutated.
# """

# Create an instance of the AdaptiveMetaHeuristic algorithm
adaptive_metaheuristic = AdaptiveMetaHeuristic(100, 10, 100, 0.1)

# Define the black box function
def func(x):
    return x[0]**2 + x[1]**2

# Optimize the black box function using the AdaptiveMetaHeuristic algorithm
optimal_solution, optimal_cost = adaptive_metaheuristic(func)

# Print the result
print("Optimal Solution:", optimal_solution)
print("Optimal Cost:", optimal_cost)

# Update the algorithm
adaptive_metaheuristic.func = func

# Run the algorithm for 1000 iterations
for _ in range(1000):
    # Evaluate the fitness of each individual
    fitness = [adaptive_metaheuristic.evaluate_fitness(individual, func) for individual in adaptive_metaheuristic.population]
    
    # Select the fittest individuals
    adaptive_metaheuristic.population = adaptive_metaheuristic.select_fittest(adaptive_metaheuristic.population, fitness)
    
    # Crossover (reproduce) the fittest individuals
    adaptive_metaheuristic.population = adaptive_metaheuristic.crossover(adaptive_metaheuristic.population)
    
    # Mutate the fittest individuals
    adaptive_metaheuristic.population = adaptive_metaheuristic.mutate(adaptive_metaheuristic.population, adaptive_metaheuristic.mutation_rate)