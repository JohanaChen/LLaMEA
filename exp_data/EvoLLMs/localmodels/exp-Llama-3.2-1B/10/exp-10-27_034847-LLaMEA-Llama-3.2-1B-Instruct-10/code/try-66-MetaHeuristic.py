import numpy as np
from scipy.optimize import minimize

class MetaHeuristic:
    """
    A metaheuristic algorithm for solving black box optimization problems.
    
    The algorithm uses a combination of local search and gradient-based optimization to find the optimal solution.
    
    Attributes:
    budget (int): The maximum number of function evaluations allowed.
    dim (int): The dimensionality of the search space.
    func (function): The black box function to optimize.
    search_space (list): The range of the search space.
    bounds (list): The bounds of the search space.
    """

    def __init__(self, budget, dim):
        """
        Initializes the MetaHeuristic algorithm.
        
        Args:
        budget (int): The maximum number of function evaluations allowed.
        dim (int): The dimensionality of the search space.
        """
        self.budget = budget
        self.dim = dim
        self.func = None
        self.search_space = None
        self.bounds = None

    def __call__(self, func):
        """
        Optimizes the black box function using MetaHeuristic.
        
        Args:
        func (function): The black box function to optimize.
        
        Returns:
        tuple: A tuple containing the optimal solution and its cost.
        """
        if self.func is None:
            raise ValueError("The black box function must be initialized before calling this method.")
        
        # Initialize the search space
        self.search_space = [self.bounds] * self.dim
        self.bounds = [(-5.0, 5.0)] * self.dim
        
        # Initialize the optimal solution and its cost
        opt_solution = None
        opt_cost = float('inf')
        
        # Perform local search
        for _ in range(self.budget):
            # Generate a new solution by perturbing the current solution
            new_solution = self.perturb(self.search_space, self.bounds)
            
            # Evaluate the new solution using the black box function
            new_cost = self.func(new_solution)
            
            # Update the optimal solution and its cost if necessary
            if new_cost < opt_cost:
                opt_solution = new_solution
                opt_cost = new_cost
        
        # Return the optimal solution and its cost
        return opt_solution, opt_cost

    def perturb(self, search_space, bounds):
        """
        Generates a new solution by perturbing the current solution.
        
        Args:
        search_space (list): The current search space.
        bounds (list): The current bounds of the search space.
        
        Returns:
        list: A new solution generated by perturbing the current solution.
        """
        # Generate a new solution by randomly perturbing the current solution
        new_solution = [self.bounds[0] + np.random.uniform(-1, 1) * (self.bounds[1] - self.bounds[0]) for _ in range(self.dim)]
        
        # Ensure the new solution is within the bounds
        new_solution = [max(bounds[i], min(new_solution[i], bounds[i])) for i in range(self.dim)]
        
        return new_solution

    def evolve(self, func, population_size, mutation_rate, bounds):
        """
        Evolves the population using evolutionary strategies.
        
        Args:
        func (function): The black box function to optimize.
        population_size (int): The size of the population.
        mutation_rate (float): The mutation rate.
        bounds (list): The bounds of the search space.
        
        Returns:
        list: The optimized population.
        """
        # Initialize the population
        population = [self.evaluate_fitness(func, individual) for individual in np.random.uniform(bounds, size=population_size)]
        
        # Evolve the population
        for _ in range(100):
            # Select the fittest individuals
            fittest_individuals = [individual for individual, fitness in zip(population, population) if fitness == min(population)]
            
            # Evolve the fittest individuals
            for _ in range(population_size // 2):
                # Select two parents
                parent1, parent2 = np.random.choice(fittest_individuals, size=2, replace=False)
                
                # Perform crossover
                child = [self.evaluate_fitness(func, individual) for individual in np.random.uniform(bounds, size=2)]
                child = [individual if individual == parent1 else individual for individual in child]
                
                # Perform mutation
                if np.random.rand() < mutation_rate:
                    child[0] = self.perturb(self.bounds, child[0])
                if np.random.rand() < mutation_rate:
                    child[1] = self.perturb(self.bounds, child[1])
                
                # Replace the fittest individual with the child
                population[fittest_individuals.index(max(population))] = child
        
        # Return the optimized population
        return population

# Description: Black Box Optimization using MetaHeuristic Algorithm
# Code: 
# ```python
# Black Box Optimization using MetaHeuristic Algorithm
# 
# This algorithm uses a combination of local search and gradient-based optimization to find the optimal solution.
# It adapts the strategy based on the performance of the individuals in the population.
# 
# Attributes:
# budget (int): The maximum number of function evaluations allowed.
# dim (int): The dimensionality of the search space.
# func (function): The black box function to optimize.
# search_space (list): The range of the search space.
# bounds (list): The bounds of the search space.
# """

# Initialize the MetaHeuristic algorithm
meta_heuristic = MetaHeuristic(1000, 100)

# Evaluate the black box function
def func(x):
    return np.sum(np.square(x))

# Initialize the population
population = meta_heuristic.evolve(func, 100, 0.1, [(-5.0, 5.0)])

# Print the optimized population
print("Optimized Population:")
for i, individual in enumerate(population):
    print(f"Individual {i+1}: {individual}")

# Print the optimal solution
opt_solution = max(population)
opt_cost = func(opt_solution)
print(f"Optimal Solution: {opt_solution}, Optimal Cost: {opt_cost}")