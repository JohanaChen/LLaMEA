{"id": "2fd4d2ee-3c83-4f92-9c2c-dc30d2c00099", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _differential_evolution(self, population, scores):\n        pop_size = len(population)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + 0.8 * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < 0.9\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, x, score):\n        temperature = 1.0\n        cooling_rate = 0.99\n        for _ in range(100):\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = 20\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(population, scores)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += 100  # Simulated Annealing uses constant evaluations\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "HybridDESA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for efficient exploration and exploitation in high-dimensional optimization.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 55, in __call__\n  File \"<string>\", line 27, in _differential_evolution\nNameError: name 'func' is not defined\n.", "error": "NameError(\"name 'func' is not defined\")Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 55, in __call__\n  File \"<string>\", line 27, in _differential_evolution\nNameError: name 'func' is not defined\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "d192eb9e-1972-4346-8c61-22e64bb7245e", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _differential_evolution(self, population, scores):\n        pop_size = len(population)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + 0.8 * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < 0.9\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, x, score):\n        temperature = 1.0\n        cooling_rate = 0.99\n        for _ in range(100):\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = 20\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(population, scores)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += 100  # Simulated Annealing uses constant evaluations\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "HybridDESA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for efficient exploration and exploitation in high-dimensional optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2fd4d2ee-3c83-4f92-9c2c-dc30d2c00099", "metadata": {}, "mutation_prompt": null}
{"id": "5e58ce1c-465c-4eea-b78d-ee4fa3b35451", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _differential_evolution(self, population, scores):\n        pop_size = len(population)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + 0.8 * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < 0.9\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, x, score):\n        temperature = 1.0\n        cooling_rate = 0.99\n        for _ in range(100):\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = 20\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(population, scores)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += 100  # Simulated Annealing uses constant evaluations\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "HybridDESA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for efficient exploration and exploitation in high-dimensional optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2fd4d2ee-3c83-4f92-9c2c-dc30d2c00099", "metadata": {}, "mutation_prompt": null}
{"id": "3152f90f-18a3-454d-b4ed-8f7a1a32958e", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _differential_evolution(self, population, scores):\n        pop_size = len(population)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + 0.8 * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < 0.9\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, x, score):\n        temperature = 1.0\n        cooling_rate = 0.99\n        for _ in range(100):\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = 20\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(population, scores)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += 100  # Simulated Annealing uses constant evaluations\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "HybridDESA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for efficient exploration and exploitation in high-dimensional optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2fd4d2ee-3c83-4f92-9c2c-dc30d2c00099", "metadata": {}, "mutation_prompt": null}
{"id": "e14c80ee-f270-4a8b-9f6a-68d465c1c408", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _differential_evolution(self, population, scores):\n        pop_size = len(population)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + 0.8 * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < 0.9\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, x, score):\n        temperature = 1.0\n        cooling_rate = 0.99\n        for _ in range(100):\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = 20\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(population, scores)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += 100  # Simulated Annealing uses constant evaluations\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "HybridDESA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for efficient exploration and exploitation in high-dimensional optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2fd4d2ee-3c83-4f92-9c2c-dc30d2c00099", "metadata": {}, "mutation_prompt": null}
{"id": "ac31c046-7ecf-45b4-8f94-83d9bcceba4e", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _differential_evolution(self, population, scores):\n        pop_size = len(population)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + 0.8 * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < 0.9\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, x, score):\n        temperature = 1.0\n        cooling_rate = 0.99\n        for _ in range(100):\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = 20\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(population, scores)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += 100  # Simulated Annealing uses constant evaluations\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "HybridDESA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for efficient exploration and exploitation in high-dimensional optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2fd4d2ee-3c83-4f92-9c2c-dc30d2c00099", "metadata": {}, "mutation_prompt": null}
{"id": "7d45ff7c-7754-409d-bf91-c3a5f14473e1", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _differential_evolution(self, population, scores):\n        pop_size = len(population)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + 0.8 * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < 0.9\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, x, score):\n        temperature = 1.0\n        cooling_rate = 0.99\n        for _ in range(100):\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = 20\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(population, scores)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += 100  # Simulated Annealing uses constant evaluations\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "HybridDESA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for efficient exploration and exploitation in high-dimensional optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2fd4d2ee-3c83-4f92-9c2c-dc30d2c00099", "metadata": {}, "mutation_prompt": null}
{"id": "4332f89c-ab38-4d12-906a-b7d134cf7108", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _differential_evolution(self, population, scores):\n        pop_size = len(population)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + 0.8 * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < 0.9\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, x, score):\n        temperature = 1.0\n        cooling_rate = 0.99\n        for _ in range(100):\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = 20\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(population, scores)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += 100  # Simulated Annealing uses constant evaluations\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "HybridDESA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for efficient exploration and exploitation in high-dimensional optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2fd4d2ee-3c83-4f92-9c2c-dc30d2c00099", "metadata": {}, "mutation_prompt": null}
{"id": "6b3f27ad-eb69-44c4-9b88-296a9a927cd6", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _differential_evolution(self, population, scores):\n        pop_size = len(population)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + 0.8 * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < 0.9\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, x, score):\n        temperature = 1.0\n        cooling_rate = 0.99\n        for _ in range(100):\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = 20\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(population, scores)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += 100  # Simulated Annealing uses constant evaluations\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "HybridDESA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for efficient exploration and exploitation in high-dimensional optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2fd4d2ee-3c83-4f92-9c2c-dc30d2c00099", "metadata": {}, "mutation_prompt": null}
{"id": "d9845d30-15fd-4cdd-83d7-3131cb13c7da", "solution": "import numpy as np\n\nclass OptimizedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _differential_evolution(self, func, population, scores):\n        pop_size = len(population)\n        F = 0.5  # Reduced mutation factor for stability\n        Cr = 0.8  # Adaptive crossover probability\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Adjusted cooling rate for faster convergence\n        for _ in range(50):  # Reduced iterations to save evaluations\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(20, self.budget // 5)  # Adaptive population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += 50  # Updated for new SA evaluation count\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "OptimizedHybridDESA", "description": "Optimized HybridDESA using adaptive population size and enhanced crossover strategy for improved efficiency in high-dimensional optimization.", "configspace": "", "generation": 9, "fitness": 0.2779928780133897, "feedback": "The algorithm OptimizedHybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.20.", "error": "", "parent_id": "2fd4d2ee-3c83-4f92-9c2c-dc30d2c00099", "metadata": {"aucs": [0.5184339158250275, 0.5716516036944679, 0.590587097543241, 0.55379674924238, 0.5980900608794282, 0.5850436081054731, 0.5395813104538045, 0.6111279856322731, 0.545208592601521, 0.580111721838146, 0.5924266306206449, 0.5483457174382729, 0.5835635377151456, 0.5494615904469172, 0.5347623763931116, 0.5562514932975136, 0.5461857054843038, 0.5520086721775832, 0.12676839901058679, 0.11645707901834956, 0.1415668125941718, 0.12381756841713054, 0.1307221717905268, 0.13302611207955473, 0.18431308570950855, 0.15157052681199623, 0.11719378249284595, 0.12927345276958824, 0.12154830990963328, 0.1142020782524702, 0.1434643460046775, 0.12616021692299328, 0.09911626066151968, 0.10939963921307205, 0.11649585561590525, 0.150877916852307, 0.9106848377508691, 0.908526875567634, 0.8534479613583235, 0.8915185080245485, 0.9432133952655869, 0.9022960342356929, 0.9152559463368451, 0.9306634077637912, 0.9498994493148086, 0.32001235668692585, 0.30675574425049434, 0.3110722731204695, 0.3347524217339758, 0.31734149353977126, 0.3466004809500286, 0.30968811239096117, 0.31357643177501837, 0.31622870027340266, 0.3628507590283965, 0.4785811948789368, 0.3220894396192736, 0.5756287075119585, 0.3250063814929314, 0.4560880576301185, 0.466377089673213, 0.36362135710215804, 0.3157036532606414, 0.14584396971546398, 0.2076396321345534, 0.2312053500542086, 0.21038576822509847, 0.22828604179192102, 0.28530926064229456, 0.21732281734173953, 0.23661117135349918, 0.19375007610996242, 0.2476548541259933, 0.22249983959103614, 0.21172676332521367, 0.22035043140868205, 0.22388039128059367, 0.23245632172141795, 0.2488112063591088, 0.22662253309129332, 0.2326627035084009, 0.010403003814351552, 0.10211209262776832, 0.0374851220233311, 0.050212836836029395, 0.0701293434207777, 0.09876317685274238, 0.14597175340038082, 0.2027280044684565, 0.2181341496614374, 0.22914519018721968, 0.22839022892062955, 0.20188843124222666, 0.12041079252605691, 0.1336850180200072, 0.2119937876150364, 0.18266936193900096, 0.20200313428112515, 0.09509941484081341, 0.03598464048562022, 0.03179291955670671, 0.1406420399879753, 0.06883485548556145, 0.05717687134789862, 0.05601716893072772, 0.05663800325477952, 0.036170795146634904, 0.07045635258307414, 0.17462291604833013, 0.16667122408967683, 0.21934493914297604, 0.1788695088896184, 0.11909488629609455, 0.15912055694786487, 0.2202166708139175, 0.10380824092899243, 0.10790594759893046, 0.40482115377721506, 0.4253300420801014, 0.4287037731115837, 0.4178170407193428, 0.4185082988957043, 0.4364787352755526, 0.4316382098868875, 0.41563803883594297, 0.40636316552117024, 0.10722643692849088, 0.14108051105970498, 0.10816913448109877, 0.11268617771289158, 0.10637716508743755, 0.10696716547777685, 0.1348183623495619, 0.08974714709401665, 0.10062506656353376, 0.19275928486570237, 0.2716780357922952, 0.211399395450946, 0.3077655588098467, 0.25995533753300093, 0.1909527555500644, 0.24721184511828087, 0.20749223029678743, 0.29449273245927565, 0.2540732925675685, 0.27186917245786213, 0.2674018931605827, 0.2724205680908066, 0.2802956203259803, 0.24673077857171333, 0.3026849906296135, 0.2866367308281087, 0.2724526054929921, 0.2230549849457255, 0.23275245279082069, 0.2374737288955202, 0.23403887751407804, 0.22707016238596078, 0.2328455813541369, 0.23972701080291203, 0.2631874135134762, 0.24243411410759685, 0.2763432703853841, 0.2331040769886904, 0.20389985781316522, 0.23430486382916527, 0.20360086020005297, 0.19802382090040693, 0.20757659031203246, 0.20439903102703283, 0.21448440015291548, 0.21582286616382007, 0.2265854240648688, 0.23073638645568129, 0.22885095156717694, 0.22045184378409344, 0.2011909948125794, 0.21386696588568055, 0.2384127252180397, 0.2661539411555419, 0.1733110974531059, 0.6429101621588782, 0.1865932428922752, 0.6286404796363207, 0.20187609796649075, 0.20099832326317446, 0.16908836882416167, 0.5092069914436737, 0.17686058188996268, 0.47650304371759367, 0.2119919017449785, 0.5195925978851388, 0.16550782705491296, 0.5536379594422642, 0.21202535841771553, 0.21058117220537664, 0.5341819654562641, 0.4101156874661456, 0.17443606983627047, 0.17942299711521448, 0.18433323739378482, 0.19147608317831233, 0.192680319453282, 0.1978505308620181, 0.1906535195615815, 0.1822076110655687, 0.18023934380222495, 0.10400245108631279, 0.08842269093649224, 0.07872066489341467, 0.08635552933542456, 0.092803308160467, 0.1051493485430558, 0.07831389784222864, 0.07607393579723598, 0.09033003717872468]}, "mutation_prompt": null}
{"id": "cb5c7bea-a389-4b1a-9409-84ee911ee30b", "solution": "import numpy as np\n\nclass OptimizedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _differential_evolution(self, func, population, scores):\n        pop_size = len(population)\n        F = 0.5  # Reduced mutation factor for stability\n        Cr = 0.8  # Adaptive crossover probability\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Adjusted cooling rate for faster convergence\n        for _ in range(50):  # Reduced iterations to save evaluations\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(20, self.budget // 5)  # Adaptive population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += 50  # Updated for new SA evaluation count\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "OptimizedHybridDESA", "description": "Optimized HybridDESA using adaptive population size and enhanced crossover strategy for improved efficiency in high-dimensional optimization.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9845d30-15fd-4cdd-83d7-3131cb13c7da", "metadata": {"aucs": [0.5184339158250275, 0.5716516036944679, 0.590587097543241, 0.55379674924238, 0.5980900608794282, 0.5850436081054731, 0.5395813104538045, 0.6111279856322731, 0.545208592601521, 0.580111721838146, 0.5924266306206449, 0.5483457174382729, 0.5835635377151456, 0.5494615904469172, 0.5347623763931116, 0.5562514932975136, 0.5461857054843038, 0.5520086721775832, 0.12676839901058679, 0.11645707901834956, 0.1415668125941718, 0.12381756841713054, 0.1307221717905268, 0.13302611207955473, 0.18431308570950855, 0.15157052681199623, 0.11719378249284595, 0.12927345276958824, 0.12154830990963328, 0.1142020782524702, 0.1434643460046775, 0.12616021692299328, 0.09911626066151968, 0.10939963921307205, 0.11649585561590525, 0.150877916852307, 0.9106848377508691, 0.908526875567634, 0.8534479613583235, 0.8915185080245485, 0.9432133952655869, 0.9022960342356929, 0.9152559463368451, 0.9306634077637912, 0.9498994493148086, 0.32001235668692585, 0.30675574425049434, 0.3110722731204695, 0.3347524217339758, 0.31734149353977126, 0.3466004809500286, 0.30968811239096117, 0.31357643177501837, 0.31622870027340266, 0.3628507590283965, 0.4785811948789368, 0.3220894396192736, 0.5756287075119585, 0.3250063814929314, 0.4560880576301185, 0.466377089673213, 0.36362135710215804, 0.3157036532606414, 0.14584396971546398, 0.2076396321345534, 0.2312053500542086, 0.21038576822509847, 0.22828604179192102, 0.28530926064229456, 0.21732281734173953, 0.23661117135349918, 0.19375007610996242, 0.2476548541259933, 0.22249983959103614, 0.21172676332521367, 0.22035043140868205, 0.22388039128059367, 0.23245632172141795, 0.2488112063591088, 0.22662253309129332, 0.2326627035084009, 0.010403003814351552, 0.10211209262776832, 0.0374851220233311, 0.050212836836029395, 0.0701293434207777, 0.09876317685274238, 0.14597175340038082, 0.2027280044684565, 0.2181341496614374, 0.22914519018721968, 0.22839022892062955, 0.20188843124222666, 0.12041079252605691, 0.1336850180200072, 0.2119937876150364, 0.18266936193900096, 0.20200313428112515, 0.09509941484081341, 0.03598464048562022, 0.03179291955670671, 0.1406420399879753, 0.06883485548556145, 0.05717687134789862, 0.05601716893072772, 0.05663800325477952, 0.036170795146634904, 0.07045635258307414, 0.17462291604833013, 0.16667122408967683, 0.21934493914297604, 0.1788695088896184, 0.11909488629609455, 0.15912055694786487, 0.2202166708139175, 0.10380824092899243, 0.10790594759893046, 0.40482115377721506, 0.4253300420801014, 0.4287037731115837, 0.4178170407193428, 0.4185082988957043, 0.4364787352755526, 0.4316382098868875, 0.41563803883594297, 0.40636316552117024, 0.10722643692849088, 0.14108051105970498, 0.10816913448109877, 0.11268617771289158, 0.10637716508743755, 0.10696716547777685, 0.1348183623495619, 0.08974714709401665, 0.10062506656353376, 0.19275928486570237, 0.2716780357922952, 0.211399395450946, 0.3077655588098467, 0.25995533753300093, 0.1909527555500644, 0.24721184511828087, 0.20749223029678743, 0.29449273245927565, 0.2540732925675685, 0.27186917245786213, 0.2674018931605827, 0.2724205680908066, 0.2802956203259803, 0.24673077857171333, 0.3026849906296135, 0.2866367308281087, 0.2724526054929921, 0.2230549849457255, 0.23275245279082069, 0.2374737288955202, 0.23403887751407804, 0.22707016238596078, 0.2328455813541369, 0.23972701080291203, 0.2631874135134762, 0.24243411410759685, 0.2763432703853841, 0.2331040769886904, 0.20389985781316522, 0.23430486382916527, 0.20360086020005297, 0.19802382090040693, 0.20757659031203246, 0.20439903102703283, 0.21448440015291548, 0.21582286616382007, 0.2265854240648688, 0.23073638645568129, 0.22885095156717694, 0.22045184378409344, 0.2011909948125794, 0.21386696588568055, 0.2384127252180397, 0.2661539411555419, 0.1733110974531059, 0.6429101621588782, 0.1865932428922752, 0.6286404796363207, 0.20187609796649075, 0.20099832326317446, 0.16908836882416167, 0.5092069914436737, 0.17686058188996268, 0.47650304371759367, 0.2119919017449785, 0.5195925978851388, 0.16550782705491296, 0.5536379594422642, 0.21202535841771553, 0.21058117220537664, 0.5341819654562641, 0.4101156874661456, 0.17443606983627047, 0.17942299711521448, 0.18433323739378482, 0.19147608317831233, 0.192680319453282, 0.1978505308620181, 0.1906535195615815, 0.1822076110655687, 0.18023934380222495, 0.10400245108631279, 0.08842269093649224, 0.07872066489341467, 0.08635552933542456, 0.092803308160467, 0.1051493485430558, 0.07831389784222864, 0.07607393579723598, 0.09033003717872468]}, "mutation_prompt": null}
{"id": "25109dc2-1889-40e0-a9c1-64d4d1bb06af", "solution": "import numpy as np\n\nclass OptimizedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _differential_evolution(self, func, population, scores):\n        pop_size = len(population)\n        F = 0.5  # Reduced mutation factor for stability\n        Cr = 0.8  # Adaptive crossover probability\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Adjusted cooling rate for faster convergence\n        for _ in range(50):  # Reduced iterations to save evaluations\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(20, self.budget // 5)  # Adaptive population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += 50  # Updated for new SA evaluation count\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "OptimizedHybridDESA", "description": "Optimized HybridDESA using adaptive population size and enhanced crossover strategy for improved efficiency in high-dimensional optimization.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9845d30-15fd-4cdd-83d7-3131cb13c7da", "metadata": {"aucs": [0.5184339158250275, 0.5716516036944679, 0.590587097543241, 0.55379674924238, 0.5980900608794282, 0.5850436081054731, 0.5395813104538045, 0.6111279856322731, 0.545208592601521, 0.580111721838146, 0.5924266306206449, 0.5483457174382729, 0.5835635377151456, 0.5494615904469172, 0.5347623763931116, 0.5562514932975136, 0.5461857054843038, 0.5520086721775832, 0.12676839901058679, 0.11645707901834956, 0.1415668125941718, 0.12381756841713054, 0.1307221717905268, 0.13302611207955473, 0.18431308570950855, 0.15157052681199623, 0.11719378249284595, 0.12927345276958824, 0.12154830990963328, 0.1142020782524702, 0.1434643460046775, 0.12616021692299328, 0.09911626066151968, 0.10939963921307205, 0.11649585561590525, 0.150877916852307, 0.9106848377508691, 0.908526875567634, 0.8534479613583235, 0.8915185080245485, 0.9432133952655869, 0.9022960342356929, 0.9152559463368451, 0.9306634077637912, 0.9498994493148086, 0.32001235668692585, 0.30675574425049434, 0.3110722731204695, 0.3347524217339758, 0.31734149353977126, 0.3466004809500286, 0.30968811239096117, 0.31357643177501837, 0.31622870027340266, 0.3628507590283965, 0.4785811948789368, 0.3220894396192736, 0.5756287075119585, 0.3250063814929314, 0.4560880576301185, 0.466377089673213, 0.36362135710215804, 0.3157036532606414, 0.14584396971546398, 0.2076396321345534, 0.2312053500542086, 0.21038576822509847, 0.22828604179192102, 0.28530926064229456, 0.21732281734173953, 0.23661117135349918, 0.19375007610996242, 0.2476548541259933, 0.22249983959103614, 0.21172676332521367, 0.22035043140868205, 0.22388039128059367, 0.23245632172141795, 0.2488112063591088, 0.22662253309129332, 0.2326627035084009, 0.010403003814351552, 0.10211209262776832, 0.0374851220233311, 0.050212836836029395, 0.0701293434207777, 0.09876317685274238, 0.14597175340038082, 0.2027280044684565, 0.2181341496614374, 0.22914519018721968, 0.22839022892062955, 0.20188843124222666, 0.12041079252605691, 0.1336850180200072, 0.2119937876150364, 0.18266936193900096, 0.20200313428112515, 0.09509941484081341, 0.03598464048562022, 0.03179291955670671, 0.1406420399879753, 0.06883485548556145, 0.05717687134789862, 0.05601716893072772, 0.05663800325477952, 0.036170795146634904, 0.07045635258307414, 0.17462291604833013, 0.16667122408967683, 0.21934493914297604, 0.1788695088896184, 0.11909488629609455, 0.15912055694786487, 0.2202166708139175, 0.10380824092899243, 0.10790594759893046, 0.40482115377721506, 0.4253300420801014, 0.4287037731115837, 0.4178170407193428, 0.4185082988957043, 0.4364787352755526, 0.4316382098868875, 0.41563803883594297, 0.40636316552117024, 0.10722643692849088, 0.14108051105970498, 0.10816913448109877, 0.11268617771289158, 0.10637716508743755, 0.10696716547777685, 0.1348183623495619, 0.08974714709401665, 0.10062506656353376, 0.19275928486570237, 0.2716780357922952, 0.211399395450946, 0.3077655588098467, 0.25995533753300093, 0.1909527555500644, 0.24721184511828087, 0.20749223029678743, 0.29449273245927565, 0.2540732925675685, 0.27186917245786213, 0.2674018931605827, 0.2724205680908066, 0.2802956203259803, 0.24673077857171333, 0.3026849906296135, 0.2866367308281087, 0.2724526054929921, 0.2230549849457255, 0.23275245279082069, 0.2374737288955202, 0.23403887751407804, 0.22707016238596078, 0.2328455813541369, 0.23972701080291203, 0.2631874135134762, 0.24243411410759685, 0.2763432703853841, 0.2331040769886904, 0.20389985781316522, 0.23430486382916527, 0.20360086020005297, 0.19802382090040693, 0.20757659031203246, 0.20439903102703283, 0.21448440015291548, 0.21582286616382007, 0.2265854240648688, 0.23073638645568129, 0.22885095156717694, 0.22045184378409344, 0.2011909948125794, 0.21386696588568055, 0.2384127252180397, 0.2661539411555419, 0.1733110974531059, 0.6429101621588782, 0.1865932428922752, 0.6286404796363207, 0.20187609796649075, 0.20099832326317446, 0.16908836882416167, 0.5092069914436737, 0.17686058188996268, 0.47650304371759367, 0.2119919017449785, 0.5195925978851388, 0.16550782705491296, 0.5536379594422642, 0.21202535841771553, 0.21058117220537664, 0.5341819654562641, 0.4101156874661456, 0.17443606983627047, 0.17942299711521448, 0.18433323739378482, 0.19147608317831233, 0.192680319453282, 0.1978505308620181, 0.1906535195615815, 0.1822076110655687, 0.18023934380222495, 0.10400245108631279, 0.08842269093649224, 0.07872066489341467, 0.08635552933542456, 0.092803308160467, 0.1051493485430558, 0.07831389784222864, 0.07607393579723598, 0.09033003717872468]}, "mutation_prompt": null}
{"id": "ef501c64-25f2-40b8-b2f8-11d4e35b70e9", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.3 * (eval_count / self.budget)  # Dynamic mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sinusoidal crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 0.8\n        cooling_rate = 0.9  # Faster cooling rate\n        for _ in range(30):  # Fewer iterations for efficiency\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Increased initial population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += 30  # Updated for new SA evaluation count\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Enhanced HybridDESA with streamlined population initialization and adaptive parameter tuning for improved optimization efficiency.", "configspace": "", "generation": 12, "fitness": 0.3287370910494647, "feedback": "The algorithm EnhancedHybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.22.", "error": "", "parent_id": "d9845d30-15fd-4cdd-83d7-3131cb13c7da", "metadata": {"aucs": [0.621373915152756, 0.6797659594631273, 0.6568994226001004, 0.6828141883328591, 0.6625024595450908, 0.6518864821569383, 0.5821501256463407, 0.6641599167977443, 0.6339044198925179, 0.5761651134294126, 0.6110089955121984, 0.5990549851930922, 0.5703598250113078, 0.14145132742450095, 0.5986849694096337, 0.5844629532050402, 0.5827279585190535, 0.5888113388079875, 0.11212712635349176, 0.11472005138819641, 0.12529906942660618, 0.1204596868979152, 0.15834621328373266, 0.14374609729398002, 0.1313856106468294, 0.1357537767202297, 0.15222634391109424, 0.13566791057904815, 0.12143525646309716, 0.1141767421357619, 0.11556943962997179, 0.1152403974051629, 0.1134765007344013, 0.1094382043143185, 0.10231791684784475, 0.11085277910316871, 0.9558426582116337, 0.9592759359966666, 0.9458598988409914, 0.9760466040042632, 0.9578940107079035, 0.902567443570107, 0.9557340879003919, 0.9346149556661526, 0.9727933029227657, 0.33117210377514217, 0.3189199247384856, 0.3285371707066356, 0.3478750498233867, 0.34071310667821963, 0.36039656308561197, 0.34245335413579747, 0.3135142922919517, 0.349687082406821, 0.6637275905679085, 0.6641323655464877, 0.7025863186117189, 0.7120529670282749, 0.6819530097690217, 0.718649202595806, 0.6735557405684256, 0.6657589402705169, 0.5906176575107545, 0.33660532407378807, 0.25281421526118897, 0.2582457245064401, 0.18774864334689678, 0.13032098757823207, 0.30907525857683127, 0.40510942297354036, 0.17694468544079467, 0.21965870241130359, 0.28795286180141166, 0.13218562179819693, 0.2236074036800093, 0.26990163975228976, 0.26243788616939356, 0.24443284922482678, 0.3306593537551381, 0.1953432569525294, 0.1962877705562741, 0.27860451183832624, 0.20484941312175764, 0.36404213730719615, 0.39532978011930253, 0.23671803844163286, 0.46971988357087024, 0.4249438617547793, 0.09138447423390428, 0.05849771028707873, 0.5556098646786807, 0.3711759675834294, 0.2854456887958423, 0.44792790130516613, 0.22399573755961655, 0.31570508912980855, 0.27744330368961934, 0.3660195875174326, 0.5427189432013205, 0.09732354525281994, 0.05039194492760357, 0.09422283299306833, 0.07708688852687084, 0.18646291178520835, 0.21820300798433412, 0.1512629196629981, 0.1722544557455925, 0.07481631851026826, 0.3418339336990809, 0.31505316470461264, 0.3472132678948088, 0.36357236596627973, 0.28727723604670397, 0.33015341026916367, 0.22692328456230948, 0.25623703081939, 0.3317278347871162, 0.4525986232646684, 0.5054911980593361, 0.49898163402765583, 0.4737037956134026, 0.49599596463239837, 0.5069646889585271, 0.5423417259307621, 0.452853381217884, 0.47793641546246735, 0.10834428508758231, 0.13820043285285788, 0.10690759745123957, 0.0986348750085353, 0.12121251306855252, 0.10800654565037715, 0.1572061974760538, 0.08840327680192717, 0.1004531386607983, 0.2418515194541978, 0.2819666974200449, 0.21894064881233222, 0.28039576764059093, 0.34253535529590495, 0.20647562239325834, 0.23279874257482636, 0.1802386846689551, 0.1976550067664723, 0.3147583660953768, 0.3029352813407563, 0.3181993684542954, 0.34455170333736695, 0.3231502875063149, 0.3265793488667167, 0.31687878743392683, 0.3421735505205976, 0.31963830467240295, 0.2911414735208735, 0.2885418477096928, 0.27218118942092295, 0.2467709030782519, 0.26439283020351945, 0.2561005226831301, 0.2701528126254047, 0.27894358917593154, 0.2737757350339881, 0.20133855674131507, 0.21742129091787854, 0.20138633959767505, 0.23612707891891516, 0.20051146862706914, 0.21086891442418165, 0.22166764150248308, 0.22766368147332128, 0.22340790467328908, 0.20945880173732268, 0.22729722395650875, 0.2343914371971686, 0.2995936857609276, 0.23143972676156876, 0.22016376394460901, 0.24488070166389553, 0.21850780368841793, 0.2320895565537907, 0.7927387543048228, 0.2108076797755123, 0.17102534340254694, 0.7457094862154329, 0.20145744808914945, 0.615780315884519, 0.18846135255207797, 0.2116540374704906, 0.7437390964772502, 0.1671106618285254, 0.20749528263178418, 0.6513881614823891, 0.20620296758712886, 0.16909445465735495, 0.16968770489619078, 0.20238886521916133, 0.8191302105896998, 0.21179980841480128, 0.19843999272389856, 0.1825883541575457, 0.1802638547365112, 0.20162146721877183, 0.18784518954707785, 0.1808341147858934, 0.1966441288194879, 0.1912923243414817, 0.17267542751286036, 0.09261550990418632, 0.08349746136777869, 0.09062669015154767, 0.08686098185653168, 0.08740898126495689, 0.08003045301514522, 0.08058825073345466, 0.0782461513471151, 0.08445021435039857]}, "mutation_prompt": null}
{"id": "a4ea56a3-fa9c-49fc-8c1e-15d268d56b0f", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.3 * (eval_count / self.budget)  # Dynamic mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sinusoidal crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 0.8\n        cooling_rate = 0.9  # Faster cooling rate\n        for _ in range(30):  # Fewer iterations for efficiency\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Increased initial population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += 30  # Updated for new SA evaluation count\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Enhanced HybridDESA with streamlined population initialization and adaptive parameter tuning for improved optimization efficiency.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ef501c64-25f2-40b8-b2f8-11d4e35b70e9", "metadata": {"aucs": [0.621373915152756, 0.6797659594631273, 0.6568994226001004, 0.6828141883328591, 0.6625024595450908, 0.6518864821569383, 0.5821501256463407, 0.6641599167977443, 0.6339044198925179, 0.5761651134294126, 0.6110089955121984, 0.5990549851930922, 0.5703598250113078, 0.14145132742450095, 0.5986849694096337, 0.5844629532050402, 0.5827279585190535, 0.5888113388079875, 0.11212712635349176, 0.11472005138819641, 0.12529906942660618, 0.1204596868979152, 0.15834621328373266, 0.14374609729398002, 0.1313856106468294, 0.1357537767202297, 0.15222634391109424, 0.13566791057904815, 0.12143525646309716, 0.1141767421357619, 0.11556943962997179, 0.1152403974051629, 0.1134765007344013, 0.1094382043143185, 0.10231791684784475, 0.11085277910316871, 0.9558426582116337, 0.9592759359966666, 0.9458598988409914, 0.9760466040042632, 0.9578940107079035, 0.902567443570107, 0.9557340879003919, 0.9346149556661526, 0.9727933029227657, 0.33117210377514217, 0.3189199247384856, 0.3285371707066356, 0.3478750498233867, 0.34071310667821963, 0.36039656308561197, 0.34245335413579747, 0.3135142922919517, 0.349687082406821, 0.6637275905679085, 0.6641323655464877, 0.7025863186117189, 0.7120529670282749, 0.6819530097690217, 0.718649202595806, 0.6735557405684256, 0.6657589402705169, 0.5906176575107545, 0.33660532407378807, 0.25281421526118897, 0.2582457245064401, 0.18774864334689678, 0.13032098757823207, 0.30907525857683127, 0.40510942297354036, 0.17694468544079467, 0.21965870241130359, 0.28795286180141166, 0.13218562179819693, 0.2236074036800093, 0.26990163975228976, 0.26243788616939356, 0.24443284922482678, 0.3306593537551381, 0.1953432569525294, 0.1962877705562741, 0.27860451183832624, 0.20484941312175764, 0.36404213730719615, 0.39532978011930253, 0.23671803844163286, 0.46971988357087024, 0.4249438617547793, 0.09138447423390428, 0.05849771028707873, 0.5556098646786807, 0.3711759675834294, 0.2854456887958423, 0.44792790130516613, 0.22399573755961655, 0.31570508912980855, 0.27744330368961934, 0.3660195875174326, 0.5427189432013205, 0.09732354525281994, 0.05039194492760357, 0.09422283299306833, 0.07708688852687084, 0.18646291178520835, 0.21820300798433412, 0.1512629196629981, 0.1722544557455925, 0.07481631851026826, 0.3418339336990809, 0.31505316470461264, 0.3472132678948088, 0.36357236596627973, 0.28727723604670397, 0.33015341026916367, 0.22692328456230948, 0.25623703081939, 0.3317278347871162, 0.4525986232646684, 0.5054911980593361, 0.49898163402765583, 0.4737037956134026, 0.49599596463239837, 0.5069646889585271, 0.5423417259307621, 0.452853381217884, 0.47793641546246735, 0.10834428508758231, 0.13820043285285788, 0.10690759745123957, 0.0986348750085353, 0.12121251306855252, 0.10800654565037715, 0.1572061974760538, 0.08840327680192717, 0.1004531386607983, 0.2418515194541978, 0.2819666974200449, 0.21894064881233222, 0.28039576764059093, 0.34253535529590495, 0.20647562239325834, 0.23279874257482636, 0.1802386846689551, 0.1976550067664723, 0.3147583660953768, 0.3029352813407563, 0.3181993684542954, 0.34455170333736695, 0.3231502875063149, 0.3265793488667167, 0.31687878743392683, 0.3421735505205976, 0.31963830467240295, 0.2911414735208735, 0.2885418477096928, 0.27218118942092295, 0.2467709030782519, 0.26439283020351945, 0.2561005226831301, 0.2701528126254047, 0.27894358917593154, 0.2737757350339881, 0.20133855674131507, 0.21742129091787854, 0.20138633959767505, 0.23612707891891516, 0.20051146862706914, 0.21086891442418165, 0.22166764150248308, 0.22766368147332128, 0.22340790467328908, 0.20945880173732268, 0.22729722395650875, 0.2343914371971686, 0.2995936857609276, 0.23143972676156876, 0.22016376394460901, 0.24488070166389553, 0.21850780368841793, 0.2320895565537907, 0.7927387543048228, 0.2108076797755123, 0.17102534340254694, 0.7457094862154329, 0.20145744808914945, 0.615780315884519, 0.18846135255207797, 0.2116540374704906, 0.7437390964772502, 0.1671106618285254, 0.20749528263178418, 0.6513881614823891, 0.20620296758712886, 0.16909445465735495, 0.16968770489619078, 0.20238886521916133, 0.8191302105896998, 0.21179980841480128, 0.19843999272389856, 0.1825883541575457, 0.1802638547365112, 0.20162146721877183, 0.18784518954707785, 0.1808341147858934, 0.1966441288194879, 0.1912923243414817, 0.17267542751286036, 0.09261550990418632, 0.08349746136777869, 0.09062669015154767, 0.08686098185653168, 0.08740898126495689, 0.08003045301514522, 0.08058825073345466, 0.0782461513471151, 0.08445021435039857]}, "mutation_prompt": null}
{"id": "469bac03-f075-450e-96f0-92caf936eb89", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.3 * (eval_count / self.budget)  # Dynamic mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sinusoidal crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 0.8\n        cooling_rate = 0.9  # Faster cooling rate\n        for _ in range(30):  # Fewer iterations for efficiency\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Increased initial population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += 30  # Updated for new SA evaluation count\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Enhanced HybridDESA with streamlined population initialization and adaptive parameter tuning for improved optimization efficiency.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ef501c64-25f2-40b8-b2f8-11d4e35b70e9", "metadata": {"aucs": [0.621373915152756, 0.6797659594631273, 0.6568994226001004, 0.6828141883328591, 0.6625024595450908, 0.6518864821569383, 0.5821501256463407, 0.6641599167977443, 0.6339044198925179, 0.5761651134294126, 0.6110089955121984, 0.5990549851930922, 0.5703598250113078, 0.14145132742450095, 0.5986849694096337, 0.5844629532050402, 0.5827279585190535, 0.5888113388079875, 0.11212712635349176, 0.11472005138819641, 0.12529906942660618, 0.1204596868979152, 0.15834621328373266, 0.14374609729398002, 0.1313856106468294, 0.1357537767202297, 0.15222634391109424, 0.13566791057904815, 0.12143525646309716, 0.1141767421357619, 0.11556943962997179, 0.1152403974051629, 0.1134765007344013, 0.1094382043143185, 0.10231791684784475, 0.11085277910316871, 0.9558426582116337, 0.9592759359966666, 0.9458598988409914, 0.9760466040042632, 0.9578940107079035, 0.902567443570107, 0.9557340879003919, 0.9346149556661526, 0.9727933029227657, 0.33117210377514217, 0.3189199247384856, 0.3285371707066356, 0.3478750498233867, 0.34071310667821963, 0.36039656308561197, 0.34245335413579747, 0.3135142922919517, 0.349687082406821, 0.6637275905679085, 0.6641323655464877, 0.7025863186117189, 0.7120529670282749, 0.6819530097690217, 0.718649202595806, 0.6735557405684256, 0.6657589402705169, 0.5906176575107545, 0.33660532407378807, 0.25281421526118897, 0.2582457245064401, 0.18774864334689678, 0.13032098757823207, 0.30907525857683127, 0.40510942297354036, 0.17694468544079467, 0.21965870241130359, 0.28795286180141166, 0.13218562179819693, 0.2236074036800093, 0.26990163975228976, 0.26243788616939356, 0.24443284922482678, 0.3306593537551381, 0.1953432569525294, 0.1962877705562741, 0.27860451183832624, 0.20484941312175764, 0.36404213730719615, 0.39532978011930253, 0.23671803844163286, 0.46971988357087024, 0.4249438617547793, 0.09138447423390428, 0.05849771028707873, 0.5556098646786807, 0.3711759675834294, 0.2854456887958423, 0.44792790130516613, 0.22399573755961655, 0.31570508912980855, 0.27744330368961934, 0.3660195875174326, 0.5427189432013205, 0.09732354525281994, 0.05039194492760357, 0.09422283299306833, 0.07708688852687084, 0.18646291178520835, 0.21820300798433412, 0.1512629196629981, 0.1722544557455925, 0.07481631851026826, 0.3418339336990809, 0.31505316470461264, 0.3472132678948088, 0.36357236596627973, 0.28727723604670397, 0.33015341026916367, 0.22692328456230948, 0.25623703081939, 0.3317278347871162, 0.4525986232646684, 0.5054911980593361, 0.49898163402765583, 0.4737037956134026, 0.49599596463239837, 0.5069646889585271, 0.5423417259307621, 0.452853381217884, 0.47793641546246735, 0.10834428508758231, 0.13820043285285788, 0.10690759745123957, 0.0986348750085353, 0.12121251306855252, 0.10800654565037715, 0.1572061974760538, 0.08840327680192717, 0.1004531386607983, 0.2418515194541978, 0.2819666974200449, 0.21894064881233222, 0.28039576764059093, 0.34253535529590495, 0.20647562239325834, 0.23279874257482636, 0.1802386846689551, 0.1976550067664723, 0.3147583660953768, 0.3029352813407563, 0.3181993684542954, 0.34455170333736695, 0.3231502875063149, 0.3265793488667167, 0.31687878743392683, 0.3421735505205976, 0.31963830467240295, 0.2911414735208735, 0.2885418477096928, 0.27218118942092295, 0.2467709030782519, 0.26439283020351945, 0.2561005226831301, 0.2701528126254047, 0.27894358917593154, 0.2737757350339881, 0.20133855674131507, 0.21742129091787854, 0.20138633959767505, 0.23612707891891516, 0.20051146862706914, 0.21086891442418165, 0.22166764150248308, 0.22766368147332128, 0.22340790467328908, 0.20945880173732268, 0.22729722395650875, 0.2343914371971686, 0.2995936857609276, 0.23143972676156876, 0.22016376394460901, 0.24488070166389553, 0.21850780368841793, 0.2320895565537907, 0.7927387543048228, 0.2108076797755123, 0.17102534340254694, 0.7457094862154329, 0.20145744808914945, 0.615780315884519, 0.18846135255207797, 0.2116540374704906, 0.7437390964772502, 0.1671106618285254, 0.20749528263178418, 0.6513881614823891, 0.20620296758712886, 0.16909445465735495, 0.16968770489619078, 0.20238886521916133, 0.8191302105896998, 0.21179980841480128, 0.19843999272389856, 0.1825883541575457, 0.1802638547365112, 0.20162146721877183, 0.18784518954707785, 0.1808341147858934, 0.1966441288194879, 0.1912923243414817, 0.17267542751286036, 0.09261550990418632, 0.08349746136777869, 0.09062669015154767, 0.08686098185653168, 0.08740898126495689, 0.08003045301514522, 0.08058825073345466, 0.0782461513471151, 0.08445021435039857]}, "mutation_prompt": null}
{"id": "a729f8c3-2d5d-4f81-b8ac-56d0ac106606", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.3 * (eval_count / self.budget)  # Dynamic mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sinusoidal crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 0.8\n        cooling_rate = 0.9  # Faster cooling rate\n        for _ in range(30):  # Fewer iterations for efficiency\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Increased initial population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += 30  # Updated for new SA evaluation count\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Enhanced HybridDESA with streamlined population initialization and adaptive parameter tuning for improved optimization efficiency.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ef501c64-25f2-40b8-b2f8-11d4e35b70e9", "metadata": {"aucs": [0.621373915152756, 0.6797659594631273, 0.6568994226001004, 0.6828141883328591, 0.6625024595450908, 0.6518864821569383, 0.5821501256463407, 0.6641599167977443, 0.6339044198925179, 0.5761651134294126, 0.6110089955121984, 0.5990549851930922, 0.5703598250113078, 0.14145132742450095, 0.5986849694096337, 0.5844629532050402, 0.5827279585190535, 0.5888113388079875, 0.11212712635349176, 0.11472005138819641, 0.12529906942660618, 0.1204596868979152, 0.15834621328373266, 0.14374609729398002, 0.1313856106468294, 0.1357537767202297, 0.15222634391109424, 0.13566791057904815, 0.12143525646309716, 0.1141767421357619, 0.11556943962997179, 0.1152403974051629, 0.1134765007344013, 0.1094382043143185, 0.10231791684784475, 0.11085277910316871, 0.9558426582116337, 0.9592759359966666, 0.9458598988409914, 0.9760466040042632, 0.9578940107079035, 0.902567443570107, 0.9557340879003919, 0.9346149556661526, 0.9727933029227657, 0.33117210377514217, 0.3189199247384856, 0.3285371707066356, 0.3478750498233867, 0.34071310667821963, 0.36039656308561197, 0.34245335413579747, 0.3135142922919517, 0.349687082406821, 0.6637275905679085, 0.6641323655464877, 0.7025863186117189, 0.7120529670282749, 0.6819530097690217, 0.718649202595806, 0.6735557405684256, 0.6657589402705169, 0.5906176575107545, 0.33660532407378807, 0.25281421526118897, 0.2582457245064401, 0.18774864334689678, 0.13032098757823207, 0.30907525857683127, 0.40510942297354036, 0.17694468544079467, 0.21965870241130359, 0.28795286180141166, 0.13218562179819693, 0.2236074036800093, 0.26990163975228976, 0.26243788616939356, 0.24443284922482678, 0.3306593537551381, 0.1953432569525294, 0.1962877705562741, 0.27860451183832624, 0.20484941312175764, 0.36404213730719615, 0.39532978011930253, 0.23671803844163286, 0.46971988357087024, 0.4249438617547793, 0.09138447423390428, 0.05849771028707873, 0.5556098646786807, 0.3711759675834294, 0.2854456887958423, 0.44792790130516613, 0.22399573755961655, 0.31570508912980855, 0.27744330368961934, 0.3660195875174326, 0.5427189432013205, 0.09732354525281994, 0.05039194492760357, 0.09422283299306833, 0.07708688852687084, 0.18646291178520835, 0.21820300798433412, 0.1512629196629981, 0.1722544557455925, 0.07481631851026826, 0.3418339336990809, 0.31505316470461264, 0.3472132678948088, 0.36357236596627973, 0.28727723604670397, 0.33015341026916367, 0.22692328456230948, 0.25623703081939, 0.3317278347871162, 0.4525986232646684, 0.5054911980593361, 0.49898163402765583, 0.4737037956134026, 0.49599596463239837, 0.5069646889585271, 0.5423417259307621, 0.452853381217884, 0.47793641546246735, 0.10834428508758231, 0.13820043285285788, 0.10690759745123957, 0.0986348750085353, 0.12121251306855252, 0.10800654565037715, 0.1572061974760538, 0.08840327680192717, 0.1004531386607983, 0.2418515194541978, 0.2819666974200449, 0.21894064881233222, 0.28039576764059093, 0.34253535529590495, 0.20647562239325834, 0.23279874257482636, 0.1802386846689551, 0.1976550067664723, 0.3147583660953768, 0.3029352813407563, 0.3181993684542954, 0.34455170333736695, 0.3231502875063149, 0.3265793488667167, 0.31687878743392683, 0.3421735505205976, 0.31963830467240295, 0.2911414735208735, 0.2885418477096928, 0.27218118942092295, 0.2467709030782519, 0.26439283020351945, 0.2561005226831301, 0.2701528126254047, 0.27894358917593154, 0.2737757350339881, 0.20133855674131507, 0.21742129091787854, 0.20138633959767505, 0.23612707891891516, 0.20051146862706914, 0.21086891442418165, 0.22166764150248308, 0.22766368147332128, 0.22340790467328908, 0.20945880173732268, 0.22729722395650875, 0.2343914371971686, 0.2995936857609276, 0.23143972676156876, 0.22016376394460901, 0.24488070166389553, 0.21850780368841793, 0.2320895565537907, 0.7927387543048228, 0.2108076797755123, 0.17102534340254694, 0.7457094862154329, 0.20145744808914945, 0.615780315884519, 0.18846135255207797, 0.2116540374704906, 0.7437390964772502, 0.1671106618285254, 0.20749528263178418, 0.6513881614823891, 0.20620296758712886, 0.16909445465735495, 0.16968770489619078, 0.20238886521916133, 0.8191302105896998, 0.21179980841480128, 0.19843999272389856, 0.1825883541575457, 0.1802638547365112, 0.20162146721877183, 0.18784518954707785, 0.1808341147858934, 0.1966441288194879, 0.1912923243414817, 0.17267542751286036, 0.09261550990418632, 0.08349746136777869, 0.09062669015154767, 0.08686098185653168, 0.08740898126495689, 0.08003045301514522, 0.08058825073345466, 0.0782461513471151, 0.08445021435039857]}, "mutation_prompt": null}
{"id": "df6a2e8c-29ae-4c89-a063-9c16dd762ba1", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.3 * (eval_count / self.budget)  # Dynamic mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sinusoidal crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 0.8\n        cooling_rate = 0.9  # Faster cooling rate\n        for _ in range(30):  # Fewer iterations for efficiency\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Increased initial population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += 30  # Updated for new SA evaluation count\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Enhanced HybridDESA with streamlined population initialization and adaptive parameter tuning for improved optimization efficiency.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ef501c64-25f2-40b8-b2f8-11d4e35b70e9", "metadata": {"aucs": [0.621373915152756, 0.6797659594631273, 0.6568994226001004, 0.6828141883328591, 0.6625024595450908, 0.6518864821569383, 0.5821501256463407, 0.6641599167977443, 0.6339044198925179, 0.5761651134294126, 0.6110089955121984, 0.5990549851930922, 0.5703598250113078, 0.14145132742450095, 0.5986849694096337, 0.5844629532050402, 0.5827279585190535, 0.5888113388079875, 0.11212712635349176, 0.11472005138819641, 0.12529906942660618, 0.1204596868979152, 0.15834621328373266, 0.14374609729398002, 0.1313856106468294, 0.1357537767202297, 0.15222634391109424, 0.13566791057904815, 0.12143525646309716, 0.1141767421357619, 0.11556943962997179, 0.1152403974051629, 0.1134765007344013, 0.1094382043143185, 0.10231791684784475, 0.11085277910316871, 0.9558426582116337, 0.9592759359966666, 0.9458598988409914, 0.9760466040042632, 0.9578940107079035, 0.902567443570107, 0.9557340879003919, 0.9346149556661526, 0.9727933029227657, 0.33117210377514217, 0.3189199247384856, 0.3285371707066356, 0.3478750498233867, 0.34071310667821963, 0.36039656308561197, 0.34245335413579747, 0.3135142922919517, 0.349687082406821, 0.6637275905679085, 0.6641323655464877, 0.7025863186117189, 0.7120529670282749, 0.6819530097690217, 0.718649202595806, 0.6735557405684256, 0.6657589402705169, 0.5906176575107545, 0.33660532407378807, 0.25281421526118897, 0.2582457245064401, 0.18774864334689678, 0.13032098757823207, 0.30907525857683127, 0.40510942297354036, 0.17694468544079467, 0.21965870241130359, 0.28795286180141166, 0.13218562179819693, 0.2236074036800093, 0.26990163975228976, 0.26243788616939356, 0.24443284922482678, 0.3306593537551381, 0.1953432569525294, 0.1962877705562741, 0.27860451183832624, 0.20484941312175764, 0.36404213730719615, 0.39532978011930253, 0.23671803844163286, 0.46971988357087024, 0.4249438617547793, 0.09138447423390428, 0.05849771028707873, 0.5556098646786807, 0.3711759675834294, 0.2854456887958423, 0.44792790130516613, 0.22399573755961655, 0.31570508912980855, 0.27744330368961934, 0.3660195875174326, 0.5427189432013205, 0.09732354525281994, 0.05039194492760357, 0.09422283299306833, 0.07708688852687084, 0.18646291178520835, 0.21820300798433412, 0.1512629196629981, 0.1722544557455925, 0.07481631851026826, 0.3418339336990809, 0.31505316470461264, 0.3472132678948088, 0.36357236596627973, 0.28727723604670397, 0.33015341026916367, 0.22692328456230948, 0.25623703081939, 0.3317278347871162, 0.4525986232646684, 0.5054911980593361, 0.49898163402765583, 0.4737037956134026, 0.49599596463239837, 0.5069646889585271, 0.5423417259307621, 0.452853381217884, 0.47793641546246735, 0.10834428508758231, 0.13820043285285788, 0.10690759745123957, 0.0986348750085353, 0.12121251306855252, 0.10800654565037715, 0.1572061974760538, 0.08840327680192717, 0.1004531386607983, 0.2418515194541978, 0.2819666974200449, 0.21894064881233222, 0.28039576764059093, 0.34253535529590495, 0.20647562239325834, 0.23279874257482636, 0.1802386846689551, 0.1976550067664723, 0.3147583660953768, 0.3029352813407563, 0.3181993684542954, 0.34455170333736695, 0.3231502875063149, 0.3265793488667167, 0.31687878743392683, 0.3421735505205976, 0.31963830467240295, 0.2911414735208735, 0.2885418477096928, 0.27218118942092295, 0.2467709030782519, 0.26439283020351945, 0.2561005226831301, 0.2701528126254047, 0.27894358917593154, 0.2737757350339881, 0.20133855674131507, 0.21742129091787854, 0.20138633959767505, 0.23612707891891516, 0.20051146862706914, 0.21086891442418165, 0.22166764150248308, 0.22766368147332128, 0.22340790467328908, 0.20945880173732268, 0.22729722395650875, 0.2343914371971686, 0.2995936857609276, 0.23143972676156876, 0.22016376394460901, 0.24488070166389553, 0.21850780368841793, 0.2320895565537907, 0.7927387543048228, 0.2108076797755123, 0.17102534340254694, 0.7457094862154329, 0.20145744808914945, 0.615780315884519, 0.18846135255207797, 0.2116540374704906, 0.7437390964772502, 0.1671106618285254, 0.20749528263178418, 0.6513881614823891, 0.20620296758712886, 0.16909445465735495, 0.16968770489619078, 0.20238886521916133, 0.8191302105896998, 0.21179980841480128, 0.19843999272389856, 0.1825883541575457, 0.1802638547365112, 0.20162146721877183, 0.18784518954707785, 0.1808341147858934, 0.1966441288194879, 0.1912923243414817, 0.17267542751286036, 0.09261550990418632, 0.08349746136777869, 0.09062669015154767, 0.08686098185653168, 0.08740898126495689, 0.08003045301514522, 0.08058825073345466, 0.0782461513471151, 0.08445021435039857]}, "mutation_prompt": null}
{"id": "de6528f5-0fa3-4631-bc7f-2c1271b3f69c", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.3 * (eval_count / self.budget)  # Dynamic mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sinusoidal crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 0.8\n        cooling_rate = 0.9  # Faster cooling rate\n        for _ in range(30):  # Fewer iterations for efficiency\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Increased initial population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += 30  # Updated for new SA evaluation count\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Enhanced HybridDESA with streamlined population initialization and adaptive parameter tuning for improved optimization efficiency.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ef501c64-25f2-40b8-b2f8-11d4e35b70e9", "metadata": {"aucs": [0.621373915152756, 0.6797659594631273, 0.6568994226001004, 0.6828141883328591, 0.6625024595450908, 0.6518864821569383, 0.5821501256463407, 0.6641599167977443, 0.6339044198925179, 0.5761651134294126, 0.6110089955121984, 0.5990549851930922, 0.5703598250113078, 0.14145132742450095, 0.5986849694096337, 0.5844629532050402, 0.5827279585190535, 0.5888113388079875, 0.11212712635349176, 0.11472005138819641, 0.12529906942660618, 0.1204596868979152, 0.15834621328373266, 0.14374609729398002, 0.1313856106468294, 0.1357537767202297, 0.15222634391109424, 0.13566791057904815, 0.12143525646309716, 0.1141767421357619, 0.11556943962997179, 0.1152403974051629, 0.1134765007344013, 0.1094382043143185, 0.10231791684784475, 0.11085277910316871, 0.9558426582116337, 0.9592759359966666, 0.9458598988409914, 0.9760466040042632, 0.9578940107079035, 0.902567443570107, 0.9557340879003919, 0.9346149556661526, 0.9727933029227657, 0.33117210377514217, 0.3189199247384856, 0.3285371707066356, 0.3478750498233867, 0.34071310667821963, 0.36039656308561197, 0.34245335413579747, 0.3135142922919517, 0.349687082406821, 0.6637275905679085, 0.6641323655464877, 0.7025863186117189, 0.7120529670282749, 0.6819530097690217, 0.718649202595806, 0.6735557405684256, 0.6657589402705169, 0.5906176575107545, 0.33660532407378807, 0.25281421526118897, 0.2582457245064401, 0.18774864334689678, 0.13032098757823207, 0.30907525857683127, 0.40510942297354036, 0.17694468544079467, 0.21965870241130359, 0.28795286180141166, 0.13218562179819693, 0.2236074036800093, 0.26990163975228976, 0.26243788616939356, 0.24443284922482678, 0.3306593537551381, 0.1953432569525294, 0.1962877705562741, 0.27860451183832624, 0.20484941312175764, 0.36404213730719615, 0.39532978011930253, 0.23671803844163286, 0.46971988357087024, 0.4249438617547793, 0.09138447423390428, 0.05849771028707873, 0.5556098646786807, 0.3711759675834294, 0.2854456887958423, 0.44792790130516613, 0.22399573755961655, 0.31570508912980855, 0.27744330368961934, 0.3660195875174326, 0.5427189432013205, 0.09732354525281994, 0.05039194492760357, 0.09422283299306833, 0.07708688852687084, 0.18646291178520835, 0.21820300798433412, 0.1512629196629981, 0.1722544557455925, 0.07481631851026826, 0.3418339336990809, 0.31505316470461264, 0.3472132678948088, 0.36357236596627973, 0.28727723604670397, 0.33015341026916367, 0.22692328456230948, 0.25623703081939, 0.3317278347871162, 0.4525986232646684, 0.5054911980593361, 0.49898163402765583, 0.4737037956134026, 0.49599596463239837, 0.5069646889585271, 0.5423417259307621, 0.452853381217884, 0.47793641546246735, 0.10834428508758231, 0.13820043285285788, 0.10690759745123957, 0.0986348750085353, 0.12121251306855252, 0.10800654565037715, 0.1572061974760538, 0.08840327680192717, 0.1004531386607983, 0.2418515194541978, 0.2819666974200449, 0.21894064881233222, 0.28039576764059093, 0.34253535529590495, 0.20647562239325834, 0.23279874257482636, 0.1802386846689551, 0.1976550067664723, 0.3147583660953768, 0.3029352813407563, 0.3181993684542954, 0.34455170333736695, 0.3231502875063149, 0.3265793488667167, 0.31687878743392683, 0.3421735505205976, 0.31963830467240295, 0.2911414735208735, 0.2885418477096928, 0.27218118942092295, 0.2467709030782519, 0.26439283020351945, 0.2561005226831301, 0.2701528126254047, 0.27894358917593154, 0.2737757350339881, 0.20133855674131507, 0.21742129091787854, 0.20138633959767505, 0.23612707891891516, 0.20051146862706914, 0.21086891442418165, 0.22166764150248308, 0.22766368147332128, 0.22340790467328908, 0.20945880173732268, 0.22729722395650875, 0.2343914371971686, 0.2995936857609276, 0.23143972676156876, 0.22016376394460901, 0.24488070166389553, 0.21850780368841793, 0.2320895565537907, 0.7927387543048228, 0.2108076797755123, 0.17102534340254694, 0.7457094862154329, 0.20145744808914945, 0.615780315884519, 0.18846135255207797, 0.2116540374704906, 0.7437390964772502, 0.1671106618285254, 0.20749528263178418, 0.6513881614823891, 0.20620296758712886, 0.16909445465735495, 0.16968770489619078, 0.20238886521916133, 0.8191302105896998, 0.21179980841480128, 0.19843999272389856, 0.1825883541575457, 0.1802638547365112, 0.20162146721877183, 0.18784518954707785, 0.1808341147858934, 0.1966441288194879, 0.1912923243414817, 0.17267542751286036, 0.09261550990418632, 0.08349746136777869, 0.09062669015154767, 0.08686098185653168, 0.08740898126495689, 0.08003045301514522, 0.08058825073345466, 0.0782461513471151, 0.08445021435039857]}, "mutation_prompt": null}
{"id": "1fc810bb-53a2-4225-8c03-c752297223d7", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.3 * (eval_count / self.budget)  # Dynamic mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sinusoidal crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 0.8\n        cooling_rate = 0.9  # Faster cooling rate\n        for _ in range(30):  # Fewer iterations for efficiency\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Increased initial population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += 30  # Updated for new SA evaluation count\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Enhanced HybridDESA with streamlined population initialization and adaptive parameter tuning for improved optimization efficiency.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ef501c64-25f2-40b8-b2f8-11d4e35b70e9", "metadata": {"aucs": [0.621373915152756, 0.6797659594631273, 0.6568994226001004, 0.6828141883328591, 0.6625024595450908, 0.6518864821569383, 0.5821501256463407, 0.6641599167977443, 0.6339044198925179, 0.5761651134294126, 0.6110089955121984, 0.5990549851930922, 0.5703598250113078, 0.14145132742450095, 0.5986849694096337, 0.5844629532050402, 0.5827279585190535, 0.5888113388079875, 0.11212712635349176, 0.11472005138819641, 0.12529906942660618, 0.1204596868979152, 0.15834621328373266, 0.14374609729398002, 0.1313856106468294, 0.1357537767202297, 0.15222634391109424, 0.13566791057904815, 0.12143525646309716, 0.1141767421357619, 0.11556943962997179, 0.1152403974051629, 0.1134765007344013, 0.1094382043143185, 0.10231791684784475, 0.11085277910316871, 0.9558426582116337, 0.9592759359966666, 0.9458598988409914, 0.9760466040042632, 0.9578940107079035, 0.902567443570107, 0.9557340879003919, 0.9346149556661526, 0.9727933029227657, 0.33117210377514217, 0.3189199247384856, 0.3285371707066356, 0.3478750498233867, 0.34071310667821963, 0.36039656308561197, 0.34245335413579747, 0.3135142922919517, 0.349687082406821, 0.6637275905679085, 0.6641323655464877, 0.7025863186117189, 0.7120529670282749, 0.6819530097690217, 0.718649202595806, 0.6735557405684256, 0.6657589402705169, 0.5906176575107545, 0.33660532407378807, 0.25281421526118897, 0.2582457245064401, 0.18774864334689678, 0.13032098757823207, 0.30907525857683127, 0.40510942297354036, 0.17694468544079467, 0.21965870241130359, 0.28795286180141166, 0.13218562179819693, 0.2236074036800093, 0.26990163975228976, 0.26243788616939356, 0.24443284922482678, 0.3306593537551381, 0.1953432569525294, 0.1962877705562741, 0.27860451183832624, 0.20484941312175764, 0.36404213730719615, 0.39532978011930253, 0.23671803844163286, 0.46971988357087024, 0.4249438617547793, 0.09138447423390428, 0.05849771028707873, 0.5556098646786807, 0.3711759675834294, 0.2854456887958423, 0.44792790130516613, 0.22399573755961655, 0.31570508912980855, 0.27744330368961934, 0.3660195875174326, 0.5427189432013205, 0.09732354525281994, 0.05039194492760357, 0.09422283299306833, 0.07708688852687084, 0.18646291178520835, 0.21820300798433412, 0.1512629196629981, 0.1722544557455925, 0.07481631851026826, 0.3418339336990809, 0.31505316470461264, 0.3472132678948088, 0.36357236596627973, 0.28727723604670397, 0.33015341026916367, 0.22692328456230948, 0.25623703081939, 0.3317278347871162, 0.4525986232646684, 0.5054911980593361, 0.49898163402765583, 0.4737037956134026, 0.49599596463239837, 0.5069646889585271, 0.5423417259307621, 0.452853381217884, 0.47793641546246735, 0.10834428508758231, 0.13820043285285788, 0.10690759745123957, 0.0986348750085353, 0.12121251306855252, 0.10800654565037715, 0.1572061974760538, 0.08840327680192717, 0.1004531386607983, 0.2418515194541978, 0.2819666974200449, 0.21894064881233222, 0.28039576764059093, 0.34253535529590495, 0.20647562239325834, 0.23279874257482636, 0.1802386846689551, 0.1976550067664723, 0.3147583660953768, 0.3029352813407563, 0.3181993684542954, 0.34455170333736695, 0.3231502875063149, 0.3265793488667167, 0.31687878743392683, 0.3421735505205976, 0.31963830467240295, 0.2911414735208735, 0.2885418477096928, 0.27218118942092295, 0.2467709030782519, 0.26439283020351945, 0.2561005226831301, 0.2701528126254047, 0.27894358917593154, 0.2737757350339881, 0.20133855674131507, 0.21742129091787854, 0.20138633959767505, 0.23612707891891516, 0.20051146862706914, 0.21086891442418165, 0.22166764150248308, 0.22766368147332128, 0.22340790467328908, 0.20945880173732268, 0.22729722395650875, 0.2343914371971686, 0.2995936857609276, 0.23143972676156876, 0.22016376394460901, 0.24488070166389553, 0.21850780368841793, 0.2320895565537907, 0.7927387543048228, 0.2108076797755123, 0.17102534340254694, 0.7457094862154329, 0.20145744808914945, 0.615780315884519, 0.18846135255207797, 0.2116540374704906, 0.7437390964772502, 0.1671106618285254, 0.20749528263178418, 0.6513881614823891, 0.20620296758712886, 0.16909445465735495, 0.16968770489619078, 0.20238886521916133, 0.8191302105896998, 0.21179980841480128, 0.19843999272389856, 0.1825883541575457, 0.1802638547365112, 0.20162146721877183, 0.18784518954707785, 0.1808341147858934, 0.1966441288194879, 0.1912923243414817, 0.17267542751286036, 0.09261550990418632, 0.08349746136777869, 0.09062669015154767, 0.08686098185653168, 0.08740898126495689, 0.08003045301514522, 0.08058825073345466, 0.0782461513471151, 0.08445021435039857]}, "mutation_prompt": null}
{"id": "70f1e4dd-c75e-43fd-a215-91a4c9daa717", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.3 * (eval_count / self.budget)  # Dynamic mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sinusoidal crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 0.8\n        cooling_rate = 0.9  # Faster cooling rate\n        for _ in range(30):  # Fewer iterations for efficiency\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Increased initial population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += 30  # Updated for new SA evaluation count\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Enhanced HybridDESA with streamlined population initialization and adaptive parameter tuning for improved optimization efficiency.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ef501c64-25f2-40b8-b2f8-11d4e35b70e9", "metadata": {"aucs": [0.621373915152756, 0.6797659594631273, 0.6568994226001004, 0.6828141883328591, 0.6625024595450908, 0.6518864821569383, 0.5821501256463407, 0.6641599167977443, 0.6339044198925179, 0.5761651134294126, 0.6110089955121984, 0.5990549851930922, 0.5703598250113078, 0.14145132742450095, 0.5986849694096337, 0.5844629532050402, 0.5827279585190535, 0.5888113388079875, 0.11212712635349176, 0.11472005138819641, 0.12529906942660618, 0.1204596868979152, 0.15834621328373266, 0.14374609729398002, 0.1313856106468294, 0.1357537767202297, 0.15222634391109424, 0.13566791057904815, 0.12143525646309716, 0.1141767421357619, 0.11556943962997179, 0.1152403974051629, 0.1134765007344013, 0.1094382043143185, 0.10231791684784475, 0.11085277910316871, 0.9558426582116337, 0.9592759359966666, 0.9458598988409914, 0.9760466040042632, 0.9578940107079035, 0.902567443570107, 0.9557340879003919, 0.9346149556661526, 0.9727933029227657, 0.33117210377514217, 0.3189199247384856, 0.3285371707066356, 0.3478750498233867, 0.34071310667821963, 0.36039656308561197, 0.34245335413579747, 0.3135142922919517, 0.349687082406821, 0.6637275905679085, 0.6641323655464877, 0.7025863186117189, 0.7120529670282749, 0.6819530097690217, 0.718649202595806, 0.6735557405684256, 0.6657589402705169, 0.5906176575107545, 0.33660532407378807, 0.25281421526118897, 0.2582457245064401, 0.18774864334689678, 0.13032098757823207, 0.30907525857683127, 0.40510942297354036, 0.17694468544079467, 0.21965870241130359, 0.28795286180141166, 0.13218562179819693, 0.2236074036800093, 0.26990163975228976, 0.26243788616939356, 0.24443284922482678, 0.3306593537551381, 0.1953432569525294, 0.1962877705562741, 0.27860451183832624, 0.20484941312175764, 0.36404213730719615, 0.39532978011930253, 0.23671803844163286, 0.46971988357087024, 0.4249438617547793, 0.09138447423390428, 0.05849771028707873, 0.5556098646786807, 0.3711759675834294, 0.2854456887958423, 0.44792790130516613, 0.22399573755961655, 0.31570508912980855, 0.27744330368961934, 0.3660195875174326, 0.5427189432013205, 0.09732354525281994, 0.05039194492760357, 0.09422283299306833, 0.07708688852687084, 0.18646291178520835, 0.21820300798433412, 0.1512629196629981, 0.1722544557455925, 0.07481631851026826, 0.3418339336990809, 0.31505316470461264, 0.3472132678948088, 0.36357236596627973, 0.28727723604670397, 0.33015341026916367, 0.22692328456230948, 0.25623703081939, 0.3317278347871162, 0.4525986232646684, 0.5054911980593361, 0.49898163402765583, 0.4737037956134026, 0.49599596463239837, 0.5069646889585271, 0.5423417259307621, 0.452853381217884, 0.47793641546246735, 0.10834428508758231, 0.13820043285285788, 0.10690759745123957, 0.0986348750085353, 0.12121251306855252, 0.10800654565037715, 0.1572061974760538, 0.08840327680192717, 0.1004531386607983, 0.2418515194541978, 0.2819666974200449, 0.21894064881233222, 0.28039576764059093, 0.34253535529590495, 0.20647562239325834, 0.23279874257482636, 0.1802386846689551, 0.1976550067664723, 0.3147583660953768, 0.3029352813407563, 0.3181993684542954, 0.34455170333736695, 0.3231502875063149, 0.3265793488667167, 0.31687878743392683, 0.3421735505205976, 0.31963830467240295, 0.2911414735208735, 0.2885418477096928, 0.27218118942092295, 0.2467709030782519, 0.26439283020351945, 0.2561005226831301, 0.2701528126254047, 0.27894358917593154, 0.2737757350339881, 0.20133855674131507, 0.21742129091787854, 0.20138633959767505, 0.23612707891891516, 0.20051146862706914, 0.21086891442418165, 0.22166764150248308, 0.22766368147332128, 0.22340790467328908, 0.20945880173732268, 0.22729722395650875, 0.2343914371971686, 0.2995936857609276, 0.23143972676156876, 0.22016376394460901, 0.24488070166389553, 0.21850780368841793, 0.2320895565537907, 0.7927387543048228, 0.2108076797755123, 0.17102534340254694, 0.7457094862154329, 0.20145744808914945, 0.615780315884519, 0.18846135255207797, 0.2116540374704906, 0.7437390964772502, 0.1671106618285254, 0.20749528263178418, 0.6513881614823891, 0.20620296758712886, 0.16909445465735495, 0.16968770489619078, 0.20238886521916133, 0.8191302105896998, 0.21179980841480128, 0.19843999272389856, 0.1825883541575457, 0.1802638547365112, 0.20162146721877183, 0.18784518954707785, 0.1808341147858934, 0.1966441288194879, 0.1912923243414817, 0.17267542751286036, 0.09261550990418632, 0.08349746136777869, 0.09062669015154767, 0.08686098185653168, 0.08740898126495689, 0.08003045301514522, 0.08058825073345466, 0.0782461513471151, 0.08445021435039857]}, "mutation_prompt": null}
{"id": "e6b49430-5d5a-4a6b-b33e-2897a48dd6d1", "solution": "import numpy as np\n\nclass OptimizedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.7 - 0.35 * (eval_count / self.budget)  # Slightly increased dynamic mutation factor range\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0  # Higher initial temperature\n        cooling_rate = 0.85  # Adjusted cooling rate for better exploitation\n        for _ in range(20):  # Reduced iterations for faster execution\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = max(20, self.budget // 5)  # Adjusted population size for better coverage\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += 20  # Adjusted for new SA evaluation count\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "OptimizedHybridDESA", "description": "OptimizedHybridDESA with strategic population updates and efficient exploration-exploitation balance.", "configspace": "", "generation": 20, "fitness": 0.11503135815638019, "feedback": "The algorithm OptimizedHybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.09.", "error": "", "parent_id": "ef501c64-25f2-40b8-b2f8-11d4e35b70e9", "metadata": {"aucs": [0.21837807034307855, 0.19935365595436927, 0.20742296355674017, 0.2042775885650473, 0.20264980690811585, 0.2230190791352954, 0.24898151811079916, 0.19662707023044612, 0.18679811106857003, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04193746750867289, 0.07233011801035827, 0.050368633218550674, 0.04766075504099532, 0.04375640533462899, 0.061749150537346975, 0.05133818602130702, 0.07234675925736933, 0.05242621616014109, 0.07407355513990477, 0.030579998250839346, 0.053777159243431516, 0.0454744239283591, 0.060962835351060174, 0.0840164758996913, 0.04348892206669186, 0.055527599570210806, 0.047424407374452304, 0.5240476088394563, 0.3095722378253807, 0.4962080212151889, 0.11891773552175877, 0.2647122752914568, 0.5182735503364742, 0.1456144436965151, 0.19232932536378877, 0.11051877683230393, 0.09506274756722322, 0.09150964478505885, 0.1292014043904548, 0.08794811542290759, 0.08305394891023332, 0.13006851640979822, 0.1327092110996959, 0.08943869343972799, 0.11389404766383482, 0.13368353888997986, 0.2144332480684047, 0.16030260226072146, 0.13350049083446935, 0.15323618124949678, 0.1579919561948807, 0.11358090142369914, 0.11976786042218157, 0.15199241518008244, 0.09411397354786799, 0.03074042500264984, 0.06410776072688495, 0.02176594472702542, 0.04949567921902531, 0.060061137921971985, 0.03237919318253968, 0.005410105541581833, 0.07385560876345076, 0.02218864672493237, 0.0970625635165856, 0.06444705498017411, 0.05058061949191417, 0.0661861146967907, 0.08000879435307529, 0.07346930974363697, 0.08063927511727687, 0.07333075659705268, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.046393290916396324, 0.06746374022168333, 0.05956255613710493, 0.04894058530145917, 0.027366109302871755, 0.05910924930086259, 0.05288214439203254, 0.05215230358853529, 0.05836801979706119, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016922237494840342, 0.0157472810262117, 0.037447939167702504, 0.009716414496849346, 0.015123818251713383, 0.021956550918681428, 0.019491929634128047, 0.019253670998402028, 0.00826981511259306, 0.24014964326767618, 0.23291855123675376, 0.19197442939952825, 0.2276966727116776, 0.23767843253007048, 0.216829132548365, 0.2236908602553901, 0.2320690789374683, 0.21606507279157106, 0.04443164681916045, 0.05985414559446667, 0.04274737011860086, 0.06620104462765097, 0.06302398874778503, 0.047118135751785806, 0.05629208272459785, 0.043918886477558816, 0.057385554859186394, 0.16085642628772745, 0.1358664430047798, 0.13878619193708042, 0.15231600282923918, 0.16582944151737888, 0.17524981461037004, 0.15203523179771472, 0.21301794277543973, 0.14883930225387665, 0.17913695220060233, 0.1734448439855767, 0.22389306585520297, 0.17610423426431532, 0.1812056168200521, 0.1760013764597983, 0.17503218064258086, 0.18052277969981279, 0.16295369131394422, 0.1280560624815651, 0.10766070955376239, 0.15095174397079247, 0.10662283848074017, 0.13157268977926506, 0.12933991016435198, 0.10730003164226143, 0.12801195488938377, 0.14361373815848932, 0.1468835461440382, 0.15392520654492892, 0.15255200933156043, 0.16429995540228304, 0.15295446100434162, 0.17527519765116817, 0.1498707960218817, 0.15671567955976684, 0.18277724523822958, 0.1505981924390104, 0.16348984208124695, 0.14836904398379192, 0.14623436677797086, 0.15542981346276596, 0.16239101373656217, 0.14172160842574644, 0.1609693197918225, 0.16359917696723336, 0.2109370947036726, 0.23212912137049435, 0.20424567434992702, 0.20497991049316855, 0.1903681000321613, 0.17765596583788557, 0.2154985864221387, 0.18835135410381598, 0.17215046132765077, 0.18600961581601916, 0.23632818428469737, 0.21063667118242324, 0.15479906399703447, 0.16214790668917578, 0.26882441718165107, 0.18129441499587529, 0.1867432372234089, 0.1755990476712157, 0.1741655820216278, 0.18588302790722122, 0.17894042662574816, 0.18683568409856555, 0.2135749380374129, 0.19440217271441484, 0.17684260283520015, 0.19165521438914745, 0.20568880668582523, 0.04871164671565331, 0.05155200570185392, 0.06939549502995002, 0.05367816290658323, 0.05997368823965388, 0.056329097068332556, 0.07532529613519179, 0.05970745579816028, 0.04606375901020332]}, "mutation_prompt": null}
{"id": "6d487b3e-7eac-4981-9701-9acf23d90baf", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.3 * (eval_count / self.budget)  # Dynamic mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sinusoidal crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 0.8\n        cooling_rate = 0.9  # Faster cooling rate\n        for _ in range(30):  # Fewer iterations for efficiency\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Increased initial population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += 30  # Updated for new SA evaluation count\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Enhanced HybridDESA with streamlined population initialization and adaptive parameter tuning for improved optimization efficiency.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ef501c64-25f2-40b8-b2f8-11d4e35b70e9", "metadata": {"aucs": [0.621373915152756, 0.6797659594631273, 0.6568994226001004, 0.6828141883328591, 0.6625024595450908, 0.6518864821569383, 0.5821501256463407, 0.6641599167977443, 0.6339044198925179, 0.5761651134294126, 0.6110089955121984, 0.5990549851930922, 0.5703598250113078, 0.14145132742450095, 0.5986849694096337, 0.5844629532050402, 0.5827279585190535, 0.5888113388079875, 0.11212712635349176, 0.11472005138819641, 0.12529906942660618, 0.1204596868979152, 0.15834621328373266, 0.14374609729398002, 0.1313856106468294, 0.1357537767202297, 0.15222634391109424, 0.13566791057904815, 0.12143525646309716, 0.1141767421357619, 0.11556943962997179, 0.1152403974051629, 0.1134765007344013, 0.1094382043143185, 0.10231791684784475, 0.11085277910316871, 0.9558426582116337, 0.9592759359966666, 0.9458598988409914, 0.9760466040042632, 0.9578940107079035, 0.902567443570107, 0.9557340879003919, 0.9346149556661526, 0.9727933029227657, 0.33117210377514217, 0.3189199247384856, 0.3285371707066356, 0.3478750498233867, 0.34071310667821963, 0.36039656308561197, 0.34245335413579747, 0.3135142922919517, 0.349687082406821, 0.6637275905679085, 0.6641323655464877, 0.7025863186117189, 0.7120529670282749, 0.6819530097690217, 0.718649202595806, 0.6735557405684256, 0.6657589402705169, 0.5906176575107545, 0.33660532407378807, 0.25281421526118897, 0.2582457245064401, 0.18774864334689678, 0.13032098757823207, 0.30907525857683127, 0.40510942297354036, 0.17694468544079467, 0.21965870241130359, 0.28795286180141166, 0.13218562179819693, 0.2236074036800093, 0.26990163975228976, 0.26243788616939356, 0.24443284922482678, 0.3306593537551381, 0.1953432569525294, 0.1962877705562741, 0.27860451183832624, 0.20484941312175764, 0.36404213730719615, 0.39532978011930253, 0.23671803844163286, 0.46971988357087024, 0.4249438617547793, 0.09138447423390428, 0.05849771028707873, 0.5556098646786807, 0.3711759675834294, 0.2854456887958423, 0.44792790130516613, 0.22399573755961655, 0.31570508912980855, 0.27744330368961934, 0.3660195875174326, 0.5427189432013205, 0.09732354525281994, 0.05039194492760357, 0.09422283299306833, 0.07708688852687084, 0.18646291178520835, 0.21820300798433412, 0.1512629196629981, 0.1722544557455925, 0.07481631851026826, 0.3418339336990809, 0.31505316470461264, 0.3472132678948088, 0.36357236596627973, 0.28727723604670397, 0.33015341026916367, 0.22692328456230948, 0.25623703081939, 0.3317278347871162, 0.4525986232646684, 0.5054911980593361, 0.49898163402765583, 0.4737037956134026, 0.49599596463239837, 0.5069646889585271, 0.5423417259307621, 0.452853381217884, 0.47793641546246735, 0.10834428508758231, 0.13820043285285788, 0.10690759745123957, 0.0986348750085353, 0.12121251306855252, 0.10800654565037715, 0.1572061974760538, 0.08840327680192717, 0.1004531386607983, 0.2418515194541978, 0.2819666974200449, 0.21894064881233222, 0.28039576764059093, 0.34253535529590495, 0.20647562239325834, 0.23279874257482636, 0.1802386846689551, 0.1976550067664723, 0.3147583660953768, 0.3029352813407563, 0.3181993684542954, 0.34455170333736695, 0.3231502875063149, 0.3265793488667167, 0.31687878743392683, 0.3421735505205976, 0.31963830467240295, 0.2911414735208735, 0.2885418477096928, 0.27218118942092295, 0.2467709030782519, 0.26439283020351945, 0.2561005226831301, 0.2701528126254047, 0.27894358917593154, 0.2737757350339881, 0.20133855674131507, 0.21742129091787854, 0.20138633959767505, 0.23612707891891516, 0.20051146862706914, 0.21086891442418165, 0.22166764150248308, 0.22766368147332128, 0.22340790467328908, 0.20945880173732268, 0.22729722395650875, 0.2343914371971686, 0.2995936857609276, 0.23143972676156876, 0.22016376394460901, 0.24488070166389553, 0.21850780368841793, 0.2320895565537907, 0.7927387543048228, 0.2108076797755123, 0.17102534340254694, 0.7457094862154329, 0.20145744808914945, 0.615780315884519, 0.18846135255207797, 0.2116540374704906, 0.7437390964772502, 0.1671106618285254, 0.20749528263178418, 0.6513881614823891, 0.20620296758712886, 0.16909445465735495, 0.16968770489619078, 0.20238886521916133, 0.8191302105896998, 0.21179980841480128, 0.19843999272389856, 0.1825883541575457, 0.1802638547365112, 0.20162146721877183, 0.18784518954707785, 0.1808341147858934, 0.1966441288194879, 0.1912923243414817, 0.17267542751286036, 0.09261550990418632, 0.08349746136777869, 0.09062669015154767, 0.08686098185653168, 0.08740898126495689, 0.08003045301514522, 0.08058825073345466, 0.0782461513471151, 0.08445021435039857]}, "mutation_prompt": null}
{"id": "0ec6dbc7-3f46-42a9-9c09-3936c8f5414e", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.3 * (eval_count / self.budget)  # Dynamic mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sinusoidal crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 0.8\n        cooling_rate = 0.9  # Faster cooling rate\n        for _ in range(30):  # Fewer iterations for efficiency\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Increased initial population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += 30  # Updated for new SA evaluation count\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Enhanced HybridDESA with streamlined population initialization and adaptive parameter tuning for improved optimization efficiency.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ef501c64-25f2-40b8-b2f8-11d4e35b70e9", "metadata": {"aucs": [0.621373915152756, 0.6797659594631273, 0.6568994226001004, 0.6828141883328591, 0.6625024595450908, 0.6518864821569383, 0.5821501256463407, 0.6641599167977443, 0.6339044198925179, 0.5761651134294126, 0.6110089955121984, 0.5990549851930922, 0.5703598250113078, 0.14145132742450095, 0.5986849694096337, 0.5844629532050402, 0.5827279585190535, 0.5888113388079875, 0.11212712635349176, 0.11472005138819641, 0.12529906942660618, 0.1204596868979152, 0.15834621328373266, 0.14374609729398002, 0.1313856106468294, 0.1357537767202297, 0.15222634391109424, 0.13566791057904815, 0.12143525646309716, 0.1141767421357619, 0.11556943962997179, 0.1152403974051629, 0.1134765007344013, 0.1094382043143185, 0.10231791684784475, 0.11085277910316871, 0.9558426582116337, 0.9592759359966666, 0.9458598988409914, 0.9760466040042632, 0.9578940107079035, 0.902567443570107, 0.9557340879003919, 0.9346149556661526, 0.9727933029227657, 0.33117210377514217, 0.3189199247384856, 0.3285371707066356, 0.3478750498233867, 0.34071310667821963, 0.36039656308561197, 0.34245335413579747, 0.3135142922919517, 0.349687082406821, 0.6637275905679085, 0.6641323655464877, 0.7025863186117189, 0.7120529670282749, 0.6819530097690217, 0.718649202595806, 0.6735557405684256, 0.6657589402705169, 0.5906176575107545, 0.33660532407378807, 0.25281421526118897, 0.2582457245064401, 0.18774864334689678, 0.13032098757823207, 0.30907525857683127, 0.40510942297354036, 0.17694468544079467, 0.21965870241130359, 0.28795286180141166, 0.13218562179819693, 0.2236074036800093, 0.26990163975228976, 0.26243788616939356, 0.24443284922482678, 0.3306593537551381, 0.1953432569525294, 0.1962877705562741, 0.27860451183832624, 0.20484941312175764, 0.36404213730719615, 0.39532978011930253, 0.23671803844163286, 0.46971988357087024, 0.4249438617547793, 0.09138447423390428, 0.05849771028707873, 0.5556098646786807, 0.3711759675834294, 0.2854456887958423, 0.44792790130516613, 0.22399573755961655, 0.31570508912980855, 0.27744330368961934, 0.3660195875174326, 0.5427189432013205, 0.09732354525281994, 0.05039194492760357, 0.09422283299306833, 0.07708688852687084, 0.18646291178520835, 0.21820300798433412, 0.1512629196629981, 0.1722544557455925, 0.07481631851026826, 0.3418339336990809, 0.31505316470461264, 0.3472132678948088, 0.36357236596627973, 0.28727723604670397, 0.33015341026916367, 0.22692328456230948, 0.25623703081939, 0.3317278347871162, 0.4525986232646684, 0.5054911980593361, 0.49898163402765583, 0.4737037956134026, 0.49599596463239837, 0.5069646889585271, 0.5423417259307621, 0.452853381217884, 0.47793641546246735, 0.10834428508758231, 0.13820043285285788, 0.10690759745123957, 0.0986348750085353, 0.12121251306855252, 0.10800654565037715, 0.1572061974760538, 0.08840327680192717, 0.1004531386607983, 0.2418515194541978, 0.2819666974200449, 0.21894064881233222, 0.28039576764059093, 0.34253535529590495, 0.20647562239325834, 0.23279874257482636, 0.1802386846689551, 0.1976550067664723, 0.3147583660953768, 0.3029352813407563, 0.3181993684542954, 0.34455170333736695, 0.3231502875063149, 0.3265793488667167, 0.31687878743392683, 0.3421735505205976, 0.31963830467240295, 0.2911414735208735, 0.2885418477096928, 0.27218118942092295, 0.2467709030782519, 0.26439283020351945, 0.2561005226831301, 0.2701528126254047, 0.27894358917593154, 0.2737757350339881, 0.20133855674131507, 0.21742129091787854, 0.20138633959767505, 0.23612707891891516, 0.20051146862706914, 0.21086891442418165, 0.22166764150248308, 0.22766368147332128, 0.22340790467328908, 0.20945880173732268, 0.22729722395650875, 0.2343914371971686, 0.2995936857609276, 0.23143972676156876, 0.22016376394460901, 0.24488070166389553, 0.21850780368841793, 0.2320895565537907, 0.7927387543048228, 0.2108076797755123, 0.17102534340254694, 0.7457094862154329, 0.20145744808914945, 0.615780315884519, 0.18846135255207797, 0.2116540374704906, 0.7437390964772502, 0.1671106618285254, 0.20749528263178418, 0.6513881614823891, 0.20620296758712886, 0.16909445465735495, 0.16968770489619078, 0.20238886521916133, 0.8191302105896998, 0.21179980841480128, 0.19843999272389856, 0.1825883541575457, 0.1802638547365112, 0.20162146721877183, 0.18784518954707785, 0.1808341147858934, 0.1966441288194879, 0.1912923243414817, 0.17267542751286036, 0.09261550990418632, 0.08349746136777869, 0.09062669015154767, 0.08686098185653168, 0.08740898126495689, 0.08003045301514522, 0.08058825073345466, 0.0782461513471151, 0.08445021435039857]}, "mutation_prompt": null}
{"id": "ff90004a-a1ce-483a-82fb-75d3e7e4b3bb", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.3 * (eval_count / self.budget)  # Dynamic mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sinusoidal crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 0.8\n        cooling_rate = 0.9  # Faster cooling rate\n        for _ in range(30):  # Fewer iterations for efficiency\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Increased initial population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += 30  # Updated for new SA evaluation count\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Enhanced HybridDESA with streamlined population initialization and adaptive parameter tuning for improved optimization efficiency.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ef501c64-25f2-40b8-b2f8-11d4e35b70e9", "metadata": {"aucs": [0.621373915152756, 0.6797659594631273, 0.6568994226001004, 0.6828141883328591, 0.6625024595450908, 0.6518864821569383, 0.5821501256463407, 0.6641599167977443, 0.6339044198925179, 0.5761651134294126, 0.6110089955121984, 0.5990549851930922, 0.5703598250113078, 0.14145132742450095, 0.5986849694096337, 0.5844629532050402, 0.5827279585190535, 0.5888113388079875, 0.11212712635349176, 0.11472005138819641, 0.12529906942660618, 0.1204596868979152, 0.15834621328373266, 0.14374609729398002, 0.1313856106468294, 0.1357537767202297, 0.15222634391109424, 0.13566791057904815, 0.12143525646309716, 0.1141767421357619, 0.11556943962997179, 0.1152403974051629, 0.1134765007344013, 0.1094382043143185, 0.10231791684784475, 0.11085277910316871, 0.9558426582116337, 0.9592759359966666, 0.9458598988409914, 0.9760466040042632, 0.9578940107079035, 0.902567443570107, 0.9557340879003919, 0.9346149556661526, 0.9727933029227657, 0.33117210377514217, 0.3189199247384856, 0.3285371707066356, 0.3478750498233867, 0.34071310667821963, 0.36039656308561197, 0.34245335413579747, 0.3135142922919517, 0.349687082406821, 0.6637275905679085, 0.6641323655464877, 0.7025863186117189, 0.7120529670282749, 0.6819530097690217, 0.718649202595806, 0.6735557405684256, 0.6657589402705169, 0.5906176575107545, 0.33660532407378807, 0.25281421526118897, 0.2582457245064401, 0.18774864334689678, 0.13032098757823207, 0.30907525857683127, 0.40510942297354036, 0.17694468544079467, 0.21965870241130359, 0.28795286180141166, 0.13218562179819693, 0.2236074036800093, 0.26990163975228976, 0.26243788616939356, 0.24443284922482678, 0.3306593537551381, 0.1953432569525294, 0.1962877705562741, 0.27860451183832624, 0.20484941312175764, 0.36404213730719615, 0.39532978011930253, 0.23671803844163286, 0.46971988357087024, 0.4249438617547793, 0.09138447423390428, 0.05849771028707873, 0.5556098646786807, 0.3711759675834294, 0.2854456887958423, 0.44792790130516613, 0.22399573755961655, 0.31570508912980855, 0.27744330368961934, 0.3660195875174326, 0.5427189432013205, 0.09732354525281994, 0.05039194492760357, 0.09422283299306833, 0.07708688852687084, 0.18646291178520835, 0.21820300798433412, 0.1512629196629981, 0.1722544557455925, 0.07481631851026826, 0.3418339336990809, 0.31505316470461264, 0.3472132678948088, 0.36357236596627973, 0.28727723604670397, 0.33015341026916367, 0.22692328456230948, 0.25623703081939, 0.3317278347871162, 0.4525986232646684, 0.5054911980593361, 0.49898163402765583, 0.4737037956134026, 0.49599596463239837, 0.5069646889585271, 0.5423417259307621, 0.452853381217884, 0.47793641546246735, 0.10834428508758231, 0.13820043285285788, 0.10690759745123957, 0.0986348750085353, 0.12121251306855252, 0.10800654565037715, 0.1572061974760538, 0.08840327680192717, 0.1004531386607983, 0.2418515194541978, 0.2819666974200449, 0.21894064881233222, 0.28039576764059093, 0.34253535529590495, 0.20647562239325834, 0.23279874257482636, 0.1802386846689551, 0.1976550067664723, 0.3147583660953768, 0.3029352813407563, 0.3181993684542954, 0.34455170333736695, 0.3231502875063149, 0.3265793488667167, 0.31687878743392683, 0.3421735505205976, 0.31963830467240295, 0.2911414735208735, 0.2885418477096928, 0.27218118942092295, 0.2467709030782519, 0.26439283020351945, 0.2561005226831301, 0.2701528126254047, 0.27894358917593154, 0.2737757350339881, 0.20133855674131507, 0.21742129091787854, 0.20138633959767505, 0.23612707891891516, 0.20051146862706914, 0.21086891442418165, 0.22166764150248308, 0.22766368147332128, 0.22340790467328908, 0.20945880173732268, 0.22729722395650875, 0.2343914371971686, 0.2995936857609276, 0.23143972676156876, 0.22016376394460901, 0.24488070166389553, 0.21850780368841793, 0.2320895565537907, 0.7927387543048228, 0.2108076797755123, 0.17102534340254694, 0.7457094862154329, 0.20145744808914945, 0.615780315884519, 0.18846135255207797, 0.2116540374704906, 0.7437390964772502, 0.1671106618285254, 0.20749528263178418, 0.6513881614823891, 0.20620296758712886, 0.16909445465735495, 0.16968770489619078, 0.20238886521916133, 0.8191302105896998, 0.21179980841480128, 0.19843999272389856, 0.1825883541575457, 0.1802638547365112, 0.20162146721877183, 0.18784518954707785, 0.1808341147858934, 0.1966441288194879, 0.1912923243414817, 0.17267542751286036, 0.09261550990418632, 0.08349746136777869, 0.09062669015154767, 0.08686098185653168, 0.08740898126495689, 0.08003045301514522, 0.08058825073345466, 0.0782461513471151, 0.08445021435039857]}, "mutation_prompt": null}
{"id": "ba320a7a-9cb1-41a9-af2e-9935fba12af0", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.5 - 0.2 * (eval_count / self.budget)  # Adjusted mutation factor for better exploration\n        Cr = 0.9  # Fixed crossover probability for consistency\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            rand_indices = np.random.choice(indices, 3, replace=False)\n            a, b, c = population[rand_indices]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i] = trial\n                scores[i] = trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Adjusted cooling rate for gradual temperature decrease\n        for _ in range(25):  # Slightly more iterations\n            neighbor = x + np.random.normal(scale=0.1, size=self.dim)\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(20, self.budget // 4)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n            eval_count += (25 // 2)  # Updated for revised SA evaluation count\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "EnhancedHybridDESA with improved mutation strategy and more efficient cooling schedule for faster convergence.", "configspace": "", "generation": 24, "fitness": 0.31286363394031697, "feedback": "The algorithm EnhancedHybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "ef501c64-25f2-40b8-b2f8-11d4e35b70e9", "metadata": {"aucs": [0.7350060135954792, 0.5632137901969619, 0.650787376409645, 0.5654540476504131, 0.6654602818299513, 0.49130851589957103, 0.7520670017882694, 0.6970306621627123, 0.5464294257233868, 0.7284500776937397, 0.6705544175944788, 0.706304236870017, 0.7126019918555975, 0.6987690351468716, 0.7091859695864636, 0.7004734116751727, 0.6785312347832976, 0.07397443658085745, 0.16382082067068982, 0.16431378818277498, 0.12421947486428908, 0.15284339967429805, 0.11645351906772339, 0.14931087144512234, 0.2816659212194462, 0.15099775774204738, 0.13806582823334013, 0.12077999884066981, 0.12406225843159924, 0.1439594398876094, 0.15824901851061313, 0.13538469547488252, 0.1473786910814564, 0.12792843749871297, 0.12855209621123032, 0.11855546524595761, 0.9345010135188991, 0.8146816571271708, 0.9410647817982715, 0.8624786902250967, 0.8925127681736565, 0.9581480798121296, 0.9301081235679882, 0.8017595717897811, 0.8949557911343594, 0.33270310178933915, 0.33580855130587595, 0.4138134293193987, 0.4013852756012134, 0.4026922313278479, 0.4278304271381611, 0.32844654918934546, 0.30852566012172467, 0.2903706141540271, 0.8062603949600886, 0.7709563415872278, 0.7651631131583916, 0.7682809080470336, 0.8082925057888813, 0.7080428015037601, 0.45886306676668465, 0.2839454301821446, 0.5724094632400103, 0.24317294609134132, 0.19921129543990246, 0.21571029047819512, 0.17814149558477488, 0.1965482787077576, 0.21270420728565564, 0.2279395049433045, 0.26714646202800674, 0.285624368303685, 0.2583329983693329, 0.1358597632098152, 0.24226444069590447, 0.22150667431010784, 0.2538265619465654, 0.13479312166013147, 0.2152012608464534, 0.19596959355685772, 0.19172363432233863, 0.03810620080273641, 9.999999999998899e-05, 0.10331416201849641, 0.06367706472180323, 0.10595918476359478, 0.005717058473544201, 0.08161324671832482, 0.13683561814238132, 0.38499440723579137, 0.13059161806056818, 0.14350780161711896, 0.24045800349633506, 0.3176787173229255, 0.15191001006040838, 0.12033880181740875, 0.20109506049056813, 0.35066102775715324, 0.2039034332941484, 0.051760091851551615, 0.05842445566533838, 0.14621535736395486, 0.28530996811482, 0.19517483880764586, 0.09191353834918281, 0.17240542276124982, 0.10386574203125443, 0.09249351118163518, 0.2762139298884043, 0.23585915184948503, 0.3118063744601842, 0.2394725367565479, 0.20134860889422956, 0.3854909147201928, 0.12396484969211319, 0.23448058890569312, 0.1580363425254302, 0.4297853539450479, 0.5167706743506744, 0.51557538182604, 0.42100655897795436, 0.45492267280286525, 0.47630387782510175, 0.5200314988193688, 0.5339704298595007, 0.5119235618029463, 0.11000766490059777, 0.11825405507540199, 0.11652153318271963, 0.1299844134677871, 0.1592923520745857, 0.14705811000086522, 0.11387339201235713, 0.1384485981013902, 0.13018765287752654, 0.2739142986931815, 0.22777496415975051, 0.21245148216558396, 0.29845866403241994, 0.2583295553604439, 0.2911939572944212, 0.33842871583826173, 0.2620567660883657, 0.3370267511724534, 0.33043952622458417, 0.3087039787225485, 0.35340287497897294, 0.3395516577562647, 0.33368391355754035, 0.31899498218851474, 0.34007194183878, 0.36385877361614316, 0.3400228175818383, 0.29761157929351234, 0.28554502843782914, 0.19546472410923266, 0.26645827287589097, 0.27967259974958003, 0.2693381912770234, 0.3048042188465785, 0.2778189133660103, 0.28046782622142963, 0.22893454149799664, 0.19816473150828218, 0.19080155213787653, 0.2125027992072147, 0.2086741829344324, 0.20754423164759983, 0.21583133434581636, 0.21492221288133684, 0.21854742646427816, 0.2494630717484232, 0.22612322322839107, 0.25416075802354476, 0.2588616638871406, 0.24623517956984198, 0.19862250148880034, 0.23741176486674187, 0.23136686191213218, 0.21746287585626423, 0.19937926621873048, 0.18498504939850147, 0.15389223457291956, 0.7757695226936006, 0.19958656690822618, 0.6791133356054138, 0.15913090059406076, 0.17063895211477265, 0.1692647957260639, 0.15665568741651548, 0.21243460092834932, 0.599403719098121, 0.16349766235827212, 0.7912134919466101, 0.6549429685609869, 0.10523810619048213, 0.5172459045060661, 0.432330598951012, 0.214400816702766, 0.19738003800370918, 0.18669695159855548, 0.19121477248246588, 0.18303548458275054, 0.18085008895138022, 0.18840440724389218, 0.18110305766160373, 0.17543841823682782, 0.09136101751601977, 0.0819338236347803, 0.07334233535994805, 0.08982245541709166, 0.0914668724101646, 0.09843458907265579, 0.08240131544451812, 0.08819355165095932, 0.08672761074746649]}, "mutation_prompt": null}
{"id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 25, "fitness": 0.39089287141440676, "feedback": "The algorithm EnhancedHybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.24.", "error": "", "parent_id": "ef501c64-25f2-40b8-b2f8-11d4e35b70e9", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "d9017e91-40f6-40f3-9be5-bd21b1a605ff", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "282240a0-9479-4307-8843-90361491c790", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "4f63b5f9-8f7a-4d31-bb59-47b45af69239", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "6c5d4fb1-abd1-4484-a6f8-9cd1f82a5413", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "b33fa7f8-bc1b-4f20-a8b5-b7ce10905516", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "c8128dc3-79d2-4161-ba1b-8553b1246183", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "18111650-8b0f-48d2-9e68-bdd17589e30c", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "d69475bd-1b74-4c3b-935d-183feb5ba12b", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "ba78979b-77db-42fd-8dc1-18f57e9eee5f", "solution": "import numpy as np\n\nclass StreamlinedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.8 - 0.3 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.8 + 0.2 * np.cos(eval_count / self.budget * np.pi)  # Adjusted crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = np.random.choice([j for j in range(pop_size) if j != i], 3, replace=False)\n            a, b, c = population[indices]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score, eval_count):\n        temperature = 1.0\n        cooling_rate = 0.9  # Simplified cooling rate\n        iteration_limit = 10  # Static iteration limit for consistency\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.1, self.dim)  # Adjusted perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n            eval_count += 1\n        return x, score, eval_count\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 6)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score, eval_count = self._simulated_annealing(func, best_individual, best_score, eval_count)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "StreamlinedHybridDESA", "description": "Streamlined Enhanced Hybrid Optimization with Adaptive Gaussian Perturbation and Efficient Sampling.", "configspace": "", "generation": 34, "fitness": 0.3774723721312171, "feedback": "The algorithm StreamlinedHybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.22.", "error": "", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.5205306235948064, 0.547027830346929, 0.5348308284807823, 0.48153128227305875, 0.5605184394471083, 0.5287849645627104, 0.5723024477260074, 0.6051302874303535, 0.5272437276126924, 0.6138729923635374, 0.6048625269722798, 0.6302041829435213, 0.5675692516663253, 0.5262130101176383, 0.6053249492981925, 0.5748198663348145, 0.623499567322962, 0.624365587912433, 0.12722123526509455, 0.0982452345998005, 0.14365318526819315, 0.12581558039712215, 0.10745285783945635, 0.1323487727241376, 0.10593315655915214, 0.12483727058705807, 0.157380121800187, 0.10401236872816977, 0.09363046252742968, 0.1041974554600078, 0.1217205797694274, 0.10109356536824798, 0.11236053983217331, 0.11193304138323834, 0.11935492497662947, 0.09143708346039581, 0.9150968545024996, 0.9379872517346476, 0.8080323022413615, 0.8691049561258818, 0.8969192864931618, 0.8217426578671565, 0.9718792977592281, 0.9838575532467302, 0.9844927618351318, 0.38158906961601835, 0.37229013819975443, 0.375707325250323, 0.37049711543555586, 0.3865006394886322, 0.38542686291822736, 0.3565425934330415, 0.3680940870757087, 0.3444211091380297, 0.5860058909043022, 0.5629582780490333, 0.5730944389755345, 0.6497669435562434, 0.6112311625053771, 0.6485479864179915, 0.7104564107628946, 0.6614416146296455, 0.640249918938108, 0.49044926490185603, 0.6032017849614586, 0.42282321996367445, 0.5207457091598419, 0.3640828691677661, 0.4002718426743521, 0.5411053532011496, 0.3710548014697469, 0.5764376763467629, 0.584610852623526, 0.4995485811984878, 0.13664830914386894, 0.5131708530456076, 0.4980252623708644, 0.4924490080457571, 0.4674149120469604, 0.5774209287189299, 0.5083926817877167, 0.5604461655730042, 0.583967262415979, 0.5288623363400227, 0.6188173386321387, 0.4922101354890229, 0.5361859342685451, 0.5471574779044274, 0.53234686706223, 0.5480315199986174, 0.6458858976523436, 0.6118497316015634, 0.6337303301419972, 0.5917592665848279, 0.6392001112184177, 0.6747931456019691, 0.6593530886322264, 0.6328835283856878, 0.6467719821511686, 0.18502353076496925, 0.28680789725529443, 0.18693988079034907, 0.3514389841512904, 0.1900281736277395, 0.33676012793991794, 0.26118712830921753, 0.1550910432125029, 0.2524407931053496, 0.34823707524756864, 0.37863645965665493, 0.38526786893653786, 0.380361446132376, 0.40288532425654866, 0.34460784244689235, 0.38223746877397924, 0.33913880760480053, 0.38345082390775065, 0.4324151965435894, 0.4541858386899438, 0.4633430471469143, 0.4431799047437962, 0.46543462821353687, 0.4360884089565815, 0.43458964624485064, 0.46432840293286726, 0.47007800076105954, 0.11694346170434888, 0.13688313176711386, 0.12308745602364812, 0.08301562565127119, 0.12923129261254762, 0.14070520822132748, 0.13819013536482438, 0.1204070779815476, 0.10208131054319725, 0.48425920446031245, 0.3824377030658005, 0.2227962831962471, 0.352935144642764, 0.2875358403897389, 0.3289827553293051, 0.3810307601031009, 0.21095470641545966, 0.25044298939151166, 0.279306437065306, 0.2695661723121139, 0.2874000942473851, 0.2819032449040887, 0.2838605915871393, 0.2818795791759383, 0.2681073360949161, 0.2726183878922672, 0.26329082480429833, 0.23273796346647146, 0.24855031622794854, 0.23684301666367213, 0.25642089982725025, 0.23082049126013093, 0.25074161999529376, 0.24705740676733368, 0.2632241339032745, 0.22962185552203007, 0.20074873979636965, 0.20940799532774568, 0.187240210361433, 0.1820881629954736, 0.19042870242362564, 0.21735267513227274, 0.24415715801366367, 0.2408942617672769, 0.22864297822507784, 0.22587206569438367, 0.20076669756529264, 0.20941839546844387, 0.1985416212835941, 0.1855486309537674, 0.19875084849984692, 0.20778901875006084, 0.20446281584608583, 0.2012807381215349, 0.17122850571076687, 0.7048529142209767, 0.7653116892798713, 0.17808324620454563, 0.1876847001052565, 0.7777321852139728, 0.6949243612749059, 0.20668159139627962, 0.6676003193905302, 0.6925213971954829, 0.16817372982338563, 0.3486346348939672, 0.6869205199918478, 0.2108913259190961, 0.2096545751853368, 0.21150824233251486, 0.7097119445340058, 0.6097956714745363, 0.18393429249273463, 0.21150364198298333, 0.2030475968688802, 0.21294825754680236, 0.16758207123738988, 0.18596599949569403, 0.18767408905801763, 0.19235616431269698, 0.18740597846375506, 0.10244943408556484, 0.10071130527327277, 0.09390786666466411, 0.09873354955911418, 0.0832016502149705, 0.07976899344629351, 0.09556022219481985, 0.08213757531735022, 0.08248587228604753]}, "mutation_prompt": null}
{"id": "6f34d78a-81a4-44d8-bc19-8683e14794f7", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "3d09f37a-a827-4331-9ed2-a34f5613cb5e", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "b8f92828-b452-4474-82bd-5f7ecf938eaa", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "e5d31d25-6e51-4d65-8a3f-73f606fc60dc", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "c7df60fc-6968-41a3-90fe-dfa600fcfc64", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "9ffbb7a2-6fd4-4f1d-a652-883d3c509da7", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "d124321a-7387-49e6-a21d-a4caf5a9d30e", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "aea41f5f-be47-4b4b-a430-e7bcb6a32ffa", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "aa60573e-2aad-4693-bf1a-dfd95af41b56", "solution": "import numpy as np\n\nclass EnhancedHybridDESA_Variant:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.7 - 0.3 * (eval_count / self.budget)  # Further adjustment to mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi / 2)  # Sinusoidal crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.9  # Accelerated cooling rate\n        iteration_limit = max(10, self.budget // 100)  # More dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.03, self.dim)  # Even smaller perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Further adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(15, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA_Variant", "description": "Evolutionary Simulated Annealing with Enhanced Adaptive Parameters for Efficient Optimization.", "configspace": "", "generation": 43, "fitness": 0.2571496532813584, "feedback": "The algorithm EnhancedHybridDESA_Variant got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.538232907042344, 0.5247603993853258, 0.553372914866466, 0.5476745442521354, 0.5473042897207305, 0.5578124137401572, 0.5425694740367402, 0.5556945438966099, 0.5372840423521503, 0.20991452538994293, 0.15626161835145536, 0.1413739089125875, 0.1846517436173798, 0.14718367637947338, 0.15963685301239816, 0.15129774436164112, 0.16839418174969123, 0.18687884768501206, 0.1612154264906268, 0.10911157206853372, 0.15607796747725078, 0.10418505839411796, 0.11504866777731981, 0.10619926953652126, 0.10662246182352297, 0.08425986369849381, 0.08655664982519395, 0.11852817239390678, 0.11750793545566718, 0.10328901018753, 0.10841613400083572, 0.08608928256694892, 0.10378730026990923, 0.10412027992822337, 0.07174717951296317, 0.11908255543902835, 0.9083026450699749, 0.9509363515673228, 0.8859813505935515, 0.9087403026352897, 0.92050385419581, 0.9425164516900982, 0.9393288339588913, 0.9169391937367487, 0.9334409356167754, 0.37016603018614114, 0.38635480681142953, 0.36533353721613415, 0.39498540550788086, 0.39484789440134516, 0.3868198955195409, 0.40284165711186026, 0.39497773576150264, 0.3959802646665468, 0.41708979700751736, 0.3617204610369147, 0.5802605010691586, 0.2806356911262734, 0.3270791058492942, 0.8053579746790359, 0.28140983871164627, 0.4772021608672311, 0.5001852981907229, 0.23167515892499502, 0.25941857103356325, 0.2285767978990113, 0.1631331851540112, 0.2736095893078895, 0.2697835516424152, 0.23298190095737914, 0.19439335649261025, 0.24693029496040564, 0.31660020338417005, 0.22155585163627023, 0.16815110052088544, 0.29780294931986395, 0.2924192437698149, 0.25669124963164514, 0.3068464604465855, 0.1542649379734543, 0.14116417714010987, 0.03851458760650217, 0.06501419743195525, 0.012133687279191285, 0.0547625017678558, 0.021499408613193882, 0.009642494303313098, 0.017480352256252663, 0.0385635083421475, 0.057898240344695706, 0.059314416042009044, 0.10860677626803239, 0.12980357795354303, 0.12779919876704549, 0.09499539584983419, 0.09632330189922689, 0.10755618460291749, 0.08516037953387035, 0.13181372992613194, 0.07912178406451309, 0.0221630432852713, 0.056404330751790965, 0.05145519155094702, 0.061620898473602526, 0.024824200778402306, 0.031694439848793055, 0.04870680509568226, 0.035397651063835966, 0.1055578343989273, 0.1151632892101283, 0.10286651521447077, 0.1815016438109237, 0.13068284829695354, 0.1275698061834719, 0.18749194709420025, 0.09685022061071902, 0.11634216402808217, 0.4909036300680335, 0.44846272443204915, 0.4687404612411966, 0.46645710818711383, 0.439728369605901, 0.4542185629818276, 0.4426066621838938, 0.4282447305404987, 0.45786908027923445, 0.1849585505051382, 0.0824984027432416, 0.07973383919586718, 0.09405647222374114, 0.0945335028702664, 0.11103219053706159, 0.10739746034379805, 0.12531532218249308, 0.1031604732254473, 0.16531965551527505, 0.2844761765300524, 0.19880256176211974, 0.17866211680765776, 0.2798642032888573, 0.37643860840003884, 0.34419229020167985, 0.19811146270862645, 0.14250183911530145, 0.2478986519913684, 0.26172253728768136, 0.25201104452518375, 0.27368269221049313, 0.22377096327790824, 0.24163491744397902, 0.2811426511702957, 0.2867725021948353, 0.2697834880452339, 0.196613658132766, 0.19221008285401076, 0.21250031794201818, 0.1586934622998979, 0.16514528489104874, 0.21497734353860876, 0.23507603141511224, 0.20097207142770424, 0.23240607071696107, 0.18989011960485025, 0.20074058035199005, 0.247422479473542, 0.22508797796961966, 0.1790076313871396, 0.1969987054216793, 0.17544913186655775, 0.16530784791844122, 0.22054399122134527, 0.2093664458265615, 0.19384712311295305, 0.28003793564356394, 0.19797928729669667, 0.20639937844162792, 0.21071956321819696, 0.2345961009802786, 0.20079006618287043, 0.19458515028230072, 0.21987945882790882, 0.5007062260357853, 0.15778428675278122, 0.723878431539493, 0.20221545063450153, 0.398682023444091, 0.7249444069652764, 0.5246848616169832, 0.21159777656298506, 0.38150281852715373, 0.16675208968290356, 0.515490580806261, 0.2126112327831976, 0.16818986397960456, 0.20959042616264656, 0.20226243184234904, 0.4733520101705393, 0.5504376073002566, 0.21009968935369994, 0.20318218179947012, 0.20209523405141383, 0.1935306606725008, 0.1961208857933141, 0.2355055465089081, 0.2077455411650183, 0.22456043630436384, 0.19208421302188983, 0.07813636091747889, 0.09169556259439782, 0.09971356532611608, 0.06425207776846309, 0.0930580763600678, 0.0759732037926738, 0.07266475497812441, 0.07801665929859702, 0.0668822070634787]}, "mutation_prompt": null}
{"id": "b189b777-3998-4468-9e6d-ca2d15beec86", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "b6eeddfd-114b-4eb7-a58c-16ae293e2dc0", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "12c181ea-eb43-455f-83c4-950f629f8069", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "10436351-7ff6-4e7e-81e1-e452cea6f7e1", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "dad1605b-2e83-42eb-86f2-ee9eba75afbe", "solution": "import numpy as np\n\nclass EnhancedHybridDESA_Optimized:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.5 - 0.2 * (eval_count / self.budget)  # Slightly adjusted mutation factor\n        Cr = 0.9 + 0.05 * np.cos(eval_count / self.budget * np.pi)  # Simplified crossover adjustment\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = np.random.choice(pop_size, 3, replace=False)\n            while i in indices:\n                indices = np.random.choice(pop_size, 3, replace=False)\n            a, b, c = population[indices]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 0.9  # Slightly altered initial temperature\n        cooling_rate = 0.9  # Adjusted cooling rate\n        iteration_limit = min(15, self.budget // 60)  # Updated iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.02, self.dim)  # Further reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 6)  # Modified population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(15, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA_Optimized", "description": "Optimized Differential Evolution and Simulated Annealing with Enhanced Adaptation and Efficient Perturbation Strategy.", "configspace": "", "generation": 48, "fitness": 0.33261776806418775, "feedback": "The algorithm EnhancedHybridDESA_Optimized got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.8304593784441459, 0.7167908077923029, 0.8224866379674622, 0.7879930415621937, 0.8237626901850497, 0.7932221691890952, 0.8109544224166192, 0.7620857753645625, 0.6799300414375551, 0.35356496199832843, 0.6537760351758028, 0.7267428220101319, 0.7770094405187542, 0.7674650931209208, 0.14097227847967808, 0.6716507446761888, 0.761463286469244, 0.1511572548258433, 0.23216993786923823, 0.348933832156502, 0.14628074743492958, 0.15490969441569924, 0.13078575832351125, 0.16057360843019108, 0.15840827041995564, 0.16234599591389742, 0.1830459778918062, 0.15465911809452004, 0.13743706162349767, 0.20595733316192422, 0.12346684220881432, 0.13580396646730641, 0.14416271623316113, 0.13640212676055108, 0.11342488592698718, 0.13018498100777487, 0.8298661421058988, 0.866362663615395, 0.8570313982324755, 0.8335486615858758, 0.9050518019238729, 0.9113332005921821, 0.8259831834092106, 0.8082489192386711, 0.8575649500894679, 0.42414561491202263, 0.37225342188688637, 0.39432360989318205, 0.4087442880084503, 0.4231577281420543, 0.43885620535374936, 0.4045212057722164, 0.40513083930788674, 0.38469731575668586, 0.8626590690364363, 0.8921913256993101, 0.22312616353787462, 0.8353889084619809, 0.853658095517884, 0.21027236945418126, 0.25444592052170234, 0.7996615688241855, 0.24241241125915336, 0.2953542710174445, 0.22018054858619707, 0.41900272845502673, 0.20667590463679852, 0.17926040660893616, 0.23458474932017326, 0.2243635753006592, 0.13223296317924527, 0.20892886317303583, 0.20490467109621635, 0.17631485135791103, 0.5114232744393125, 0.25374761982020855, 0.20387144815091152, 0.22690573418219806, 0.38400433448365756, 0.20189229405634435, 0.20021077805133947, 0.008407788637230573, 0.24957458420712197, 0.37301705824114173, 0.03152708344626354, 0.17807587643562695, 0.14802905407848244, 0.006057400923027645, 0.21890473152890977, 0.029674098484560263, 0.3909941112362785, 0.287110845633751, 0.4966868733395593, 0.43859812782046714, 0.09235388751424034, 0.09371128437189258, 0.457213369978135, 0.2084752555163678, 0.18244220784204412, 0.26284142400142196, 0.13781207015774344, 0.20617605995845256, 0.0932748583152857, 0.34016528328697837, 0.13394413032593078, 0.12457420205861836, 0.13857509690122916, 0.11072620653804266, 0.4030458651571379, 0.25462825379458887, 0.27737186500089706, 0.3247094687473171, 0.27663593593756475, 0.2707499585002826, 0.22770954740887162, 0.16687804515411975, 0.09039127446770523, 0.5563173816995612, 0.579198235230935, 0.503781366804251, 0.5033706695076281, 0.6294649643161081, 0.48243278911221776, 0.5757203679970018, 0.5588889925449261, 0.4765026687233347, 0.11105407744931783, 0.1478701458069681, 0.1561843384092112, 0.11510321979324378, 0.1484850338377398, 0.1371081447495257, 0.1251893274159489, 0.17932134944954103, 0.11883048728563661, 0.19432644201062999, 0.22321281161900075, 0.3080878412053579, 0.4592998379496812, 0.4435169068594723, 0.20402923794408756, 0.561195131342265, 0.41807223582040887, 0.19373873122503005, 0.43231171103572175, 0.3805411943951391, 0.3891152690839087, 0.42200717458137027, 0.411265614473839, 0.4070437509956778, 0.41684027828101244, 0.4702898995708933, 0.43087548226776273, 0.3530653691474006, 0.2944990666123556, 0.35321539235897814, 0.2865398130566156, 0.31205626509436457, 0.31020661743860334, 0.36228815910313117, 0.3658568908698123, 0.34787421009176234, 0.28213555629164844, 0.22399301638356683, 0.23742301712492564, 0.22384331629722753, 0.21055047345521094, 0.21791206676124697, 0.2708452981164513, 0.2177585966746467, 0.25565397024128744, 0.21653326912018178, 0.2360158118705482, 0.2370005765418659, 0.1933136947914864, 0.24720895418164768, 0.21849359335321528, 0.2570494480979735, 0.2225861998786136, 0.48057270991037826, 0.16989646279080606, 0.18479554361935757, 0.15108583494813577, 0.16555082390198927, 0.1975428152751787, 0.17417843962358803, 0.18577847708755046, 0.18762580174713817, 0.6722640001160438, 0.8101740281003293, 0.21151009004687693, 0.5341633915104231, 0.20193260510499078, 0.19587008428239638, 0.16539224868336422, 0.166277162481977, 0.15522459675513378, 0.4499034115098516, 0.20073477404782203, 0.20369034306139122, 0.2233554078807215, 0.2010787830360644, 0.21167962976682209, 0.20708080155628616, 0.20243891193432073, 0.2983914398800107, 0.2135106685889392, 0.10219994129854226, 0.10290838595028562, 0.09439878026703741, 0.08751837812354446, 0.09207690448320882, 0.08833149566278009, 0.09897687673846356, 0.09562977970890696, 0.10718739965883595]}, "mutation_prompt": null}
{"id": "8d82593d-2b53-4954-a4a2-2d0de40edeb3", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "8b1762b7-c1f5-4da5-a0f7-d00b639fa90d", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "3ee59cc9-c81e-41d6-abca-0dcba26b0376", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "7a422a3d-63f5-48a3-a836-a29e21ff44d7", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "783213df-de94-4fd9-a07e-451e2eb6ba28", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "10ece242-e6c9-4551-8b8f-d62d999dcf8c", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "b6eab669-013b-4577-aabb-0f0c757e0bd0", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "581fafc0-87bb-4d15-a016-7533a4f6d79f", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "f268636a-8b63-45fc-a217-d03242d02f70", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "9d31e8f2-9d9d-4672-8e3e-3570a4887eea", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "ad6bd87b-c9aa-4d41-9c5b-ca6cb816e459", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "cd90f24b-80e2-4591-80d9-5d822af144a4", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "7b47ef3b-a419-4710-8dad-166ce481992c", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "945a5102-61f6-470a-a8f4-839e9530dff1", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "8d9e242e-4607-4936-8871-e081aeb6d843", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "3fc73435-d1e9-4d37-a267-46b04b7a6e93", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "c19b6a48-9101-412a-b944-8a2a6e71116b", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "6abadd5f-a964-4a82-ad46-842fd8bfa703", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "cb0f1d32-04d5-4a95-8813-cc866c3073e0", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "8a8425ea-6782-4ba4-8338-3cba1a6ba49b", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "56e531fd-2d98-488e-b59c-515a36e221a1", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "317be1ee-805d-47db-9bb2-53006f5b2e97", "solution": "import numpy as np\n\nclass AdvancedAdaptiveEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.5 - 0.3 * (eval_count / self.budget)  # Optimized mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi / 2)  # Sine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = np.delete(np.arange(pop_size), i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = self._clip(a + F * (b - c))  # Directly clip mutant\n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.9  # Optimized cooling rate\n        iteration_limit = max(10, self.budget // 100)  # More iterations for thorough search\n        for _ in range(iteration_limit):\n            neighbor = self._clip(x + np.random.normal(0, 0.1, self.dim))  # Adaptive perturbation\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(50, self.budget // 4)  # Increased population size for diversity\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(pop_size, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "AdvancedAdaptiveEvolution", "description": "Advanced Adaptive Evolution with Enhanced Annealing and Random Restarts for Robust Optimization.", "configspace": "", "generation": 70, "fitness": 0.25776189312056536, "feedback": "The algorithm AdvancedAdaptiveEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.5716400839333633, 0.54469650549044, 0.5527092673386327, 0.5490608301005848, 0.5504652703318497, 0.5313110197992543, 0.55706456775078, 0.5408012720583264, 0.5350897038224277, 0.2072181203296306, 0.21706665774007394, 0.222625764906629, 0.2256860273561141, 0.21986799453056505, 0.20940719171913036, 0.19429380464129276, 0.2019609398826604, 0.2218831449091222, 0.12310014365309019, 0.10022009167710588, 0.10626842962543814, 0.10466470475636158, 0.11605786900474069, 0.09877870846146053, 0.10072000721023955, 0.10236401091497205, 0.11872622307124125, 0.0865663072251307, 0.09775802243067444, 0.11016051562952511, 0.11239145826273234, 0.09405624724062545, 0.10553227354229622, 0.1293319752717198, 0.11363370305314147, 0.09668630532402744, 0.8967971725399807, 0.9359539535998455, 0.8761547831443934, 0.9020418361997959, 0.8994120542033434, 0.8799072314419284, 0.9358793327757091, 0.8943303395198634, 0.8837151318046192, 0.3267719658336862, 0.32577001022659346, 0.32467339979422416, 0.3279431976991456, 0.32994140570979524, 0.3125994319517553, 0.32410682448590844, 0.3319085503331096, 0.3086104797356434, 0.31752024742709095, 0.4005675431459198, 0.4384279036283827, 0.5189786955186035, 0.4903248098763867, 0.4268461431809335, 0.3138153216558739, 0.3252577413559756, 0.3828392565887878, 0.2451225922277407, 0.16559826498500063, 0.18569644174980526, 0.20111125061959279, 0.19567064549854762, 0.20372545602356562, 0.21649473623497018, 0.21135993363792094, 0.19875027704041426, 0.2122376444988171, 0.21409680737011905, 0.20765864311296678, 0.2032951790211599, 0.18615392278169096, 0.20825131449447198, 0.17077658900756254, 0.23331091412899463, 0.16301894597733013, 0.05106232826224477, 0.06648867472153575, 0.047568673625730695, 0.08553681852978368, 0.05174202005908135, 0.06326456145308079, 0.04195097127469327, 0.07803175509023386, 0.07718709818751923, 0.21251276226889304, 0.14891741590132423, 0.13663918261157015, 0.16395763997274293, 0.10446734866882212, 0.1722954068162682, 0.17941570579352972, 0.17119363253395659, 0.1735912475922483, 0.008523150604240803, 0.0018078772867516912, 0.01787403407944499, 0.005726517053480151, 0.02376936567619392, 0.018972929875909705, 0.008717181681831443, 0.018361618356912524, 0.0115175677002739, 0.14254440347408903, 0.12698887543210713, 0.12438677954884703, 0.12072739756757767, 0.15139855101207544, 0.12614674936659398, 0.1348780229160298, 0.1412236064548824, 0.11406221589485865, 0.45239627721028464, 0.4524925141782111, 0.4777176986273466, 0.45740021818521326, 0.44327762996196074, 0.4437734627639115, 0.45132518271734556, 0.4650805345282698, 0.44950002853881765, 0.08755860057850917, 0.1224772075062337, 0.08291502372264947, 0.10383492420874751, 0.10240284989492188, 0.1398602208860713, 0.09771173079376672, 0.1272739387667723, 0.0999588921687582, 0.16603648059524945, 0.2997672077294239, 0.190575975344753, 0.18492257895854392, 0.3029465861532413, 0.3291285169455981, 0.3173623781149486, 0.1995197860304806, 0.1435755005982755, 0.28944652166163787, 0.2824430952202678, 0.27316554803915416, 0.2747503650391986, 0.2913142554483873, 0.26024659769476544, 0.29141367880013813, 0.29992105747513187, 0.3026205761906181, 0.20858596458672174, 0.21423204845482058, 0.21254556557516224, 0.22527448839464148, 0.22735654517135295, 0.24151767618569586, 0.21531622937130324, 0.2071801317468528, 0.23005473436161983, 0.19213304609851678, 0.19611173394017267, 0.19532579301535447, 0.21684568960889827, 0.20730181051565166, 0.19390880919136644, 0.1954885945002809, 0.24149429228248065, 0.19444843201574624, 0.2076937242346245, 0.19940726731218827, 0.20040868214506113, 0.21524447452613193, 0.23317817623639792, 0.28582184063095717, 0.20346987001855799, 0.19391914549774658, 0.20781214447757768, 0.658931321151076, 0.4190197850383084, 0.5992877334251936, 0.18175478985301374, 0.2718699725799365, 0.727981835073984, 0.40868961747892574, 0.31651272311437495, 0.39674324409576534, 0.6382845365700437, 0.43812048620455546, 0.493735818856997, 0.4050982359890881, 0.21105730017207247, 0.4477028074866879, 0.18908490327955962, 0.384152728399097, 0.1974728440674901, 0.1829581947626039, 0.18623788162936794, 0.20010428123340596, 0.18341813683410846, 0.19154012920768304, 0.182467564276116, 0.20286675435787627, 0.1988688421927528, 0.20746010611253107, 0.07795411343630654, 0.078091739434338, 0.07874948349826172, 0.07737918457763593, 0.0765944903760063, 0.07919285741665039, 0.07336734677769452, 0.07245969151387344, 0.07642731006653192]}, "mutation_prompt": null}
{"id": "cabf1012-28cc-4ae7-a943-dbb6d889c0fa", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "368b409c-b17d-4415-8b83-584916b692df", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "2487ee3d-e34c-4317-993f-484a40eeee9a", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "328ebf73-bf94-4b7a-9486-2ce9ec40ed7b", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "0e3dbb6b-aa4c-469d-aac2-c1da9f715f31", "solution": "import numpy as np\n\nclass EnhancedHybridDESAOptimized:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.7 - 0.3 * (eval_count / self.budget)  # Enhanced mutation factor adjustment\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi / 2)  # Sine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            idxs = np.random.choice(pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = self._clip(a + F * (b - c))\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.9  # Simplified cooling rate\n        iteration_limit = min(15, self.budget // 40)  # Adjusted iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.03, self.dim)  # Smaller perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 6)  # Modified population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(15, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESAOptimized", "description": "EnhancedHybridDESA with Efficient Population Management and Optimized Parameter Control for Accelerated Convergence.", "configspace": "", "generation": 75, "fitness": 0.32243830429681314, "feedback": "The algorithm EnhancedHybridDESAOptimized got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.20.", "error": "", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.6372120665257714, 0.6339234119896371, 0.6037759548114099, 0.6156821745357512, 0.6662641746383886, 0.6307602310863112, 0.652045813106978, 0.645674431825347, 0.671165080564653, 0.6455987534068338, 0.6462664948309148, 0.6131057300482395, 0.6311140612116388, 0.6307574619303247, 0.6452701704328486, 0.6622331320919943, 0.6271619632018427, 0.6305329228352916, 0.1592758421437791, 0.13150910928277282, 0.13968081962326573, 0.20213886073043985, 0.12208729718023947, 0.16392450059297803, 0.1549330511426915, 0.13822025888117495, 0.1367894027809825, 0.13502562480156943, 0.20537570539533379, 0.14842430080195768, 0.15001328378011292, 0.11117869289441751, 0.11597102352387678, 0.13196481291936002, 0.12214274880377851, 0.14030172068544178, 0.8995660172750556, 0.9413323078831793, 0.9537905274962837, 0.8513171533467275, 0.8973123391077664, 0.9451621603063801, 0.8800029449217458, 0.9405921510896387, 0.9053140158435519, 0.34175576793207074, 0.3323250721152473, 0.3362328467037109, 0.35943677371567184, 0.3365041843574621, 0.3374134245048531, 0.3536395379186551, 0.34737918269887047, 0.335441455347084, 0.5805436925410663, 0.6358907428792102, 0.6465060216694201, 0.6098882653050972, 0.6208423235071118, 0.699721236023304, 0.5569126456671816, 0.6333301530559255, 0.5149984449373102, 0.30140733557989674, 0.24147909204132723, 0.2822752378758886, 0.21220082817237051, 0.2599122212935392, 0.24327331557721776, 0.2803439711617237, 0.2568172949589511, 0.2658777237340326, 0.2488158114321456, 0.21742545693770698, 0.28671770293996424, 0.28710360358914055, 0.25143477254222957, 0.22085341827070293, 0.2401185480202792, 0.28246011108823754, 0.22460882288578976, 0.29969123003559983, 0.2773015468230624, 0.24902258692634538, 0.30634787181766154, 0.22601186861129452, 0.2796134711325039, 0.289753665208358, 0.29975139858459254, 0.2625863956840976, 0.3183127292381208, 0.3276701046111993, 0.31719175308447745, 0.37481871792228705, 0.32017558563333703, 0.29836175829505296, 0.4018680351466898, 0.3172984498442639, 0.4075192334780765, 0.12078331308870205, 0.11177765212211055, 0.060110256382967964, 0.15118820363191277, 0.2151028144081154, 0.23255663899713608, 0.13140389179006928, 0.10935229009227898, 0.1545411271036995, 0.25247771521585904, 0.2375442697121085, 0.2570560402322777, 0.2823156225759915, 0.2751541866581013, 0.2864153909823427, 0.2571699951566301, 0.26724834875759096, 0.23748260449438152, 0.45052136075521176, 0.44869792138577724, 0.4717817620036593, 0.4558054423479202, 0.45631330292168737, 0.45589083507925743, 0.47245035587274, 0.4655059188607915, 0.4809882220470181, 0.11123968697466646, 0.12501310574699165, 0.11612496836905117, 0.14314231742521044, 0.11368963339124183, 0.12006028098733279, 0.16186536463256018, 0.1154076868474796, 0.14946253631188922, 0.2912723637090212, 0.25062090680409466, 0.19025448476468487, 0.310733145648718, 0.2478173813305118, 0.2987949132433022, 0.30276000040804163, 0.26569481136508055, 0.1800598983431141, 0.3036099165614914, 0.29844687205290776, 0.29039271515401555, 0.2990810582543557, 0.2938171212004167, 0.2958360184253711, 0.31413544774466085, 0.30738748680687844, 0.2970843190984378, 0.25960430265009826, 0.22774617428056776, 0.2417062764801604, 0.24948581401446912, 0.23609329540249047, 0.2447060172009894, 0.25696956408588134, 0.25621924972776167, 0.24538580438854174, 0.19923338153572412, 0.18276313088737128, 0.18599322436577126, 0.19695320002405892, 0.1939077552684847, 0.2194176269296848, 0.2183233834736409, 0.22423661561508046, 0.1896740677894102, 0.22182826318965432, 0.21387696253998378, 0.19341344636189484, 0.2081507863409049, 0.20619793568730915, 0.22076420806555197, 0.2225032042577323, 0.20034657621392093, 0.22842467802785837, 0.6306292315799134, 0.5530976629649564, 0.18112257051782021, 0.1655786505615714, 0.19849728394685995, 0.19395695969422888, 0.1867086311974474, 0.16462513644659715, 0.20460599171536054, 0.4869479919832833, 0.4780984850761628, 0.5875589816573348, 0.4902816014277729, 0.16451394963740007, 0.5174337807661296, 0.5121827991400625, 0.20690843296238381, 0.15290717604261572, 0.198856186054561, 0.18759910159839766, 0.20461190250354344, 0.19952070474602746, 0.19941701737184003, 0.20136938372484892, 0.19659730110214146, 0.19800134048592355, 0.1952382215921793, 0.08709169105158032, 0.11010069872812378, 0.0930749272075978, 0.06979121205053851, 0.08665226633957968, 0.07855723565915163, 0.09746360567034229, 0.08380113825154711, 0.0808354642068545]}, "mutation_prompt": null}
{"id": "8263b755-08e9-45f9-bb39-bef31397c920", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "66349f30-619d-42f6-8edd-6b5529294b0e", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "f16e0ba1-5ca2-4385-9348-335403370e21", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "d1882df2-627d-4648-bfce-19ee1f1e646c", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "e1193a12-dee2-40cb-99a5-6ec60fda7a2a", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "d3589282-083e-44e0-9dbe-17e8bd8db792", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "a2c9fb2e-a1fe-42d4-9dca-4ffd1189bbc7", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "5c8f79b5-7bca-4461-a0ea-08bda251bde7", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "98c9569d-4b6a-4308-8fbb-7d836578fee3", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "3e97b951-ddf8-486f-927e-e950ce5e1e64", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "6d506d7f-f52f-4ec0-9193-9c712388ca44", "solution": "import numpy as np\n\nclass EnhancedHybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.6 - 0.25 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.9 + 0.1 * np.cos(eval_count / self.budget * np.pi / 2)  # Cosine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _simulated_annealing(self, func, x, score):\n        temperature = 1.0\n        cooling_rate = 0.95  # Refined cooling rate\n        iteration_limit = min(20, self.budget // 50)  # Dynamic iteration limit\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score or np.random.rand() < np.exp((score - neighbor_score) / temperature):\n                x, score = neighbor, neighbor_score\n            \n            temperature *= cooling_rate\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(30, self.budget // 5)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._simulated_annealing(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(20, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridDESA", "description": "Hybridized Adaptive Differential Evolution with Simulated Annealing and Gaussian Perturbation for Enhanced Global Optimization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.648573724220131, 0.7161811639048652, 0.7103228596040803, 0.6053617338801107, 0.7143060736930043, 0.7142162437165485, 0.6827591611966428, 0.49381890375720416, 0.6328756336957349, 0.5578624002368477, 0.6502558210307603, 0.6426532970185734, 0.6403439946750832, 0.6541844693363916, 0.6493955848341848, 0.6720788137128189, 0.5257622196057545, 0.6416017191790664, 0.13143612509073122, 0.1130419306925623, 0.11944633055051368, 0.1294358737205259, 0.13492817910041688, 0.11491874791365242, 0.13366277891543887, 0.18889731842855617, 0.13771460349806752, 0.11974553634876572, 0.12821208361042213, 0.12703619692957724, 0.09290142383854705, 0.14063993413514841, 0.1144371663288628, 0.12830729506276606, 0.13589010223420206, 0.12922810741279922, 0.7495315751282561, 0.9791783948916617, 0.9364068157421772, 0.8753265607146161, 0.770681995932269, 0.766812188195759, 0.7488437829075039, 0.7869913012174303, 0.9212545698734099, 0.34049018306005796, 0.30490087484044615, 0.327103925783932, 0.3287810749695065, 0.3014374547577131, 0.3268965468407674, 0.34264389675143925, 0.3214000346444379, 0.339213337155171, 0.7905509367163022, 0.8099990647968349, 0.7185273516691782, 0.8494823286312114, 0.8430037927828345, 0.7754374146814136, 0.7226636900860941, 0.8018427218161943, 0.7847264637355571, 0.2484153070766203, 0.2220744206992794, 0.2616034791346643, 0.2790710972680197, 0.23661770346322342, 0.4180465676653765, 0.2891962119689364, 0.5838057607140921, 0.2589896835205271, 0.29493931906991055, 0.2249984587700058, 0.5639406306799691, 0.3296923015147505, 0.2799596579810084, 0.2759540484712061, 0.3605914584109293, 0.19904016447113526, 0.3120288075917136, 0.6034935961003367, 0.6106408921353409, 0.6239494360895572, 0.6685852065145177, 0.6247465675358613, 0.6343174866608849, 0.6014069073813075, 0.570739878490125, 0.5914003861957475, 0.6955126256178366, 0.718719719118379, 0.6523717294586999, 0.7213738520885189, 0.6846722510084977, 0.6924843354557586, 0.6986410671593763, 0.5399792571191739, 0.6714968837459618, 0.27395912262525934, 0.263078500014554, 0.20227116334881978, 0.11738893120834304, 0.1952265087603967, 0.2617895656347592, 0.13882826725727393, 0.15973523214223895, 0.1347340825707639, 0.5020459351555628, 0.5031631996103193, 0.5082649225700788, 0.484879884835832, 0.27800934432357394, 0.48919100167002794, 0.507660757673689, 0.4493530741041829, 0.44672741483914247, 0.5010733959991032, 0.6664159487675103, 0.6380783243713462, 0.6552890154191661, 0.6756042762507019, 0.4393871026477354, 0.6542656364457591, 0.6092324678456458, 0.6626463142216699, 0.11331302763786644, 0.10439526725296122, 0.12037972755788984, 0.16532472621343586, 0.14409507588038994, 0.1510988741631467, 0.14540423708169004, 0.15443974938169702, 0.13748961836783125, 0.20790125221727918, 0.25601412173185556, 0.20946736616979822, 0.2530038657248814, 0.32841883078928535, 0.4047776444225686, 0.3515621608201315, 0.44342999438594044, 0.24051849529389924, 0.31801552800788824, 0.30832638779187627, 0.3625740846035824, 0.32334643695832044, 0.3204726754377921, 0.34579205389635814, 0.3636608305190797, 0.36286443099916554, 0.33781272304341936, 0.30289648398010094, 0.32113670576460096, 0.30023903098089044, 0.2983729018812662, 0.30657279350696387, 0.3033842375108551, 0.32859182312831947, 0.32982776722788554, 0.2959848017502452, 0.20449642575647542, 0.22059452144757152, 0.18615454677592702, 0.21556670694781144, 0.19567039630236915, 0.2295483715533071, 0.2167427559996591, 0.23345728630345675, 0.21324223242507867, 0.22055423616361702, 0.23264656929827987, 0.2062031059847511, 0.25622027044429474, 0.22648132598459014, 0.21844913528328136, 0.22772398200680544, 0.2305339756219852, 0.20103739355292982, 0.7544542422976137, 0.20376320582884444, 0.1706720121023838, 0.7381856600175132, 0.19915833850512954, 0.17000390563115253, 0.1646345604875813, 0.7427723658747091, 0.7424911197265256, 0.7595900945738621, 0.7438663900816193, 0.36895867388104364, 0.7769695517383708, 0.16727591977774714, 0.7806554525739265, 0.16816124554032907, 0.21266654038256527, 0.21076024673614502, 0.20927154541577986, 0.1919913551526261, 0.18196055486139262, 0.18828162496921863, 0.19117688650741127, 0.2086237486093646, 0.20289509385717563, 0.1820780686584651, 0.2227713547736907, 0.09615236985723363, 0.08912435237128358, 0.08286267063373487, 0.09538308484927838, 0.08132470278348758, 0.08144730791297883, 0.08624716595101778, 0.08598748896827235, 0.08565397759680249]}, "mutation_prompt": null}
{"id": "c760641a-42a8-4880-b237-c2ee09e57afe", "solution": "import numpy as np\n\nclass EnhancedHybridFTESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.5 - 0.2 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _tabu_search(self, func, x, score):\n        tabu_list = []\n        iteration_limit = min(10, self.budget // 100)\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.uniform(-0.1, 0.1, self.dim)  # Uniform perturbation\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score and neighbor.tolist() not in tabu_list:\n                x, score = neighbor, neighbor_score\n                tabu_list.append(neighbor.tolist())\n            if len(tabu_list) > 5:  # Limit tabu list size\n                tabu_list.pop(0)\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._tabu_search(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(10, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridFTESA", "description": "EnhancedHybridFTESA combines Tabu Search with Differential Evolution and Simulated Annealing for improved exploration and exploitation balance.", "configspace": "", "generation": 87, "fitness": 0.41634676204231796, "feedback": "The algorithm EnhancedHybridFTESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.28.", "error": "", "parent_id": "56099c28-aa9c-4c33-9b03-07b8c5ce0553", "metadata": {"aucs": [0.8881588567496903, 0.8804645191171939, 0.8832006779813523, 0.880489324221724, 0.9091349008875693, 0.8873667240814282, 0.8941018906157128, 0.8951439489418853, 0.8833675671250466, 0.7793442210462811, 0.7521580567747992, 0.7812251901383434, 0.7470396496209917, 0.7693919541717918, 0.7898142102907748, 0.7991421192001629, 0.7750137738087475, 0.7827509077963568, 0.13711278506372815, 0.17496675124345185, 0.2528452560445985, 0.3784216637686927, 0.16955567333695487, 0.34838294487332155, 0.23851733193816105, 0.2201157368319705, 0.1695908270867874, 0.11946442993686701, 0.1309644376546456, 0.18515532357445097, 0.13145618844494367, 0.15311142708578485, 0.14767805479973684, 0.1384171750510217, 0.1642178844908354, 0.1358924878864256, 0.9497751392895067, 0.9422176025672138, 0.9642301016482123, 0.9641155691632283, 0.9579857101041478, 0.9515012682399547, 0.9470910952349466, 0.9663990949953548, 0.9497869839833771, 0.5517550430935816, 0.4030297708787818, 0.6899020842090338, 0.6644043424912506, 0.6583914103285077, 0.642552854054245, 0.4763790592444549, 0.4885663657117264, 0.5441596966323297, 0.8851421367377128, 0.8375255269317223, 0.22763010111508997, 0.8714297919605809, 0.8230290265716692, 0.8230141550438175, 0.8823503176244772, 0.7924507610997955, 0.7585348663254745, 0.21632979988629253, 0.17915280136440526, 0.19744908071510248, 0.27261545472557547, 0.23474588339124558, 0.2701123906859475, 0.28285837585058604, 0.15657218037925413, 0.20706910386809185, 0.24406634372860758, 0.19187477762756922, 0.15062297083054133, 0.20711809634670886, 0.1848422702036462, 0.43587435414681464, 0.2014271053396226, 0.19369623964663307, 0.18680462898933725, 0.24878394211792165, 0.12556816583815567, 0.47518787319174516, 0.407086001226889, 0.22298524182785873, 0.14476132737657788, 0.41283048003682987, 0.3251943591580939, 0.16100212513767453, 0.2661921891987957, 0.27059609623098724, 0.5811099032521536, 0.36442943275162254, 0.29856669215774734, 0.3638285243024172, 0.38342194407118235, 0.45760318366668795, 0.5785784467958612, 0.13067273042245542, 0.20865067175643193, 0.10788493871388982, 0.34359711048897557, 0.10418401578679781, 0.08224769260645082, 0.1630221582711462, 0.15988528760810272, 0.0932121059366795, 0.36425077163562913, 0.34360607771542395, 0.4773645781214646, 0.3395928756651425, 0.37957542247825904, 0.38873617068029576, 0.22361323873492234, 0.17345458504240485, 0.32201694417751126, 0.8140230110092863, 0.7577721976733405, 0.6596946846537206, 0.6215866873951525, 0.6226444196765686, 0.6918350237605397, 0.7152784749043681, 0.7746077030799947, 0.6665593370422503, 0.1241826297017582, 0.135169504620408, 0.11904210410314986, 0.11124898516931647, 0.11726975291236319, 0.14883111446697572, 0.13916953432766477, 0.12072962942752896, 0.159201745334688, 0.19795061384616164, 0.26926967214416275, 0.36765135387868564, 0.5511703292767747, 0.21515558205911667, 0.17729841260802137, 0.29307834331989135, 0.5409267999762131, 0.3825746461917141, 0.5911235351293724, 0.5953218671375085, 0.5955045636771124, 0.524954847217627, 0.5818114599301134, 0.576013774399805, 0.5784897394437256, 0.461652513670736, 0.6525762524119003, 0.42969900886140855, 0.4147371745162638, 0.3974001485927664, 0.42122462224887847, 0.40162155461989746, 0.45707940835614436, 0.4104435803990759, 0.43015713577100867, 0.4783625617128471, 0.20354828844365558, 0.21206023778716454, 0.19538996935236796, 0.206550399018675, 0.19597247979349441, 0.2351175446410726, 0.19687470553767084, 0.21406903003908762, 0.19945973712531329, 0.484538962119203, 0.22473105741225508, 0.5609381816543497, 0.4673554742679712, 0.6055194610905866, 0.2394438406867191, 0.23481937490899485, 0.2106768551527135, 0.5635483512531356, 0.8114488978897988, 0.1620277131256962, 0.1631998747283787, 0.8966467328009798, 0.20200339522796573, 0.8934642556100985, 0.18916325356262764, 0.7941681290299544, 0.8290047480959357, 0.8245983859752802, 0.7421782258879527, 0.16958041039329597, 0.8224687379903372, 0.1689483538518094, 0.16920491868939103, 0.21191554310254634, 0.8589432189832281, 0.12686383042159266, 0.19761482294604082, 0.18422922982565326, 0.17968872615548404, 0.17777540812808657, 0.1763732333088437, 0.1739623252643685, 0.19192710708557947, 0.18177184664642498, 0.2025226765197633, 0.09952752841142087, 0.10248421318950718, 0.08773772211493391, 0.08145995742614032, 0.08872043713721178, 0.07832631779842614, 0.0856018940312735, 0.07422285977724974, 0.0953657701973738]}, "mutation_prompt": null}
{"id": "6119019d-7544-40a7-89c5-8370540b886a", "solution": "import numpy as np\n\nclass EnhancedHybridFTESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.5 - 0.2 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _tabu_search(self, func, x, score):\n        tabu_list = []\n        iteration_limit = min(10, self.budget // 100)\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.uniform(-0.1, 0.1, self.dim)  # Uniform perturbation\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score and neighbor.tolist() not in tabu_list:\n                x, score = neighbor, neighbor_score\n                tabu_list.append(neighbor.tolist())\n            if len(tabu_list) > 5:  # Limit tabu list size\n                tabu_list.pop(0)\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._tabu_search(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(10, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridFTESA", "description": "EnhancedHybridFTESA combines Tabu Search with Differential Evolution and Simulated Annealing for improved exploration and exploitation balance.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c760641a-42a8-4880-b237-c2ee09e57afe", "metadata": {"aucs": [0.8881588567496903, 0.8804645191171939, 0.8832006779813523, 0.880489324221724, 0.9091349008875693, 0.8873667240814282, 0.8941018906157128, 0.8951439489418853, 0.8833675671250466, 0.7793442210462811, 0.7521580567747992, 0.7812251901383434, 0.7470396496209917, 0.7693919541717918, 0.7898142102907748, 0.7991421192001629, 0.7750137738087475, 0.7827509077963568, 0.13711278506372815, 0.17496675124345185, 0.2528452560445985, 0.3784216637686927, 0.16955567333695487, 0.34838294487332155, 0.23851733193816105, 0.2201157368319705, 0.1695908270867874, 0.11946442993686701, 0.1309644376546456, 0.18515532357445097, 0.13145618844494367, 0.15311142708578485, 0.14767805479973684, 0.1384171750510217, 0.1642178844908354, 0.1358924878864256, 0.9497751392895067, 0.9422176025672138, 0.9642301016482123, 0.9641155691632283, 0.9579857101041478, 0.9515012682399547, 0.9470910952349466, 0.9663990949953548, 0.9497869839833771, 0.5517550430935816, 0.4030297708787818, 0.6899020842090338, 0.6644043424912506, 0.6583914103285077, 0.642552854054245, 0.4763790592444549, 0.4885663657117264, 0.5441596966323297, 0.8851421367377128, 0.8375255269317223, 0.22763010111508997, 0.8714297919605809, 0.8230290265716692, 0.8230141550438175, 0.8823503176244772, 0.7924507610997955, 0.7585348663254745, 0.21632979988629253, 0.17915280136440526, 0.19744908071510248, 0.27261545472557547, 0.23474588339124558, 0.2701123906859475, 0.28285837585058604, 0.15657218037925413, 0.20706910386809185, 0.24406634372860758, 0.19187477762756922, 0.15062297083054133, 0.20711809634670886, 0.1848422702036462, 0.43587435414681464, 0.2014271053396226, 0.19369623964663307, 0.18680462898933725, 0.24878394211792165, 0.12556816583815567, 0.47518787319174516, 0.407086001226889, 0.22298524182785873, 0.14476132737657788, 0.41283048003682987, 0.3251943591580939, 0.16100212513767453, 0.2661921891987957, 0.27059609623098724, 0.5811099032521536, 0.36442943275162254, 0.29856669215774734, 0.3638285243024172, 0.38342194407118235, 0.45760318366668795, 0.5785784467958612, 0.13067273042245542, 0.20865067175643193, 0.10788493871388982, 0.34359711048897557, 0.10418401578679781, 0.08224769260645082, 0.1630221582711462, 0.15988528760810272, 0.0932121059366795, 0.36425077163562913, 0.34360607771542395, 0.4773645781214646, 0.3395928756651425, 0.37957542247825904, 0.38873617068029576, 0.22361323873492234, 0.17345458504240485, 0.32201694417751126, 0.8140230110092863, 0.7577721976733405, 0.6596946846537206, 0.6215866873951525, 0.6226444196765686, 0.6918350237605397, 0.7152784749043681, 0.7746077030799947, 0.6665593370422503, 0.1241826297017582, 0.135169504620408, 0.11904210410314986, 0.11124898516931647, 0.11726975291236319, 0.14883111446697572, 0.13916953432766477, 0.12072962942752896, 0.159201745334688, 0.19795061384616164, 0.26926967214416275, 0.36765135387868564, 0.5511703292767747, 0.21515558205911667, 0.17729841260802137, 0.29307834331989135, 0.5409267999762131, 0.3825746461917141, 0.5911235351293724, 0.5953218671375085, 0.5955045636771124, 0.524954847217627, 0.5818114599301134, 0.576013774399805, 0.5784897394437256, 0.461652513670736, 0.6525762524119003, 0.42969900886140855, 0.4147371745162638, 0.3974001485927664, 0.42122462224887847, 0.40162155461989746, 0.45707940835614436, 0.4104435803990759, 0.43015713577100867, 0.4783625617128471, 0.20354828844365558, 0.21206023778716454, 0.19538996935236796, 0.206550399018675, 0.19597247979349441, 0.2351175446410726, 0.19687470553767084, 0.21406903003908762, 0.19945973712531329, 0.484538962119203, 0.22473105741225508, 0.5609381816543497, 0.4673554742679712, 0.6055194610905866, 0.2394438406867191, 0.23481937490899485, 0.2106768551527135, 0.5635483512531356, 0.8114488978897988, 0.1620277131256962, 0.1631998747283787, 0.8966467328009798, 0.20200339522796573, 0.8934642556100985, 0.18916325356262764, 0.7941681290299544, 0.8290047480959357, 0.8245983859752802, 0.7421782258879527, 0.16958041039329597, 0.8224687379903372, 0.1689483538518094, 0.16920491868939103, 0.21191554310254634, 0.8589432189832281, 0.12686383042159266, 0.19761482294604082, 0.18422922982565326, 0.17968872615548404, 0.17777540812808657, 0.1763732333088437, 0.1739623252643685, 0.19192710708557947, 0.18177184664642498, 0.2025226765197633, 0.09952752841142087, 0.10248421318950718, 0.08773772211493391, 0.08145995742614032, 0.08872043713721178, 0.07832631779842614, 0.0856018940312735, 0.07422285977724974, 0.0953657701973738]}, "mutation_prompt": null}
{"id": "f9609213-0a22-4399-8da8-30558905d351", "solution": "import numpy as np\n\nclass EnhancedHybridFTESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.5 - 0.2 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _tabu_search(self, func, x, score):\n        tabu_list = []\n        iteration_limit = min(10, self.budget // 100)\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.uniform(-0.1, 0.1, self.dim)  # Uniform perturbation\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score and neighbor.tolist() not in tabu_list:\n                x, score = neighbor, neighbor_score\n                tabu_list.append(neighbor.tolist())\n            if len(tabu_list) > 5:  # Limit tabu list size\n                tabu_list.pop(0)\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._tabu_search(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(10, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridFTESA", "description": "EnhancedHybridFTESA combines Tabu Search with Differential Evolution and Simulated Annealing for improved exploration and exploitation balance.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c760641a-42a8-4880-b237-c2ee09e57afe", "metadata": {"aucs": [0.8881588567496903, 0.8804645191171939, 0.8832006779813523, 0.880489324221724, 0.9091349008875693, 0.8873667240814282, 0.8941018906157128, 0.8951439489418853, 0.8833675671250466, 0.7793442210462811, 0.7521580567747992, 0.7812251901383434, 0.7470396496209917, 0.7693919541717918, 0.7898142102907748, 0.7991421192001629, 0.7750137738087475, 0.7827509077963568, 0.13711278506372815, 0.17496675124345185, 0.2528452560445985, 0.3784216637686927, 0.16955567333695487, 0.34838294487332155, 0.23851733193816105, 0.2201157368319705, 0.1695908270867874, 0.11946442993686701, 0.1309644376546456, 0.18515532357445097, 0.13145618844494367, 0.15311142708578485, 0.14767805479973684, 0.1384171750510217, 0.1642178844908354, 0.1358924878864256, 0.9497751392895067, 0.9422176025672138, 0.9642301016482123, 0.9641155691632283, 0.9579857101041478, 0.9515012682399547, 0.9470910952349466, 0.9663990949953548, 0.9497869839833771, 0.5517550430935816, 0.4030297708787818, 0.6899020842090338, 0.6644043424912506, 0.6583914103285077, 0.642552854054245, 0.4763790592444549, 0.4885663657117264, 0.5441596966323297, 0.8851421367377128, 0.8375255269317223, 0.22763010111508997, 0.8714297919605809, 0.8230290265716692, 0.8230141550438175, 0.8823503176244772, 0.7924507610997955, 0.7585348663254745, 0.21632979988629253, 0.17915280136440526, 0.19744908071510248, 0.27261545472557547, 0.23474588339124558, 0.2701123906859475, 0.28285837585058604, 0.15657218037925413, 0.20706910386809185, 0.24406634372860758, 0.19187477762756922, 0.15062297083054133, 0.20711809634670886, 0.1848422702036462, 0.43587435414681464, 0.2014271053396226, 0.19369623964663307, 0.18680462898933725, 0.24878394211792165, 0.12556816583815567, 0.47518787319174516, 0.407086001226889, 0.22298524182785873, 0.14476132737657788, 0.41283048003682987, 0.3251943591580939, 0.16100212513767453, 0.2661921891987957, 0.27059609623098724, 0.5811099032521536, 0.36442943275162254, 0.29856669215774734, 0.3638285243024172, 0.38342194407118235, 0.45760318366668795, 0.5785784467958612, 0.13067273042245542, 0.20865067175643193, 0.10788493871388982, 0.34359711048897557, 0.10418401578679781, 0.08224769260645082, 0.1630221582711462, 0.15988528760810272, 0.0932121059366795, 0.36425077163562913, 0.34360607771542395, 0.4773645781214646, 0.3395928756651425, 0.37957542247825904, 0.38873617068029576, 0.22361323873492234, 0.17345458504240485, 0.32201694417751126, 0.8140230110092863, 0.7577721976733405, 0.6596946846537206, 0.6215866873951525, 0.6226444196765686, 0.6918350237605397, 0.7152784749043681, 0.7746077030799947, 0.6665593370422503, 0.1241826297017582, 0.135169504620408, 0.11904210410314986, 0.11124898516931647, 0.11726975291236319, 0.14883111446697572, 0.13916953432766477, 0.12072962942752896, 0.159201745334688, 0.19795061384616164, 0.26926967214416275, 0.36765135387868564, 0.5511703292767747, 0.21515558205911667, 0.17729841260802137, 0.29307834331989135, 0.5409267999762131, 0.3825746461917141, 0.5911235351293724, 0.5953218671375085, 0.5955045636771124, 0.524954847217627, 0.5818114599301134, 0.576013774399805, 0.5784897394437256, 0.461652513670736, 0.6525762524119003, 0.42969900886140855, 0.4147371745162638, 0.3974001485927664, 0.42122462224887847, 0.40162155461989746, 0.45707940835614436, 0.4104435803990759, 0.43015713577100867, 0.4783625617128471, 0.20354828844365558, 0.21206023778716454, 0.19538996935236796, 0.206550399018675, 0.19597247979349441, 0.2351175446410726, 0.19687470553767084, 0.21406903003908762, 0.19945973712531329, 0.484538962119203, 0.22473105741225508, 0.5609381816543497, 0.4673554742679712, 0.6055194610905866, 0.2394438406867191, 0.23481937490899485, 0.2106768551527135, 0.5635483512531356, 0.8114488978897988, 0.1620277131256962, 0.1631998747283787, 0.8966467328009798, 0.20200339522796573, 0.8934642556100985, 0.18916325356262764, 0.7941681290299544, 0.8290047480959357, 0.8245983859752802, 0.7421782258879527, 0.16958041039329597, 0.8224687379903372, 0.1689483538518094, 0.16920491868939103, 0.21191554310254634, 0.8589432189832281, 0.12686383042159266, 0.19761482294604082, 0.18422922982565326, 0.17968872615548404, 0.17777540812808657, 0.1763732333088437, 0.1739623252643685, 0.19192710708557947, 0.18177184664642498, 0.2025226765197633, 0.09952752841142087, 0.10248421318950718, 0.08773772211493391, 0.08145995742614032, 0.08872043713721178, 0.07832631779842614, 0.0856018940312735, 0.07422285977724974, 0.0953657701973738]}, "mutation_prompt": null}
{"id": "65ef719a-dff7-4dbf-b3ec-0779096d6322", "solution": "import numpy as np\n\nclass EnhancedHybridFTESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.5 - 0.2 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _tabu_search(self, func, x, score):\n        tabu_list = []\n        iteration_limit = min(10, self.budget // 100)\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.uniform(-0.1, 0.1, self.dim)  # Uniform perturbation\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score and neighbor.tolist() not in tabu_list:\n                x, score = neighbor, neighbor_score\n                tabu_list.append(neighbor.tolist())\n            if len(tabu_list) > 5:  # Limit tabu list size\n                tabu_list.pop(0)\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._tabu_search(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(10, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridFTESA", "description": "EnhancedHybridFTESA combines Tabu Search with Differential Evolution and Simulated Annealing for improved exploration and exploitation balance.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c760641a-42a8-4880-b237-c2ee09e57afe", "metadata": {"aucs": [0.8881588567496903, 0.8804645191171939, 0.8832006779813523, 0.880489324221724, 0.9091349008875693, 0.8873667240814282, 0.8941018906157128, 0.8951439489418853, 0.8833675671250466, 0.7793442210462811, 0.7521580567747992, 0.7812251901383434, 0.7470396496209917, 0.7693919541717918, 0.7898142102907748, 0.7991421192001629, 0.7750137738087475, 0.7827509077963568, 0.13711278506372815, 0.17496675124345185, 0.2528452560445985, 0.3784216637686927, 0.16955567333695487, 0.34838294487332155, 0.23851733193816105, 0.2201157368319705, 0.1695908270867874, 0.11946442993686701, 0.1309644376546456, 0.18515532357445097, 0.13145618844494367, 0.15311142708578485, 0.14767805479973684, 0.1384171750510217, 0.1642178844908354, 0.1358924878864256, 0.9497751392895067, 0.9422176025672138, 0.9642301016482123, 0.9641155691632283, 0.9579857101041478, 0.9515012682399547, 0.9470910952349466, 0.9663990949953548, 0.9497869839833771, 0.5517550430935816, 0.4030297708787818, 0.6899020842090338, 0.6644043424912506, 0.6583914103285077, 0.642552854054245, 0.4763790592444549, 0.4885663657117264, 0.5441596966323297, 0.8851421367377128, 0.8375255269317223, 0.22763010111508997, 0.8714297919605809, 0.8230290265716692, 0.8230141550438175, 0.8823503176244772, 0.7924507610997955, 0.7585348663254745, 0.21632979988629253, 0.17915280136440526, 0.19744908071510248, 0.27261545472557547, 0.23474588339124558, 0.2701123906859475, 0.28285837585058604, 0.15657218037925413, 0.20706910386809185, 0.24406634372860758, 0.19187477762756922, 0.15062297083054133, 0.20711809634670886, 0.1848422702036462, 0.43587435414681464, 0.2014271053396226, 0.19369623964663307, 0.18680462898933725, 0.24878394211792165, 0.12556816583815567, 0.47518787319174516, 0.407086001226889, 0.22298524182785873, 0.14476132737657788, 0.41283048003682987, 0.3251943591580939, 0.16100212513767453, 0.2661921891987957, 0.27059609623098724, 0.5811099032521536, 0.36442943275162254, 0.29856669215774734, 0.3638285243024172, 0.38342194407118235, 0.45760318366668795, 0.5785784467958612, 0.13067273042245542, 0.20865067175643193, 0.10788493871388982, 0.34359711048897557, 0.10418401578679781, 0.08224769260645082, 0.1630221582711462, 0.15988528760810272, 0.0932121059366795, 0.36425077163562913, 0.34360607771542395, 0.4773645781214646, 0.3395928756651425, 0.37957542247825904, 0.38873617068029576, 0.22361323873492234, 0.17345458504240485, 0.32201694417751126, 0.8140230110092863, 0.7577721976733405, 0.6596946846537206, 0.6215866873951525, 0.6226444196765686, 0.6918350237605397, 0.7152784749043681, 0.7746077030799947, 0.6665593370422503, 0.1241826297017582, 0.135169504620408, 0.11904210410314986, 0.11124898516931647, 0.11726975291236319, 0.14883111446697572, 0.13916953432766477, 0.12072962942752896, 0.159201745334688, 0.19795061384616164, 0.26926967214416275, 0.36765135387868564, 0.5511703292767747, 0.21515558205911667, 0.17729841260802137, 0.29307834331989135, 0.5409267999762131, 0.3825746461917141, 0.5911235351293724, 0.5953218671375085, 0.5955045636771124, 0.524954847217627, 0.5818114599301134, 0.576013774399805, 0.5784897394437256, 0.461652513670736, 0.6525762524119003, 0.42969900886140855, 0.4147371745162638, 0.3974001485927664, 0.42122462224887847, 0.40162155461989746, 0.45707940835614436, 0.4104435803990759, 0.43015713577100867, 0.4783625617128471, 0.20354828844365558, 0.21206023778716454, 0.19538996935236796, 0.206550399018675, 0.19597247979349441, 0.2351175446410726, 0.19687470553767084, 0.21406903003908762, 0.19945973712531329, 0.484538962119203, 0.22473105741225508, 0.5609381816543497, 0.4673554742679712, 0.6055194610905866, 0.2394438406867191, 0.23481937490899485, 0.2106768551527135, 0.5635483512531356, 0.8114488978897988, 0.1620277131256962, 0.1631998747283787, 0.8966467328009798, 0.20200339522796573, 0.8934642556100985, 0.18916325356262764, 0.7941681290299544, 0.8290047480959357, 0.8245983859752802, 0.7421782258879527, 0.16958041039329597, 0.8224687379903372, 0.1689483538518094, 0.16920491868939103, 0.21191554310254634, 0.8589432189832281, 0.12686383042159266, 0.19761482294604082, 0.18422922982565326, 0.17968872615548404, 0.17777540812808657, 0.1763732333088437, 0.1739623252643685, 0.19192710708557947, 0.18177184664642498, 0.2025226765197633, 0.09952752841142087, 0.10248421318950718, 0.08773772211493391, 0.08145995742614032, 0.08872043713721178, 0.07832631779842614, 0.0856018940312735, 0.07422285977724974, 0.0953657701973738]}, "mutation_prompt": null}
{"id": "e5c920f0-1aa9-4fe6-85b6-24275b3bedf2", "solution": "import numpy as np\n\nclass EnhancedHybridFTESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.5 - 0.2 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _tabu_search(self, func, x, score):\n        tabu_list = []\n        iteration_limit = min(10, self.budget // 100)\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.uniform(-0.1, 0.1, self.dim)  # Uniform perturbation\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score and neighbor.tolist() not in tabu_list:\n                x, score = neighbor, neighbor_score\n                tabu_list.append(neighbor.tolist())\n            if len(tabu_list) > 5:  # Limit tabu list size\n                tabu_list.pop(0)\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._tabu_search(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(10, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridFTESA", "description": "EnhancedHybridFTESA combines Tabu Search with Differential Evolution and Simulated Annealing for improved exploration and exploitation balance.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c760641a-42a8-4880-b237-c2ee09e57afe", "metadata": {"aucs": [0.8881588567496903, 0.8804645191171939, 0.8832006779813523, 0.880489324221724, 0.9091349008875693, 0.8873667240814282, 0.8941018906157128, 0.8951439489418853, 0.8833675671250466, 0.7793442210462811, 0.7521580567747992, 0.7812251901383434, 0.7470396496209917, 0.7693919541717918, 0.7898142102907748, 0.7991421192001629, 0.7750137738087475, 0.7827509077963568, 0.13711278506372815, 0.17496675124345185, 0.2528452560445985, 0.3784216637686927, 0.16955567333695487, 0.34838294487332155, 0.23851733193816105, 0.2201157368319705, 0.1695908270867874, 0.11946442993686701, 0.1309644376546456, 0.18515532357445097, 0.13145618844494367, 0.15311142708578485, 0.14767805479973684, 0.1384171750510217, 0.1642178844908354, 0.1358924878864256, 0.9497751392895067, 0.9422176025672138, 0.9642301016482123, 0.9641155691632283, 0.9579857101041478, 0.9515012682399547, 0.9470910952349466, 0.9663990949953548, 0.9497869839833771, 0.5517550430935816, 0.4030297708787818, 0.6899020842090338, 0.6644043424912506, 0.6583914103285077, 0.642552854054245, 0.4763790592444549, 0.4885663657117264, 0.5441596966323297, 0.8851421367377128, 0.8375255269317223, 0.22763010111508997, 0.8714297919605809, 0.8230290265716692, 0.8230141550438175, 0.8823503176244772, 0.7924507610997955, 0.7585348663254745, 0.21632979988629253, 0.17915280136440526, 0.19744908071510248, 0.27261545472557547, 0.23474588339124558, 0.2701123906859475, 0.28285837585058604, 0.15657218037925413, 0.20706910386809185, 0.24406634372860758, 0.19187477762756922, 0.15062297083054133, 0.20711809634670886, 0.1848422702036462, 0.43587435414681464, 0.2014271053396226, 0.19369623964663307, 0.18680462898933725, 0.24878394211792165, 0.12556816583815567, 0.47518787319174516, 0.407086001226889, 0.22298524182785873, 0.14476132737657788, 0.41283048003682987, 0.3251943591580939, 0.16100212513767453, 0.2661921891987957, 0.27059609623098724, 0.5811099032521536, 0.36442943275162254, 0.29856669215774734, 0.3638285243024172, 0.38342194407118235, 0.45760318366668795, 0.5785784467958612, 0.13067273042245542, 0.20865067175643193, 0.10788493871388982, 0.34359711048897557, 0.10418401578679781, 0.08224769260645082, 0.1630221582711462, 0.15988528760810272, 0.0932121059366795, 0.36425077163562913, 0.34360607771542395, 0.4773645781214646, 0.3395928756651425, 0.37957542247825904, 0.38873617068029576, 0.22361323873492234, 0.17345458504240485, 0.32201694417751126, 0.8140230110092863, 0.7577721976733405, 0.6596946846537206, 0.6215866873951525, 0.6226444196765686, 0.6918350237605397, 0.7152784749043681, 0.7746077030799947, 0.6665593370422503, 0.1241826297017582, 0.135169504620408, 0.11904210410314986, 0.11124898516931647, 0.11726975291236319, 0.14883111446697572, 0.13916953432766477, 0.12072962942752896, 0.159201745334688, 0.19795061384616164, 0.26926967214416275, 0.36765135387868564, 0.5511703292767747, 0.21515558205911667, 0.17729841260802137, 0.29307834331989135, 0.5409267999762131, 0.3825746461917141, 0.5911235351293724, 0.5953218671375085, 0.5955045636771124, 0.524954847217627, 0.5818114599301134, 0.576013774399805, 0.5784897394437256, 0.461652513670736, 0.6525762524119003, 0.42969900886140855, 0.4147371745162638, 0.3974001485927664, 0.42122462224887847, 0.40162155461989746, 0.45707940835614436, 0.4104435803990759, 0.43015713577100867, 0.4783625617128471, 0.20354828844365558, 0.21206023778716454, 0.19538996935236796, 0.206550399018675, 0.19597247979349441, 0.2351175446410726, 0.19687470553767084, 0.21406903003908762, 0.19945973712531329, 0.484538962119203, 0.22473105741225508, 0.5609381816543497, 0.4673554742679712, 0.6055194610905866, 0.2394438406867191, 0.23481937490899485, 0.2106768551527135, 0.5635483512531356, 0.8114488978897988, 0.1620277131256962, 0.1631998747283787, 0.8966467328009798, 0.20200339522796573, 0.8934642556100985, 0.18916325356262764, 0.7941681290299544, 0.8290047480959357, 0.8245983859752802, 0.7421782258879527, 0.16958041039329597, 0.8224687379903372, 0.1689483538518094, 0.16920491868939103, 0.21191554310254634, 0.8589432189832281, 0.12686383042159266, 0.19761482294604082, 0.18422922982565326, 0.17968872615548404, 0.17777540812808657, 0.1763732333088437, 0.1739623252643685, 0.19192710708557947, 0.18177184664642498, 0.2025226765197633, 0.09952752841142087, 0.10248421318950718, 0.08773772211493391, 0.08145995742614032, 0.08872043713721178, 0.07832631779842614, 0.0856018940312735, 0.07422285977724974, 0.0953657701973738]}, "mutation_prompt": null}
{"id": "0a2f661f-4dd1-4e1e-b4f9-ee648f597ec8", "solution": "import numpy as np\n\nclass EnhancedHybridFTESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.5 - 0.2 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _tabu_search(self, func, x, score):\n        tabu_list = []\n        iteration_limit = min(10, self.budget // 100)\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.uniform(-0.1, 0.1, self.dim)  # Uniform perturbation\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score and neighbor.tolist() not in tabu_list:\n                x, score = neighbor, neighbor_score\n                tabu_list.append(neighbor.tolist())\n            if len(tabu_list) > 5:  # Limit tabu list size\n                tabu_list.pop(0)\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._tabu_search(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(10, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridFTESA", "description": "EnhancedHybridFTESA combines Tabu Search with Differential Evolution and Simulated Annealing for improved exploration and exploitation balance.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c760641a-42a8-4880-b237-c2ee09e57afe", "metadata": {"aucs": [0.8881588567496903, 0.8804645191171939, 0.8832006779813523, 0.880489324221724, 0.9091349008875693, 0.8873667240814282, 0.8941018906157128, 0.8951439489418853, 0.8833675671250466, 0.7793442210462811, 0.7521580567747992, 0.7812251901383434, 0.7470396496209917, 0.7693919541717918, 0.7898142102907748, 0.7991421192001629, 0.7750137738087475, 0.7827509077963568, 0.13711278506372815, 0.17496675124345185, 0.2528452560445985, 0.3784216637686927, 0.16955567333695487, 0.34838294487332155, 0.23851733193816105, 0.2201157368319705, 0.1695908270867874, 0.11946442993686701, 0.1309644376546456, 0.18515532357445097, 0.13145618844494367, 0.15311142708578485, 0.14767805479973684, 0.1384171750510217, 0.1642178844908354, 0.1358924878864256, 0.9497751392895067, 0.9422176025672138, 0.9642301016482123, 0.9641155691632283, 0.9579857101041478, 0.9515012682399547, 0.9470910952349466, 0.9663990949953548, 0.9497869839833771, 0.5517550430935816, 0.4030297708787818, 0.6899020842090338, 0.6644043424912506, 0.6583914103285077, 0.642552854054245, 0.4763790592444549, 0.4885663657117264, 0.5441596966323297, 0.8851421367377128, 0.8375255269317223, 0.22763010111508997, 0.8714297919605809, 0.8230290265716692, 0.8230141550438175, 0.8823503176244772, 0.7924507610997955, 0.7585348663254745, 0.21632979988629253, 0.17915280136440526, 0.19744908071510248, 0.27261545472557547, 0.23474588339124558, 0.2701123906859475, 0.28285837585058604, 0.15657218037925413, 0.20706910386809185, 0.24406634372860758, 0.19187477762756922, 0.15062297083054133, 0.20711809634670886, 0.1848422702036462, 0.43587435414681464, 0.2014271053396226, 0.19369623964663307, 0.18680462898933725, 0.24878394211792165, 0.12556816583815567, 0.47518787319174516, 0.407086001226889, 0.22298524182785873, 0.14476132737657788, 0.41283048003682987, 0.3251943591580939, 0.16100212513767453, 0.2661921891987957, 0.27059609623098724, 0.5811099032521536, 0.36442943275162254, 0.29856669215774734, 0.3638285243024172, 0.38342194407118235, 0.45760318366668795, 0.5785784467958612, 0.13067273042245542, 0.20865067175643193, 0.10788493871388982, 0.34359711048897557, 0.10418401578679781, 0.08224769260645082, 0.1630221582711462, 0.15988528760810272, 0.0932121059366795, 0.36425077163562913, 0.34360607771542395, 0.4773645781214646, 0.3395928756651425, 0.37957542247825904, 0.38873617068029576, 0.22361323873492234, 0.17345458504240485, 0.32201694417751126, 0.8140230110092863, 0.7577721976733405, 0.6596946846537206, 0.6215866873951525, 0.6226444196765686, 0.6918350237605397, 0.7152784749043681, 0.7746077030799947, 0.6665593370422503, 0.1241826297017582, 0.135169504620408, 0.11904210410314986, 0.11124898516931647, 0.11726975291236319, 0.14883111446697572, 0.13916953432766477, 0.12072962942752896, 0.159201745334688, 0.19795061384616164, 0.26926967214416275, 0.36765135387868564, 0.5511703292767747, 0.21515558205911667, 0.17729841260802137, 0.29307834331989135, 0.5409267999762131, 0.3825746461917141, 0.5911235351293724, 0.5953218671375085, 0.5955045636771124, 0.524954847217627, 0.5818114599301134, 0.576013774399805, 0.5784897394437256, 0.461652513670736, 0.6525762524119003, 0.42969900886140855, 0.4147371745162638, 0.3974001485927664, 0.42122462224887847, 0.40162155461989746, 0.45707940835614436, 0.4104435803990759, 0.43015713577100867, 0.4783625617128471, 0.20354828844365558, 0.21206023778716454, 0.19538996935236796, 0.206550399018675, 0.19597247979349441, 0.2351175446410726, 0.19687470553767084, 0.21406903003908762, 0.19945973712531329, 0.484538962119203, 0.22473105741225508, 0.5609381816543497, 0.4673554742679712, 0.6055194610905866, 0.2394438406867191, 0.23481937490899485, 0.2106768551527135, 0.5635483512531356, 0.8114488978897988, 0.1620277131256962, 0.1631998747283787, 0.8966467328009798, 0.20200339522796573, 0.8934642556100985, 0.18916325356262764, 0.7941681290299544, 0.8290047480959357, 0.8245983859752802, 0.7421782258879527, 0.16958041039329597, 0.8224687379903372, 0.1689483538518094, 0.16920491868939103, 0.21191554310254634, 0.8589432189832281, 0.12686383042159266, 0.19761482294604082, 0.18422922982565326, 0.17968872615548404, 0.17777540812808657, 0.1763732333088437, 0.1739623252643685, 0.19192710708557947, 0.18177184664642498, 0.2025226765197633, 0.09952752841142087, 0.10248421318950718, 0.08773772211493391, 0.08145995742614032, 0.08872043713721178, 0.07832631779842614, 0.0856018940312735, 0.07422285977724974, 0.0953657701973738]}, "mutation_prompt": null}
{"id": "1bdf24f6-61d3-48d9-9db7-ec6af8bbb13b", "solution": "import numpy as np\n\nclass EnhancedHybridFTESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.5 - 0.2 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _tabu_search(self, func, x, score):\n        tabu_list = []\n        iteration_limit = min(10, self.budget // 100)\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.uniform(-0.1, 0.1, self.dim)  # Uniform perturbation\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score and neighbor.tolist() not in tabu_list:\n                x, score = neighbor, neighbor_score\n                tabu_list.append(neighbor.tolist())\n            if len(tabu_list) > 5:  # Limit tabu list size\n                tabu_list.pop(0)\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._tabu_search(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(10, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridFTESA", "description": "EnhancedHybridFTESA combines Tabu Search with Differential Evolution and Simulated Annealing for improved exploration and exploitation balance.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c760641a-42a8-4880-b237-c2ee09e57afe", "metadata": {"aucs": [0.8881588567496903, 0.8804645191171939, 0.8832006779813523, 0.880489324221724, 0.9091349008875693, 0.8873667240814282, 0.8941018906157128, 0.8951439489418853, 0.8833675671250466, 0.7793442210462811, 0.7521580567747992, 0.7812251901383434, 0.7470396496209917, 0.7693919541717918, 0.7898142102907748, 0.7991421192001629, 0.7750137738087475, 0.7827509077963568, 0.13711278506372815, 0.17496675124345185, 0.2528452560445985, 0.3784216637686927, 0.16955567333695487, 0.34838294487332155, 0.23851733193816105, 0.2201157368319705, 0.1695908270867874, 0.11946442993686701, 0.1309644376546456, 0.18515532357445097, 0.13145618844494367, 0.15311142708578485, 0.14767805479973684, 0.1384171750510217, 0.1642178844908354, 0.1358924878864256, 0.9497751392895067, 0.9422176025672138, 0.9642301016482123, 0.9641155691632283, 0.9579857101041478, 0.9515012682399547, 0.9470910952349466, 0.9663990949953548, 0.9497869839833771, 0.5517550430935816, 0.4030297708787818, 0.6899020842090338, 0.6644043424912506, 0.6583914103285077, 0.642552854054245, 0.4763790592444549, 0.4885663657117264, 0.5441596966323297, 0.8851421367377128, 0.8375255269317223, 0.22763010111508997, 0.8714297919605809, 0.8230290265716692, 0.8230141550438175, 0.8823503176244772, 0.7924507610997955, 0.7585348663254745, 0.21632979988629253, 0.17915280136440526, 0.19744908071510248, 0.27261545472557547, 0.23474588339124558, 0.2701123906859475, 0.28285837585058604, 0.15657218037925413, 0.20706910386809185, 0.24406634372860758, 0.19187477762756922, 0.15062297083054133, 0.20711809634670886, 0.1848422702036462, 0.43587435414681464, 0.2014271053396226, 0.19369623964663307, 0.18680462898933725, 0.24878394211792165, 0.12556816583815567, 0.47518787319174516, 0.407086001226889, 0.22298524182785873, 0.14476132737657788, 0.41283048003682987, 0.3251943591580939, 0.16100212513767453, 0.2661921891987957, 0.27059609623098724, 0.5811099032521536, 0.36442943275162254, 0.29856669215774734, 0.3638285243024172, 0.38342194407118235, 0.45760318366668795, 0.5785784467958612, 0.13067273042245542, 0.20865067175643193, 0.10788493871388982, 0.34359711048897557, 0.10418401578679781, 0.08224769260645082, 0.1630221582711462, 0.15988528760810272, 0.0932121059366795, 0.36425077163562913, 0.34360607771542395, 0.4773645781214646, 0.3395928756651425, 0.37957542247825904, 0.38873617068029576, 0.22361323873492234, 0.17345458504240485, 0.32201694417751126, 0.8140230110092863, 0.7577721976733405, 0.6596946846537206, 0.6215866873951525, 0.6226444196765686, 0.6918350237605397, 0.7152784749043681, 0.7746077030799947, 0.6665593370422503, 0.1241826297017582, 0.135169504620408, 0.11904210410314986, 0.11124898516931647, 0.11726975291236319, 0.14883111446697572, 0.13916953432766477, 0.12072962942752896, 0.159201745334688, 0.19795061384616164, 0.26926967214416275, 0.36765135387868564, 0.5511703292767747, 0.21515558205911667, 0.17729841260802137, 0.29307834331989135, 0.5409267999762131, 0.3825746461917141, 0.5911235351293724, 0.5953218671375085, 0.5955045636771124, 0.524954847217627, 0.5818114599301134, 0.576013774399805, 0.5784897394437256, 0.461652513670736, 0.6525762524119003, 0.42969900886140855, 0.4147371745162638, 0.3974001485927664, 0.42122462224887847, 0.40162155461989746, 0.45707940835614436, 0.4104435803990759, 0.43015713577100867, 0.4783625617128471, 0.20354828844365558, 0.21206023778716454, 0.19538996935236796, 0.206550399018675, 0.19597247979349441, 0.2351175446410726, 0.19687470553767084, 0.21406903003908762, 0.19945973712531329, 0.484538962119203, 0.22473105741225508, 0.5609381816543497, 0.4673554742679712, 0.6055194610905866, 0.2394438406867191, 0.23481937490899485, 0.2106768551527135, 0.5635483512531356, 0.8114488978897988, 0.1620277131256962, 0.1631998747283787, 0.8966467328009798, 0.20200339522796573, 0.8934642556100985, 0.18916325356262764, 0.7941681290299544, 0.8290047480959357, 0.8245983859752802, 0.7421782258879527, 0.16958041039329597, 0.8224687379903372, 0.1689483538518094, 0.16920491868939103, 0.21191554310254634, 0.8589432189832281, 0.12686383042159266, 0.19761482294604082, 0.18422922982565326, 0.17968872615548404, 0.17777540812808657, 0.1763732333088437, 0.1739623252643685, 0.19192710708557947, 0.18177184664642498, 0.2025226765197633, 0.09952752841142087, 0.10248421318950718, 0.08773772211493391, 0.08145995742614032, 0.08872043713721178, 0.07832631779842614, 0.0856018940312735, 0.07422285977724974, 0.0953657701973738]}, "mutation_prompt": null}
{"id": "3885efbc-60ee-4cf0-a340-517e38b6231a", "solution": "import numpy as np\n\nclass EnhancedHybridFTESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.5 - 0.2 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _tabu_search(self, func, x, score):\n        tabu_list = []\n        iteration_limit = min(10, self.budget // 100)\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.uniform(-0.1, 0.1, self.dim)  # Uniform perturbation\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score and neighbor.tolist() not in tabu_list:\n                x, score = neighbor, neighbor_score\n                tabu_list.append(neighbor.tolist())\n            if len(tabu_list) > 5:  # Limit tabu list size\n                tabu_list.pop(0)\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._tabu_search(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(10, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridFTESA", "description": "EnhancedHybridFTESA combines Tabu Search with Differential Evolution and Simulated Annealing for improved exploration and exploitation balance.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c760641a-42a8-4880-b237-c2ee09e57afe", "metadata": {"aucs": [0.8881588567496903, 0.8804645191171939, 0.8832006779813523, 0.880489324221724, 0.9091349008875693, 0.8873667240814282, 0.8941018906157128, 0.8951439489418853, 0.8833675671250466, 0.7793442210462811, 0.7521580567747992, 0.7812251901383434, 0.7470396496209917, 0.7693919541717918, 0.7898142102907748, 0.7991421192001629, 0.7750137738087475, 0.7827509077963568, 0.13711278506372815, 0.17496675124345185, 0.2528452560445985, 0.3784216637686927, 0.16955567333695487, 0.34838294487332155, 0.23851733193816105, 0.2201157368319705, 0.1695908270867874, 0.11946442993686701, 0.1309644376546456, 0.18515532357445097, 0.13145618844494367, 0.15311142708578485, 0.14767805479973684, 0.1384171750510217, 0.1642178844908354, 0.1358924878864256, 0.9497751392895067, 0.9422176025672138, 0.9642301016482123, 0.9641155691632283, 0.9579857101041478, 0.9515012682399547, 0.9470910952349466, 0.9663990949953548, 0.9497869839833771, 0.5517550430935816, 0.4030297708787818, 0.6899020842090338, 0.6644043424912506, 0.6583914103285077, 0.642552854054245, 0.4763790592444549, 0.4885663657117264, 0.5441596966323297, 0.8851421367377128, 0.8375255269317223, 0.22763010111508997, 0.8714297919605809, 0.8230290265716692, 0.8230141550438175, 0.8823503176244772, 0.7924507610997955, 0.7585348663254745, 0.21632979988629253, 0.17915280136440526, 0.19744908071510248, 0.27261545472557547, 0.23474588339124558, 0.2701123906859475, 0.28285837585058604, 0.15657218037925413, 0.20706910386809185, 0.24406634372860758, 0.19187477762756922, 0.15062297083054133, 0.20711809634670886, 0.1848422702036462, 0.43587435414681464, 0.2014271053396226, 0.19369623964663307, 0.18680462898933725, 0.24878394211792165, 0.12556816583815567, 0.47518787319174516, 0.407086001226889, 0.22298524182785873, 0.14476132737657788, 0.41283048003682987, 0.3251943591580939, 0.16100212513767453, 0.2661921891987957, 0.27059609623098724, 0.5811099032521536, 0.36442943275162254, 0.29856669215774734, 0.3638285243024172, 0.38342194407118235, 0.45760318366668795, 0.5785784467958612, 0.13067273042245542, 0.20865067175643193, 0.10788493871388982, 0.34359711048897557, 0.10418401578679781, 0.08224769260645082, 0.1630221582711462, 0.15988528760810272, 0.0932121059366795, 0.36425077163562913, 0.34360607771542395, 0.4773645781214646, 0.3395928756651425, 0.37957542247825904, 0.38873617068029576, 0.22361323873492234, 0.17345458504240485, 0.32201694417751126, 0.8140230110092863, 0.7577721976733405, 0.6596946846537206, 0.6215866873951525, 0.6226444196765686, 0.6918350237605397, 0.7152784749043681, 0.7746077030799947, 0.6665593370422503, 0.1241826297017582, 0.135169504620408, 0.11904210410314986, 0.11124898516931647, 0.11726975291236319, 0.14883111446697572, 0.13916953432766477, 0.12072962942752896, 0.159201745334688, 0.19795061384616164, 0.26926967214416275, 0.36765135387868564, 0.5511703292767747, 0.21515558205911667, 0.17729841260802137, 0.29307834331989135, 0.5409267999762131, 0.3825746461917141, 0.5911235351293724, 0.5953218671375085, 0.5955045636771124, 0.524954847217627, 0.5818114599301134, 0.576013774399805, 0.5784897394437256, 0.461652513670736, 0.6525762524119003, 0.42969900886140855, 0.4147371745162638, 0.3974001485927664, 0.42122462224887847, 0.40162155461989746, 0.45707940835614436, 0.4104435803990759, 0.43015713577100867, 0.4783625617128471, 0.20354828844365558, 0.21206023778716454, 0.19538996935236796, 0.206550399018675, 0.19597247979349441, 0.2351175446410726, 0.19687470553767084, 0.21406903003908762, 0.19945973712531329, 0.484538962119203, 0.22473105741225508, 0.5609381816543497, 0.4673554742679712, 0.6055194610905866, 0.2394438406867191, 0.23481937490899485, 0.2106768551527135, 0.5635483512531356, 0.8114488978897988, 0.1620277131256962, 0.1631998747283787, 0.8966467328009798, 0.20200339522796573, 0.8934642556100985, 0.18916325356262764, 0.7941681290299544, 0.8290047480959357, 0.8245983859752802, 0.7421782258879527, 0.16958041039329597, 0.8224687379903372, 0.1689483538518094, 0.16920491868939103, 0.21191554310254634, 0.8589432189832281, 0.12686383042159266, 0.19761482294604082, 0.18422922982565326, 0.17968872615548404, 0.17777540812808657, 0.1763732333088437, 0.1739623252643685, 0.19192710708557947, 0.18177184664642498, 0.2025226765197633, 0.09952752841142087, 0.10248421318950718, 0.08773772211493391, 0.08145995742614032, 0.08872043713721178, 0.07832631779842614, 0.0856018940312735, 0.07422285977724974, 0.0953657701973738]}, "mutation_prompt": null}
{"id": "1bd84d64-6963-4263-8031-6d4f224434e5", "solution": "import numpy as np\n\nclass EnhancedHybridFTESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.5 - 0.2 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _tabu_search(self, func, x, score):\n        tabu_list = []\n        iteration_limit = min(10, self.budget // 100)\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.uniform(-0.1, 0.1, self.dim)  # Uniform perturbation\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score and neighbor.tolist() not in tabu_list:\n                x, score = neighbor, neighbor_score\n                tabu_list.append(neighbor.tolist())\n            if len(tabu_list) > 5:  # Limit tabu list size\n                tabu_list.pop(0)\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._tabu_search(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(10, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridFTESA", "description": "EnhancedHybridFTESA combines Tabu Search with Differential Evolution and Simulated Annealing for improved exploration and exploitation balance.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c760641a-42a8-4880-b237-c2ee09e57afe", "metadata": {"aucs": [0.8881588567496903, 0.8804645191171939, 0.8832006779813523, 0.880489324221724, 0.9091349008875693, 0.8873667240814282, 0.8941018906157128, 0.8951439489418853, 0.8833675671250466, 0.7793442210462811, 0.7521580567747992, 0.7812251901383434, 0.7470396496209917, 0.7693919541717918, 0.7898142102907748, 0.7991421192001629, 0.7750137738087475, 0.7827509077963568, 0.13711278506372815, 0.17496675124345185, 0.2528452560445985, 0.3784216637686927, 0.16955567333695487, 0.34838294487332155, 0.23851733193816105, 0.2201157368319705, 0.1695908270867874, 0.11946442993686701, 0.1309644376546456, 0.18515532357445097, 0.13145618844494367, 0.15311142708578485, 0.14767805479973684, 0.1384171750510217, 0.1642178844908354, 0.1358924878864256, 0.9497751392895067, 0.9422176025672138, 0.9642301016482123, 0.9641155691632283, 0.9579857101041478, 0.9515012682399547, 0.9470910952349466, 0.9663990949953548, 0.9497869839833771, 0.5517550430935816, 0.4030297708787818, 0.6899020842090338, 0.6644043424912506, 0.6583914103285077, 0.642552854054245, 0.4763790592444549, 0.4885663657117264, 0.5441596966323297, 0.8851421367377128, 0.8375255269317223, 0.22763010111508997, 0.8714297919605809, 0.8230290265716692, 0.8230141550438175, 0.8823503176244772, 0.7924507610997955, 0.7585348663254745, 0.21632979988629253, 0.17915280136440526, 0.19744908071510248, 0.27261545472557547, 0.23474588339124558, 0.2701123906859475, 0.28285837585058604, 0.15657218037925413, 0.20706910386809185, 0.24406634372860758, 0.19187477762756922, 0.15062297083054133, 0.20711809634670886, 0.1848422702036462, 0.43587435414681464, 0.2014271053396226, 0.19369623964663307, 0.18680462898933725, 0.24878394211792165, 0.12556816583815567, 0.47518787319174516, 0.407086001226889, 0.22298524182785873, 0.14476132737657788, 0.41283048003682987, 0.3251943591580939, 0.16100212513767453, 0.2661921891987957, 0.27059609623098724, 0.5811099032521536, 0.36442943275162254, 0.29856669215774734, 0.3638285243024172, 0.38342194407118235, 0.45760318366668795, 0.5785784467958612, 0.13067273042245542, 0.20865067175643193, 0.10788493871388982, 0.34359711048897557, 0.10418401578679781, 0.08224769260645082, 0.1630221582711462, 0.15988528760810272, 0.0932121059366795, 0.36425077163562913, 0.34360607771542395, 0.4773645781214646, 0.3395928756651425, 0.37957542247825904, 0.38873617068029576, 0.22361323873492234, 0.17345458504240485, 0.32201694417751126, 0.8140230110092863, 0.7577721976733405, 0.6596946846537206, 0.6215866873951525, 0.6226444196765686, 0.6918350237605397, 0.7152784749043681, 0.7746077030799947, 0.6665593370422503, 0.1241826297017582, 0.135169504620408, 0.11904210410314986, 0.11124898516931647, 0.11726975291236319, 0.14883111446697572, 0.13916953432766477, 0.12072962942752896, 0.159201745334688, 0.19795061384616164, 0.26926967214416275, 0.36765135387868564, 0.5511703292767747, 0.21515558205911667, 0.17729841260802137, 0.29307834331989135, 0.5409267999762131, 0.3825746461917141, 0.5911235351293724, 0.5953218671375085, 0.5955045636771124, 0.524954847217627, 0.5818114599301134, 0.576013774399805, 0.5784897394437256, 0.461652513670736, 0.6525762524119003, 0.42969900886140855, 0.4147371745162638, 0.3974001485927664, 0.42122462224887847, 0.40162155461989746, 0.45707940835614436, 0.4104435803990759, 0.43015713577100867, 0.4783625617128471, 0.20354828844365558, 0.21206023778716454, 0.19538996935236796, 0.206550399018675, 0.19597247979349441, 0.2351175446410726, 0.19687470553767084, 0.21406903003908762, 0.19945973712531329, 0.484538962119203, 0.22473105741225508, 0.5609381816543497, 0.4673554742679712, 0.6055194610905866, 0.2394438406867191, 0.23481937490899485, 0.2106768551527135, 0.5635483512531356, 0.8114488978897988, 0.1620277131256962, 0.1631998747283787, 0.8966467328009798, 0.20200339522796573, 0.8934642556100985, 0.18916325356262764, 0.7941681290299544, 0.8290047480959357, 0.8245983859752802, 0.7421782258879527, 0.16958041039329597, 0.8224687379903372, 0.1689483538518094, 0.16920491868939103, 0.21191554310254634, 0.8589432189832281, 0.12686383042159266, 0.19761482294604082, 0.18422922982565326, 0.17968872615548404, 0.17777540812808657, 0.1763732333088437, 0.1739623252643685, 0.19192710708557947, 0.18177184664642498, 0.2025226765197633, 0.09952752841142087, 0.10248421318950718, 0.08773772211493391, 0.08145995742614032, 0.08872043713721178, 0.07832631779842614, 0.0856018940312735, 0.07422285977724974, 0.0953657701973738]}, "mutation_prompt": null}
{"id": "71c92f77-1600-4dd7-96e5-e3e147a17b3f", "solution": "import numpy as np\n\nclass EnhancedHybridFTESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.5 - 0.2 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _tabu_search(self, func, x, score):\n        tabu_list = []\n        iteration_limit = min(10, self.budget // 100)\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.uniform(-0.1, 0.1, self.dim)  # Uniform perturbation\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score and neighbor.tolist() not in tabu_list:\n                x, score = neighbor, neighbor_score\n                tabu_list.append(neighbor.tolist())\n            if len(tabu_list) > 5:  # Limit tabu list size\n                tabu_list.pop(0)\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._tabu_search(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(10, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridFTESA", "description": "EnhancedHybridFTESA combines Tabu Search with Differential Evolution and Simulated Annealing for improved exploration and exploitation balance.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c760641a-42a8-4880-b237-c2ee09e57afe", "metadata": {"aucs": [0.8881588567496903, 0.8804645191171939, 0.8832006779813523, 0.880489324221724, 0.9091349008875693, 0.8873667240814282, 0.8941018906157128, 0.8951439489418853, 0.8833675671250466, 0.7793442210462811, 0.7521580567747992, 0.7812251901383434, 0.7470396496209917, 0.7693919541717918, 0.7898142102907748, 0.7991421192001629, 0.7750137738087475, 0.7827509077963568, 0.13711278506372815, 0.17496675124345185, 0.2528452560445985, 0.3784216637686927, 0.16955567333695487, 0.34838294487332155, 0.23851733193816105, 0.2201157368319705, 0.1695908270867874, 0.11946442993686701, 0.1309644376546456, 0.18515532357445097, 0.13145618844494367, 0.15311142708578485, 0.14767805479973684, 0.1384171750510217, 0.1642178844908354, 0.1358924878864256, 0.9497751392895067, 0.9422176025672138, 0.9642301016482123, 0.9641155691632283, 0.9579857101041478, 0.9515012682399547, 0.9470910952349466, 0.9663990949953548, 0.9497869839833771, 0.5517550430935816, 0.4030297708787818, 0.6899020842090338, 0.6644043424912506, 0.6583914103285077, 0.642552854054245, 0.4763790592444549, 0.4885663657117264, 0.5441596966323297, 0.8851421367377128, 0.8375255269317223, 0.22763010111508997, 0.8714297919605809, 0.8230290265716692, 0.8230141550438175, 0.8823503176244772, 0.7924507610997955, 0.7585348663254745, 0.21632979988629253, 0.17915280136440526, 0.19744908071510248, 0.27261545472557547, 0.23474588339124558, 0.2701123906859475, 0.28285837585058604, 0.15657218037925413, 0.20706910386809185, 0.24406634372860758, 0.19187477762756922, 0.15062297083054133, 0.20711809634670886, 0.1848422702036462, 0.43587435414681464, 0.2014271053396226, 0.19369623964663307, 0.18680462898933725, 0.24878394211792165, 0.12556816583815567, 0.47518787319174516, 0.407086001226889, 0.22298524182785873, 0.14476132737657788, 0.41283048003682987, 0.3251943591580939, 0.16100212513767453, 0.2661921891987957, 0.27059609623098724, 0.5811099032521536, 0.36442943275162254, 0.29856669215774734, 0.3638285243024172, 0.38342194407118235, 0.45760318366668795, 0.5785784467958612, 0.13067273042245542, 0.20865067175643193, 0.10788493871388982, 0.34359711048897557, 0.10418401578679781, 0.08224769260645082, 0.1630221582711462, 0.15988528760810272, 0.0932121059366795, 0.36425077163562913, 0.34360607771542395, 0.4773645781214646, 0.3395928756651425, 0.37957542247825904, 0.38873617068029576, 0.22361323873492234, 0.17345458504240485, 0.32201694417751126, 0.8140230110092863, 0.7577721976733405, 0.6596946846537206, 0.6215866873951525, 0.6226444196765686, 0.6918350237605397, 0.7152784749043681, 0.7746077030799947, 0.6665593370422503, 0.1241826297017582, 0.135169504620408, 0.11904210410314986, 0.11124898516931647, 0.11726975291236319, 0.14883111446697572, 0.13916953432766477, 0.12072962942752896, 0.159201745334688, 0.19795061384616164, 0.26926967214416275, 0.36765135387868564, 0.5511703292767747, 0.21515558205911667, 0.17729841260802137, 0.29307834331989135, 0.5409267999762131, 0.3825746461917141, 0.5911235351293724, 0.5953218671375085, 0.5955045636771124, 0.524954847217627, 0.5818114599301134, 0.576013774399805, 0.5784897394437256, 0.461652513670736, 0.6525762524119003, 0.42969900886140855, 0.4147371745162638, 0.3974001485927664, 0.42122462224887847, 0.40162155461989746, 0.45707940835614436, 0.4104435803990759, 0.43015713577100867, 0.4783625617128471, 0.20354828844365558, 0.21206023778716454, 0.19538996935236796, 0.206550399018675, 0.19597247979349441, 0.2351175446410726, 0.19687470553767084, 0.21406903003908762, 0.19945973712531329, 0.484538962119203, 0.22473105741225508, 0.5609381816543497, 0.4673554742679712, 0.6055194610905866, 0.2394438406867191, 0.23481937490899485, 0.2106768551527135, 0.5635483512531356, 0.8114488978897988, 0.1620277131256962, 0.1631998747283787, 0.8966467328009798, 0.20200339522796573, 0.8934642556100985, 0.18916325356262764, 0.7941681290299544, 0.8290047480959357, 0.8245983859752802, 0.7421782258879527, 0.16958041039329597, 0.8224687379903372, 0.1689483538518094, 0.16920491868939103, 0.21191554310254634, 0.8589432189832281, 0.12686383042159266, 0.19761482294604082, 0.18422922982565326, 0.17968872615548404, 0.17777540812808657, 0.1763732333088437, 0.1739623252643685, 0.19192710708557947, 0.18177184664642498, 0.2025226765197633, 0.09952752841142087, 0.10248421318950718, 0.08773772211493391, 0.08145995742614032, 0.08872043713721178, 0.07832631779842614, 0.0856018940312735, 0.07422285977724974, 0.0953657701973738]}, "mutation_prompt": null}
{"id": "19b86dcd-54d7-47ce-aefa-f26d891f7001", "solution": "import numpy as np\n\nclass EnhancedHybridFTESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.5 - 0.2 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _tabu_search(self, func, x, score):\n        tabu_list = []\n        iteration_limit = min(10, self.budget // 100)\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.uniform(-0.1, 0.1, self.dim)  # Uniform perturbation\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score and neighbor.tolist() not in tabu_list:\n                x, score = neighbor, neighbor_score\n                tabu_list.append(neighbor.tolist())\n            if len(tabu_list) > 5:  # Limit tabu list size\n                tabu_list.pop(0)\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._tabu_search(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(10, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridFTESA", "description": "EnhancedHybridFTESA combines Tabu Search with Differential Evolution and Simulated Annealing for improved exploration and exploitation balance.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c760641a-42a8-4880-b237-c2ee09e57afe", "metadata": {"aucs": [0.8881588567496903, 0.8804645191171939, 0.8832006779813523, 0.880489324221724, 0.9091349008875693, 0.8873667240814282, 0.8941018906157128, 0.8951439489418853, 0.8833675671250466, 0.7793442210462811, 0.7521580567747992, 0.7812251901383434, 0.7470396496209917, 0.7693919541717918, 0.7898142102907748, 0.7991421192001629, 0.7750137738087475, 0.7827509077963568, 0.13711278506372815, 0.17496675124345185, 0.2528452560445985, 0.3784216637686927, 0.16955567333695487, 0.34838294487332155, 0.23851733193816105, 0.2201157368319705, 0.1695908270867874, 0.11946442993686701, 0.1309644376546456, 0.18515532357445097, 0.13145618844494367, 0.15311142708578485, 0.14767805479973684, 0.1384171750510217, 0.1642178844908354, 0.1358924878864256, 0.9497751392895067, 0.9422176025672138, 0.9642301016482123, 0.9641155691632283, 0.9579857101041478, 0.9515012682399547, 0.9470910952349466, 0.9663990949953548, 0.9497869839833771, 0.5517550430935816, 0.4030297708787818, 0.6899020842090338, 0.6644043424912506, 0.6583914103285077, 0.642552854054245, 0.4763790592444549, 0.4885663657117264, 0.5441596966323297, 0.8851421367377128, 0.8375255269317223, 0.22763010111508997, 0.8714297919605809, 0.8230290265716692, 0.8230141550438175, 0.8823503176244772, 0.7924507610997955, 0.7585348663254745, 0.21632979988629253, 0.17915280136440526, 0.19744908071510248, 0.27261545472557547, 0.23474588339124558, 0.2701123906859475, 0.28285837585058604, 0.15657218037925413, 0.20706910386809185, 0.24406634372860758, 0.19187477762756922, 0.15062297083054133, 0.20711809634670886, 0.1848422702036462, 0.43587435414681464, 0.2014271053396226, 0.19369623964663307, 0.18680462898933725, 0.24878394211792165, 0.12556816583815567, 0.47518787319174516, 0.407086001226889, 0.22298524182785873, 0.14476132737657788, 0.41283048003682987, 0.3251943591580939, 0.16100212513767453, 0.2661921891987957, 0.27059609623098724, 0.5811099032521536, 0.36442943275162254, 0.29856669215774734, 0.3638285243024172, 0.38342194407118235, 0.45760318366668795, 0.5785784467958612, 0.13067273042245542, 0.20865067175643193, 0.10788493871388982, 0.34359711048897557, 0.10418401578679781, 0.08224769260645082, 0.1630221582711462, 0.15988528760810272, 0.0932121059366795, 0.36425077163562913, 0.34360607771542395, 0.4773645781214646, 0.3395928756651425, 0.37957542247825904, 0.38873617068029576, 0.22361323873492234, 0.17345458504240485, 0.32201694417751126, 0.8140230110092863, 0.7577721976733405, 0.6596946846537206, 0.6215866873951525, 0.6226444196765686, 0.6918350237605397, 0.7152784749043681, 0.7746077030799947, 0.6665593370422503, 0.1241826297017582, 0.135169504620408, 0.11904210410314986, 0.11124898516931647, 0.11726975291236319, 0.14883111446697572, 0.13916953432766477, 0.12072962942752896, 0.159201745334688, 0.19795061384616164, 0.26926967214416275, 0.36765135387868564, 0.5511703292767747, 0.21515558205911667, 0.17729841260802137, 0.29307834331989135, 0.5409267999762131, 0.3825746461917141, 0.5911235351293724, 0.5953218671375085, 0.5955045636771124, 0.524954847217627, 0.5818114599301134, 0.576013774399805, 0.5784897394437256, 0.461652513670736, 0.6525762524119003, 0.42969900886140855, 0.4147371745162638, 0.3974001485927664, 0.42122462224887847, 0.40162155461989746, 0.45707940835614436, 0.4104435803990759, 0.43015713577100867, 0.4783625617128471, 0.20354828844365558, 0.21206023778716454, 0.19538996935236796, 0.206550399018675, 0.19597247979349441, 0.2351175446410726, 0.19687470553767084, 0.21406903003908762, 0.19945973712531329, 0.484538962119203, 0.22473105741225508, 0.5609381816543497, 0.4673554742679712, 0.6055194610905866, 0.2394438406867191, 0.23481937490899485, 0.2106768551527135, 0.5635483512531356, 0.8114488978897988, 0.1620277131256962, 0.1631998747283787, 0.8966467328009798, 0.20200339522796573, 0.8934642556100985, 0.18916325356262764, 0.7941681290299544, 0.8290047480959357, 0.8245983859752802, 0.7421782258879527, 0.16958041039329597, 0.8224687379903372, 0.1689483538518094, 0.16920491868939103, 0.21191554310254634, 0.8589432189832281, 0.12686383042159266, 0.19761482294604082, 0.18422922982565326, 0.17968872615548404, 0.17777540812808657, 0.1763732333088437, 0.1739623252643685, 0.19192710708557947, 0.18177184664642498, 0.2025226765197633, 0.09952752841142087, 0.10248421318950718, 0.08773772211493391, 0.08145995742614032, 0.08872043713721178, 0.07832631779842614, 0.0856018940312735, 0.07422285977724974, 0.0953657701973738]}, "mutation_prompt": null}
{"id": "dfd7c321-4402-46fe-8d26-aa199ca5911c", "solution": "import numpy as np\n\nclass EnhancedHybridFTESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.5 - 0.2 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _tabu_search(self, func, x, score):\n        tabu_list = []\n        iteration_limit = min(10, self.budget // 100)\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.uniform(-0.1, 0.1, self.dim)  # Uniform perturbation\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score and neighbor.tolist() not in tabu_list:\n                x, score = neighbor, neighbor_score\n                tabu_list.append(neighbor.tolist())\n            if len(tabu_list) > 5:  # Limit tabu list size\n                tabu_list.pop(0)\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._tabu_search(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(10, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridFTESA", "description": "EnhancedHybridFTESA combines Tabu Search with Differential Evolution and Simulated Annealing for improved exploration and exploitation balance.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c760641a-42a8-4880-b237-c2ee09e57afe", "metadata": {"aucs": [0.8881588567496903, 0.8804645191171939, 0.8832006779813523, 0.880489324221724, 0.9091349008875693, 0.8873667240814282, 0.8941018906157128, 0.8951439489418853, 0.8833675671250466, 0.7793442210462811, 0.7521580567747992, 0.7812251901383434, 0.7470396496209917, 0.7693919541717918, 0.7898142102907748, 0.7991421192001629, 0.7750137738087475, 0.7827509077963568, 0.13711278506372815, 0.17496675124345185, 0.2528452560445985, 0.3784216637686927, 0.16955567333695487, 0.34838294487332155, 0.23851733193816105, 0.2201157368319705, 0.1695908270867874, 0.11946442993686701, 0.1309644376546456, 0.18515532357445097, 0.13145618844494367, 0.15311142708578485, 0.14767805479973684, 0.1384171750510217, 0.1642178844908354, 0.1358924878864256, 0.9497751392895067, 0.9422176025672138, 0.9642301016482123, 0.9641155691632283, 0.9579857101041478, 0.9515012682399547, 0.9470910952349466, 0.9663990949953548, 0.9497869839833771, 0.5517550430935816, 0.4030297708787818, 0.6899020842090338, 0.6644043424912506, 0.6583914103285077, 0.642552854054245, 0.4763790592444549, 0.4885663657117264, 0.5441596966323297, 0.8851421367377128, 0.8375255269317223, 0.22763010111508997, 0.8714297919605809, 0.8230290265716692, 0.8230141550438175, 0.8823503176244772, 0.7924507610997955, 0.7585348663254745, 0.21632979988629253, 0.17915280136440526, 0.19744908071510248, 0.27261545472557547, 0.23474588339124558, 0.2701123906859475, 0.28285837585058604, 0.15657218037925413, 0.20706910386809185, 0.24406634372860758, 0.19187477762756922, 0.15062297083054133, 0.20711809634670886, 0.1848422702036462, 0.43587435414681464, 0.2014271053396226, 0.19369623964663307, 0.18680462898933725, 0.24878394211792165, 0.12556816583815567, 0.47518787319174516, 0.407086001226889, 0.22298524182785873, 0.14476132737657788, 0.41283048003682987, 0.3251943591580939, 0.16100212513767453, 0.2661921891987957, 0.27059609623098724, 0.5811099032521536, 0.36442943275162254, 0.29856669215774734, 0.3638285243024172, 0.38342194407118235, 0.45760318366668795, 0.5785784467958612, 0.13067273042245542, 0.20865067175643193, 0.10788493871388982, 0.34359711048897557, 0.10418401578679781, 0.08224769260645082, 0.1630221582711462, 0.15988528760810272, 0.0932121059366795, 0.36425077163562913, 0.34360607771542395, 0.4773645781214646, 0.3395928756651425, 0.37957542247825904, 0.38873617068029576, 0.22361323873492234, 0.17345458504240485, 0.32201694417751126, 0.8140230110092863, 0.7577721976733405, 0.6596946846537206, 0.6215866873951525, 0.6226444196765686, 0.6918350237605397, 0.7152784749043681, 0.7746077030799947, 0.6665593370422503, 0.1241826297017582, 0.135169504620408, 0.11904210410314986, 0.11124898516931647, 0.11726975291236319, 0.14883111446697572, 0.13916953432766477, 0.12072962942752896, 0.159201745334688, 0.19795061384616164, 0.26926967214416275, 0.36765135387868564, 0.5511703292767747, 0.21515558205911667, 0.17729841260802137, 0.29307834331989135, 0.5409267999762131, 0.3825746461917141, 0.5911235351293724, 0.5953218671375085, 0.5955045636771124, 0.524954847217627, 0.5818114599301134, 0.576013774399805, 0.5784897394437256, 0.461652513670736, 0.6525762524119003, 0.42969900886140855, 0.4147371745162638, 0.3974001485927664, 0.42122462224887847, 0.40162155461989746, 0.45707940835614436, 0.4104435803990759, 0.43015713577100867, 0.4783625617128471, 0.20354828844365558, 0.21206023778716454, 0.19538996935236796, 0.206550399018675, 0.19597247979349441, 0.2351175446410726, 0.19687470553767084, 0.21406903003908762, 0.19945973712531329, 0.484538962119203, 0.22473105741225508, 0.5609381816543497, 0.4673554742679712, 0.6055194610905866, 0.2394438406867191, 0.23481937490899485, 0.2106768551527135, 0.5635483512531356, 0.8114488978897988, 0.1620277131256962, 0.1631998747283787, 0.8966467328009798, 0.20200339522796573, 0.8934642556100985, 0.18916325356262764, 0.7941681290299544, 0.8290047480959357, 0.8245983859752802, 0.7421782258879527, 0.16958041039329597, 0.8224687379903372, 0.1689483538518094, 0.16920491868939103, 0.21191554310254634, 0.8589432189832281, 0.12686383042159266, 0.19761482294604082, 0.18422922982565326, 0.17968872615548404, 0.17777540812808657, 0.1763732333088437, 0.1739623252643685, 0.19192710708557947, 0.18177184664642498, 0.2025226765197633, 0.09952752841142087, 0.10248421318950718, 0.08773772211493391, 0.08145995742614032, 0.08872043713721178, 0.07832631779842614, 0.0856018940312735, 0.07422285977724974, 0.0953657701973738]}, "mutation_prompt": null}
{"id": "61f2ec33-a92d-42d7-ad02-87e133617ca5", "solution": "import numpy as np\n\nclass EnhancedHybridFTESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def _clip(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n    \n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n    \n    def _adaptive_parameters(self, eval_count):\n        F = 0.5 - 0.2 * (eval_count / self.budget)  # Adjusted mutation factor\n        Cr = 0.8 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sine crossover probability\n        return F, Cr\n    \n    def _differential_evolution(self, func, population, scores, eval_count):\n        pop_size = len(population)\n        F, Cr = self._adaptive_parameters(eval_count)\n        for i in range(pop_size):\n            indices = list(range(pop_size))\n            indices.remove(i)\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = a + F * (b - c)\n            mutant = self._clip(mutant)\n            \n            crossover_mask = np.random.rand(self.dim) < Cr\n            trial = np.where(crossover_mask, mutant, population[i])\n            trial_score = func(trial)\n            \n            if trial_score < scores[i]:\n                population[i], scores[i] = trial, trial_score\n        return population, scores\n    \n    def _tabu_search(self, func, x, score):\n        tabu_list = []\n        iteration_limit = min(10, self.budget // 100)\n        for _ in range(iteration_limit):\n            neighbor = x + np.random.uniform(-0.1, 0.1, self.dim)  # Uniform perturbation\n            neighbor = self._clip(neighbor)\n            neighbor_score = func(neighbor)\n            \n            if neighbor_score < score and neighbor.tolist() not in tabu_list:\n                x, score = neighbor, neighbor_score\n                tabu_list.append(neighbor.tolist())\n            if len(tabu_list) > 5:  # Limit tabu list size\n                tabu_list.pop(0)\n        return x, score\n    \n    def __call__(self, func):\n        pop_size = min(25, self.budget // 4)  # Adjusted population size\n        population = self._initialize_population(pop_size)\n        scores = np.array([func(ind) for ind in population])\n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            population, scores = self._differential_evolution(func, population, scores, eval_count)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            best_individual, best_score = self._tabu_search(func, best_individual, best_score)\n            \n            population[best_idx], scores[best_idx] = best_individual, best_score\n            eval_count += min(10, self.budget - eval_count)  # Ensure budget compliance\n            \n        best_idx = np.argmin(scores)\n        return population[best_idx], scores[best_idx]", "name": "EnhancedHybridFTESA", "description": "EnhancedHybridFTESA combines Tabu Search with Differential Evolution and Simulated Annealing for improved exploration and exploitation balance.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c760641a-42a8-4880-b237-c2ee09e57afe", "metadata": {"aucs": [0.8881588567496903, 0.8804645191171939, 0.8832006779813523, 0.880489324221724, 0.9091349008875693, 0.8873667240814282, 0.8941018906157128, 0.8951439489418853, 0.8833675671250466, 0.7793442210462811, 0.7521580567747992, 0.7812251901383434, 0.7470396496209917, 0.7693919541717918, 0.7898142102907748, 0.7991421192001629, 0.7750137738087475, 0.7827509077963568, 0.13711278506372815, 0.17496675124345185, 0.2528452560445985, 0.3784216637686927, 0.16955567333695487, 0.34838294487332155, 0.23851733193816105, 0.2201157368319705, 0.1695908270867874, 0.11946442993686701, 0.1309644376546456, 0.18515532357445097, 0.13145618844494367, 0.15311142708578485, 0.14767805479973684, 0.1384171750510217, 0.1642178844908354, 0.1358924878864256, 0.9497751392895067, 0.9422176025672138, 0.9642301016482123, 0.9641155691632283, 0.9579857101041478, 0.9515012682399547, 0.9470910952349466, 0.9663990949953548, 0.9497869839833771, 0.5517550430935816, 0.4030297708787818, 0.6899020842090338, 0.6644043424912506, 0.6583914103285077, 0.642552854054245, 0.4763790592444549, 0.4885663657117264, 0.5441596966323297, 0.8851421367377128, 0.8375255269317223, 0.22763010111508997, 0.8714297919605809, 0.8230290265716692, 0.8230141550438175, 0.8823503176244772, 0.7924507610997955, 0.7585348663254745, 0.21632979988629253, 0.17915280136440526, 0.19744908071510248, 0.27261545472557547, 0.23474588339124558, 0.2701123906859475, 0.28285837585058604, 0.15657218037925413, 0.20706910386809185, 0.24406634372860758, 0.19187477762756922, 0.15062297083054133, 0.20711809634670886, 0.1848422702036462, 0.43587435414681464, 0.2014271053396226, 0.19369623964663307, 0.18680462898933725, 0.24878394211792165, 0.12556816583815567, 0.47518787319174516, 0.407086001226889, 0.22298524182785873, 0.14476132737657788, 0.41283048003682987, 0.3251943591580939, 0.16100212513767453, 0.2661921891987957, 0.27059609623098724, 0.5811099032521536, 0.36442943275162254, 0.29856669215774734, 0.3638285243024172, 0.38342194407118235, 0.45760318366668795, 0.5785784467958612, 0.13067273042245542, 0.20865067175643193, 0.10788493871388982, 0.34359711048897557, 0.10418401578679781, 0.08224769260645082, 0.1630221582711462, 0.15988528760810272, 0.0932121059366795, 0.36425077163562913, 0.34360607771542395, 0.4773645781214646, 0.3395928756651425, 0.37957542247825904, 0.38873617068029576, 0.22361323873492234, 0.17345458504240485, 0.32201694417751126, 0.8140230110092863, 0.7577721976733405, 0.6596946846537206, 0.6215866873951525, 0.6226444196765686, 0.6918350237605397, 0.7152784749043681, 0.7746077030799947, 0.6665593370422503, 0.1241826297017582, 0.135169504620408, 0.11904210410314986, 0.11124898516931647, 0.11726975291236319, 0.14883111446697572, 0.13916953432766477, 0.12072962942752896, 0.159201745334688, 0.19795061384616164, 0.26926967214416275, 0.36765135387868564, 0.5511703292767747, 0.21515558205911667, 0.17729841260802137, 0.29307834331989135, 0.5409267999762131, 0.3825746461917141, 0.5911235351293724, 0.5953218671375085, 0.5955045636771124, 0.524954847217627, 0.5818114599301134, 0.576013774399805, 0.5784897394437256, 0.461652513670736, 0.6525762524119003, 0.42969900886140855, 0.4147371745162638, 0.3974001485927664, 0.42122462224887847, 0.40162155461989746, 0.45707940835614436, 0.4104435803990759, 0.43015713577100867, 0.4783625617128471, 0.20354828844365558, 0.21206023778716454, 0.19538996935236796, 0.206550399018675, 0.19597247979349441, 0.2351175446410726, 0.19687470553767084, 0.21406903003908762, 0.19945973712531329, 0.484538962119203, 0.22473105741225508, 0.5609381816543497, 0.4673554742679712, 0.6055194610905866, 0.2394438406867191, 0.23481937490899485, 0.2106768551527135, 0.5635483512531356, 0.8114488978897988, 0.1620277131256962, 0.1631998747283787, 0.8966467328009798, 0.20200339522796573, 0.8934642556100985, 0.18916325356262764, 0.7941681290299544, 0.8290047480959357, 0.8245983859752802, 0.7421782258879527, 0.16958041039329597, 0.8224687379903372, 0.1689483538518094, 0.16920491868939103, 0.21191554310254634, 0.8589432189832281, 0.12686383042159266, 0.19761482294604082, 0.18422922982565326, 0.17968872615548404, 0.17777540812808657, 0.1763732333088437, 0.1739623252643685, 0.19192710708557947, 0.18177184664642498, 0.2025226765197633, 0.09952752841142087, 0.10248421318950718, 0.08773772211493391, 0.08145995742614032, 0.08872043713721178, 0.07832631779842614, 0.0856018940312735, 0.07422285977724974, 0.0953657701973738]}, "mutation_prompt": null}
