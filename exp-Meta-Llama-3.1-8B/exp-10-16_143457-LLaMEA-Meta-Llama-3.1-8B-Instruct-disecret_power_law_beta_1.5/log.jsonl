{"id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/gpfs/scratch1/shared/hyin/LLaMEA/llamea/llamea.py\", line 180, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/gpfs/scratch1/shared/hyin/LLaMEA/llamea/llamea.py\", line 257, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"/gpfs/scratch1/shared/hyin/LLaMEA/mutation_exp.py\", line 24, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 73, in <module>\n  File \"<string>\", line 56, in __call__\nTypeError: uniform() takes 3 positional arguments but 4 were given\n.", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')Traceback (most recent call last):\n  File \"/gpfs/scratch1/shared/hyin/LLaMEA/llamea/llamea.py\", line 180, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/gpfs/scratch1/shared/hyin/LLaMEA/llamea/llamea.py\", line 257, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"/gpfs/scratch1/shared/hyin/LLaMEA/mutation_exp.py\", line 24, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 73, in <module>\n  File \"<string>\", line 56, in __call__\nTypeError: uniform() takes 3 positional arguments but 4 were given\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "86634f02-a65b-4d25-a9a4-525751052ad6", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO_Q:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.qp = 0.05\n        self.qm = 0.05\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _quantum_mutation(self, x):\n        for i in range(self.dim):\n            if self.rand.random() < self.qm:\n                x[i] += self.rand.uniform(-1, 1)\n                if x[i] < self.lower_bound:\n                    x[i] = self.lower_bound\n                elif x[i] > self.upper_bound:\n                    x[i] = self.upper_bound\n        return x\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._quantum_mutation(x)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._quantum_mutation(x)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo_q = AMSHS_BBO_Q(budget, dim)\nbest_solution, best_fitness = amshs_bbo_q(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO_Q", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm with Quantum-Inspired Mutation for Black Box Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "acd47e61-f6af-4839-b42a-f8167522af3f", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.F = 0.5\n        self.CR = 0.9\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _differential_evolution(self, x, y, z):\n        for i in range(self.dim):\n            r1 = self.rand.randint(0, self.population_size - 1)\n            r2 = self.rand.randint(0, self.population_size - 1)\n            if self.rand.random() < self.CR or i == self.rand.randint(0, self.dim - 1):\n                x[i] = y[i] + self.F * (z[i] - y[i])\n                if x[i] < self.lower_bound:\n                    x[i] = self.lower_bound\n                elif x[i] > self.upper_bound:\n                    x[i] = self.upper_bound\n        return x\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                y = population[self.rand.randint(0, self.population_size - 1)]\n                z = population[self.rand.randint(0, self.population_size - 1)]\n                x = self._differential_evolution(x, y, z)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                y = population[self.rand.randint(0, self.population_size - 1)]\n                z = population[self.rand.randint(0, self.population_size - 1)]\n                x = self._differential_evolution(x, y, z)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo_de = AMSHS_BBO_DE(budget, dim)\nbest_solution, best_fitness = amshs_bbo_de(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO_DE", "description": "Adaptive Multi-Swarm Harmony Search Algorithm with Differential Evolution for Black Box Optimization (AMSHS_BBO_DE) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics, and incorporates differential evolution to improve convergence speed.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "0df1d96f-7c05-4a00-af8c-9736665eace8", "solution": "import numpy as np\nimport random\n\nclass AMSHS_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.F = 0.5\n        self.CR = 0.5\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _differential_evolution(self, x, bounds):\n        x1 = np.random.choice(self.population_size)\n        x2 = np.random.choice(self.population_size)\n        x3 = np.random.choice(self.population_size)\n\n        v = x + self.F * (self.population[x1] - self.population[x2]) + self.CR * (self.population[x3] - x)\n        v = np.clip(v, bounds[:, 0], bounds[:, 1])\n\n        return v\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._differential_evolution(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._differential_evolution(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_de = AMSHS_DE(budget, dim)\nbest_solution, best_fitness = amshs_de(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_DE", "description": "Adaptive Multi-Swarm Harmony Search Algorithm with Differential Evolution (AMSHS_DE) - A novel population-based optimization algorithm that dynamically adjusts harmony search parameters and swarm size based on problem's characteristics, and incorporates differential evolution for enhanced exploration.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'AMSHS_DE' object has no attribute 'population'\").", "error": "AttributeError(\"'AMSHS_DE' object has no attribute 'population'\")", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "f055e766-89f1-4194-b2ed-a838ca6da766", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        else:\n            # Update with probability 1 - paranoid\n            best_idx = np.argmin([np.linalg.norm(memory[i] - x) for i in range(self.harmony_memory_size)])\n            memory[best_idx] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with Probability-Inspired Harmony Memory Update.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "764840b4-8110-4c15-b9d7-d5eac4746b2d", "solution": "import numpy as np\nimport random\n\nclass AdaptiveMultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = int(0.2 * self.population_size)  # adapt swarm size\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            # adapt harmony search rate based on problem's characteristics\n            self.hsr = 0.5 + 0.5 * (1 - (self.budget / self.population_size))\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AdaptiveMultiSwarmHarmonySearch(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AdaptiveMultiSwarmHarmonySearch", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "2867b6f3-5577-45f5-8333-38e56f9f84b1", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            idx = self.rand.randint(0, self.harmony_memory_size - 1)\n            if self.rand.random() < 0.5:\n                memory[idx] = x\n            else:\n                memory[idx] = memory[idx] + self.rand.uniform(-1, 1)\n                memory[idx] = np.clip(memory[idx], self.lower_bound, self.upper_bound)\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization with Dynamic Harmony Memory Update and Enhanced Exploration-Exploitation Balance.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "0f4be240-50e1-4602-b707-40f9921534e7", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.levy_flight_rate = 0.05\n        self.param_adaptation_rate = 0.1\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _levy_flight(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.levy_flight_rate:\n                step_size = np.random levy(3, self.rand.uniform(0.1, 1.0))\n                x[i] += step_size * (bounds[i, 1] - bounds[i, 0]) * self.rand.choice([-1, 1])\n                x[i] = np.clip(x[i], bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _self_adaptive_parameters(self):\n        self.paranoid = max(0.01, self.paranoid - self.param_adaptation_rate)\n        self.bw = max(0.01, self.bw - self.param_adaptation_rate)\n        self.hsr = max(0.01, self.hsr - self.param_adaptation_rate)\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._levy_flight(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            self._self_adaptive_parameters()\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._levy_flight(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm with Levy Flight and Self-Adaptive Parameters for Black Box Optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 33, 39, '                step_size = np.random levy(3, self.rand.uniform(0.1, 1.0))\\n')).", "error": "SyntaxError('invalid syntax', ('<string>', 33, 39, '                step_size = np.random levy(3, self.rand.uniform(0.1, 1.0))\\n'))", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "71beecdc-003c-4551-95b3-e4e90e6b89bf", "solution": "import numpy as np\nimport random\n\nclass AdaptiveAMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.adjusted_hsr = self.hsr\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.adjusted_hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n        iteration = 0\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n            iteration += 1\n            if iteration % 10 == 0:\n                self.adjusted_hsr = max(0.01, self.adjusted_hsr - 0.001)\n                self.rand.random()\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nadaptive_amshs_bbo = AdaptiveAMSHS_BBO(budget, dim)\nbest_solution, best_fitness = adaptive_amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AdaptiveAMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "5802db7d-ba09-4332-a90d-0ba5e5c77ae0", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.social_learning_rate = 0.5\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _social_learning(self, swarm, best_solution):\n        for i in range(self.swarm_size):\n            x = swarm[i]\n            for j in range(self.dim):\n                if self.rand.random() < self.social_learning_rate:\n                    x[j] = best_solution[j]\n            swarm[i] = x\n        return swarm\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n            for k in range(self.swarm_size):\n                x = swarm[k]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                swarm[k] = x\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n            swarm = self._social_learning(swarm, best_solution)\n            for k in range(self.swarm_size):\n                x = swarm[k]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                swarm[k] = x\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm with Social Learning for Black Box Optimization - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics, and incorporates social learning to share knowledge between swarms.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "6998dd3b-7821-4a6b-83ff-6cb65ea86bfa", "solution": "import numpy as np\nimport random\n\nclass AMSHS_CSIE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.cs_rate = 0.25\n        self.cs_pa = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _cuckoo_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.cs_pa:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n            elif self.rand.random() < self.cs_rate:\n                x[i] = np.random.choice([self.lower_bound, self.upper_bound])\n        return x\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._cuckoo_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._cuckoo_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_csie = AMSHS_CSIE(budget, dim)\nbest_solution, best_fitness = amshs_csie(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_CSIE", "description": "Adaptive Multi-Swarm Harmony Search Algorithm with Cuckoo Search-Inspired Exploration (AMSHS-CSIE) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics, and incorporates Cuckoo Search-inspired exploration to enhance the search process.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "b5bc16ff-d708-4c1c-9850-0400950a4fdb", "solution": "import numpy as np\nimport random\n\nclass AdaptiveAMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.difficulty = 0.0\n        self.harmony_memory_update_rate = 0.5\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.harmony_memory_update_rate:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _adjust_parameters(self):\n        if self.difficulty < 0.5:\n            self.hsr = min(self.hsr + 0.01, 1.0)\n            self.paranoid = max(self.paranoid - 0.01, 0.0)\n            self.harmony_memory_update_rate = max(self.harmony_memory_update_rate - 0.01, 0.0)\n        else:\n            self.hsr = max(self.hsr - 0.01, 0.0)\n            self.paranoid = min(self.paranoid + 0.01, 1.0)\n            self.harmony_memory_update_rate = min(self.harmony_memory_update_rate + 0.01, 1.0)\n\n    def __call__(self, func):\n        self.difficulty = self.budget / (self.population_size * self.dim)\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            self._adjust_parameters()\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nadaptive_amshs_bbo = AdaptiveAMSHS_BBO(budget, dim)\nbest_solution, best_fitness = adaptive_amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AdaptiveAMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm with Self-Adaptive Harmony Memory Size and Parameter Adjustment based on the Problem's Difficulty.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "8345ff81-5ba1-4761-bd2f-bad4152a1646", "solution": "import numpy as np\nimport random\n\nclass AdaptiveDE_AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.F = 0.5\n        self.CR = 0.5\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _differential_evolution(self, x, bounds):\n        x1 = np.random.choice(self.population_size)\n        x2 = np.random.choice(self.population_size)\n        x3 = np.random.choice(self.population_size)\n        while x1 == x2 or x1 == x3 or x2 == x3:\n            x1 = np.random.choice(self.population_size)\n            x2 = np.random.choice(self.population_size)\n            x3 = np.random.choice(self.population_size)\n        x_new = x + self.F * (self.population[x1] - self.population[x2]) + self.CR * (self.population[x3] - x)\n        for i in range(self.dim):\n            if self.rand.random() < 0.5:\n                x_new[i] = np.random.uniform(bounds[i, 0], bounds[i, 1])\n        return x_new\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._differential_evolution(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._differential_evolution(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nadaptive_de_amshs_bbo = AdaptiveDE_AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = adaptive_de_amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AdaptiveDE_AMSHS_BBO", "description": "Adaptive Multi-Swarm Harmony Search Algorithm with Differential Evolution for Black Box Optimization, which combines the adaptive harmony search with differential evolution to improve the exploration and exploitation capabilities.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'AdaptiveDE_AMSHS_BBO' object has no attribute 'population'\").", "error": "AttributeError(\"'AdaptiveDE_AMSHS_BBO' object has no attribute 'population'\")", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "f47c27c0-d92a-477a-b108-5da6fe653d39", "solution": "import numpy as np\nimport random\n\nclass AMSHS_DE_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.F = 0.5\n        self.CR = 0.9\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _differential_evolution(self, x, population):\n        r1, r2, r3 = self.rand.randint(0, self.population_size - 1), self.rand.randint(0, self.population_size - 1), self.rand.randint(0, self.population_size - 1)\n        x_new = x + self.F * (population[r1] - population[r2]) + self.CR * (population[r3] - x)\n        return x_new\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._differential_evolution(x, population)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._differential_evolution(x, population)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_de_bbo = AMSHS_DE_BBO(budget, dim)\nbest_solution, best_fitness = amshs_de_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_DE_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm with Differential Evolution for Black Box Optimization - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics, and incorporates differential evolution to enhance exploration and exploitation.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "143f836a-ca40-49a0-91bf-f98741f2177c", "solution": "import numpy as np\nimport random\n\nclass AdaptiveAMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.probability = 0.2\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _adaptive_parameter_update(self, x, best_solution):\n        for i in range(self.dim):\n            if self.rand.random() < self.probability:\n                if x[i] > best_solution[i]:\n                    self.hsr *= 1.1\n                else:\n                    self.hsr /= 1.1\n                if self.hsr < 0.01:\n                    self.hsr = 0.01\n                elif self.hsr > 0.99:\n                    self.hsr = 0.99\n        return x\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._adaptive_parameter_update(x, best_solution)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._adaptive_parameter_update(x, best_solution)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nadaptive_amshs_bbo = AdaptiveAMSHS_BBO(budget, dim)\nbest_solution, best_fitness = adaptive_amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AdaptiveAMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "1cf9823e-3105-4b19-96bc-bb82c09f09ba", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.hms_update_interval = 100  # update harmony memory size every 100 iterations\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _update_harmony_memory_size(self, iteration):\n        if iteration % self.hms_update_interval == 0:\n            self.harmony_memory_size = int(self.population_size * 0.2 + self.rand.randint(0, self.population_size // 2))\n\n    def _update_swarm_size(self, iteration):\n        if iteration % (self.hms_update_interval * 2) == 0:\n            self.swarm_size = int(self.population_size * 0.1 + self.rand.randint(0, self.population_size // 2))\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for iteration in range(self.budget):\n            self._update_harmony_memory_size(iteration)\n            self._update_swarm_size(iteration)\n\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization with Dynamically Adjusted Harmony Memory Size and Swarm Size.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "002b1205-c405-4e2d-90a9-10081b17b8cb", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.swarm_size_update = 0.05  # probability to update swarm size\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _update_swarm_size(self):\n        if self.rand.random() < self.swarm_size_update:\n            self.swarm_size = int(self.rand.uniform(1, self.population_size))\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n        swarm_size = self.swarm_size\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            self._update_swarm_size()\n            swarm_size = int(self.swarm_size)\n\n            for k in range(swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with Dynamic Swarm Size and Harmony Memory Update.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "649f3551-1e82-4a54-871a-6294c92ce9fe", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.adaptive_harmony_memory_size = 0.2\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, int(self.harmony_memory_size * self.adaptive_harmony_memory_size))] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (int(self.harmony_memory_size * self.adaptive_harmony_memory_size), self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization with Adaptive Harmony Memory Size and Probabilistic Harmony Search.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "f0407b10-4445-45ae-997d-a905f11103e5", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.ls_rate = 0.05  # local search rate\n        self.ls_budget = 10  # local search budget\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _local_search(self, x):\n        for _ in range(self.ls_budget):\n            for i in range(self.dim):\n                if self.rand.random() < self.ls_rate:\n                    x[i] += self.rand.uniform(-1, 1) * 0.1\n                    x[i] = max(self.lower_bound, min(self.upper_bound, x[i]))\n        return x\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._local_search(x)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._local_search(x)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm with Local Search for Black Box Optimization, which dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics and incorporates a local search mechanism to improve the solution quality.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "2eee0145-dcd5-41da-bf52-9e04856b102e", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.dynamic_swarm_size = 5\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _dynamic_swarm_size_adjustment(self, population, best_solution):\n        distance = np.linalg.norm(population - best_solution, axis=1)\n        self.swarm_size = int(np.sum(distance < 1.0) + self.dynamic_swarm_size)\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            self._dynamic_swarm_size_adjustment(population, best_solution)\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with Improved Harmony Search Mechanism and Dynamic Swarm Size Adjustment.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "d5872f4c-d624-4e1f-9147-f6ae5c267431", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                if self.rand.random() < 0.5:\n                    x[i] = self.rand.uniform(bounds[i, 0] * (1 - self.bw), bounds[i, 1] * (1 + self.bw))\n                else:\n                    x[i] = self.rand.uniform(bounds[i, 0] * (1 - self.bw), bounds[i, 1] * (1 + self.bw))\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with enhanced harmony search strategy using probability-based bounds adjustment.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "120f0718-f478-4479-973a-73b4ea30409f", "solution": "import numpy as np\nimport random\n\nclass AMSHS_DE_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.F = 0.5\n        self.CR = 0.9\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _differential_evolution(self, x, bounds):\n        for i in range(self.dim):\n            r1, r2, r3 = np.random.randint(0, self.population_size, 3)\n            x[i] += self.F * (bounds[r1, i] - bounds[r2, i]) + self.CR * (bounds[r3, i] - x[i])\n            if x[i] < bounds[0, i] or x[i] > bounds[1, i]:\n                x[i] = np.random.uniform(bounds[0, i], bounds[1, i])\n        return x\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._differential_evolution(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._differential_evolution(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_de_bbo = AMSHS_DE_BBO(budget, dim)\nbest_solution, best_fitness = amshs_de_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_DE_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm with Differential Evolution for Black Box Optimization, which combines the advantages of harmony search and differential evolution to dynamically adjust the search strategy based on the problem's characteristics and adaptively update the swarm size and harmony memory size.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 49 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 49 is out of bounds for axis 0 with size 10')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "fdda3e60-26e8-41a1-a362-f7d02ce60e80", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "48a060b3-a76c-4084-afdd-3efd2e3a4615", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.swarm_adaptation_rate = 0.05\n        self.harmony_memory_adaptation_rate = 0.05\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _adapt_swarm_size(self):\n        if self.rand.random() < self.swarm_adaptation_rate:\n            self.swarm_size = max(1, int(self.swarm_size * self.rand.uniform(0.9, 1.1)))\n        return self.swarm_size\n\n    def _adapt_harmony_memory_size(self):\n        if self.rand.random() < self.harmony_memory_adaptation_rate:\n            self.harmony_memory_size = max(1, int(self.harmony_memory_size * self.rand.uniform(0.9, 1.1)))\n        return self.harmony_memory_size\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n        swarm_size = self.swarm_size\n        harmony_memory_size = self.harmony_memory_size\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            swarm_size = self._adapt_swarm_size()\n            harmony_memory_size = self._adapt_harmony_memory_size()\n\n            for k in range(swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with Dynamic Harmony Memory and Swarm Size Adaptation.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "0bdf2723-60d0-4b67-82af-575f854d9e3f", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n        swarm_size = self.swarm_size\n        harmony_memory_size = self.harmony_memory_size\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            # Dynamically adjust swarm size and harmony memory size\n            if i % 10 == 0 and i!= 0:\n                swarm_size = max(5, int(swarm_size * 0.9))\n                harmony_memory_size = max(5, int(harmony_memory_size * 0.9))\n\n            for k in range(swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with Dynamic Harmony Memory and Swarm Size Adjustment.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "0357960f-02e7-42e2-ba5b-d32bbd71aea9", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.cr = 0.5\n        self.f = 0.5\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _differential_evolution_crossover(self, x1, x2, x3):\n        r1, r2, r3 = self.rand.random(), self.rand.random(), self.rand.random()\n        if self.rand.random() < self.cr:\n            for i in range(self.dim):\n                if self.rand.random() < r1:\n                    x1[i] = x2[i] + self.f * (x3[i] - x2[i])\n                elif self.rand.random() < r2:\n                    x1[i] = x3[i] + self.f * (x2[i] - x3[i])\n                elif self.rand.random() < r3:\n                    x1[i] = x2[i] + self.f * (x3[i] - x2[i])\n        return x1\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._differential_evolution_crossover(x, population[self.rand.randint(0, self.population_size - 1)], population[self.rand.randint(0, self.population_size - 1)])\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._differential_evolution_crossover(x, population[self.rand.randint(0, self.population_size - 1)], population[self.rand.randint(0, self.population_size - 1)])\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo_de = AMSHS_BBO_DE(budget, dim)\nbest_solution, best_fitness = amshs_bbo_de(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO_DE", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm with Differential Evolution Crossover for Black Box Optimization (AMSHS-BBO-DE) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics, and incorporates differential evolution crossover to enhance exploration and exploitation.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "3fcd9ea8-e93e-4f07-90f2-3352f73c2508", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _probability_inspired_harmony_memory_update(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            if self.rand.random() < 0.5:\n                memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n            else:\n                memory[self.rand.randint(0, self.harmony_memory_size - 1)] = self._harmony_search(memory[self.rand.randint(0, self.harmony_memory_size - 1)], np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n        return memory\n\n    def _multi_directional_harmony_search(self, x, bounds, direction):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                if direction == 'plus':\n                    x[i] = self.rand.uniform(x[i] + 0.1, x[i] + 1.0)\n                elif direction =='minus':\n                    x[i] = self.rand.uniform(x[i] - 0.1, x[i] - 1.0)\n                else:\n                    x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._multi_directional_harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim), 'plus')\n                x = self._multi_directional_harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim),'minus')\n                x = self._multi_directional_harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim), 'random')\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._probability_inspired_harmony_memory_update(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm with Probability-Inspired Harmony Memory Update and Multi-Directional Harmony Search.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "f600043e-22f8-4317-9e2b-d77993f92319", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            idx = self.rand.randint(0, self.harmony_memory_size - 1)\n            memory[idx] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j].copy()  # Create a copy to avoid modifying the original population\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Fix the error in the original code\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics, with an improved version to fix the error in the original code.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "fabaae7d-a699-4b99-8a97-a69b52255dba", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.zeros(self.dim)\n                for d in range(self.dim):\n                    if self.rand.random() < 0.5:\n                        x[d] = self.rand.uniform(self.lower_bound, self.upper_bound)\n                    else:\n                        x[d] = self.rand.gauss(self.lower_bound, 1.0)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics, but with a modified version that uses a probability of 2 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "630e5bca-ab03-4757-8dc2-96090db3eb07", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.zeros(self.dim)\n                for d in range(self.dim):\n                    if self.rand.random() < self.hsr:\n                        x[d] = self.rand.uniform(self.lower_bound, self.upper_bound)\n                    else:\n                        x[d] = self.rand.gauss(self.lower_bound, self.bw)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with a Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics and incorporates a novel strategy of using a probability-based approach to update the harmony memory.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "e2650dc1-a352-4d97-809e-6aaed97f0380", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = np.random.normal(bounds[i, 0], self.bw)\n                x[i] = np.clip(x[i], bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        else:\n            best_solution = np.min(memory, axis=0)\n            for i in range(self.dim):\n                if self.rand.random() < 0.5:\n                    x[i] = np.random.normal(best_solution[i], self.bw)\n                else:\n                    x[i] = np.random.normal(memory[self.rand.randint(0, self.harmony_memory_size - 1), i], self.bw)\n                x[i] = np.clip(x[i], bounds[i, 0], bounds[i, 1])\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with enhanced harmony search strategy using Gaussian distribution and a new update rule for the harmony memory.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'bounds' is not defined\").", "error": "NameError(\"name 'bounds' is not defined\")", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "8c43228e-a524-4898-bf52-5920d482112e", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.swarm_sizes = [self.swarm_size, int(self.swarm_size * 0.8), int(self.swarm_size * 0.6), int(self.swarm_size * 0.4)]\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n            elif self.rand.random() < 0.5:\n                x[i] = x[i] + self.rand.uniform(-1, 1)\n                x[i] = max(self.lower_bound, min(self.upper_bound, x[i]))\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n        swarm_size = self.swarm_size\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n            if i % 100 == 0 and i!= 0:\n                swarm_size = self.swarm_sizes[int((i / 100) % len(self.swarm_sizes))]\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with improved harmony search strategy and adaptive swarm size.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "2e4b5e67-3970-4cb0-a515-9b8e79b7c273", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _levy_flight(self, x, bounds):\n        step_size = np.random.normal(0, 1, self.dim)\n        step_size = step_size / np.linalg.norm(step_size)\n        step_size = step_size * (np.random.uniform(0.1, 10, 1)[0] ** 2)\n        x = x + step_size\n        for i in range(self.dim):\n            if x[i] < bounds[i, 0]:\n                x[i] = bounds[i, 0]\n            elif x[i] > bounds[i, 1]:\n                x[i] = bounds[i, 1]\n        return x\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._levy_flight(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._levy_flight(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "Adaptive Multi-Swarm Harmony Search Algorithm with Multi-Dimensional Levy Flights for Black Box Optimization", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "98285f2e-9a23-4842-9309-2acd15290b8b", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j].copy()\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm with Dynamic Harmony Memory Update for Black Box Optimization.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "b8f70570-963b-46ee-b835-d569fb5f12d0", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                bounds = np.array([[self.lower_bound, self.upper_bound]] * self.dim)\n                x = self._harmony_search(x, bounds)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                bounds = np.array([[self.lower_bound, self.upper_bound]] * self.dim)\n                x = self._harmony_search(x, bounds)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "73c589d6-b95d-42cb-b60e-c331d12e4ce7", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.mu = 0.5  # probability for mutation\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _mutation_operator(self, x):\n        for i in range(self.dim):\n            if self.rand.random() < self.mu:\n                x[i] += self.rand.uniform(-1, 1)\n                x[i] = max(self.lower_bound, min(x[i], self.upper_bound))\n        return x\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._mutation_operator(x)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._mutation_operator(x)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm with a Novel Mutation Operator for Black Box Optimization, which incorporates a probability-based mutation operator to enhance exploration and exploitation.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "08c6d5e9-4ac1-441e-a4bd-bf5ff5cc19f3", "solution": "import numpy as np\nimport random\n\nclass AMSHS_DE_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.cr = 0.5\n        self.f = 0.5\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _differential_evolution(self, x, bounds, best_solution):\n        for i in range(self.dim):\n            r1, r2 = self.rand.randint(0, self.population_size - 1), self.rand.randint(0, self.population_size - 1)\n            if self.rand.random() < self.cr:\n                x[i] = best_solution[i] + self.f * (bounds[r1, i] - bounds[r2, i])\n                if x[i] < bounds[i, 0] or x[i] > bounds[i, 1]:\n                    x[i] = np.random.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._differential_evolution(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim), best_solution)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._differential_evolution(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim), best_solution)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_de_bbo = AMSHS_DE_BBO(budget, dim)\nbest_solution, best_fitness = amshs_de_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_DE_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm with Differential Evolution for Black Box Optimization, where the Harmony Search algorithm is combined with Differential Evolution to improve the exploration and exploitation capabilities.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 44 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 44 is out of bounds for axis 0 with size 10')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "63c7b74b-8c53-4776-89be-0e90e1c37482", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n            else:\n                x[i] += self.rand.uniform(-self.bw, self.bw)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization with improved Harmony Search and Paranoid Mechanism.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "3e190f08-ec5e-4527-a7fa-f7d26def1e9d", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            idx = self.rand.randint(0, self.harmony_memory_size - 1)\n            memory[idx] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.array([self.rand.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)])\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization with Randomized Harmony Memory Update and Improved Harmony Search.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "c258a3a3-2518-4a40-8414-dbb182805f42", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n            else:\n                x[i] = x[i] + self.rand.uniform(-self.bw, self.bw)\n                x[i] = max(self.lower_bound, min(x[i], self.upper_bound))\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization with Dynamically Adjusted Harmony Search Parameters and Swarm Size.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "834d38ed-3cad-46e6-9e17-d889fe7dbec0", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.harmony_memory_update_rate = 0.1\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.harmony_memory_update_rate:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n        harmony_memory_size = self.harmony_memory_size\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n                harmony_memory_size = int(self.rand.gauss(self.harmony_memory_size, self.harmony_memory_size * 0.1))\n                harmony_memory_size = max(1, min(harmony_memory_size, 50))\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with a self-adaptive harmony memory size.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "9275304b-0cbf-4b62-9f44-e6efa5f7869f", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.crossover_rate = 0.5\n        self.mutation_rate = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _crossover(self, x1, x2):\n        child = np.zeros(self.dim)\n        for i in range(self.dim):\n            if self.rand.random() < self.crossover_rate:\n                child[i] = (x1[i] + x2[i]) / 2\n            else:\n                child[i] = x1[i]\n        return child\n\n    def _mutation(self, x):\n        for i in range(self.dim):\n            if self.rand.random() < self.mutation_rate:\n                x[i] += self.rand.uniform(-1, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x1 = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x2 = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x1 = self._harmony_search(x1, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x2 = self._harmony_search(x2, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                child = self._crossover(x1, x2)\n                child = self._mutation(child)\n                fitness = self._evaluate_function(child)\n                if fitness < best_fitness:\n                    best_solution = child\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(child, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm with Crossover and Mutation for Black Box Optimization.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "9c1cc542-3be7-4faf-a127-eab042f0156b", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n            else:\n                x[i] = x[i] + self.rand.uniform(-self.bw, self.bw)\n                x[i] = max(self.lower_bound, min(self.upper_bound, x[i]))\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization with Improved Harmony Search and Swarm Size Adaptation.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "031d64e0-0948-4dc0-9686-787b44d25fe8", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics, modified to handle a wide range of tasks and evaluated on the BBOB test suite of 24 noiseless functions.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "3bf1cbd5-d0ab-440a-8d3a-417886a70996", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            # Update swarm size based on the problem's characteristics\n            if i % 100 == 0:\n                if self.rand.random() < 0.5:\n                    self.swarm_size = int(self.swarm_size * 1.1)\n                else:\n                    self.swarm_size = int(self.swarm_size * 0.9)\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with Dynamic Harmony Memory Update and Swarm Size Adjustment.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "da29d64d-0f9b-4e32-a1c3-42e2365e605e", "solution": "import numpy as np\nimport random\nfrom sklearn.neighbors import KNeighborsMapper\nfrom sklearn.cluster import KMeans\n\nclass AMSHS_BBO_SOM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.som_mapper = KNeighborsMapper(n_neighbors=10)\n        self.cluster_centers = np.random.uniform(self.lower_bound, self.upper_bound, (10, self.dim))\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _cluster_solution(self, x):\n        return self.som_mapper.fit_transform(x.reshape(1, -1))\n\n    def _update_cluster_centers(self, cluster_labels):\n        kmeans = KMeans(n_clusters=10)\n        kmeans.fit(self.cluster_centers)\n        self.cluster_centers = kmeans.cluster_centers_\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            cluster_labels = self._cluster_solution(population)\n            self._update_cluster_centers(cluster_labels)\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo_som = AMSHS_BBO_SOM(budget, dim)\nbest_solution, best_fitness = amshs_bbo_som(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO_SOM", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization with Self-Organizing Maps (AMSHS-BBO-SOM) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics and utilizes self-organizing maps to improve the exploration-exploitation trade-off.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'sklearn'\").", "error": "ModuleNotFoundError(\"No module named 'sklearn'\")", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "99bcbe78-2e94-4b6a-895a-ed5fd4a4ad54", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.de_rand = np.random.rand(self.population_size, self.dim)\n        self.de_f = 0.5\n        self.cauchy_lambda = 1.0\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _mutation_de(self, x):\n        r1, r2, r3 = self.rand.randint(0, self.population_size - 1), self.rand.randint(0, self.population_size - 1), self.rand.randint(0, self.population_size - 1)\n        v = x + self.de_f * (self.de_rand[r1] - self.de_rand[r2]) + self.de_f * (self.de_rand[r3] - self.de_rand[r2])\n        v = v + self.cauchy_lambda * np.random.standard_cauchy(self.dim)\n        return v\n\n    def _mutation_cauchy(self, x):\n        v = x + self.cauchy_lambda * np.random.standard_cauchy(self.dim)\n        return v\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                v1 = self._mutation_de(x)\n                v2 = self._mutation_cauchy(x)\n                x = (v1 + v2) / 2\n                x = np.clip(x, self.lower_bound, self.upper_bound)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                v1 = self._mutation_de(x)\n                v2 = self._mutation_cauchy(x)\n                x = (v1 + v2) / 2\n                x = np.clip(x, self.lower_bound, self.upper_bound)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with a Novel Mutation Operator that combines Differential Evolution and Cauchy Mutation to enhance exploration and exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "cc429e77-6fb3-43c7-ab78-afddf10e8542", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "03b5b3aa-d7d5-439d-b3b0-e9041984c284", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                if self.rand.random() < 0.5:\n                    population[j] = x\n                else:\n                    population[j] = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics, improved with probability-based selection of individuals for update.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "8c482bea-64e2-403d-bafb-5d341c9fe1b4", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j].copy()\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "67753454-ad16-48d3-97e8-444ebde8638c", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "4424e4ab-61f6-4638-a642-fc82c22eacc5", "solution": "import numpy as np\nimport random\n\nclass AMSHS_DE_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.F = 0.5  # Differential evolution parameter\n        self.CR = 0.5  # Differential evolution parameter\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _differential_evolution(self, x):\n        x_new = x + self.F * (self.rand.uniform(-1, 1, self.dim) * x)\n        x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n        return x_new\n\n    def _crossover(self, x1, x2, x3):\n        r = self.rand.random()\n        x_new = x1 + r * (x2 - x3)\n        x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n        return x_new\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._differential_evolution(x)\n                x = self._crossover(x, population[self.rand.randint(0, self.population_size - 1)], population[self.rand.randint(0, self.population_size - 1)])\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._differential_evolution(x)\n                x = self._crossover(x, population[self.rand.randint(0, self.population_size - 1)], population[self.rand.randint(0, self.population_size - 1)])\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_de_bbo = AMSHS_DE_BBO(budget, dim)\nbest_solution, best_fitness = amshs_de_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_DE_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm with Differential Evolution for Black Box Optimization (AMSHS-DE-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics, and incorporates differential evolution to enhance exploration.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "f426476b-1c27-48c8-8c51-d30a847e9493", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "da87bbc1-c99f-4526-99d9-7d7172490207", "solution": "import numpy as np\nimport random\n\nclass AdaptiveAMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.problem_difficulty = 0.0\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _adjust_swarm_size(self):\n        if self.problem_difficulty < 0.5:\n            self.swarm_size = int(self.swarm_size * 1.2)\n        elif self.problem_difficulty > 0.8:\n            self.swarm_size = int(self.swarm_size * 0.8)\n\n    def _update_problem_difficulty(self, fitness):\n        if fitness < 0.1:\n            self.problem_difficulty += 0.01\n        elif fitness > 0.9:\n            self.problem_difficulty -= 0.01\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                self._update_problem_difficulty(fitness)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            self._adjust_swarm_size()\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                self._update_problem_difficulty(fitness)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nadaptive_amshs_bbo = AdaptiveAMSHS_BBO(budget, dim)\nbest_solution, best_fitness = adaptive_amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AdaptiveAMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization with Dynamic Swarm Size Adjustment and Harmony Memory Update based on Problem Difficulty.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "713f13cc-5e9b-45ba-a1b4-73747d90e006", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _dynamic_swarm_size_adjustment(self, iteration):\n        swarm_size = int(self.swarm_size * (1 - iteration / self.budget))\n        return max(swarm_size, 1)\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            swarm_size = self._dynamic_swarm_size_adjustment(i)\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm with Improved Harmony Memory Update and Dynamic Swarm Size Adjustment.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "97fca116-8fc7-47d3-83ee-3b0944c690eb", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.01  # Reduced the harmony search rate to 1%\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n            elif self.rand.random() < self.bw:  # Introduced a new parameter for bounded perturbation\n                x[i] = x[i] + self.rand.uniform(-1, 1)\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization with Improved Harmony Search Strategy.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "a1f9da8a-3d76-42e1-a2e6-beb12dd1455a", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "1fcc4565-b9a9-4b0a-84e5-da59aea93182", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            idx = np.where(np.random.rand(self.harmony_memory_size) < self.paranoid)[0][0]\n            memory[idx] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n        swarm_size = self.swarm_size\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n            # Dynamic swarm size adjustment\n            if i % (self.budget // 10) == 0:\n                swarm_size = int(self.swarm_size * (1 + self.rand.random() * 0.2 - 0.1))\n                if swarm_size < 1:\n                    swarm_size = 1\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization with Dynamic Harmony Memory Update and Swarm Size Adjustment.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "de0313f0-49a0-4cca-81ba-6116942bc723", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO_AS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.adaptive_swarm_size = 5\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _adaptive_swarm_size(self, swarm_size):\n        if self.rand.random() < 0.5:\n            swarm_size += self.adaptive_swarm_size\n        else:\n            swarm_size -= self.adaptive_swarm_size\n        return max(1, swarm_size)\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            swarm_size = self.swarm_size\n            swarm_size = self._adaptive_swarm_size(swarm_size)\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo_as = AMSHS_BBO_AS(budget, dim)\nbest_solution, best_fitness = amshs_bbo_as(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO_AS", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization with Enhanced Harmony Search and Adaptive Swarm Size (AMSHS_BBO-AS) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics and utilizes adaptive swarm size to improve convergence.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "7faa1d51-9b48-47a9-9248-0acbf398598a", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO_EHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n            elif self.rand.random() < self.bw:\n                x[i] = x[i] + self.rand.uniform(-1, 1)\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo_ehs = AMSHS_BBO_EHS(budget, dim)\nbest_solution, best_fitness = amshs_bbo_ehs(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO_EHS", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization with Enhanced Harmony Search (AMSHS_BBO-EHS) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics, incorporating an enhanced harmony search strategy to improve exploration and exploitation.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "b84a05d9-5f3c-4efd-922b-e7d97376a856", "solution": "import numpy as np\nimport random\n\nclass AdaptiveAMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n        swarm_size_multiplier = 1.0\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            swarm_size_multiplier = np.exp(-i / self.budget)\n            for k in range(int(self.swarm_size * swarm_size_multiplier)):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nadaptive_amshs_bbo = AdaptiveAMSHS_BBO(budget, dim)\nbest_solution, best_fitness = adaptive_amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AdaptiveAMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "96f0cf35-cfb9-4395-8734-4c8793a424fd", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _probability_inspired_harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n            else:\n                x[i] = x[i] + self.rand.uniform(-self.bw, self.bw)\n                if x[i] < bounds[i, 0]:\n                    x[i] = bounds[i, 0]\n                elif x[i] > bounds[i, 1]:\n                    x[i] = bounds[i, 1]\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _adaptive_swarm_size(self, population):\n        best_fitness = np.min([self._evaluate_function(x) for x in population])\n        if best_fitness < 0.5:\n            self.swarm_size = int(self.swarm_size * 1.1)\n        elif best_fitness > 1.5:\n            self.swarm_size = int(self.swarm_size * 0.9)\n        return self.swarm_size\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._probability_inspired_harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            self.swarm_size = self._adaptive_swarm_size(population)\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._probability_inspired_harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with Probability-Inspired Harmony Search and Adaptive Swarm Size.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "2428b54b-c582-469e-b44d-71b67f8e16f1", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO_MDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.exploitation_rate = 0.5\n        self.exploitation_bias = 0.1\n        self.exploration_bias = 0.9\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _exploitation_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.exploitation_rate:\n                x[i] = self.rand.uniform(x[i] - self.exploitation_bias, x[i] + self.exploitation_bias)\n        return x\n\n    def _exploration_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.exploration_rate:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._exploitation_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._exploration_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo_mde = AMSHS_BBO_MDE(budget, dim)\nbest_solution, best_fitness = amshs_bbo_mde(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO_MDE", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization with Multi-Directional Exploration (AMSHS-BBO-MDE)", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "f0ed75ea-b492-4757-a875-8955985ff234", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _dynamic_swarm_size(self, best_fitness):\n        if best_fitness < 0.1:\n            self.swarm_size = 20\n        elif best_fitness < 0.5:\n            self.swarm_size = 15\n        else:\n            self.swarm_size = 10\n\n    def _dynamic_harmony_memory_update(self, best_fitness):\n        if best_fitness < 0.1:\n            self.paranoid = 0.05\n        elif best_fitness < 0.5:\n            self.paranoid = 0.1\n        else:\n            self.paranoid = 0.2\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            self._dynamic_swarm_size(best_fitness)\n            self._dynamic_harmony_memory_update(best_fitness)\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "Adaptive Multi-Swarm Harmony Search Algorithm with Dynamic Swarm Size and Harmony Memory Update based on Problem Difficulty.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "8472d658-f211-491f-8ba0-3608a4c861c0", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            idx = self.rand.randint(0, self.harmony_memory_size - 1)\n            memory[idx] = x\n            return memory\n        else:\n            return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with Improved Harmony Search and Memory Update Strategies.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "c6418140-a1fc-42ae-9793-9f4fa2fa202d", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid_rate = 0.1\n        self.harmony_search_rate = 0.1\n        self.update_rate = 0.1\n        self.bw = 0.1\n        self.rand = random.Random()\n        self.iteration = 0\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.harmony_search_rate:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.update_rate:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _update_rates(self):\n        self.harmony_search_rate = max(0.01, self.harmony_search_rate * 0.9)\n        self.paranoid_rate = max(0.01, self.paranoid_rate * 0.9)\n        self.update_rate = max(0.01, self.update_rate * 0.9)\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            self.iteration += 1\n            self._update_rates()\n\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with enhanced Harmony Search strategy that adaptively adjusts the Harmony Search Rate (HSR) and Paranoid Rate (PR) based on the problem's characteristics.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "1fc5f0e0-2381-46d5-b8bf-95a08753b12a", "solution": "import numpy as np\nimport random\n\nclass AMSHS_DE_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.F = 0.5\n        self.CR = 0.9\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _differential_evolution(self, x, bounds):\n        r1, r2, r3 = self.rand.randint(0, self.population_size - 1), self.rand.randint(0, self.population_size - 1), self.rand.randint(0, self.population_size - 1)\n        mutant = x + self.F * (bounds[r1] - bounds[r2])\n        trial = mutant + self.CR * (x - bounds[r3])\n        for i in range(self.dim):\n            if self.rand.random() < self.CR:\n                trial[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return trial\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                trial = self._differential_evolution(x, population)\n                trial = self._harmony_search(trial, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(trial)\n                if fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                trial = self._differential_evolution(x, population)\n                trial = self._harmony_search(trial, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(trial)\n                if fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(trial, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_de_bbo = AMSHS_DE_BBO(budget, dim)\nbest_solution, best_fitness = amshs_de_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_DE_BBO", "description": "Adaptive Multi-Swarm Harmony Search Algorithm with Differential Evolution for Black Box Optimization, which combines the advantages of Harmony Search and Differential Evolution to improve the convergence speed and accuracy.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "72783662-0ed4-4573-ac6e-7a7b8ea12877", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "58c6ba54-96e9-46c4-af98-59292276dc10", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.extended_bounds = np.array([[self.lower_bound - 1, self.upper_bound + 1]] * self.dim)\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _extend_bounds(self, x):\n        for i in range(self.dim):\n            if self.rand.random() < self.bw:\n                if self.rand.random() < 0.5:\n                    x[i] = np.clip(x[i] + self.rand.uniform(-1, 1), self.extended_bounds[i, 0], self.extended_bounds[i, 1])\n                else:\n                    x[i] = np.clip(x[i] - self.rand.uniform(-1, 1), self.extended_bounds[i, 0], self.extended_bounds[i, 1])\n        return x\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._extend_bounds(x)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._extend_bounds(x)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm with Dynamic Boundary Extension for Black Box Optimization, which incorporates dynamic boundary extension and adaptive swarm size to improve the algorithm's performance and adaptability.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "324b7ca9-38ea-4d73-8c1b-80762a89e9c1", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.diversity_threshold = 0.5\n        self.convergence_threshold = 0.01\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _adaptive_mutation(self, x, bounds):\n        diversity = np.std([self.rand.uniform(bounds[i, 0], bounds[i, 1]) for i in range(self.dim)])\n        convergence = np.abs(np.mean(x) - self.rand.uniform(bounds[i, 0], bounds[i, 1]) for i in range(self.dim))\n        if diversity > self.diversity_threshold or convergence > self.convergence_threshold:\n            for i in range(self.dim):\n                if self.rand.random() < 0.5:\n                    x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._adaptive_mutation(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._adaptive_mutation(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with a novel adaptive mutation operator that dynamically adjusts the mutation probability based on the swarm's diversity and convergence.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"bad operand type for abs(): 'generator'\").", "error": "TypeError(\"bad operand type for abs(): 'generator'\")", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "76890e5b-5b12-4aa7-bf44-bf2a246120a4", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.5  # Update 1: Set harmony search rate to 0.5\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:  # Update 2: Use self.rand.random() for random number generation\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Update 3: Use np.random.uniform for random number generation\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with adaptive harmony search rate and swarm size.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "25bb9754-b948-4788-8488-c9148b6a9f12", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j].copy()\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "26e5ae7e-2ebf-4bda-9b3c-9440d940b392", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            swarm_size = int(self.swarm_size * (1 - (i / self.budget)))\n            for k in range(swarm_size):\n                x = np.zeros(self.dim)\n                for d in range(self.dim):\n                    if self.rand.random() < self.hsr:\n                        x[d] = self.rand.uniform(self.lower_bound, self.upper_bound)\n                    else:\n                        x[d] = population[self.rand.randint(0, self.population_size - 1)][d]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm with Enhanced Exploration and Exploitation using a Probability-Inspired Swarm Sizing Mechanism.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "f25a8eed-8bac-47d0-89be-287ad00f1490", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n        diversity = np.zeros(self.population_size)\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                diversity[j] = fitness\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            # Adjust swarm size based on fitness diversity\n            if np.var(diversity) > 1:\n                self.swarm_size = int(self.population_size * (np.var(diversity) / 1))\n            else:\n                self.swarm_size = 10\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n            # Adjust harmony memory size based on fitness diversity\n            if np.var(diversity) > 1:\n                self.harmony_memory_size = int(self.population_size * (np.var(diversity) / 1))\n            else:\n                self.harmony_memory_size = 10\n\n        return best_solution, best_fitness", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm with Dynamically Adjusted Swarm Size and Harmony Memory Size based on the Problem's Characteristics and Fitness Diversity.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "1d451ac4-f740-48ab-9158-0b101f3f5205", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            idx = self.rand.randint(0, self.harmony_memory_size - 1)\n            memory[idx] = x\n            # Update harmony memory size based on the best fitness\n            if func(x) < func(memory[idx]):\n                memory[idx] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            # Update harmony memory size based on the best fitness\n            if best_fitness < func(harmony_memory[0]):\n                harmony_memory[0] = best_solution\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization with Dynamic Swarm Size and Harmony Memory Update.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "d1cf67cb-8e56-4869-ad17-ddfee281bd62", "solution": "import numpy as np\nimport random\nfrom scipy.stats import norm\n\nclass AMSHS_BBO_QM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.qm_prob = 0.2  # probability of applying quantum-inspired mutation\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _quantum_insipred_mutation(self, x):\n        for i in range(self.dim):\n            if self.rand.random() < self.qm_prob:\n                x[i] += self.rand.gauss(0, 1)\n                x[i] = np.clip(x[i], self.lower_bound, self.upper_bound)\n        return x\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._quantum_insipred_mutation(x)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._quantum_insipred_mutation(x)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo_qm = AMSHS_BBO_QM(budget, dim)\nbest_solution, best_fitness = amshs_bbo_qm(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO_QM", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm with Quantum-Inspired Mutation for Black Box Optimization (AMSHS-BBO-QM) - An adaptive population-based optimization algorithm that dynamically adjusts the harmony search parameters, swarm size, and incorporates quantum-inspired mutation to improve exploration and exploitation.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "65ba9a32-761e-4ef2-a79b-94de95f1f9f5", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n        swarm_indices = list(range(self.population_size))\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            # Probability-based swarm selection strategy\n            swarm_probabilities = np.array([np.sum([self.rand.random() < self.bw for _ in range(self.dim)]) for _ in swarm_indices])\n            swarm_probabilities /= np.sum(swarm_probabilities)\n            selected_swarm_index = np.random.choice(swarm_indices, p=swarm_probabilities)\n            x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n            x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n            fitness = self._evaluate_function(x)\n            if fitness < best_fitness:\n                best_solution = x\n                best_fitness = fitness\n            harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with a probability-based swarm selection strategy.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: UFuncTypeError(<ufunc 'divide'>, 'same_kind', dtype('float64'), dtype('int64'), 2).", "error": "UFuncTypeError(<ufunc 'divide'>, 'same_kind', dtype('float64'), dtype('int64'), 2)", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "a3f534d7-5aa1-4551-8da0-209faeac0190", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j].copy()\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with Dynamically Adjusted Harmony Search Parameters and Swarm Size.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "950d7a73-0467-47b1-ae5d-7f17deb75fa6", "solution": "import numpy as np\nimport random\n\nclass Adaptive_AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.swarm_size_factor = 1.0\n        self.harmony_memory_size_factor = 1.0\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _update_swarm_size(self):\n        self.swarm_size = int(self.population_size * self.swarm_size_factor)\n        self.swarm_size_factor = min(2.0, max(0.1, self.swarm_size_factor + self.rand.random() * 0.1 - 0.05))\n\n    def _update_harmony_memory_size(self):\n        self.harmony_memory_size = int(self.population_size * self.harmony_memory_size_factor)\n        self.harmony_memory_size_factor = min(2.0, max(0.1, self.harmony_memory_size_factor + self.rand.random() * 0.1 - 0.05))\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n        iteration = 0\n\n        while self.budget > 0:\n            self._update_swarm_size()\n            self._update_harmony_memory_size()\n            for i in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            iteration += 1\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nadaptive_amshs_bbo = Adaptive_AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = adaptive_amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "Adaptive_AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization with Adaptive Swarm Size and Harmony Memory Size.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "735d1514-cd0b-4277-85fc-e708319ce334", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n            for d in range(self.dim):\n                if self.rand.random() < 0.5:\n                    x = best_solution\n                else:\n                    x = self.rand.uniform(self.lower_bound, self.upper_bound)\n                x[d] = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]]))[d]\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with a modified harmony search strategy that incorporates a probability of 2 for each dimension to decide whether to update the current solution with a new random solution or the best solution found so far.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "a0f2066f-6f87-4927-a5c1-0fff381cb02a", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.F = 0.5\n        self.CR = 0.9\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _differential_evolution(self, x, bounds):\n        r1 = np.random.randint(0, self.population_size)\n        r2 = np.random.randint(0, self.population_size)\n        r3 = np.random.randint(0, self.population_size)\n        v = x + self.F * (bounds[r1] - bounds[r2])\n        u = x + self.CR * (v - x)\n        return u\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                u = self._differential_evolution(x, population)\n                fitness = self._evaluate_function(u)\n                if fitness < best_fitness:\n                    best_solution = u\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                u = self._differential_evolution(x, population)\n                fitness = self._evaluate_function(u)\n                if fitness < best_fitness:\n                    best_solution = u\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(u, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo_de = AMSHS_BBO_DE(budget, dim)\nbest_solution, best_fitness = amshs_bbo_de(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO_DE", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm with Differential Evolution for Black Box Optimization, which dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics and incorporates differential evolution to improve the search process.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "120bc5d6-cfc7-4a54-8782-5bd52c3a6b60", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.swarm_size_multiplier = 0.1  # new parameter\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n            else:\n                x[i] += self.rand.normal(0, 0.1)  # new line\n        return x\n\n    def _update_swarm_size(self):\n        self.swarm_size = int(self.population_size * self.swarm_size_multiplier)  # new line\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            self._update_swarm_size()  # new line\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with Improved Harmony Search and Dynamic Swarm Size Adjustment.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'Random' object has no attribute 'normal'\").", "error": "AttributeError(\"'Random' object has no attribute 'normal'\")", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "9a7f93ae-0bd7-43d8-bfb2-28bcc626fc07", "solution": "import numpy as np\nimport random\n\nclass AdaptiveMultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.ls_rate = 0.2\n        self.ls_max_iter = 10\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _local_search(self, x, bounds):\n        for _ in range(self.ls_max_iter):\n            for i in range(self.dim):\n                if self.rand.random() < self.ls_rate:\n                    x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n            fitness = self._evaluate_function(x)\n            if fitness < self._evaluate_function(x):\n                x = np.copy(x)\n        return x\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._local_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._local_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nadaptive_multi_swarm_harmony_search = AdaptiveMultiSwarmHarmonySearch(budget, dim)\nbest_solution, best_fitness = adaptive_multi_swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AdaptiveMultiSwarmHarmonySearch", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm with Local Search for Black Box Optimization, which adaptively adjusts the harmony search parameters and swarm size based on the problem's characteristics, and incorporates a local search mechanism to refine the solution.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "fdc561ea-5f4b-4099-90d9-a045c3b3f24f", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i][0], bounds[i][1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j].copy()\n                x = self._harmony_search(x, [[self.lower_bound, self.upper_bound]] * self.dim)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.array([self.rand.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)])\n                x = self._harmony_search(x, [[self.lower_bound, self.upper_bound]] * self.dim)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics, modified to use the random.Random class instead of numpy's random number generator.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "bf0bfcc9-17bf-4a07-b7aa-19e3c12c0bbc", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "d8087d97-e5a2-4d14-8d3b-39615effa323", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            idx = self.rand.randint(0, self.harmony_memory_size - 1)\n            if self.rand.random() < 0.5:\n                memory[idx] = x\n            else:\n                memory[idx] = memory[idx] + self.rand.uniform(-1, 1) * (x - memory[idx])\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization with Probability-Inspired Harmony Memory Update and Improved Harmony Search Mechanism.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "76e51ad4-dbd2-45c9-bee6-1ebaa874375c", "solution": "import numpy as np\nimport random\n\nclass AMSHS_DE_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.f = 0.5\n        self.cr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _differential_evolution_crossover(self, x1, x2, x3):\n        for i in range(self.dim):\n            r = self.rand.random()\n            if r < self.cr:\n                x1[i] = x1[i] + self.f * (x2[i] - x3[i])\n        return x1\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x1 = population[j]\n                x2 = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x3 = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x1 = self._differential_evolution_crossover(x1, x2, x3)\n                x1 = self._harmony_search(x1, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x1)\n                if fitness < best_fitness:\n                    best_solution = x1\n                    best_fitness = fitness\n                population[j] = x1\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_de_bbo = AMSHS_DE_BBO(budget, dim)\nbest_solution, best_fitness = amshs_de_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_DE_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm with Differential Evolution Crossover for Black Box Optimization, which combines the adaptive parameters of Harmony Search with the Differential Evolution crossover operator to improve the exploration and exploitation capabilities.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "4757be3f-9a2b-4927-8f9a-38a4610ba01a", "solution": "import numpy as np\nimport random\n\nclass AMSHS_DE_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.F = 0.5\n        self.CR = 0.9\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _de_crossover(self, x1, x2, x3):\n        r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n        for i in range(self.dim):\n            if r1 < self.CR or i == np.random.randint(0, self.dim):\n                x1[i] = x2[i] + self.F * (x3[i] - x2[i])\n        return x1\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x1, x2, x3 = population[j], self.rand.uniform(self.lower_bound, self.upper_bound, self.dim), self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x1 = self._harmony_search(x1, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x2 = self._harmony_search(x2, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x3 = self._harmony_search(x3, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x1 = self._de_crossover(x1, x2, x3)\n                fitness = self._evaluate_function(x1)\n                if fitness < best_fitness:\n                    best_solution = x1\n                    best_fitness = fitness\n                population[j] = x1\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_de_bbo = AMSHS_DE_BBO(budget, dim)\nbest_solution, best_fitness = amshs_de_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_DE_BBO", "description": "Adaptive Multi-Swarm Harmony Search Algorithm with Differential Evolution Crossover for Black Box Optimization", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "e0dd7c23-77a7-4574-931b-fdf222749d6f", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = np.random.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics, improved by refining the strategy to handle the `uniform` function's arguments.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "3bf1977f-6d48-4341-9145-a742b6885f71", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.5  # changed to 0.5\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n            else:\n                x[i] = x[i] + self.rand.uniform(-self.bw, self.bw)\n                x[i] = np.clip(x[i], bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "Adaptive Multi-Swarm Harmony Search Algorithm with Dynamic Harmony Memory Update and Improved Harmony Search Strategy.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "2d4df59f-9825-416b-ac24-b45c0f98bb7d", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO_ANS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.neighborhood_size = int(self.population_size / 5)\n        self.diversity_threshold = 0.5\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _calculate_diversity(self, population):\n        diversity = np.std(population, axis=0)\n        return np.mean(diversity)\n\n    def _update_neighborhood_structure(self, population):\n        diversity = self._calculate_diversity(population)\n        if diversity < self.diversity_threshold:\n            self.neighborhood_size = int(self.neighborhood_size / 2)\n        else:\n            self.neighborhood_size = int(self.neighborhood_size * 1.5)\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            self._update_neighborhood_structure(population)\n\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                neighbors = population[np.random.choice(self.population_size, self.neighborhood_size, replace=False)]\n                for neighbor in neighbors:\n                    x = (x + neighbor) / 2\n                    fitness = self._evaluate_function(x)\n                    if fitness < best_fitness:\n                        best_solution = x\n                        best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo_ans = AMSHS_BBO_ANS(budget, dim)\nbest_solution, best_fitness = amshs_bbo_ans(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO_ANS", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization with Adaptive Neighborhood Structure (AMSHS-BBO-ANS) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters, swarm size, and neighborhood structure based on the problem's characteristics and the population's diversity.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "0d257f88-9694-49c6-8ba8-7ea0d7710dee", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, [[self.lower_bound, self.upper_bound]] * self.dim)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.array([self.rand.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)])\n                x = self._harmony_search(x, [[self.lower_bound, self.upper_bound]] * self.dim)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('list indices must be integers or slices, not tuple').", "error": "TypeError('list indices must be integers or slices, not tuple')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "24c054f0-98b8-4d44-a800-1e64641997ce", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n            else:\n                x[i] += self.rand.normal(0, self.bw)  # Introduce Gaussian perturbation\n                x[i] = max(self.lower_bound, min(x[i], self.upper_bound))  # Boundary handling\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Use np.random instead of self.rand\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with Improved Harmony Search Mechanism.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'Random' object has no attribute 'normal'\").", "error": "AttributeError(\"'Random' object has no attribute 'normal'\")", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "9056044a-a4f3-484e-9da7-fc13258be0ec", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, [[self.lower_bound, self.upper_bound] for _ in range(self.dim)])\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.array([self.rand.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)])\n                x = self._harmony_search(x, [[self.lower_bound, self.upper_bound] for _ in range(self.dim)])\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('list indices must be integers or slices, not tuple').", "error": "TypeError('list indices must be integers or slices, not tuple')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "65035342-3354-47b8-9175-f368c491a926", "solution": "import numpy as np\nimport random\n\nclass AMSHS_DE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.F = 0.5\n        self.CR = 0.9\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _differential_evolution(self, x, bounds):\n        r1 = self.rand.randint(0, self.population_size - 1)\n        r2 = self.rand.randint(0, self.population_size - 1)\n        while r2 == r1:\n            r2 = self.rand.randint(0, self.population_size - 1)\n        r3 = self.rand.randint(0, self.population_size - 1)\n        while r3 == r1 or r3 == r2:\n            r3 = self.rand.randint(0, self.population_size - 1)\n        x_new = x + self.F * (bounds[r2] - bounds[r3])\n        x_new = np.clip(x_new, bounds[0, 0], bounds[0, 1])\n        return x_new\n\n    def _local_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < 0.1:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._differential_evolution(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._local_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._differential_evolution(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._local_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_de_ls = AMSHS_DE_LS(budget, dim)\nbest_solution, best_fitness = amshs_de_ls(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_DE_LS", "description": "Adaptive Multi-Swarm Harmony Search Algorithm with Differential Evolution and Local Search (AMSHS_DE_LS) - A novel optimization algorithm that combines the strengths of harmony search, differential evolution, and local search to efficiently search for the global optimum.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 19 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 19 is out of bounds for axis 0 with size 10')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "5fdae4fa-95d7-4f67-8cb9-70e621ce5f2d", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.convergence_threshold = 0.01\n        self.convergence_counter = 0\n        self.max_convergence_counter = 10\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _adjust_parameters(self):\n        if self.convergence_counter >= self.max_convergence_counter:\n            self.paranoid *= 0.9\n            self.bw *= 0.9\n            self.hsr *= 0.9\n            self.convergence_counter = 0\n        if self.rand.random() < 0.5:\n            self.population_size *= 1.1\n            self.swarm_size *= 1.1\n            self.harmony_memory_size *= 1.1\n        if self.rand.random() < 0.5:\n            self.paranoid *= 1.1\n            self.bw *= 1.1\n            self.hsr *= 1.1\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n        convergence = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n            convergence = np.mean([self._evaluate_function(x) for x in population])\n            if abs(convergence - best_fitness) < self.convergence_threshold:\n                self.convergence_counter += 1\n            else:\n                self.convergence_counter = 0\n\n            self._adjust_parameters()\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo_dps = AMSHS_BBO_DPS(budget, dim)\nbest_solution, best_fitness = amshs_bbo_dps(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO_DPS", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm with Dynamic Swarm Size and Parameter Adjustment (AMSHS-BBO-DPS) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters, swarm size, and harmony memory size based on the problem's characteristics and convergence.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "f43b2498-ed59-4d52-9fba-9b07f0ee229b", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.cs_rate = 0.25\n        self.alpha = 1.0\n        self.phi = 3.0\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _cuckoo_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.cs_rate:\n                x[i] = x[i] + self.rand.gauss(0, self.alpha) * (self.upper_bound - self.lower_bound)\n                x[i] = max(self.lower_bound, min(x[i], self.upper_bound))\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._cuckoo_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._cuckoo_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with a novel hybridization of Harmony Search and Cuckoo Search algorithms.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: Exception('Budget exceeded').", "error": "Exception('Budget exceeded')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "dbd74b65-01ed-44b2-a56d-930ad585f3b2", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n        self.adaptive_mutation_rate = 0.01\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def _adaptive_mutation(self, x):\n        for i in range(self.dim):\n            if self.rand.random() < self.adaptive_mutation_rate:\n                x[i] += self.rand.gauss(0, 0.1)\n                if x[i] < self.lower_bound:\n                    x[i] = self.lower_bound\n                elif x[i] > self.upper_bound:\n                    x[i] = self.upper_bound\n        return x\n\n    def _swarm_intelligence(self, population):\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                x = population[i]\n                x[j] = self.rand.uniform(self.lower_bound, self.upper_bound)\n                if self.rand.random() < 0.1:\n                    x[j] = self.rand.choice(population[:, j])\n        return population\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                x = self._adaptive_mutation(x)\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            population = self._swarm_intelligence(population)\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with a novel strategy of incorporating a probability-based adaptive mutation rate and a swarm intelligence-based exploration-exploitation trade-off.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "d6566836-772a-494f-8258-58e42dfc665d", "solution": "import numpy as np\nimport random\n\nclass AdaptiveMultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n        swarm_size = self.swarm_size\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            if i % 10 == 0:  # adjust swarm size every 10 iterations\n                swarm_size = int(self.population_size * (1 - i / self.budget))\n                self.swarm_size = swarm_size\n\n            for k in range(swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nadaptive_multi_swarm_harmony_search = AdaptiveMultiSwarmHarmonySearch(budget, dim)\nbest_solution, best_fitness = adaptive_multi_swarm_harmony_search(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AdaptiveMultiSwarmHarmonySearch", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) - A population-based optimization algorithm that dynamically adjusts the harmony search parameters and swarm size based on the problem's characteristics.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
{"id": "805b0d38-7c78-4844-9c8a-1d2f655c15aa", "solution": "import numpy as np\nimport random\n\nclass AMSHS_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 10\n        self.harmony_memory_size = 10\n        self.paranoid = 0.1\n        self.bw = 0.1\n        self.hsr = 0.1\n        self.rand = random.Random()\n\n    def _generate_initial_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _evaluate_function(self, x):\n        if self.budget > 0:\n            self.budget -= 1\n            return func(x)\n        else:\n            raise Exception(\"Budget exceeded\")\n\n    def _harmony_search(self, x, bounds):\n        for i in range(self.dim):\n            if self.rand.random() < self.hsr:\n                x[i] = self.rand.uniform(bounds[i, 0], bounds[i, 1])\n            else:\n                x[i] += self.rand.uniform(-self.bw, self.bw) if self.rand.random() < 0.5 else self.rand.uniform(-self.bw, self.bw) * x[i]\n        return x\n\n    def _update_harmony_memory(self, x, memory):\n        if self.rand.random() < self.paranoid:\n            memory[self.rand.randint(0, self.harmony_memory_size - 1)] = x\n        return memory\n\n    def __call__(self, func):\n        population = self._generate_initial_population()\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        best_solution = np.zeros(self.dim)\n        best_fitness = float('inf')\n\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                population[j] = x\n\n            for k in range(self.swarm_size):\n                x = self.rand.uniform(self.lower_bound, self.upper_bound, self.dim)\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                fitness = self._evaluate_function(x)\n                if fitness < best_fitness:\n                    best_solution = x\n                    best_fitness = fitness\n                harmony_memory = self._update_harmony_memory(x, harmony_memory)\n\n            # Introduce swarm dynamics\n            for j in range(self.population_size):\n                x = population[j]\n                x = self._harmony_search(x, np.array([[self.lower_bound, self.upper_bound]] * self.dim))\n                population[j] = x\n                # Calculate distance to nearest swarm member\n                distances = np.linalg.norm(population - x, axis=1)\n                nearest_swarm_member = np.argmin(distances)\n                # Update x based on nearest swarm member\n                x = (x + population[nearest_swarm_member]) / 2\n                population[j] = x\n\n        return best_solution, best_fitness\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\namshs_bbo = AMSHS_BBO(budget, dim)\nbest_solution, best_fitness = amshs_bbo(func)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AMSHS_BBO", "description": "A Novel Adaptive Multi-Swarm Harmony Search Algorithm for Black Box Optimization (AMSHS-BBO) with Improved Harmony Search and Swarm Dynamics.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('uniform() takes 3 positional arguments but 4 were given').", "error": "TypeError('uniform() takes 3 positional arguments but 4 were given')", "parent_id": "b6bed1ea-cb72-499c-8959-67e267adcde8", "metadata": {}, "mutation_prompt": null}
