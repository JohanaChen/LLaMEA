{"id": "f9b0d618-7a35-434e-b25a-70310dd42c6e", "solution": "import numpy as np\nimport random\n\nclass AHQPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqspo = AHQPSO(budget, dim)\nbest_solution, best_fitness = ahqspo(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQPSO", "description": "Adaptive Hybridization of Harmony Search and Quantum-Behaved Particle Swarm Optimization (AHQPSO) - An adaptive hybrid algorithm that combines the exploration capabilities of Harmony Search with the exploitation capabilities of Quantum-Behaved Particle Swarm Optimization.", "configspace": "", "generation": 0, "fitness": 0.09144843562834944, "feedback": "The algorithm AHQPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": null, "metadata": {"aucs": [0.1777139996739341, 0.17578811482102485, 0.170257377687277, 0.17150387971053227, 0.18818139055183436, 0.1743435064021196, 0.17856999940812623, 0.1627570653971666, 0.1900640255741839, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0420769044974153, 0.046540046771576415, 0.036843840851905174, 0.041028703578300574, 0.03732066520661048, 0.03948978223329991, 0.0528437448134802, 0.06702432684758475, 0.058711088734964334, 0.025979934130904825, 0.032508982847686774, 0.0481463786277756, 0.027803019802558393, 0.04926774209271334, 0.05702674525995721, 0.03768548859383769, 0.03992308285267243, 0.029898291447754133, 0.08746944629118047, 0.0741770523943478, 0.09087431849796956, 0.08822863271431869, 0.08032688292695478, 0.08639412375773481, 0.08222559889516068, 0.08620909750186001, 0.07933359613958268, 0.07973913569416458, 0.08043703106553202, 0.10171882691615464, 0.06783755759972065, 0.062276416502640486, 0.06130150772388787, 0.09472457566024695, 0.061028138297436585, 0.09992729358139563, 0.12553619411724048, 0.19308637766117165, 0.1481850439168273, 0.10471519865355927, 0.09685346092514469, 0.13123694841517808, 0.12595553978877339, 0.1368487698841222, 0.11599925472713601, 0.0043507767599104685, 0.004560104586776803, 0.006205422871878197, 0.004189550067818515, 9.999999999998899e-05, 0.0004343670982023262, 9.999999999998899e-05, 9.999999999998899e-05, 0.019872591751231683, 0.008148577147152003, 0.06957272857429797, 9.999999999998899e-05, 0.011988543793833517, 0.035362057023575866, 0.011860097762603106, 0.017993280776203546, 0.006568189490159582, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05293794841224442, 0.06858859508378334, 0.045274884319672526, 0.06941906045599022, 0.03258759184138249, 0.055770453722678415, 0.05295698494644707, 0.05008726726802559, 0.06421743361722532, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006754747757416024, 9.999999999998899e-05, 0.22082032439354093, 0.19298032777251062, 0.19495588911784612, 0.2055799784281095, 0.18923395481742278, 0.20724700933075846, 0.1998807079546645, 0.17860340449937617, 0.20408032060320924, 0.05001390496924141, 0.04250646008327186, 0.04401887178405428, 0.04318053323128679, 0.04044574604984119, 0.046009660620107806, 0.073263588849099, 0.043993360971981255, 0.05229792848072812, 0.13752783092736576, 0.1273795545501043, 0.1372168098523947, 0.1412797182171618, 0.14115194246620144, 0.13013755749087796, 0.15034268976310372, 0.14861619065631115, 0.1338453581186947, 0.17182146956931754, 0.1605601443813055, 0.1760473800192245, 0.16779352461211916, 0.1821496595795835, 0.1769644640004372, 0.16591313548350284, 0.17377774300845283, 0.15374618240477322, 0.11534321591796037, 0.10382166168941254, 0.11849032669552728, 0.1123738480417984, 0.13610603218022022, 0.11676919299387534, 0.10628682615994733, 0.1237427242099084, 0.1229185550255375, 0.1410630187122207, 0.16233450221944246, 0.1583470274596206, 0.1601583581414543, 0.1453603756054126, 0.16236042742370171, 0.15533346120938785, 0.17355151355563359, 0.18277724523822958, 0.14195011305864957, 0.1458796029894096, 0.1426064404081222, 0.14101597620439077, 0.1441162926604549, 0.15282202985716775, 0.14096434603863706, 0.14175390856222403, 0.16207881422481074, 0.18402833448490363, 0.16679477618376493, 0.16657141521439822, 0.1596427042756502, 0.15120231260257588, 0.1411966535145892, 0.16139484817187333, 0.1634028490223587, 0.17650083581544018, 0.15768378219198798, 0.15833462142207844, 0.16490498282695387, 0.150330135465925, 0.18886734367950586, 0.16045374486843178, 0.16855947523118198, 0.1733826927034039, 0.2028812417861957, 0.1757397014909311, 0.19094915976158955, 0.17585034123885257, 0.18683568409856555, 0.2135749380374129, 0.18382439475410084, 0.17594512205278, 0.18933528979092384, 0.20568880668582523, 0.058344077551123696, 0.055317793090979506, 0.06585155299632517, 0.05186305593955043, 0.05934830659822565, 0.055933964908894684, 0.07532529613519179, 0.05491659739916577, 0.06073069639553741]}, "mutation_prompt": null}
{"id": "89fc7198-3767-4268-8adc-f242a63a9c6c", "solution": "import numpy as np\nimport random\n\nclass AHQPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqspo = AHQPSO(budget, dim)\nbest_solution, best_fitness = ahqspo(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQPSO", "description": "Adaptive Hybridization of Harmony Search and Quantum-Behaved Particle Swarm Optimization (AHQPSO) - An adaptive hybrid algorithm that combines the exploration capabilities of Harmony Search with the exploitation capabilities of Quantum-Behaved Particle Swarm Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9b0d618-7a35-434e-b25a-70310dd42c6e", "metadata": {"aucs": [0.1777139996739341, 0.17578811482102485, 0.170257377687277, 0.17150387971053227, 0.18818139055183436, 0.1743435064021196, 0.17856999940812623, 0.1627570653971666, 0.1900640255741839, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0420769044974153, 0.046540046771576415, 0.036843840851905174, 0.041028703578300574, 0.03732066520661048, 0.03948978223329991, 0.0528437448134802, 0.06702432684758475, 0.058711088734964334, 0.025979934130904825, 0.032508982847686774, 0.0481463786277756, 0.027803019802558393, 0.04926774209271334, 0.05702674525995721, 0.03768548859383769, 0.03992308285267243, 0.029898291447754133, 0.08746944629118047, 0.0741770523943478, 0.09087431849796956, 0.08822863271431869, 0.08032688292695478, 0.08639412375773481, 0.08222559889516068, 0.08620909750186001, 0.07933359613958268, 0.07973913569416458, 0.08043703106553202, 0.10171882691615464, 0.06783755759972065, 0.062276416502640486, 0.06130150772388787, 0.09472457566024695, 0.061028138297436585, 0.09992729358139563, 0.12553619411724048, 0.19308637766117165, 0.1481850439168273, 0.10471519865355927, 0.09685346092514469, 0.13123694841517808, 0.12595553978877339, 0.1368487698841222, 0.11599925472713601, 0.0043507767599104685, 0.004560104586776803, 0.006205422871878197, 0.004189550067818515, 9.999999999998899e-05, 0.0004343670982023262, 9.999999999998899e-05, 9.999999999998899e-05, 0.019872591751231683, 0.008148577147152003, 0.06957272857429797, 9.999999999998899e-05, 0.011988543793833517, 0.035362057023575866, 0.011860097762603106, 0.017993280776203546, 0.006568189490159582, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05293794841224442, 0.06858859508378334, 0.045274884319672526, 0.06941906045599022, 0.03258759184138249, 0.055770453722678415, 0.05295698494644707, 0.05008726726802559, 0.06421743361722532, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006754747757416024, 9.999999999998899e-05, 0.22082032439354093, 0.19298032777251062, 0.19495588911784612, 0.2055799784281095, 0.18923395481742278, 0.20724700933075846, 0.1998807079546645, 0.17860340449937617, 0.20408032060320924, 0.05001390496924141, 0.04250646008327186, 0.04401887178405428, 0.04318053323128679, 0.04044574604984119, 0.046009660620107806, 0.073263588849099, 0.043993360971981255, 0.05229792848072812, 0.13752783092736576, 0.1273795545501043, 0.1372168098523947, 0.1412797182171618, 0.14115194246620144, 0.13013755749087796, 0.15034268976310372, 0.14861619065631115, 0.1338453581186947, 0.17182146956931754, 0.1605601443813055, 0.1760473800192245, 0.16779352461211916, 0.1821496595795835, 0.1769644640004372, 0.16591313548350284, 0.17377774300845283, 0.15374618240477322, 0.11534321591796037, 0.10382166168941254, 0.11849032669552728, 0.1123738480417984, 0.13610603218022022, 0.11676919299387534, 0.10628682615994733, 0.1237427242099084, 0.1229185550255375, 0.1410630187122207, 0.16233450221944246, 0.1583470274596206, 0.1601583581414543, 0.1453603756054126, 0.16236042742370171, 0.15533346120938785, 0.17355151355563359, 0.18277724523822958, 0.14195011305864957, 0.1458796029894096, 0.1426064404081222, 0.14101597620439077, 0.1441162926604549, 0.15282202985716775, 0.14096434603863706, 0.14175390856222403, 0.16207881422481074, 0.18402833448490363, 0.16679477618376493, 0.16657141521439822, 0.1596427042756502, 0.15120231260257588, 0.1411966535145892, 0.16139484817187333, 0.1634028490223587, 0.17650083581544018, 0.15768378219198798, 0.15833462142207844, 0.16490498282695387, 0.150330135465925, 0.18886734367950586, 0.16045374486843178, 0.16855947523118198, 0.1733826927034039, 0.2028812417861957, 0.1757397014909311, 0.19094915976158955, 0.17585034123885257, 0.18683568409856555, 0.2135749380374129, 0.18382439475410084, 0.17594512205278, 0.18933528979092384, 0.20568880668582523, 0.058344077551123696, 0.055317793090979506, 0.06585155299632517, 0.05186305593955043, 0.05934830659822565, 0.055933964908894684, 0.07532529613519179, 0.05491659739916577, 0.06073069639553741]}, "mutation_prompt": null}
{"id": "72fcb4a9-740e-4393-b6bb-6229f29ff987", "solution": "import numpy as np\nimport random\n\nclass AHQBACO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco = AHQBACO(budget, dim)\nbest_solution, best_fitness = ahqbaco(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization (AHQBACO) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization.", "configspace": "", "generation": 2, "fitness": 0.0919437890223552, "feedback": "The algorithm AHQBACO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": "f9b0d618-7a35-434e-b25a-70310dd42c6e", "metadata": {"aucs": [0.1679206248099212, 0.1730397538914542, 0.15954351657358878, 0.15404605366386603, 0.1648562418301468, 0.15898560438757192, 0.1627080782607181, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03143133387113628, 0.042299821549620864, 0.028786365634780098, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024995338660832367, 0.019581190153767913, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.06627008772211107, 0.06681197977842457, 0.07658319026970528, 0.07649533299022915, 0.07940608740585997, 0.0752590661214817, 0.07832626347259575, 0.07352620179891678, 0.07734145785707802, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.1926773706368211, 0.1608105915480288, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08905742753322088, 0.12806815271036465, 0.11275589901584737, 0.14907852280907952, 0.11207037063532244, 0.11185100965219175, 0.11303239351823924, 0.1178318544096354, 0.10442740715925158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18876344404115986, 0.1952465446966145, 0.17638713725373223, 0.18787450350182366, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03152262647728599, 0.04231214916752091, 0.13523484187121937, 0.11949803569855721, 0.1403075403980727, 0.13871562955069006, 0.13721084259603444, 0.10991010495874565, 0.14680156083880325, 0.1414549001063835, 0.12120314996980142, 0.1610745641389092, 0.14938782888659952, 0.16684772814827575, 0.17532727757374866, 0.1696172853400656, 0.16948801030744798, 0.15127901597955062, 0.17359018863582443, 0.14098282474331114, 0.09990585299789723, 0.08928782259693491, 0.10716775680921653, 0.12123726798047696, 0.12356593607112099, 0.12221803993150993, 0.09812208369943642, 0.12246757639898764, 0.11059392574141602, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1428554788833184, 0.138573316280035, 0.14977569096645127, 0.13979322800927452, 0.14616867812813394, 0.14085960050253765, 0.12623570558600972, 0.13526331024062344, 0.16012466570397244, 0.13001274008038144, 0.16111021637023348, 0.15824819331131224, 0.1513814835885421, 0.1353860294342618, 0.12082248404264118, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13364278059408274, 0.11961705079305107, 0.11996219230734095, 0.13675049794254157, 0.15881153565352435, 0.15864079118702246, 0.10988046452472044, 0.17088022390676283, 0.18556423272408507, 0.18519976647975844, 0.18697243178423184, 0.20971619836577715, 0.21455027575041663, 0.18258603635653925, 0.17634428845756733, 0.20268554675043404, 0.054158139718948006, 0.10910671837840769, 0.06407690351369455, 0.06002240575971174, 0.06099869662024471, 0.054207497242153346, 0.07290093633919859, 0.06374437679210643, 0.06514440219635964]}, "mutation_prompt": null}
{"id": "4dff9fb1-b53c-4f6a-8630-b599c3f8c403", "solution": "import numpy as np\nimport random\n\nclass AHQBACO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco = AHQBACO(budget, dim)\nbest_solution, best_fitness = ahqbaco(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization (AHQBACO) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72fcb4a9-740e-4393-b6bb-6229f29ff987", "metadata": {"aucs": [0.1679206248099212, 0.1730397538914542, 0.15954351657358878, 0.15404605366386603, 0.1648562418301468, 0.15898560438757192, 0.1627080782607181, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03143133387113628, 0.042299821549620864, 0.028786365634780098, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024995338660832367, 0.019581190153767913, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.06627008772211107, 0.06681197977842457, 0.07658319026970528, 0.07649533299022915, 0.07940608740585997, 0.0752590661214817, 0.07832626347259575, 0.07352620179891678, 0.07734145785707802, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.1926773706368211, 0.1608105915480288, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08905742753322088, 0.12806815271036465, 0.11275589901584737, 0.14907852280907952, 0.11207037063532244, 0.11185100965219175, 0.11303239351823924, 0.1178318544096354, 0.10442740715925158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18876344404115986, 0.1952465446966145, 0.17638713725373223, 0.18787450350182366, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03152262647728599, 0.04231214916752091, 0.13523484187121937, 0.11949803569855721, 0.1403075403980727, 0.13871562955069006, 0.13721084259603444, 0.10991010495874565, 0.14680156083880325, 0.1414549001063835, 0.12120314996980142, 0.1610745641389092, 0.14938782888659952, 0.16684772814827575, 0.17532727757374866, 0.1696172853400656, 0.16948801030744798, 0.15127901597955062, 0.17359018863582443, 0.14098282474331114, 0.09990585299789723, 0.08928782259693491, 0.10716775680921653, 0.12123726798047696, 0.12356593607112099, 0.12221803993150993, 0.09812208369943642, 0.12246757639898764, 0.11059392574141602, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1428554788833184, 0.138573316280035, 0.14977569096645127, 0.13979322800927452, 0.14616867812813394, 0.14085960050253765, 0.12623570558600972, 0.13526331024062344, 0.16012466570397244, 0.13001274008038144, 0.16111021637023348, 0.15824819331131224, 0.1513814835885421, 0.1353860294342618, 0.12082248404264118, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13364278059408274, 0.11961705079305107, 0.11996219230734095, 0.13675049794254157, 0.15881153565352435, 0.15864079118702246, 0.10988046452472044, 0.17088022390676283, 0.18556423272408507, 0.18519976647975844, 0.18697243178423184, 0.20971619836577715, 0.21455027575041663, 0.18258603635653925, 0.17634428845756733, 0.20268554675043404, 0.054158139718948006, 0.10910671837840769, 0.06407690351369455, 0.06002240575971174, 0.06099869662024471, 0.054207497242153346, 0.07290093633919859, 0.06374437679210643, 0.06514440219635964]}, "mutation_prompt": null}
{"id": "a0e4b999-a7db-4ede-ac20-86c4643eb22b", "solution": "import numpy as np\nimport random\n\nclass AHQBACO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco = AHQBACO(budget, dim)\nbest_solution, best_fitness = ahqbaco(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization (AHQBACO) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72fcb4a9-740e-4393-b6bb-6229f29ff987", "metadata": {"aucs": [0.1679206248099212, 0.1730397538914542, 0.15954351657358878, 0.15404605366386603, 0.1648562418301468, 0.15898560438757192, 0.1627080782607181, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03143133387113628, 0.042299821549620864, 0.028786365634780098, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024995338660832367, 0.019581190153767913, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.06627008772211107, 0.06681197977842457, 0.07658319026970528, 0.07649533299022915, 0.07940608740585997, 0.0752590661214817, 0.07832626347259575, 0.07352620179891678, 0.07734145785707802, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.1926773706368211, 0.1608105915480288, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08905742753322088, 0.12806815271036465, 0.11275589901584737, 0.14907852280907952, 0.11207037063532244, 0.11185100965219175, 0.11303239351823924, 0.1178318544096354, 0.10442740715925158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18876344404115986, 0.1952465446966145, 0.17638713725373223, 0.18787450350182366, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03152262647728599, 0.04231214916752091, 0.13523484187121937, 0.11949803569855721, 0.1403075403980727, 0.13871562955069006, 0.13721084259603444, 0.10991010495874565, 0.14680156083880325, 0.1414549001063835, 0.12120314996980142, 0.1610745641389092, 0.14938782888659952, 0.16684772814827575, 0.17532727757374866, 0.1696172853400656, 0.16948801030744798, 0.15127901597955062, 0.17359018863582443, 0.14098282474331114, 0.09990585299789723, 0.08928782259693491, 0.10716775680921653, 0.12123726798047696, 0.12356593607112099, 0.12221803993150993, 0.09812208369943642, 0.12246757639898764, 0.11059392574141602, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1428554788833184, 0.138573316280035, 0.14977569096645127, 0.13979322800927452, 0.14616867812813394, 0.14085960050253765, 0.12623570558600972, 0.13526331024062344, 0.16012466570397244, 0.13001274008038144, 0.16111021637023348, 0.15824819331131224, 0.1513814835885421, 0.1353860294342618, 0.12082248404264118, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13364278059408274, 0.11961705079305107, 0.11996219230734095, 0.13675049794254157, 0.15881153565352435, 0.15864079118702246, 0.10988046452472044, 0.17088022390676283, 0.18556423272408507, 0.18519976647975844, 0.18697243178423184, 0.20971619836577715, 0.21455027575041663, 0.18258603635653925, 0.17634428845756733, 0.20268554675043404, 0.054158139718948006, 0.10910671837840769, 0.06407690351369455, 0.06002240575971174, 0.06099869662024471, 0.054207497242153346, 0.07290093633919859, 0.06374437679210643, 0.06514440219635964]}, "mutation_prompt": null}
{"id": "caadefad-53a5-4543-a83a-3232c3c614e3", "solution": "import numpy as np\nimport random\n\nclass AHQBACO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco = AHQBACO(budget, dim)\nbest_solution, best_fitness = ahqbaco(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization (AHQBACO) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72fcb4a9-740e-4393-b6bb-6229f29ff987", "metadata": {"aucs": [0.1679206248099212, 0.1730397538914542, 0.15954351657358878, 0.15404605366386603, 0.1648562418301468, 0.15898560438757192, 0.1627080782607181, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03143133387113628, 0.042299821549620864, 0.028786365634780098, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024995338660832367, 0.019581190153767913, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.06627008772211107, 0.06681197977842457, 0.07658319026970528, 0.07649533299022915, 0.07940608740585997, 0.0752590661214817, 0.07832626347259575, 0.07352620179891678, 0.07734145785707802, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.1926773706368211, 0.1608105915480288, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08905742753322088, 0.12806815271036465, 0.11275589901584737, 0.14907852280907952, 0.11207037063532244, 0.11185100965219175, 0.11303239351823924, 0.1178318544096354, 0.10442740715925158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18876344404115986, 0.1952465446966145, 0.17638713725373223, 0.18787450350182366, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03152262647728599, 0.04231214916752091, 0.13523484187121937, 0.11949803569855721, 0.1403075403980727, 0.13871562955069006, 0.13721084259603444, 0.10991010495874565, 0.14680156083880325, 0.1414549001063835, 0.12120314996980142, 0.1610745641389092, 0.14938782888659952, 0.16684772814827575, 0.17532727757374866, 0.1696172853400656, 0.16948801030744798, 0.15127901597955062, 0.17359018863582443, 0.14098282474331114, 0.09990585299789723, 0.08928782259693491, 0.10716775680921653, 0.12123726798047696, 0.12356593607112099, 0.12221803993150993, 0.09812208369943642, 0.12246757639898764, 0.11059392574141602, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1428554788833184, 0.138573316280035, 0.14977569096645127, 0.13979322800927452, 0.14616867812813394, 0.14085960050253765, 0.12623570558600972, 0.13526331024062344, 0.16012466570397244, 0.13001274008038144, 0.16111021637023348, 0.15824819331131224, 0.1513814835885421, 0.1353860294342618, 0.12082248404264118, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13364278059408274, 0.11961705079305107, 0.11996219230734095, 0.13675049794254157, 0.15881153565352435, 0.15864079118702246, 0.10988046452472044, 0.17088022390676283, 0.18556423272408507, 0.18519976647975844, 0.18697243178423184, 0.20971619836577715, 0.21455027575041663, 0.18258603635653925, 0.17634428845756733, 0.20268554675043404, 0.054158139718948006, 0.10910671837840769, 0.06407690351369455, 0.06002240575971174, 0.06099869662024471, 0.054207497242153346, 0.07290093633919859, 0.06374437679210643, 0.06514440219635964]}, "mutation_prompt": null}
{"id": "bb1d1ce3-4cad-4a77-9402-71a1e40f6c14", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            # Differential Evolution\n            if i >= self.budget // 2:\n                r1, r2, r3 = random.sample(range(self.budget), 3)\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[r1] - self.harmony_memory[r2]) + self.CR * (self.onlooker_bees[r3] - self.harmony_memory[r1])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                if func(trial_solution) < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_de = AHQBACO_DE(budget, dim)\nbest_solution, best_fitness = ahqbaco_de(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DE", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization with Differential Evolution (AHQBACO-DE) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization and incorporates Differential Evolution for enhanced global search.", "configspace": "", "generation": 6, "fitness": 0.0919437890223552, "feedback": "The algorithm AHQBACO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": "72fcb4a9-740e-4393-b6bb-6229f29ff987", "metadata": {"aucs": [0.1679206248099212, 0.1730397538914542, 0.15954351657358878, 0.15404605366386603, 0.1648562418301468, 0.15898560438757192, 0.1627080782607181, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03143133387113628, 0.042299821549620864, 0.028786365634780098, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024995338660832367, 0.019581190153767913, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.06627008772211107, 0.06681197977842457, 0.07658319026970528, 0.07649533299022915, 0.07940608740585997, 0.0752590661214817, 0.07832626347259575, 0.07352620179891678, 0.07734145785707802, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.1926773706368211, 0.1608105915480288, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08905742753322088, 0.12806815271036465, 0.11275589901584737, 0.14907852280907952, 0.11207037063532244, 0.11185100965219175, 0.11303239351823924, 0.1178318544096354, 0.10442740715925158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18876344404115986, 0.1952465446966145, 0.17638713725373223, 0.18787450350182366, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03152262647728599, 0.04231214916752091, 0.13523484187121937, 0.11949803569855721, 0.1403075403980727, 0.13871562955069006, 0.13721084259603444, 0.10991010495874565, 0.14680156083880325, 0.1414549001063835, 0.12120314996980142, 0.1610745641389092, 0.14938782888659952, 0.16684772814827575, 0.17532727757374866, 0.1696172853400656, 0.16948801030744798, 0.15127901597955062, 0.17359018863582443, 0.14098282474331114, 0.09990585299789723, 0.08928782259693491, 0.10716775680921653, 0.12123726798047696, 0.12356593607112099, 0.12221803993150993, 0.09812208369943642, 0.12246757639898764, 0.11059392574141602, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1428554788833184, 0.138573316280035, 0.14977569096645127, 0.13979322800927452, 0.14616867812813394, 0.14085960050253765, 0.12623570558600972, 0.13526331024062344, 0.16012466570397244, 0.13001274008038144, 0.16111021637023348, 0.15824819331131224, 0.1513814835885421, 0.1353860294342618, 0.12082248404264118, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13364278059408274, 0.11961705079305107, 0.11996219230734095, 0.13675049794254157, 0.15881153565352435, 0.15864079118702246, 0.10988046452472044, 0.17088022390676283, 0.18556423272408507, 0.18519976647975844, 0.18697243178423184, 0.20971619836577715, 0.21455027575041663, 0.18258603635653925, 0.17634428845756733, 0.20268554675043404, 0.054158139718948006, 0.10910671837840769, 0.06407690351369455, 0.06002240575971174, 0.06099869662024471, 0.054207497242153346, 0.07290093633919859, 0.06374437679210643, 0.06514440219635964]}, "mutation_prompt": null}
{"id": "62431911-a0f6-4622-ae4e-5098ff406daa", "solution": "import numpy as np\nimport random\n\nclass AHQBACO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.probability = 0.5\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Dynamically adjust probability of exploration and exploitation\n            self.probability = 0.5 + 0.2 * (1 - i / self.budget)\n            # Harmony Search\n            if random.random() < self.probability:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco = AHQBACO(budget, dim)\nbest_solution, best_fitness = ahqbaco(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization with Dynamically Adjusted Probability of Exploration and Exploitation.", "configspace": "", "generation": 7, "fitness": 0.0919437890223552, "feedback": "The algorithm AHQBACO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": "72fcb4a9-740e-4393-b6bb-6229f29ff987", "metadata": {"aucs": [0.1679206248099212, 0.1730397538914542, 0.15954351657358878, 0.15404605366386603, 0.1648562418301468, 0.15898560438757192, 0.1627080782607181, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03143133387113628, 0.042299821549620864, 0.028786365634780098, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024995338660832367, 0.019581190153767913, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.06627008772211107, 0.06681197977842457, 0.07658319026970528, 0.07649533299022915, 0.07940608740585997, 0.0752590661214817, 0.07832626347259575, 0.07352620179891678, 0.07734145785707802, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.1926773706368211, 0.1608105915480288, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08905742753322088, 0.12806815271036465, 0.11275589901584737, 0.14907852280907952, 0.11207037063532244, 0.11185100965219175, 0.11303239351823924, 0.1178318544096354, 0.10442740715925158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18876344404115986, 0.1952465446966145, 0.17638713725373223, 0.18787450350182366, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03152262647728599, 0.04231214916752091, 0.13523484187121937, 0.11949803569855721, 0.1403075403980727, 0.13871562955069006, 0.13721084259603444, 0.10991010495874565, 0.14680156083880325, 0.1414549001063835, 0.12120314996980142, 0.1610745641389092, 0.14938782888659952, 0.16684772814827575, 0.17532727757374866, 0.1696172853400656, 0.16948801030744798, 0.15127901597955062, 0.17359018863582443, 0.14098282474331114, 0.09990585299789723, 0.08928782259693491, 0.10716775680921653, 0.12123726798047696, 0.12356593607112099, 0.12221803993150993, 0.09812208369943642, 0.12246757639898764, 0.11059392574141602, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1428554788833184, 0.138573316280035, 0.14977569096645127, 0.13979322800927452, 0.14616867812813394, 0.14085960050253765, 0.12623570558600972, 0.13526331024062344, 0.16012466570397244, 0.13001274008038144, 0.16111021637023348, 0.15824819331131224, 0.1513814835885421, 0.1353860294342618, 0.12082248404264118, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13364278059408274, 0.11961705079305107, 0.11996219230734095, 0.13675049794254157, 0.15881153565352435, 0.15864079118702246, 0.10988046452472044, 0.17088022390676283, 0.18556423272408507, 0.18519976647975844, 0.18697243178423184, 0.20971619836577715, 0.21455027575041663, 0.18258603635653925, 0.17634428845756733, 0.20268554675043404, 0.054158139718948006, 0.10910671837840769, 0.06407690351369455, 0.06002240575971174, 0.06099869662024471, 0.054207497242153346, 0.07290093633919859, 0.06374437679210643, 0.06514440219635964]}, "mutation_prompt": null}
{"id": "517bff49-f551-42dd-a7fd-62563fff736d", "solution": "import numpy as np\nimport random\n\nclass AHQBACO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco = AHQBACO(budget, dim)\nbest_solution, best_fitness = ahqbaco(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization (AHQBACO) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72fcb4a9-740e-4393-b6bb-6229f29ff987", "metadata": {"aucs": [0.1679206248099212, 0.1730397538914542, 0.15954351657358878, 0.15404605366386603, 0.1648562418301468, 0.15898560438757192, 0.1627080782607181, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03143133387113628, 0.042299821549620864, 0.028786365634780098, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024995338660832367, 0.019581190153767913, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.06627008772211107, 0.06681197977842457, 0.07658319026970528, 0.07649533299022915, 0.07940608740585997, 0.0752590661214817, 0.07832626347259575, 0.07352620179891678, 0.07734145785707802, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.1926773706368211, 0.1608105915480288, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08905742753322088, 0.12806815271036465, 0.11275589901584737, 0.14907852280907952, 0.11207037063532244, 0.11185100965219175, 0.11303239351823924, 0.1178318544096354, 0.10442740715925158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18876344404115986, 0.1952465446966145, 0.17638713725373223, 0.18787450350182366, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03152262647728599, 0.04231214916752091, 0.13523484187121937, 0.11949803569855721, 0.1403075403980727, 0.13871562955069006, 0.13721084259603444, 0.10991010495874565, 0.14680156083880325, 0.1414549001063835, 0.12120314996980142, 0.1610745641389092, 0.14938782888659952, 0.16684772814827575, 0.17532727757374866, 0.1696172853400656, 0.16948801030744798, 0.15127901597955062, 0.17359018863582443, 0.14098282474331114, 0.09990585299789723, 0.08928782259693491, 0.10716775680921653, 0.12123726798047696, 0.12356593607112099, 0.12221803993150993, 0.09812208369943642, 0.12246757639898764, 0.11059392574141602, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1428554788833184, 0.138573316280035, 0.14977569096645127, 0.13979322800927452, 0.14616867812813394, 0.14085960050253765, 0.12623570558600972, 0.13526331024062344, 0.16012466570397244, 0.13001274008038144, 0.16111021637023348, 0.15824819331131224, 0.1513814835885421, 0.1353860294342618, 0.12082248404264118, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13364278059408274, 0.11961705079305107, 0.11996219230734095, 0.13675049794254157, 0.15881153565352435, 0.15864079118702246, 0.10988046452472044, 0.17088022390676283, 0.18556423272408507, 0.18519976647975844, 0.18697243178423184, 0.20971619836577715, 0.21455027575041663, 0.18258603635653925, 0.17634428845756733, 0.20268554675043404, 0.054158139718948006, 0.10910671837840769, 0.06407690351369455, 0.06002240575971174, 0.06099869662024471, 0.054207497242153346, 0.07290093633919859, 0.06374437679210643, 0.06514440219635964]}, "mutation_prompt": null}
{"id": "f3aa1b3d-4db4-4bf4-b7f5-f909d770d3fd", "solution": "import numpy as np\nimport random\n\nclass AHQBACO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco = AHQBACO(budget, dim)\nbest_solution, best_fitness = ahqbaco(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization (AHQBACO) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72fcb4a9-740e-4393-b6bb-6229f29ff987", "metadata": {"aucs": [0.1679206248099212, 0.1730397538914542, 0.15954351657358878, 0.15404605366386603, 0.1648562418301468, 0.15898560438757192, 0.1627080782607181, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03143133387113628, 0.042299821549620864, 0.028786365634780098, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024995338660832367, 0.019581190153767913, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.06627008772211107, 0.06681197977842457, 0.07658319026970528, 0.07649533299022915, 0.07940608740585997, 0.0752590661214817, 0.07832626347259575, 0.07352620179891678, 0.07734145785707802, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.1926773706368211, 0.1608105915480288, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08905742753322088, 0.12806815271036465, 0.11275589901584737, 0.14907852280907952, 0.11207037063532244, 0.11185100965219175, 0.11303239351823924, 0.1178318544096354, 0.10442740715925158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18876344404115986, 0.1952465446966145, 0.17638713725373223, 0.18787450350182366, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03152262647728599, 0.04231214916752091, 0.13523484187121937, 0.11949803569855721, 0.1403075403980727, 0.13871562955069006, 0.13721084259603444, 0.10991010495874565, 0.14680156083880325, 0.1414549001063835, 0.12120314996980142, 0.1610745641389092, 0.14938782888659952, 0.16684772814827575, 0.17532727757374866, 0.1696172853400656, 0.16948801030744798, 0.15127901597955062, 0.17359018863582443, 0.14098282474331114, 0.09990585299789723, 0.08928782259693491, 0.10716775680921653, 0.12123726798047696, 0.12356593607112099, 0.12221803993150993, 0.09812208369943642, 0.12246757639898764, 0.11059392574141602, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1428554788833184, 0.138573316280035, 0.14977569096645127, 0.13979322800927452, 0.14616867812813394, 0.14085960050253765, 0.12623570558600972, 0.13526331024062344, 0.16012466570397244, 0.13001274008038144, 0.16111021637023348, 0.15824819331131224, 0.1513814835885421, 0.1353860294342618, 0.12082248404264118, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13364278059408274, 0.11961705079305107, 0.11996219230734095, 0.13675049794254157, 0.15881153565352435, 0.15864079118702246, 0.10988046452472044, 0.17088022390676283, 0.18556423272408507, 0.18519976647975844, 0.18697243178423184, 0.20971619836577715, 0.21455027575041663, 0.18258603635653925, 0.17634428845756733, 0.20268554675043404, 0.054158139718948006, 0.10910671837840769, 0.06407690351369455, 0.06002240575971174, 0.06099869662024471, 0.054207497242153346, 0.07290093633919859, 0.06374437679210643, 0.06514440219635964]}, "mutation_prompt": null}
{"id": "474a16a5-2469-4360-8b69-96da2584baef", "solution": "import numpy as np\nimport random\n\nclass AHQBACO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco = AHQBACO(budget, dim)\nbest_solution, best_fitness = ahqbaco(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization (AHQBACO) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72fcb4a9-740e-4393-b6bb-6229f29ff987", "metadata": {"aucs": [0.1679206248099212, 0.1730397538914542, 0.15954351657358878, 0.15404605366386603, 0.1648562418301468, 0.15898560438757192, 0.1627080782607181, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03143133387113628, 0.042299821549620864, 0.028786365634780098, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024995338660832367, 0.019581190153767913, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.06627008772211107, 0.06681197977842457, 0.07658319026970528, 0.07649533299022915, 0.07940608740585997, 0.0752590661214817, 0.07832626347259575, 0.07352620179891678, 0.07734145785707802, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.1926773706368211, 0.1608105915480288, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08905742753322088, 0.12806815271036465, 0.11275589901584737, 0.14907852280907952, 0.11207037063532244, 0.11185100965219175, 0.11303239351823924, 0.1178318544096354, 0.10442740715925158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18876344404115986, 0.1952465446966145, 0.17638713725373223, 0.18787450350182366, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03152262647728599, 0.04231214916752091, 0.13523484187121937, 0.11949803569855721, 0.1403075403980727, 0.13871562955069006, 0.13721084259603444, 0.10991010495874565, 0.14680156083880325, 0.1414549001063835, 0.12120314996980142, 0.1610745641389092, 0.14938782888659952, 0.16684772814827575, 0.17532727757374866, 0.1696172853400656, 0.16948801030744798, 0.15127901597955062, 0.17359018863582443, 0.14098282474331114, 0.09990585299789723, 0.08928782259693491, 0.10716775680921653, 0.12123726798047696, 0.12356593607112099, 0.12221803993150993, 0.09812208369943642, 0.12246757639898764, 0.11059392574141602, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1428554788833184, 0.138573316280035, 0.14977569096645127, 0.13979322800927452, 0.14616867812813394, 0.14085960050253765, 0.12623570558600972, 0.13526331024062344, 0.16012466570397244, 0.13001274008038144, 0.16111021637023348, 0.15824819331131224, 0.1513814835885421, 0.1353860294342618, 0.12082248404264118, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13364278059408274, 0.11961705079305107, 0.11996219230734095, 0.13675049794254157, 0.15881153565352435, 0.15864079118702246, 0.10988046452472044, 0.17088022390676283, 0.18556423272408507, 0.18519976647975844, 0.18697243178423184, 0.20971619836577715, 0.21455027575041663, 0.18258603635653925, 0.17634428845756733, 0.20268554675043404, 0.054158139718948006, 0.10910671837840769, 0.06407690351369455, 0.06002240575971174, 0.06099869662024471, 0.054207497242153346, 0.07290093633919859, 0.06374437679210643, 0.06514440219635964]}, "mutation_prompt": null}
{"id": "eb406a6b-b1c2-43f2-8ec6-b2517ea37fb4", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_EQVU:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                # Enhanced Quantum Velocity Update\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim) * np.exp(-np.random.uniform(0, 1)))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_eqvu = AHQBACO_EQVU(budget, dim)\nbest_solution, best_fitness = ahqbaco_eqvu(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_EQVU", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization with Enhanced Quantum Velocity Update (AHQBACO-EQVU) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization, enhanced with a novel quantum velocity update strategy.", "configspace": "", "generation": 11, "fitness": 0.0913874903859444, "feedback": "The algorithm AHQBACO_EQVU got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": "72fcb4a9-740e-4393-b6bb-6229f29ff987", "metadata": {"aucs": [0.16847670563310002, 0.17315246682932572, 0.15986706082690538, 0.15404605366386603, 0.1648562418301468, 0.15896411614583772, 0.16271175500102564, 0.1394327624586822, 0.14875652322618194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031080645324328526, 0.04229920659856412, 0.028809072115973833, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02305610914330014, 0.016886019185531786, 0.03032385339547805, 0.01969646754387211, 0.03324384160719274, 0.04442032952410169, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.06627008772211107, 0.06681197977842457, 0.07658319424653837, 0.07649533299022915, 0.07940608740585997, 0.07525896959157452, 0.07832626347259575, 0.07352620179891678, 0.07734145785707802, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.1643323744195423, 0.1920602701188897, 0.17142809598165054, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.10461284187863984, 0.13204106908395674, 0.12238244945258414, 0.10574511758810401, 0.10254425865019035, 0.13265687597540565, 0.10558410392878415, 0.12481744200383671, 0.09826307027808234, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.031232590993447995, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066457767062868, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18874501413220757, 0.1936390814702279, 0.1768854936194757, 0.1893005568411943, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037738964235411565, 0.03149266130555939, 0.04231214916752091, 0.13526369017723194, 0.12851180585808764, 0.12270718884325893, 0.138721549059328, 0.13721084259603444, 0.10978102578027171, 0.1457017828912145, 0.14244422376407107, 0.13498736079027607, 0.16064120313837338, 0.14955560823646374, 0.16680452365995024, 0.18362359351350477, 0.16592008115974588, 0.17992802470475167, 0.15127901597955062, 0.17358279159389045, 0.1407299701069813, 0.09990338604709592, 0.089294766279151, 0.1071915995426882, 0.12441385466961996, 0.12145734005054287, 0.12748285224040357, 0.09812208369943642, 0.12248496761002425, 0.11058124878447961, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.2601824680846143, 0.26017734341597376, 0.2601763624133814, 0.2601875539181707, 0.2601749966015179, 0.2601818706513471, 0.13893520562352002, 0.13850612184474753, 0.13725347424948775, 0.1338884377007845, 0.13863313354235596, 0.14203414602605002, 0.1424595426081069, 0.12795496624497915, 0.15943127996743112, 0.1298152131520921, 0.16262701114292888, 0.16041440670575957, 0.1514278405568491, 0.1353881671987741, 0.12057833564554055, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.1400989037405388, 0.13449798490680187, 0.13400576898175054, 0.11958826615339746, 0.11999474810315747, 0.13675049794254157, 0.15890561977648976, 0.15975527131259148, 0.10987883443796476, 0.17802186758397087, 0.18322803013045175, 0.17935130509981667, 0.1868314550350043, 0.20774338612579946, 0.1714900338479285, 0.18199765277714686, 0.1735103028865056, 0.20028432606723978, 0.05794844480255923, 0.051811950469924484, 0.06941861086936674, 0.058688733636069634, 0.06030565163646606, 0.06419257760202768, 0.07485174327798727, 0.0562823433148143, 0.05589873983859128]}, "mutation_prompt": null}
{"id": "6e805eae-f96d-4ac5-ba72-8676bb5db510", "solution": "import numpy as np\nimport random\n\nclass AHQBACO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco = AHQBACO(budget, dim)\nbest_solution, best_fitness = ahqbaco(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization (AHQBACO) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72fcb4a9-740e-4393-b6bb-6229f29ff987", "metadata": {"aucs": [0.1679206248099212, 0.1730397538914542, 0.15954351657358878, 0.15404605366386603, 0.1648562418301468, 0.15898560438757192, 0.1627080782607181, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03143133387113628, 0.042299821549620864, 0.028786365634780098, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024995338660832367, 0.019581190153767913, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.06627008772211107, 0.06681197977842457, 0.07658319026970528, 0.07649533299022915, 0.07940608740585997, 0.0752590661214817, 0.07832626347259575, 0.07352620179891678, 0.07734145785707802, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.1926773706368211, 0.1608105915480288, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08905742753322088, 0.12806815271036465, 0.11275589901584737, 0.14907852280907952, 0.11207037063532244, 0.11185100965219175, 0.11303239351823924, 0.1178318544096354, 0.10442740715925158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18876344404115986, 0.1952465446966145, 0.17638713725373223, 0.18787450350182366, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03152262647728599, 0.04231214916752091, 0.13523484187121937, 0.11949803569855721, 0.1403075403980727, 0.13871562955069006, 0.13721084259603444, 0.10991010495874565, 0.14680156083880325, 0.1414549001063835, 0.12120314996980142, 0.1610745641389092, 0.14938782888659952, 0.16684772814827575, 0.17532727757374866, 0.1696172853400656, 0.16948801030744798, 0.15127901597955062, 0.17359018863582443, 0.14098282474331114, 0.09990585299789723, 0.08928782259693491, 0.10716775680921653, 0.12123726798047696, 0.12356593607112099, 0.12221803993150993, 0.09812208369943642, 0.12246757639898764, 0.11059392574141602, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1428554788833184, 0.138573316280035, 0.14977569096645127, 0.13979322800927452, 0.14616867812813394, 0.14085960050253765, 0.12623570558600972, 0.13526331024062344, 0.16012466570397244, 0.13001274008038144, 0.16111021637023348, 0.15824819331131224, 0.1513814835885421, 0.1353860294342618, 0.12082248404264118, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13364278059408274, 0.11961705079305107, 0.11996219230734095, 0.13675049794254157, 0.15881153565352435, 0.15864079118702246, 0.10988046452472044, 0.17088022390676283, 0.18556423272408507, 0.18519976647975844, 0.18697243178423184, 0.20971619836577715, 0.21455027575041663, 0.18258603635653925, 0.17634428845756733, 0.20268554675043404, 0.054158139718948006, 0.10910671837840769, 0.06407690351369455, 0.06002240575971174, 0.06099869662024471, 0.054207497242153346, 0.07290093633919859, 0.06374437679210643, 0.06514440219635964]}, "mutation_prompt": null}
{"id": "e9c26f94-0a32-4c32-b01d-43a617964ab5", "solution": "import numpy as np\nimport random\n\nclass AHQBACO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco = AHQBACO(budget, dim)\nbest_solution, best_fitness = ahqbaco(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization (AHQBACO) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72fcb4a9-740e-4393-b6bb-6229f29ff987", "metadata": {"aucs": [0.1679206248099212, 0.1730397538914542, 0.15954351657358878, 0.15404605366386603, 0.1648562418301468, 0.15898560438757192, 0.1627080782607181, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03143133387113628, 0.042299821549620864, 0.028786365634780098, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024995338660832367, 0.019581190153767913, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.06627008772211107, 0.06681197977842457, 0.07658319026970528, 0.07649533299022915, 0.07940608740585997, 0.0752590661214817, 0.07832626347259575, 0.07352620179891678, 0.07734145785707802, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.1926773706368211, 0.1608105915480288, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08905742753322088, 0.12806815271036465, 0.11275589901584737, 0.14907852280907952, 0.11207037063532244, 0.11185100965219175, 0.11303239351823924, 0.1178318544096354, 0.10442740715925158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18876344404115986, 0.1952465446966145, 0.17638713725373223, 0.18787450350182366, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03152262647728599, 0.04231214916752091, 0.13523484187121937, 0.11949803569855721, 0.1403075403980727, 0.13871562955069006, 0.13721084259603444, 0.10991010495874565, 0.14680156083880325, 0.1414549001063835, 0.12120314996980142, 0.1610745641389092, 0.14938782888659952, 0.16684772814827575, 0.17532727757374866, 0.1696172853400656, 0.16948801030744798, 0.15127901597955062, 0.17359018863582443, 0.14098282474331114, 0.09990585299789723, 0.08928782259693491, 0.10716775680921653, 0.12123726798047696, 0.12356593607112099, 0.12221803993150993, 0.09812208369943642, 0.12246757639898764, 0.11059392574141602, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1428554788833184, 0.138573316280035, 0.14977569096645127, 0.13979322800927452, 0.14616867812813394, 0.14085960050253765, 0.12623570558600972, 0.13526331024062344, 0.16012466570397244, 0.13001274008038144, 0.16111021637023348, 0.15824819331131224, 0.1513814835885421, 0.1353860294342618, 0.12082248404264118, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13364278059408274, 0.11961705079305107, 0.11996219230734095, 0.13675049794254157, 0.15881153565352435, 0.15864079118702246, 0.10988046452472044, 0.17088022390676283, 0.18556423272408507, 0.18519976647975844, 0.18697243178423184, 0.20971619836577715, 0.21455027575041663, 0.18258603635653925, 0.17634428845756733, 0.20268554675043404, 0.054158139718948006, 0.10910671837840769, 0.06407690351369455, 0.06002240575971174, 0.06099869662024471, 0.054207497242153346, 0.07290093633919859, 0.06374437679210643, 0.06514440219635964]}, "mutation_prompt": null}
{"id": "070b0d68-a681-47f2-896a-84bdeb8a6835", "solution": "import numpy as np\nimport random\n\nclass AHQBACO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.mutation_probability = 0.5\n        self.dynamic_parameter = 0.5\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.mutation_probability:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n                # Dynamic parameter adaptation\n                self.dynamic_parameter = 0.5 + 0.2 * np.random.uniform(-1, 1)\n                self.mutation_probability = 0.5 + 0.1 * np.random.uniform(-1, 1)\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco = AHQBACO(budget, dim)\nbest_solution, best_fitness = ahqbaco(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization with Dynamic Parameter Adaptation and Self-Adaptive Mutation Probability.", "configspace": "", "generation": 14, "fitness": 0.09106616965278864, "feedback": "The algorithm AHQBACO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": "72fcb4a9-740e-4393-b6bb-6229f29ff987", "metadata": {"aucs": [0.16836984127394827, 0.17321972761587, 0.15894483716058172, 0.15403367629343134, 0.16485424983197405, 0.15898560438757192, 0.1627100739152354, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030882287120201357, 0.04229676289419204, 0.028808228427551485, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02233150231622949, 0.019301171753611013, 0.030284104675209478, 0.01969646754387211, 0.033296493522723125, 0.04442032952410169, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.06627008772211107, 0.06681197977842457, 0.07658319424653837, 0.07649533299022915, 0.07940608740585997, 0.0752590661214817, 0.07832626347259575, 0.07352620179891678, 0.07734145785707802, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03206108743577474, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15859626761479617, 0.19325901717889693, 0.15626823701190407, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.1012279087731669, 0.11049611360884193, 0.11087762611540553, 0.097121729416497, 0.11707276838854364, 0.11760509761671001, 0.10954864507988327, 0.09624953837246408, 0.09272311372582431, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.05665304223455714, 0.021831543164293143, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20663545778460557, 0.18834777022491744, 0.17579218048408696, 0.19993768247722887, 0.17742555383982783, 0.1887654330634927, 0.19548987931644302, 0.1751989089614976, 0.18821348284584305, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.032419446337311086, 0.039398907522902316, 0.037806129429233226, 0.031731264781534096, 0.04231214916752091, 0.13867926288161347, 0.12932212017894984, 0.11882099889653075, 0.13871562955069006, 0.13721084259603444, 0.10976293303063778, 0.14662683065022608, 0.14958439452305916, 0.11766167542833605, 0.16123655891131983, 0.14949800932642754, 0.16680708812501743, 0.174747186164244, 0.1712483599909912, 0.17593048943926892, 0.15127901597955062, 0.1735513051076003, 0.14099254424354746, 0.09992485560734332, 0.08934110711536947, 0.1072006177731264, 0.12030427268412769, 0.121367369686872, 0.12319403899543091, 0.09812208369943642, 0.12247426488315882, 0.11069531153863077, 0.26018223221605774, 0.2601763462457861, 0.26017841665814934, 0.26018132180600584, 0.26017295935158313, 0.26017623524504585, 0.2711981198515824, 0.2601737466540327, 0.2601794947077204, 0.13927039698949517, 0.14025860677032165, 0.14377885158585135, 0.13585154658893572, 0.14878940279668007, 0.14697452155250812, 0.15371095740828356, 0.15091233711065322, 0.16112281026459785, 0.127724706726146, 0.16251523111685806, 0.15865414849016413, 0.15133598276863014, 0.13539319478723677, 0.12063180162462162, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14366718702491377, 0.13406252454194778, 0.1338534791570073, 0.11958652933029024, 0.1200207530276044, 0.13675049794254157, 0.15855936617686783, 0.15677892011114924, 0.10970957791147606, 0.17082728343538256, 0.18493857057250151, 0.16904308903143062, 0.1842612123568389, 0.20552401590902258, 0.17579571353839385, 0.17774862344441955, 0.1781545809194084, 0.20097736680959366, 0.0590891511434769, 0.05926344031463271, 0.06401799009546161, 0.05826716596295323, 0.06223233134801298, 0.053701146393711485, 0.0721026782606714, 0.05988169012593714, 0.05935786878310678]}, "mutation_prompt": null}
{"id": "79b5d2c1-4d93-4f2c-83df-4a8713df45f6", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_D:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.diversity = np.mean(np.linalg.norm(self.harmony_memory, axis=1))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Dynamic exploration rate\n            exploration_rate = 0.5 * (1 - self.diversity) + 0.5\n            # Harmony Search\n            if random.random() < exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                # Update diversity\n                self.diversity = np.mean(np.linalg.norm(self.harmony_memory, axis=1))\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                # Update diversity\n                self.diversity = np.mean(np.linalg.norm(self.harmony_memory, axis=1))\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_d = AHQBACO_D(budget, dim)\nbest_solution, best_fitness = ahqbaco_d(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_D", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization with Dynamic Exploration and Exploitation (AHQBACO-D): A dynamic adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization, and dynamically adjusts the exploration and exploitation rates based on the current population diversity.", "configspace": "", "generation": 15, "fitness": 0.0919437890223552, "feedback": "The algorithm AHQBACO_D got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": "72fcb4a9-740e-4393-b6bb-6229f29ff987", "metadata": {"aucs": [0.1679206248099212, 0.1730397538914542, 0.15954351657358878, 0.15404605366386603, 0.1648562418301468, 0.15898560438757192, 0.1627080782607181, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03143133387113628, 0.042299821549620864, 0.028786365634780098, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024995338660832367, 0.019581190153767913, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.06627008772211107, 0.06681197977842457, 0.07658319026970528, 0.07649533299022915, 0.07940608740585997, 0.0752590661214817, 0.07832626347259575, 0.07352620179891678, 0.07734145785707802, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.1926773706368211, 0.1608105915480288, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08905742753322088, 0.12806815271036465, 0.11275589901584737, 0.14907852280907952, 0.11207037063532244, 0.11185100965219175, 0.11303239351823924, 0.1178318544096354, 0.10442740715925158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18876344404115986, 0.1952465446966145, 0.17638713725373223, 0.18787450350182366, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03152262647728599, 0.04231214916752091, 0.13523484187121937, 0.11949803569855721, 0.1403075403980727, 0.13871562955069006, 0.13721084259603444, 0.10991010495874565, 0.14680156083880325, 0.1414549001063835, 0.12120314996980142, 0.1610745641389092, 0.14938782888659952, 0.16684772814827575, 0.17532727757374866, 0.1696172853400656, 0.16948801030744798, 0.15127901597955062, 0.17359018863582443, 0.14098282474331114, 0.09990585299789723, 0.08928782259693491, 0.10716775680921653, 0.12123726798047696, 0.12356593607112099, 0.12221803993150993, 0.09812208369943642, 0.12246757639898764, 0.11059392574141602, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1428554788833184, 0.138573316280035, 0.14977569096645127, 0.13979322800927452, 0.14616867812813394, 0.14085960050253765, 0.12623570558600972, 0.13526331024062344, 0.16012466570397244, 0.13001274008038144, 0.16111021637023348, 0.15824819331131224, 0.1513814835885421, 0.1353860294342618, 0.12082248404264118, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13364278059408274, 0.11961705079305107, 0.11996219230734095, 0.13675049794254157, 0.15881153565352435, 0.15864079118702246, 0.10988046452472044, 0.17088022390676283, 0.18556423272408507, 0.18519976647975844, 0.18697243178423184, 0.20971619836577715, 0.21455027575041663, 0.18258603635653925, 0.17634428845756733, 0.20268554675043404, 0.054158139718948006, 0.10910671837840769, 0.06407690351369455, 0.06002240575971174, 0.06099869662024471, 0.054207497242153346, 0.07290093633919859, 0.06374437679210643, 0.06514440219635964]}, "mutation_prompt": null}
{"id": "b883005c-006f-4539-a91f-142e6635667f", "solution": "import numpy as np\nimport random\n\nclass AHQBACO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco = AHQBACO(budget, dim)\nbest_solution, best_fitness = ahqbaco(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization (AHQBACO) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72fcb4a9-740e-4393-b6bb-6229f29ff987", "metadata": {"aucs": [0.1679206248099212, 0.1730397538914542, 0.15954351657358878, 0.15404605366386603, 0.1648562418301468, 0.15898560438757192, 0.1627080782607181, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03143133387113628, 0.042299821549620864, 0.028786365634780098, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024995338660832367, 0.019581190153767913, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.06627008772211107, 0.06681197977842457, 0.07658319026970528, 0.07649533299022915, 0.07940608740585997, 0.0752590661214817, 0.07832626347259575, 0.07352620179891678, 0.07734145785707802, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.1926773706368211, 0.1608105915480288, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08905742753322088, 0.12806815271036465, 0.11275589901584737, 0.14907852280907952, 0.11207037063532244, 0.11185100965219175, 0.11303239351823924, 0.1178318544096354, 0.10442740715925158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18876344404115986, 0.1952465446966145, 0.17638713725373223, 0.18787450350182366, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03152262647728599, 0.04231214916752091, 0.13523484187121937, 0.11949803569855721, 0.1403075403980727, 0.13871562955069006, 0.13721084259603444, 0.10991010495874565, 0.14680156083880325, 0.1414549001063835, 0.12120314996980142, 0.1610745641389092, 0.14938782888659952, 0.16684772814827575, 0.17532727757374866, 0.1696172853400656, 0.16948801030744798, 0.15127901597955062, 0.17359018863582443, 0.14098282474331114, 0.09990585299789723, 0.08928782259693491, 0.10716775680921653, 0.12123726798047696, 0.12356593607112099, 0.12221803993150993, 0.09812208369943642, 0.12246757639898764, 0.11059392574141602, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1428554788833184, 0.138573316280035, 0.14977569096645127, 0.13979322800927452, 0.14616867812813394, 0.14085960050253765, 0.12623570558600972, 0.13526331024062344, 0.16012466570397244, 0.13001274008038144, 0.16111021637023348, 0.15824819331131224, 0.1513814835885421, 0.1353860294342618, 0.12082248404264118, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13364278059408274, 0.11961705079305107, 0.11996219230734095, 0.13675049794254157, 0.15881153565352435, 0.15864079118702246, 0.10988046452472044, 0.17088022390676283, 0.18556423272408507, 0.18519976647975844, 0.18697243178423184, 0.20971619836577715, 0.21455027575041663, 0.18258603635653925, 0.17634428845756733, 0.20268554675043404, 0.054158139718948006, 0.10910671837840769, 0.06407690351369455, 0.06002240575971174, 0.06099869662024471, 0.054207497242153346, 0.07290093633919859, 0.06374437679210643, 0.06514440219635964]}, "mutation_prompt": null}
{"id": "f6bc2375-c532-4434-8af8-24c74fc13244", "solution": "import numpy as np\nimport random\n\nclass AHQBACO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco = AHQBACO(budget, dim)\nbest_solution, best_fitness = ahqbaco(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization (AHQBACO) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72fcb4a9-740e-4393-b6bb-6229f29ff987", "metadata": {"aucs": [0.1679206248099212, 0.1730397538914542, 0.15954351657358878, 0.15404605366386603, 0.1648562418301468, 0.15898560438757192, 0.1627080782607181, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03143133387113628, 0.042299821549620864, 0.028786365634780098, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024995338660832367, 0.019581190153767913, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.06627008772211107, 0.06681197977842457, 0.07658319026970528, 0.07649533299022915, 0.07940608740585997, 0.0752590661214817, 0.07832626347259575, 0.07352620179891678, 0.07734145785707802, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.1926773706368211, 0.1608105915480288, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08905742753322088, 0.12806815271036465, 0.11275589901584737, 0.14907852280907952, 0.11207037063532244, 0.11185100965219175, 0.11303239351823924, 0.1178318544096354, 0.10442740715925158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18876344404115986, 0.1952465446966145, 0.17638713725373223, 0.18787450350182366, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03152262647728599, 0.04231214916752091, 0.13523484187121937, 0.11949803569855721, 0.1403075403980727, 0.13871562955069006, 0.13721084259603444, 0.10991010495874565, 0.14680156083880325, 0.1414549001063835, 0.12120314996980142, 0.1610745641389092, 0.14938782888659952, 0.16684772814827575, 0.17532727757374866, 0.1696172853400656, 0.16948801030744798, 0.15127901597955062, 0.17359018863582443, 0.14098282474331114, 0.09990585299789723, 0.08928782259693491, 0.10716775680921653, 0.12123726798047696, 0.12356593607112099, 0.12221803993150993, 0.09812208369943642, 0.12246757639898764, 0.11059392574141602, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1428554788833184, 0.138573316280035, 0.14977569096645127, 0.13979322800927452, 0.14616867812813394, 0.14085960050253765, 0.12623570558600972, 0.13526331024062344, 0.16012466570397244, 0.13001274008038144, 0.16111021637023348, 0.15824819331131224, 0.1513814835885421, 0.1353860294342618, 0.12082248404264118, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13364278059408274, 0.11961705079305107, 0.11996219230734095, 0.13675049794254157, 0.15881153565352435, 0.15864079118702246, 0.10988046452472044, 0.17088022390676283, 0.18556423272408507, 0.18519976647975844, 0.18697243178423184, 0.20971619836577715, 0.21455027575041663, 0.18258603635653925, 0.17634428845756733, 0.20268554675043404, 0.054158139718948006, 0.10910671837840769, 0.06407690351369455, 0.06002240575971174, 0.06099869662024471, 0.054207497242153346, 0.07290093633919859, 0.06374437679210643, 0.06514440219635964]}, "mutation_prompt": null}
{"id": "33d5ebb7-458d-4f1b-ba20-4bee90824741", "solution": "import numpy as np\nimport random\n\nclass AHQBACO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco = AHQBACO(budget, dim)\nbest_solution, best_fitness = ahqbaco(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization (AHQBACO) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72fcb4a9-740e-4393-b6bb-6229f29ff987", "metadata": {"aucs": [0.1679206248099212, 0.1730397538914542, 0.15954351657358878, 0.15404605366386603, 0.1648562418301468, 0.15898560438757192, 0.1627080782607181, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03143133387113628, 0.042299821549620864, 0.028786365634780098, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024995338660832367, 0.019581190153767913, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.06627008772211107, 0.06681197977842457, 0.07658319026970528, 0.07649533299022915, 0.07940608740585997, 0.0752590661214817, 0.07832626347259575, 0.07352620179891678, 0.07734145785707802, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.1926773706368211, 0.1608105915480288, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08905742753322088, 0.12806815271036465, 0.11275589901584737, 0.14907852280907952, 0.11207037063532244, 0.11185100965219175, 0.11303239351823924, 0.1178318544096354, 0.10442740715925158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18876344404115986, 0.1952465446966145, 0.17638713725373223, 0.18787450350182366, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03152262647728599, 0.04231214916752091, 0.13523484187121937, 0.11949803569855721, 0.1403075403980727, 0.13871562955069006, 0.13721084259603444, 0.10991010495874565, 0.14680156083880325, 0.1414549001063835, 0.12120314996980142, 0.1610745641389092, 0.14938782888659952, 0.16684772814827575, 0.17532727757374866, 0.1696172853400656, 0.16948801030744798, 0.15127901597955062, 0.17359018863582443, 0.14098282474331114, 0.09990585299789723, 0.08928782259693491, 0.10716775680921653, 0.12123726798047696, 0.12356593607112099, 0.12221803993150993, 0.09812208369943642, 0.12246757639898764, 0.11059392574141602, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1428554788833184, 0.138573316280035, 0.14977569096645127, 0.13979322800927452, 0.14616867812813394, 0.14085960050253765, 0.12623570558600972, 0.13526331024062344, 0.16012466570397244, 0.13001274008038144, 0.16111021637023348, 0.15824819331131224, 0.1513814835885421, 0.1353860294342618, 0.12082248404264118, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13364278059408274, 0.11961705079305107, 0.11996219230734095, 0.13675049794254157, 0.15881153565352435, 0.15864079118702246, 0.10988046452472044, 0.17088022390676283, 0.18556423272408507, 0.18519976647975844, 0.18697243178423184, 0.20971619836577715, 0.21455027575041663, 0.18258603635653925, 0.17634428845756733, 0.20268554675043404, 0.054158139718948006, 0.10910671837840769, 0.06407690351369455, 0.06002240575971174, 0.06099869662024471, 0.054207497242153346, 0.07290093633919859, 0.06374437679210643, 0.06514440219635964]}, "mutation_prompt": null}
{"id": "72aa72ee-e226-4516-b151-69c8c12b2627", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_LF_OB:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n\n    def levy_flight(self, x):\n        u = np.random.uniform(0, 1, self.dim)\n        v = np.random.uniform(0, 1, self.dim)\n        step_size = 0.01 * (u / (v ** (1 / 1.5)))\n        return x + step_size\n\n    def opposition_based_learning(self, x):\n        return -x + 10 * np.random.uniform(0, 1, self.dim)\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                if random.random() < 0.5:\n                    self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n                else:\n                    self.harmony_memory[i] = self.levy_flight(self.harmony_memory[i])\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            # Opposition-based learning\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.opposition_based_learning(self.harmony_memory[i])\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_lf_ob = AHQBACO_LF_OB(budget, dim)\nbest_solution, best_fitness = ahqbaco_lf_ob(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_LF_OB", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization with Levy Flight and Opposition-Based Learning (AHQBACO-LF-OB).", "configspace": "", "generation": 19, "fitness": 0.09170010317905211, "feedback": "The algorithm AHQBACO_LF_OB got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": "72fcb4a9-740e-4393-b6bb-6229f29ff987", "metadata": {"aucs": [0.16831769711753386, 0.17311307434443002, 0.15937862035576, 0.15405448214738426, 0.1648562418301468, 0.1590100166789975, 0.16270787239075957, 0.13943664263821687, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03105910532670786, 0.04229828244084477, 0.02871066285981505, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.022523958163049418, 0.017396259932010105, 0.030213255096327885, 0.01969646754387211, 0.033153130081172266, 0.04468139392222803, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.06627008772211107, 0.06681197977842457, 0.07658319026970528, 0.07649533299022915, 0.07940608740585997, 0.0752590661214817, 0.07832626347259575, 0.07352620179891678, 0.07734145785707802, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03164403457049647, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.1678800162846643, 0.19132008603565365, 0.16901364774750927, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.10044135095176665, 0.13104309199029684, 0.1088044681910404, 0.10678919305904144, 0.11084244641482566, 0.10758175612979759, 0.13174477034112353, 0.10836254295523218, 0.12530197434637735, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831684190246947, 0.0363756508372739, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.1887459838153227, 0.19377996954355858, 0.17583069295502063, 0.1881997028561424, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03797651361921761, 0.03149868058512406, 0.04231214916752091, 0.13535075311542355, 0.12212993144713313, 0.1412194673731294, 0.13871562955069006, 0.13721084259603444, 0.10975133584142294, 0.1468505230297129, 0.14135747764780093, 0.11948105763275507, 0.1608169144332109, 0.14938199943968544, 0.16682836854616212, 0.16813948631363584, 0.18192475767904104, 0.17146684744913998, 0.15127901597955062, 0.17360872098874203, 0.14067088458992183, 0.09992591138714046, 0.08927975875151373, 0.10716775680921653, 0.12152377056986585, 0.1219387262952556, 0.12092212742309638, 0.09812208369943642, 0.12248101970438452, 0.11052548111724847, 0.26018223221605774, 0.2601763462457861, 0.2601799940369649, 0.260181837843781, 0.26017734341597376, 0.26017694376492306, 0.2601875539181707, 0.2601737466540327, 0.26017953811524486, 0.14134552476090445, 0.13789858625938778, 0.13637753373560368, 0.14005395132022402, 0.1367517438776289, 0.14249193908056224, 0.13648507124891218, 0.143313252993847, 0.15890532503478294, 0.13028839717293506, 0.16268696960458362, 0.15812072100077312, 0.15143720630719892, 0.1353860294342618, 0.1210392302460872, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14069703219645158, 0.13406252454194778, 0.13370277032486844, 0.11961740909298313, 0.11996365346598648, 0.13675359588029, 0.15902051640997705, 0.1588985605728772, 0.11033651266998945, 0.16626673609735132, 0.18502685479500824, 0.18480221882642112, 0.1923843107024471, 0.20997491549964642, 0.21277544464120968, 0.1848295213157578, 0.1873143164654224, 0.20019697604053632, 0.052268318607119, 0.0596275630443972, 0.06348982448386209, 0.06795227486551081, 0.06280191479542807, 0.053031697571199965, 0.07286385125893502, 0.07361742167528151, 0.06638903356597348]}, "mutation_prompt": null}
{"id": "ffc55852-3bb1-4c19-9e52-927ec032b729", "solution": "import numpy as np\nimport random\n\nclass AHQBACO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco = AHQBACO(budget, dim)\nbest_solution, best_fitness = ahqbaco(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization (AHQBACO) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72fcb4a9-740e-4393-b6bb-6229f29ff987", "metadata": {"aucs": [0.1679206248099212, 0.1730397538914542, 0.15954351657358878, 0.15404605366386603, 0.1648562418301468, 0.15898560438757192, 0.1627080782607181, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03143133387113628, 0.042299821549620864, 0.028786365634780098, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024995338660832367, 0.019581190153767913, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.06627008772211107, 0.06681197977842457, 0.07658319026970528, 0.07649533299022915, 0.07940608740585997, 0.0752590661214817, 0.07832626347259575, 0.07352620179891678, 0.07734145785707802, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.1926773706368211, 0.1608105915480288, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08905742753322088, 0.12806815271036465, 0.11275589901584737, 0.14907852280907952, 0.11207037063532244, 0.11185100965219175, 0.11303239351823924, 0.1178318544096354, 0.10442740715925158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18876344404115986, 0.1952465446966145, 0.17638713725373223, 0.18787450350182366, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03152262647728599, 0.04231214916752091, 0.13523484187121937, 0.11949803569855721, 0.1403075403980727, 0.13871562955069006, 0.13721084259603444, 0.10991010495874565, 0.14680156083880325, 0.1414549001063835, 0.12120314996980142, 0.1610745641389092, 0.14938782888659952, 0.16684772814827575, 0.17532727757374866, 0.1696172853400656, 0.16948801030744798, 0.15127901597955062, 0.17359018863582443, 0.14098282474331114, 0.09990585299789723, 0.08928782259693491, 0.10716775680921653, 0.12123726798047696, 0.12356593607112099, 0.12221803993150993, 0.09812208369943642, 0.12246757639898764, 0.11059392574141602, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1428554788833184, 0.138573316280035, 0.14977569096645127, 0.13979322800927452, 0.14616867812813394, 0.14085960050253765, 0.12623570558600972, 0.13526331024062344, 0.16012466570397244, 0.13001274008038144, 0.16111021637023348, 0.15824819331131224, 0.1513814835885421, 0.1353860294342618, 0.12082248404264118, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13364278059408274, 0.11961705079305107, 0.11996219230734095, 0.13675049794254157, 0.15881153565352435, 0.15864079118702246, 0.10988046452472044, 0.17088022390676283, 0.18556423272408507, 0.18519976647975844, 0.18697243178423184, 0.20971619836577715, 0.21455027575041663, 0.18258603635653925, 0.17634428845756733, 0.20268554675043404, 0.054158139718948006, 0.10910671837840769, 0.06407690351369455, 0.06002240575971174, 0.06099869662024471, 0.054207497242153346, 0.07290093633919859, 0.06374437679210643, 0.06514440219635964]}, "mutation_prompt": null}
{"id": "0a12067b-b356-401f-a609-68abb35278e1", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn = AHQBACO_DN(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization with Dynamic Neighborhoods (AHQBACO-DN) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization and dynamically adjusts the neighborhoods of onlooker bees based on the fitness of employed bees.", "configspace": "", "generation": 21, "fitness": 0.12817199423068665, "feedback": "The algorithm AHQBACO_DN got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "72fcb4a9-740e-4393-b6bb-6229f29ff987", "metadata": {"aucs": [0.1679179937781059, 0.17302578444658379, 0.15769112610706104, 0.15403095327174998, 0.16485414420748767, 0.15898560438757192, 0.16270741935431654, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03091841247445737, 0.042299821549620864, 0.028707454718879255, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.022775144325087093, 0.019374829655044556, 0.029981316956660287, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9789314818823658, 0.9887291511166051, 0.9967091909508705, 0.9490330456128686, 0.9849543004622303, 0.9999001200375565, 0.9984358291545808, 0.963282723764036, 0.9648001775691007, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.1482328137754133, 0.19205520532700826, 0.16003160493776414, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08093228215519344, 0.10135360235335722, 0.10130927377412169, 0.1481869597493265, 0.1119824890054737, 0.10665739795921925, 0.11299025301705556, 0.09562370321999392, 0.09557267232127453, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831543164293143, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.1887370728543144, 0.19429770749190467, 0.17247318636976106, 0.18759066358241328, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037738355399636214, 0.03150842159239786, 0.04231214916752091, 0.13541456153709952, 0.11517827480921061, 0.11795695037128207, 0.1387220562751541, 0.1372262786133278, 0.10991543368466938, 0.14685190152952476, 0.1414655682168191, 0.12059206651009569, 0.16061810443661284, 0.1493576353589049, 0.16684316589609638, 0.1684557805658442, 0.16789007496321395, 0.16634476767959172, 0.15127901597955062, 0.17357244887918022, 0.14094974471496513, 0.09990580805300364, 0.08928111045160281, 0.10716775680921653, 0.12078973865352693, 0.11985837116319031, 0.12137362962338305, 0.09812208369943642, 0.12246601612611141, 0.11056438674338531, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2601875539181707, 0.2601678946548399, 0.26017816934690785, 0.1321896653493443, 0.13614994584965479, 0.12739941219488515, 0.12777220716730464, 0.14569881022274822, 0.14084817961805252, 0.12623570558600972, 0.13507824487384246, 0.16005469550930485, 0.1300023739036189, 0.1608880523592503, 0.15810353169668634, 0.15135986039941796, 0.1353812470117839, 0.12051821611200686, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13406252454194778, 0.13349385713146278, 0.11961705079305107, 0.11996197588588142, 0.13675049794254157, 0.15834517139785698, 0.1586304149046318, 0.1095858815959988, 0.1638380806367833, 0.1829946270924817, 0.16799917534186537, 0.1820993644137604, 0.2099163930368073, 0.1704845485640628, 0.17660772311341166, 0.17635471181300078, 0.2000745921927376, 0.05307511008979693, 0.10910642640898427, 0.06373616994773179, 0.05452789301589478, 0.06069417504582275, 0.05295047019517041, 0.0708762347149553, 0.06367105538332873, 0.06267647706741775]}, "mutation_prompt": null}
{"id": "51803864-423e-4d47-8a5d-78432578c568", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn = AHQBACO_DN(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization with Dynamic Neighborhoods (AHQBACO-DN) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization and dynamically adjusts the neighborhoods of onlooker bees based on the fitness of employed bees.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0a12067b-b356-401f-a609-68abb35278e1", "metadata": {"aucs": [0.1679179937781059, 0.17302578444658379, 0.15769112610706104, 0.15403095327174998, 0.16485414420748767, 0.15898560438757192, 0.16270741935431654, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03091841247445737, 0.042299821549620864, 0.028707454718879255, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.022775144325087093, 0.019374829655044556, 0.029981316956660287, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9789314818823658, 0.9887291511166051, 0.9967091909508705, 0.9490330456128686, 0.9849543004622303, 0.9999001200375565, 0.9984358291545808, 0.963282723764036, 0.9648001775691007, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.1482328137754133, 0.19205520532700826, 0.16003160493776414, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08093228215519344, 0.10135360235335722, 0.10130927377412169, 0.1481869597493265, 0.1119824890054737, 0.10665739795921925, 0.11299025301705556, 0.09562370321999392, 0.09557267232127453, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831543164293143, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.1887370728543144, 0.19429770749190467, 0.17247318636976106, 0.18759066358241328, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037738355399636214, 0.03150842159239786, 0.04231214916752091, 0.13541456153709952, 0.11517827480921061, 0.11795695037128207, 0.1387220562751541, 0.1372262786133278, 0.10991543368466938, 0.14685190152952476, 0.1414655682168191, 0.12059206651009569, 0.16061810443661284, 0.1493576353589049, 0.16684316589609638, 0.1684557805658442, 0.16789007496321395, 0.16634476767959172, 0.15127901597955062, 0.17357244887918022, 0.14094974471496513, 0.09990580805300364, 0.08928111045160281, 0.10716775680921653, 0.12078973865352693, 0.11985837116319031, 0.12137362962338305, 0.09812208369943642, 0.12246601612611141, 0.11056438674338531, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2601875539181707, 0.2601678946548399, 0.26017816934690785, 0.1321896653493443, 0.13614994584965479, 0.12739941219488515, 0.12777220716730464, 0.14569881022274822, 0.14084817961805252, 0.12623570558600972, 0.13507824487384246, 0.16005469550930485, 0.1300023739036189, 0.1608880523592503, 0.15810353169668634, 0.15135986039941796, 0.1353812470117839, 0.12051821611200686, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13406252454194778, 0.13349385713146278, 0.11961705079305107, 0.11996197588588142, 0.13675049794254157, 0.15834517139785698, 0.1586304149046318, 0.1095858815959988, 0.1638380806367833, 0.1829946270924817, 0.16799917534186537, 0.1820993644137604, 0.2099163930368073, 0.1704845485640628, 0.17660772311341166, 0.17635471181300078, 0.2000745921927376, 0.05307511008979693, 0.10910642640898427, 0.06373616994773179, 0.05452789301589478, 0.06069417504582275, 0.05295047019517041, 0.0708762347149553, 0.06367105538332873, 0.06267647706741775]}, "mutation_prompt": null}
{"id": "414ff8e4-1295-4264-bd11-3718b682c64e", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn = AHQBACO_DN(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization with Dynamic Neighborhoods (AHQBACO-DN) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization and dynamically adjusts the neighborhoods of onlooker bees based on the fitness of employed bees.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0a12067b-b356-401f-a609-68abb35278e1", "metadata": {"aucs": [0.1679179937781059, 0.17302578444658379, 0.15769112610706104, 0.15403095327174998, 0.16485414420748767, 0.15898560438757192, 0.16270741935431654, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03091841247445737, 0.042299821549620864, 0.028707454718879255, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.022775144325087093, 0.019374829655044556, 0.029981316956660287, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9789314818823658, 0.9887291511166051, 0.9967091909508705, 0.9490330456128686, 0.9849543004622303, 0.9999001200375565, 0.9984358291545808, 0.963282723764036, 0.9648001775691007, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.1482328137754133, 0.19205520532700826, 0.16003160493776414, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08093228215519344, 0.10135360235335722, 0.10130927377412169, 0.1481869597493265, 0.1119824890054737, 0.10665739795921925, 0.11299025301705556, 0.09562370321999392, 0.09557267232127453, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831543164293143, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.1887370728543144, 0.19429770749190467, 0.17247318636976106, 0.18759066358241328, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037738355399636214, 0.03150842159239786, 0.04231214916752091, 0.13541456153709952, 0.11517827480921061, 0.11795695037128207, 0.1387220562751541, 0.1372262786133278, 0.10991543368466938, 0.14685190152952476, 0.1414655682168191, 0.12059206651009569, 0.16061810443661284, 0.1493576353589049, 0.16684316589609638, 0.1684557805658442, 0.16789007496321395, 0.16634476767959172, 0.15127901597955062, 0.17357244887918022, 0.14094974471496513, 0.09990580805300364, 0.08928111045160281, 0.10716775680921653, 0.12078973865352693, 0.11985837116319031, 0.12137362962338305, 0.09812208369943642, 0.12246601612611141, 0.11056438674338531, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2601875539181707, 0.2601678946548399, 0.26017816934690785, 0.1321896653493443, 0.13614994584965479, 0.12739941219488515, 0.12777220716730464, 0.14569881022274822, 0.14084817961805252, 0.12623570558600972, 0.13507824487384246, 0.16005469550930485, 0.1300023739036189, 0.1608880523592503, 0.15810353169668634, 0.15135986039941796, 0.1353812470117839, 0.12051821611200686, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13406252454194778, 0.13349385713146278, 0.11961705079305107, 0.11996197588588142, 0.13675049794254157, 0.15834517139785698, 0.1586304149046318, 0.1095858815959988, 0.1638380806367833, 0.1829946270924817, 0.16799917534186537, 0.1820993644137604, 0.2099163930368073, 0.1704845485640628, 0.17660772311341166, 0.17635471181300078, 0.2000745921927376, 0.05307511008979693, 0.10910642640898427, 0.06373616994773179, 0.05452789301589478, 0.06069417504582275, 0.05295047019517041, 0.0708762347149553, 0.06367105538332873, 0.06267647706741775]}, "mutation_prompt": null}
{"id": "a2468586-8d57-4037-925f-348d90d7487c", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn = AHQBACO_DN(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization with Dynamic Neighborhoods (AHQBACO-DN) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization and dynamically adjusts the neighborhoods of onlooker bees based on the fitness of employed bees.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0a12067b-b356-401f-a609-68abb35278e1", "metadata": {"aucs": [0.1679179937781059, 0.17302578444658379, 0.15769112610706104, 0.15403095327174998, 0.16485414420748767, 0.15898560438757192, 0.16270741935431654, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03091841247445737, 0.042299821549620864, 0.028707454718879255, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.022775144325087093, 0.019374829655044556, 0.029981316956660287, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9789314818823658, 0.9887291511166051, 0.9967091909508705, 0.9490330456128686, 0.9849543004622303, 0.9999001200375565, 0.9984358291545808, 0.963282723764036, 0.9648001775691007, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.1482328137754133, 0.19205520532700826, 0.16003160493776414, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08093228215519344, 0.10135360235335722, 0.10130927377412169, 0.1481869597493265, 0.1119824890054737, 0.10665739795921925, 0.11299025301705556, 0.09562370321999392, 0.09557267232127453, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831543164293143, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.1887370728543144, 0.19429770749190467, 0.17247318636976106, 0.18759066358241328, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037738355399636214, 0.03150842159239786, 0.04231214916752091, 0.13541456153709952, 0.11517827480921061, 0.11795695037128207, 0.1387220562751541, 0.1372262786133278, 0.10991543368466938, 0.14685190152952476, 0.1414655682168191, 0.12059206651009569, 0.16061810443661284, 0.1493576353589049, 0.16684316589609638, 0.1684557805658442, 0.16789007496321395, 0.16634476767959172, 0.15127901597955062, 0.17357244887918022, 0.14094974471496513, 0.09990580805300364, 0.08928111045160281, 0.10716775680921653, 0.12078973865352693, 0.11985837116319031, 0.12137362962338305, 0.09812208369943642, 0.12246601612611141, 0.11056438674338531, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2601875539181707, 0.2601678946548399, 0.26017816934690785, 0.1321896653493443, 0.13614994584965479, 0.12739941219488515, 0.12777220716730464, 0.14569881022274822, 0.14084817961805252, 0.12623570558600972, 0.13507824487384246, 0.16005469550930485, 0.1300023739036189, 0.1608880523592503, 0.15810353169668634, 0.15135986039941796, 0.1353812470117839, 0.12051821611200686, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13406252454194778, 0.13349385713146278, 0.11961705079305107, 0.11996197588588142, 0.13675049794254157, 0.15834517139785698, 0.1586304149046318, 0.1095858815959988, 0.1638380806367833, 0.1829946270924817, 0.16799917534186537, 0.1820993644137604, 0.2099163930368073, 0.1704845485640628, 0.17660772311341166, 0.17635471181300078, 0.2000745921927376, 0.05307511008979693, 0.10910642640898427, 0.06373616994773179, 0.05452789301589478, 0.06069417504582275, 0.05295047019517041, 0.0708762347149553, 0.06367105538332873, 0.06267647706741775]}, "mutation_prompt": null}
{"id": "18215637-1203-4796-be06-3859f4318ebf", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn = AHQBACO_DN(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization with Dynamic Neighborhoods (AHQBACO-DN) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization and dynamically adjusts the neighborhoods of onlooker bees based on the fitness of employed bees.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0a12067b-b356-401f-a609-68abb35278e1", "metadata": {"aucs": [0.1679179937781059, 0.17302578444658379, 0.15769112610706104, 0.15403095327174998, 0.16485414420748767, 0.15898560438757192, 0.16270741935431654, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03091841247445737, 0.042299821549620864, 0.028707454718879255, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.022775144325087093, 0.019374829655044556, 0.029981316956660287, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9789314818823658, 0.9887291511166051, 0.9967091909508705, 0.9490330456128686, 0.9849543004622303, 0.9999001200375565, 0.9984358291545808, 0.963282723764036, 0.9648001775691007, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.1482328137754133, 0.19205520532700826, 0.16003160493776414, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08093228215519344, 0.10135360235335722, 0.10130927377412169, 0.1481869597493265, 0.1119824890054737, 0.10665739795921925, 0.11299025301705556, 0.09562370321999392, 0.09557267232127453, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831543164293143, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.1887370728543144, 0.19429770749190467, 0.17247318636976106, 0.18759066358241328, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037738355399636214, 0.03150842159239786, 0.04231214916752091, 0.13541456153709952, 0.11517827480921061, 0.11795695037128207, 0.1387220562751541, 0.1372262786133278, 0.10991543368466938, 0.14685190152952476, 0.1414655682168191, 0.12059206651009569, 0.16061810443661284, 0.1493576353589049, 0.16684316589609638, 0.1684557805658442, 0.16789007496321395, 0.16634476767959172, 0.15127901597955062, 0.17357244887918022, 0.14094974471496513, 0.09990580805300364, 0.08928111045160281, 0.10716775680921653, 0.12078973865352693, 0.11985837116319031, 0.12137362962338305, 0.09812208369943642, 0.12246601612611141, 0.11056438674338531, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2601875539181707, 0.2601678946548399, 0.26017816934690785, 0.1321896653493443, 0.13614994584965479, 0.12739941219488515, 0.12777220716730464, 0.14569881022274822, 0.14084817961805252, 0.12623570558600972, 0.13507824487384246, 0.16005469550930485, 0.1300023739036189, 0.1608880523592503, 0.15810353169668634, 0.15135986039941796, 0.1353812470117839, 0.12051821611200686, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13406252454194778, 0.13349385713146278, 0.11961705079305107, 0.11996197588588142, 0.13675049794254157, 0.15834517139785698, 0.1586304149046318, 0.1095858815959988, 0.1638380806367833, 0.1829946270924817, 0.16799917534186537, 0.1820993644137604, 0.2099163930368073, 0.1704845485640628, 0.17660772311341166, 0.17635471181300078, 0.2000745921927376, 0.05307511008979693, 0.10910642640898427, 0.06373616994773179, 0.05452789301589478, 0.06069417504582275, 0.05295047019517041, 0.0708762347149553, 0.06367105538332873, 0.06267647706741775]}, "mutation_prompt": null}
{"id": "0652d2aa-1cd7-417e-bcd7-dbed5365473f", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN_MATR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.memory = np.zeros((budget, dim))\n        self.traj_refine = 0.5\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                # Memory-Augmented Trajectory Refinement\n                self.memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.memory[i]) else self.memory[i]\n                self.traj_refine = 0.5 + 0.5 * np.random.uniform(-1, 1)\n                self.onlooker_bees[i] = self.memory[i] + np.random.uniform(-self.traj_refine, self.traj_refine, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                # Memory-Augmented Trajectory Refinement\n                self.memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.memory[i]) else self.memory[i]\n                self.traj_refine = 0.5 + 0.5 * np.random.uniform(-1, 1)\n                self.onlooker_bees[i] = self.memory[i] + np.random.uniform(-self.traj_refine, self.traj_refine, self.dim)\n                self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn_matr = AHQBACO_DN_MATR(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn_matr(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN_MATR", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization with Dynamic Neighborhoods and Memory-Augmented Trajectory Refinement (AHQBACO-DN-MATR)", "configspace": "", "generation": 26, "fitness": 0.12268941632607457, "feedback": "The algorithm AHQBACO_DN_MATR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "0a12067b-b356-401f-a609-68abb35278e1", "metadata": {"aucs": [0.16488632044724671, 0.17002343942951992, 0.14566433008341662, 0.15185438779198013, 0.14342098570522632, 0.14361821255196305, 0.151459468303334, 0.11907780024483272, 0.1396088993163267, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02930090976247013, 0.03963458475654513, 0.024493800185121706, 0.02358591132603871, 0.03114341968581935, 0.034562030929982446, 0.03737854540650609, 0.04188508347895059, 0.03284433229512829, 0.019860560949217843, 0.015186267743968695, 0.024573656477021366, 0.01954507864163102, 0.017038518069697584, 0.03181391378823173, 0.030108100192550058, 0.016290378268478678, 0.0226303345839044, 0.8771046556051333, 0.9680270892006472, 0.944289206932626, 0.9872723496087645, 0.9946291544597368, 0.9941536723693659, 0.9684556701799837, 0.9797926272801555, 0.9909540566018499, 0.06214619189219717, 0.059324548480195305, 0.09564870695088834, 0.04170781372163923, 0.059684231786957254, 0.027156405830124797, 0.08048120346983978, 0.03088667745679108, 0.08457404027954107, 0.14540586497581443, 0.18896538049597966, 0.15679446327757973, 0.08254693131017643, 0.07860902745004983, 0.10036955177693219, 0.06803440620603396, 0.10179626365373029, 0.09806112577789539, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007554395424840599, 0.08768583321823775, 0.08663073186872994, 0.08250773481525431, 0.09545881759182029, 0.08871465575443582, 0.07750068737591154, 0.09216061993476032, 0.10541489112487523, 0.08383930145891194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0018642720287928016, 0.059063542210913145, 0.03832073070582265, 0.04154885252548135, 0.018593560509083673, 0.0285836805983104, 9.999999999998899e-05, 0.026382498323849313, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.19240897812861013, 0.18371717423023592, 0.17375282897702693, 0.19429385775271713, 0.16767275036718043, 0.18516087213682708, 0.1896792734411582, 0.17324765299074008, 0.18489913743872288, 0.024763867917624527, 0.03382435887111446, 0.021641361286669825, 0.032231122671891876, 0.026119984758715353, 0.03278815442579075, 0.027164027567708193, 0.0236082178471968, 0.038459102529883604, 0.13357507293650783, 0.11062754543835485, 0.11790011891678931, 0.13680661682787465, 0.13403380221625993, 0.10744910159680565, 0.1436728598620708, 0.13277052003038592, 0.10879758932768857, 0.15596667666421205, 0.14648050159708326, 0.16554719616980018, 0.16750758791574805, 0.17184331313310208, 0.16283571014582, 0.1444119058543767, 0.1733555844126975, 0.13213859346955525, 0.09359998360169008, 0.08309876135763972, 0.10324043681107775, 0.1202185874097782, 0.12312955860505459, 0.11377073150166017, 0.09382481009001986, 0.12120241647293772, 0.09817552726346002, 0.2601813882744033, 0.2601763462457861, 0.26017666954069796, 0.26018132180600584, 0.26017734341597376, 0.26017153992687414, 0.2625833110685568, 0.2601737466540327, 0.26017816934690785, 0.11422624946711712, 0.13226523693149905, 0.11846772303930142, 0.11873573573614049, 0.12796096923962086, 0.13529679274986917, 0.13718396859281778, 0.12666913785024825, 0.15694370692285853, 0.12851785694214757, 0.15511407106735242, 0.1536774634511472, 0.14551932112403576, 0.12160443106009622, 0.11300946399226286, 0.13108424034428623, 0.12549387705837511, 0.148978095012803, 0.12460776361429693, 0.11007761791679282, 0.1178489793399583, 0.11463611107777927, 0.09116964899156044, 0.11500607120976747, 0.15602431612812306, 0.14462718032150967, 0.10850616960322901, 0.17544610077964773, 0.18186111866741694, 0.17115424672617485, 0.1820535739137067, 0.2031212331185569, 0.18283502084635672, 0.16751982102599738, 0.17581048426855528, 0.19449390389030796, 0.05022225495953336, 0.0669305253216127, 0.061015169619228815, 0.056340541614218975, 0.05699520598331187, 0.062091157828542465, 0.06382058333911667, 0.06576733108430322, 0.049984392497248176]}, "mutation_prompt": null}
{"id": "4907547d-ea14-415a-9c54-21570f707ed6", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn = AHQBACO_DN(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization with Dynamic Neighborhoods (AHQBACO-DN) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization and dynamically adjusts the neighborhoods of onlooker bees based on the fitness of employed bees.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0a12067b-b356-401f-a609-68abb35278e1", "metadata": {"aucs": [0.1679179937781059, 0.17302578444658379, 0.15769112610706104, 0.15403095327174998, 0.16485414420748767, 0.15898560438757192, 0.16270741935431654, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03091841247445737, 0.042299821549620864, 0.028707454718879255, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.022775144325087093, 0.019374829655044556, 0.029981316956660287, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9789314818823658, 0.9887291511166051, 0.9967091909508705, 0.9490330456128686, 0.9849543004622303, 0.9999001200375565, 0.9984358291545808, 0.963282723764036, 0.9648001775691007, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.1482328137754133, 0.19205520532700826, 0.16003160493776414, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08093228215519344, 0.10135360235335722, 0.10130927377412169, 0.1481869597493265, 0.1119824890054737, 0.10665739795921925, 0.11299025301705556, 0.09562370321999392, 0.09557267232127453, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831543164293143, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.1887370728543144, 0.19429770749190467, 0.17247318636976106, 0.18759066358241328, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037738355399636214, 0.03150842159239786, 0.04231214916752091, 0.13541456153709952, 0.11517827480921061, 0.11795695037128207, 0.1387220562751541, 0.1372262786133278, 0.10991543368466938, 0.14685190152952476, 0.1414655682168191, 0.12059206651009569, 0.16061810443661284, 0.1493576353589049, 0.16684316589609638, 0.1684557805658442, 0.16789007496321395, 0.16634476767959172, 0.15127901597955062, 0.17357244887918022, 0.14094974471496513, 0.09990580805300364, 0.08928111045160281, 0.10716775680921653, 0.12078973865352693, 0.11985837116319031, 0.12137362962338305, 0.09812208369943642, 0.12246601612611141, 0.11056438674338531, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2601875539181707, 0.2601678946548399, 0.26017816934690785, 0.1321896653493443, 0.13614994584965479, 0.12739941219488515, 0.12777220716730464, 0.14569881022274822, 0.14084817961805252, 0.12623570558600972, 0.13507824487384246, 0.16005469550930485, 0.1300023739036189, 0.1608880523592503, 0.15810353169668634, 0.15135986039941796, 0.1353812470117839, 0.12051821611200686, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13406252454194778, 0.13349385713146278, 0.11961705079305107, 0.11996197588588142, 0.13675049794254157, 0.15834517139785698, 0.1586304149046318, 0.1095858815959988, 0.1638380806367833, 0.1829946270924817, 0.16799917534186537, 0.1820993644137604, 0.2099163930368073, 0.1704845485640628, 0.17660772311341166, 0.17635471181300078, 0.2000745921927376, 0.05307511008979693, 0.10910642640898427, 0.06373616994773179, 0.05452789301589478, 0.06069417504582275, 0.05295047019517041, 0.0708762347149553, 0.06367105538332873, 0.06267647706741775]}, "mutation_prompt": null}
{"id": "ca188be0-e57f-4e9f-b02c-9bacb132efac", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn = AHQBACO_DN(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization with Dynamic Neighborhoods (AHQBACO-DN) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization and dynamically adjusts the neighborhoods of onlooker bees based on the fitness of employed bees.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0a12067b-b356-401f-a609-68abb35278e1", "metadata": {"aucs": [0.1679179937781059, 0.17302578444658379, 0.15769112610706104, 0.15403095327174998, 0.16485414420748767, 0.15898560438757192, 0.16270741935431654, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03091841247445737, 0.042299821549620864, 0.028707454718879255, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.022775144325087093, 0.019374829655044556, 0.029981316956660287, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9789314818823658, 0.9887291511166051, 0.9967091909508705, 0.9490330456128686, 0.9849543004622303, 0.9999001200375565, 0.9984358291545808, 0.963282723764036, 0.9648001775691007, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.1482328137754133, 0.19205520532700826, 0.16003160493776414, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08093228215519344, 0.10135360235335722, 0.10130927377412169, 0.1481869597493265, 0.1119824890054737, 0.10665739795921925, 0.11299025301705556, 0.09562370321999392, 0.09557267232127453, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831543164293143, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.1887370728543144, 0.19429770749190467, 0.17247318636976106, 0.18759066358241328, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037738355399636214, 0.03150842159239786, 0.04231214916752091, 0.13541456153709952, 0.11517827480921061, 0.11795695037128207, 0.1387220562751541, 0.1372262786133278, 0.10991543368466938, 0.14685190152952476, 0.1414655682168191, 0.12059206651009569, 0.16061810443661284, 0.1493576353589049, 0.16684316589609638, 0.1684557805658442, 0.16789007496321395, 0.16634476767959172, 0.15127901597955062, 0.17357244887918022, 0.14094974471496513, 0.09990580805300364, 0.08928111045160281, 0.10716775680921653, 0.12078973865352693, 0.11985837116319031, 0.12137362962338305, 0.09812208369943642, 0.12246601612611141, 0.11056438674338531, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2601875539181707, 0.2601678946548399, 0.26017816934690785, 0.1321896653493443, 0.13614994584965479, 0.12739941219488515, 0.12777220716730464, 0.14569881022274822, 0.14084817961805252, 0.12623570558600972, 0.13507824487384246, 0.16005469550930485, 0.1300023739036189, 0.1608880523592503, 0.15810353169668634, 0.15135986039941796, 0.1353812470117839, 0.12051821611200686, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13406252454194778, 0.13349385713146278, 0.11961705079305107, 0.11996197588588142, 0.13675049794254157, 0.15834517139785698, 0.1586304149046318, 0.1095858815959988, 0.1638380806367833, 0.1829946270924817, 0.16799917534186537, 0.1820993644137604, 0.2099163930368073, 0.1704845485640628, 0.17660772311341166, 0.17635471181300078, 0.2000745921927376, 0.05307511008979693, 0.10910642640898427, 0.06373616994773179, 0.05452789301589478, 0.06069417504582275, 0.05295047019517041, 0.0708762347149553, 0.06367105538332873, 0.06267647706741775]}, "mutation_prompt": null}
{"id": "d25fa80e-536b-4e6a-a701-f63e0ea4ecdc", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN_PNM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.pnm_probability = 0.1  # probability of neighborhood mutation\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                # Probabilistic neighborhood mutation\n                if random.random() < self.pnm_probability:\n                    self.onlooker_bees[i] = self.onlooker_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                # Probabilistic neighborhood mutation\n                if random.random() < self.pnm_probability:\n                    self.onlooker_bees[i] = self.onlooker_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn_pnm = AHQBACO_DN_PNM(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn_pnm(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN_PNM", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization with Dynamic Neighborhoods and Probabilistic Neighborhood Mutation (AHQBACO-DN-PNM) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization, dynamically adjusts the neighborhoods of onlooker bees based on the fitness of employed bees, and introduces a probabilistic neighborhood mutation mechanism to further enhance the search process.", "configspace": "", "generation": 29, "fitness": 0.1280385210505036, "feedback": "The algorithm AHQBACO_DN_PNM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "0a12067b-b356-401f-a609-68abb35278e1", "metadata": {"aucs": [0.16777543221238667, 0.17299885514505897, 0.15855755727648246, 0.1540328077434373, 0.16485277201301995, 0.15898560438757192, 0.16270741935431654, 0.1394357502690513, 0.14875543656335266, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03086439284856224, 0.04229920659856412, 0.028745741435670213, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.021299021888129155, 0.018831795785187344, 0.03079358078420369, 0.01969646754387211, 0.033153130081172266, 0.045355448204391524, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9946901654576417, 0.9917385047386349, 0.9967284333325023, 0.975221921131275, 0.9806517683615518, 0.9999001200375565, 0.9984356409844637, 0.9594822072057279, 0.9866701775691006, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16416772566994509, 0.19065217736943996, 0.1507326182283305, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.10740387860192335, 0.09795879690667975, 0.08307160179684414, 0.10283255703101546, 0.12057107123044264, 0.10124211354445944, 0.0918912774017201, 0.10340353284033987, 0.09111429998523979, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831543164293143, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.1887370728543144, 0.19374821060565728, 0.1775577898838585, 0.18742430221693263, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03771441780637086, 0.03171416322068921, 0.04231214916752091, 0.13579128902211213, 0.12225139932394269, 0.11797401403415808, 0.1387225781051249, 0.1372262786133278, 0.1103311585124811, 0.14629735732940918, 0.14950226519396348, 0.11763076928803218, 0.1606932416716118, 0.1494082167804146, 0.1668283483391093, 0.17368242312360038, 0.16486978817794806, 0.16569539473245298, 0.15127901597955062, 0.17359018863582443, 0.14070485530493992, 0.0999016709424837, 0.08910219350883197, 0.10716775680921653, 0.11104434776124505, 0.12718453748134473, 0.11728779173379023, 0.09812208369943642, 0.12246347688409076, 0.11058023632394232, 0.2601813882744033, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.26017153992687414, 0.2601875539181707, 0.2601678946548399, 0.26017816934690785, 0.14326219235670268, 0.1423347580681309, 0.13465286152027856, 0.12519087527408623, 0.13536011845990648, 0.14111526455022871, 0.12240571245375109, 0.13669475457989777, 0.15890532503478294, 0.12813731810556006, 0.16166645935934898, 0.15817876239490525, 0.1513790965305689, 0.1353860294342618, 0.12049726038630582, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.1401841753060742, 0.13436624907465233, 0.13409171163785305, 0.11960846630903421, 0.11996197588588142, 0.13675049794254157, 0.15868921114818058, 0.1578459106281772, 0.11022347965107948, 0.17130783108923808, 0.18298736147446548, 0.1777723988082487, 0.18176493784953607, 0.20611215581371845, 0.17117248036154198, 0.17171404561058368, 0.1838986153905675, 0.2027721335087186, 0.053607530230321165, 0.06057332886329203, 0.06345364441477541, 0.05369122498678147, 0.06085951922877553, 0.051282526036658616, 0.07027506389281757, 0.051152223833255794, 0.05222009405472816]}, "mutation_prompt": null}
{"id": "6c586915-2538-43e8-a766-6902ac633b6d", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN_IPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.learning_factor = 0.7298  # initial learning factor\n        self.self_adaptive_velocity = np.zeros((budget, dim))  # self-adaptive velocity update rule\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.5:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Improved Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = self.learning_factor * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.self_adaptive_velocity[i] = 0.1 * np.random.uniform(-1, 1, self.dim) + 0.9 * self.velocity[i]\n                self.harmony_memory[i] = self.harmony_memory[i] + self.self_adaptive_velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n                self.learning_factor = 0.5 + 0.5 * np.sin(10 * (i / self.budget))  # dynamic learning factor\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn_ipso = AHQBACO_DN_IPSO(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn_ipso(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN_IPSO", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization with Dynamic Neighborhoods and Improved Quantum-Behaved Particle Swarm Optimization (AHQBACO-DN-IPSO) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization and dynamically adjusts the neighborhoods of onlooker bees based on the fitness of employed bees, with an improved Quantum-Behaved Particle Swarm Optimization component that uses a dynamic learning factor and a self-adaptive velocity update rule.", "configspace": "", "generation": 30, "fitness": 0.12789480120555807, "feedback": "The algorithm AHQBACO_DN_IPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "0a12067b-b356-401f-a609-68abb35278e1", "metadata": {"aucs": [0.16830557459692264, 0.1730030963720437, 0.16000784394110756, 0.15413975649585032, 0.16485967231631604, 0.15897100690557542, 0.16270429889919014, 0.1394424978566864, 0.14875648707147826, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030726017093971714, 0.04231027122683484, 0.028727308992726686, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.022474250892649095, 0.01936117980174845, 0.030107833628517433, 0.01969646754387211, 0.033153130081172266, 0.044654688385949104, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9953742739392467, 0.994095502879515, 0.9605411144507018, 0.9788936209036054, 0.9010934675918962, 0.9999001200375565, 0.9546807491988167, 0.9623085237131611, 0.9984250440583365, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16486303933304225, 0.189720320067868, 0.15812956622162544, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08215386523572776, 0.12588629386008487, 0.1117951665223631, 0.09549731383282745, 0.09368256389656637, 0.09639998089077306, 0.12724904807863546, 0.08791817850373196, 0.1075312071101433, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831543164293143, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20661818808493548, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.1774155273664466, 0.18871350186886504, 0.19522088570155482, 0.17580959203657898, 0.1877821056371638, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037829043380400384, 0.03149234042422633, 0.04231214916752091, 0.13540919676745977, 0.1298341810650251, 0.11821479177091154, 0.1387155273583558, 0.13721084259603444, 0.11042289177734432, 0.14632262549616315, 0.14138939912965565, 0.11809595044391896, 0.1610745641389092, 0.14940564018277835, 0.16679844311504277, 0.17084008635035075, 0.17467660828864096, 0.17079150968007284, 0.15144492360276818, 0.17353975153293155, 0.14064970410036182, 0.09991241190251643, 0.0891135534855535, 0.10716408229344454, 0.12532166866376215, 0.12086291997648912, 0.11866854296245055, 0.09812208369943642, 0.1224903945369541, 0.11054270815835154, 0.2601813882744033, 0.26016601643901793, 0.2601799940369649, 0.26018132180600584, 0.2601665068806729, 0.2632119017005059, 0.2601875539181707, 0.2601756259303749, 0.26017816934690785, 0.13434400219712916, 0.13970202860746506, 0.13757296784851514, 0.1312277111713369, 0.1474437185766716, 0.14115619726869533, 0.12542594513098226, 0.12931430207398464, 0.15890532503478294, 0.1340014559607049, 0.16194077656853167, 0.15825505847680688, 0.15140922018181624, 0.1353860294342618, 0.12104250911233505, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.1413182244071577, 0.13406811512954864, 0.13383306591002386, 0.11958313344491767, 0.11994701756160409, 0.13675359588029, 0.15863923354822362, 0.15890281998249411, 0.10923426297588323, 0.17623512810747088, 0.18298662223703388, 0.18477953225347776, 0.18215795450203998, 0.20816640647458606, 0.17618327205205042, 0.18307880836288581, 0.17594159139051913, 0.20160512613031956, 0.051067160587467186, 0.07365481414840036, 0.0624652635113736, 0.05011642004620953, 0.05856229375134048, 0.051748415108643475, 0.0726896568361941, 0.0556708210523037, 0.05145142250940138]}, "mutation_prompt": null}
{"id": "9061428c-f3ee-4a1d-867a-04f3476beb6f", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.9)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2 = AHQBACO_DN2(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization with Dynamic Neighborhoods and Dynamic Exploration-Exploitation Tradeoff (AHQBACO-DN2) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization, dynamically adjusts the neighborhoods of onlooker bees based on the fitness of employed bees, and dynamically adjusts the exploration-exploitation tradeoff based on the convergence of the algorithm.", "configspace": "", "generation": 31, "fitness": 0.12833156152719596, "feedback": "The algorithm AHQBACO_DN2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "0a12067b-b356-401f-a609-68abb35278e1", "metadata": {"aucs": [0.16777956103619596, 0.17302578444658379, 0.15954138089087244, 0.1540328077434373, 0.16486720326507898, 0.15895695840163737, 0.16270741935431654, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030687720146829855, 0.04229920659856412, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02484300085510005, 0.016387750030765758, 0.03039635989476097, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9870027195072814, 0.9397727441281807, 0.9819514713670061, 0.9904247417202404, 0.9791806882542481, 0.9999001200375565, 0.9939307850609067, 0.9468842276134357, 0.9633711805532488, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16445899252251694, 0.19251264416280434, 0.15710473244435375, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08637246507304841, 0.12740167524302104, 0.10848236017349189, 0.09157168790313919, 0.0945126724140044, 0.1058709446767252, 0.08937260103869682, 0.10265746626855166, 0.09543280535896481, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.033198415640640855, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18871350186886504, 0.1942830385150579, 0.17638713725373223, 0.1873999167545075, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037738355399636214, 0.03149234042422633, 0.04231214916752091, 0.13566589911417104, 0.11518010766085951, 0.1403075403980727, 0.13871562955069006, 0.1372262786133278, 0.1097355930509093, 0.14679662014780237, 0.1414549001063835, 0.11982832573820867, 0.1610745641389092, 0.149343332833774, 0.16681252075516728, 0.17390016624160565, 0.16459870047718217, 0.16649653935521858, 0.15127901597955062, 0.17355384695910447, 0.14094129698813318, 0.09990585299789723, 0.08927646262021338, 0.1071630535151673, 0.11814028698687329, 0.12351602289666441, 0.12041935284579319, 0.09812208369943642, 0.12245563847484786, 0.11051259371597966, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.2601665068806729, 0.26017153992687414, 0.26263770681344867, 0.2601678946548399, 0.26017816934690785, 0.1407555242655073, 0.138573316280035, 0.14977569096645127, 0.13670129547293797, 0.13703625611246606, 0.14084817961805252, 0.12623570558600972, 0.12791972836821264, 0.15937956746530713, 0.13001686266829715, 0.16080547770912668, 0.1582109416108034, 0.15137550649944465, 0.13538153959863353, 0.1206017820247891, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013973170546046, 0.13406252454194778, 0.13348907333088667, 0.11959952352508518, 0.11993937425063539, 0.13675049794254157, 0.15881046962968215, 0.15864017961057142, 0.10908185570859041, 0.18990571507404408, 0.18556423272408507, 0.18519976647975844, 0.18705664773167208, 0.20939390573284133, 0.16994464138519927, 0.18091071892496713, 0.17352816580817998, 0.20268042657962027, 0.05370732823685154, 0.10910642640898427, 0.0637581134875469, 0.05641413628780134, 0.05805474214227857, 0.05199977476805484, 0.07284048589835002, 0.06270127460431774, 0.05867764153446875]}, "mutation_prompt": null}
{"id": "a2c330d5-4fda-49b4-ba82-e00f58d8db00", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.9)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de = AHQBACO_DN2_DE(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization with Dynamic Neighborhoods and Dynamic Exploration-Exploitation Tradeoff and Adaptive Differential Evolution (AHQBACO-DN2-DE) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization, dynamically adjusts the neighborhoods of onlooker bees based on the fitness of employed bees, dynamically adjusts the exploration-exploitation tradeoff based on the convergence of the algorithm, and incorporates Adaptive Differential Evolution for enhanced exploration.", "configspace": "", "generation": 32, "fitness": 0.1284305962518531, "feedback": "The algorithm AHQBACO_DN2_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "9061428c-f3ee-4a1d-867a-04f3476beb6f", "metadata": {"aucs": [0.1677770146933657, 0.1728954492371706, 0.157608303931004, 0.15403975832839967, 0.1648562418301468, 0.158979878581736, 0.1627049578055918, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03135287374124596, 0.042297665339880997, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.021650506778563616, 0.019278146891583803, 0.029938111114669708, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9658179814417502, 0.9932423229580043, 0.9820079165317014, 0.9753881074006837, 0.9850981882542482, 0.9927243402131976, 0.9938561017944598, 0.9882009745029933, 0.9643965858822654, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.1641965298523086, 0.19192860842385262, 0.16003672374383004, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08796250228177871, 0.08877020939071845, 0.10037899069346423, 0.14757590116537034, 0.09715318123956951, 0.10889140837969569, 0.1128369139922274, 0.1058159962558155, 0.09540251428682955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.1774167541950743, 0.1887606785329785, 0.19510487677909327, 0.173167389347873, 0.18637402924846325, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03775841439762828, 0.03152262647728599, 0.04231214916752091, 0.13578299041779696, 0.1194993123551269, 0.11796342286324657, 0.1387262254078152, 0.13935915309590108, 0.10997898183062449, 0.14596673926858128, 0.14144675127365913, 0.12028868050735875, 0.1610745641389092, 0.14937621116201716, 0.16680543873487874, 0.17531023736908935, 0.16690798511797478, 0.16742146422737425, 0.15127901597955062, 0.17357244887918022, 0.14087278706859396, 0.09989989921586839, 0.08928111045160281, 0.1071630535151673, 0.12068793637322195, 0.1196683984253275, 0.12187676502929368, 0.09812208369943642, 0.12246601612611141, 0.11059126015736165, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.2601665068806729, 0.2626273777805045, 0.26263770681344867, 0.2601737466540327, 0.2601794947077204, 0.1320742537490298, 0.13856814490582914, 0.14977569096645127, 0.13954742512387364, 0.13475812284210986, 0.14085960050253765, 0.12623570558600972, 0.13507824487384246, 0.15937956746530713, 0.12667632666487683, 0.1606319760738859, 0.158102956406742, 0.15137879995535475, 0.1353812470117839, 0.12080512571953517, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.1400986269807849, 0.13406252454194778, 0.13349307992784254, 0.11960477127904323, 0.11996197588588142, 0.13675049794254157, 0.15868787212298918, 0.15563161425694072, 0.10980097721265791, 0.16962733976013966, 0.18305443369716945, 0.18467801093731995, 0.18705268496937877, 0.2095867472928581, 0.17039569584947112, 0.17635016818094573, 0.17394147594001153, 0.20268042657962027, 0.05351282892939524, 0.07096618215184203, 0.06366274175944053, 0.059815160297119974, 0.057973197302232604, 0.053017432462454606, 0.07289074544633645, 0.05649213363916006, 0.06434213002545763]}, "mutation_prompt": null}
{"id": "7c336874-f516-449c-932a-7ee0a0e5cd0b", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.9)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de = AHQBACO_DN2_DE(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization with Dynamic Neighborhoods and Dynamic Exploration-Exploitation Tradeoff and Adaptive Differential Evolution (AHQBACO-DN2-DE) - An adaptive hybrid algorithm that combines the exploration capabilities of Quantum-Behaved Harmony Search with the exploitation capabilities of Artificial Bee Colony Optimization, dynamically adjusts the neighborhoods of onlooker bees based on the fitness of employed bees, dynamically adjusts the exploration-exploitation tradeoff based on the convergence of the algorithm, and incorporates Adaptive Differential Evolution for enhanced exploration.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a2c330d5-4fda-49b4-ba82-e00f58d8db00", "metadata": {"aucs": [0.1677770146933657, 0.1728954492371706, 0.157608303931004, 0.15403975832839967, 0.1648562418301468, 0.158979878581736, 0.1627049578055918, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03135287374124596, 0.042297665339880997, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.021650506778563616, 0.019278146891583803, 0.029938111114669708, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9658179814417502, 0.9932423229580043, 0.9820079165317014, 0.9753881074006837, 0.9850981882542482, 0.9927243402131976, 0.9938561017944598, 0.9882009745029933, 0.9643965858822654, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.1641965298523086, 0.19192860842385262, 0.16003672374383004, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08796250228177871, 0.08877020939071845, 0.10037899069346423, 0.14757590116537034, 0.09715318123956951, 0.10889140837969569, 0.1128369139922274, 0.1058159962558155, 0.09540251428682955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.1774167541950743, 0.1887606785329785, 0.19510487677909327, 0.173167389347873, 0.18637402924846325, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03775841439762828, 0.03152262647728599, 0.04231214916752091, 0.13578299041779696, 0.1194993123551269, 0.11796342286324657, 0.1387262254078152, 0.13935915309590108, 0.10997898183062449, 0.14596673926858128, 0.14144675127365913, 0.12028868050735875, 0.1610745641389092, 0.14937621116201716, 0.16680543873487874, 0.17531023736908935, 0.16690798511797478, 0.16742146422737425, 0.15127901597955062, 0.17357244887918022, 0.14087278706859396, 0.09989989921586839, 0.08928111045160281, 0.1071630535151673, 0.12068793637322195, 0.1196683984253275, 0.12187676502929368, 0.09812208369943642, 0.12246601612611141, 0.11059126015736165, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.2601665068806729, 0.2626273777805045, 0.26263770681344867, 0.2601737466540327, 0.2601794947077204, 0.1320742537490298, 0.13856814490582914, 0.14977569096645127, 0.13954742512387364, 0.13475812284210986, 0.14085960050253765, 0.12623570558600972, 0.13507824487384246, 0.15937956746530713, 0.12667632666487683, 0.1606319760738859, 0.158102956406742, 0.15137879995535475, 0.1353812470117839, 0.12080512571953517, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.1400986269807849, 0.13406252454194778, 0.13349307992784254, 0.11960477127904323, 0.11996197588588142, 0.13675049794254157, 0.15868787212298918, 0.15563161425694072, 0.10980097721265791, 0.16962733976013966, 0.18305443369716945, 0.18467801093731995, 0.18705268496937877, 0.2095867472928581, 0.17039569584947112, 0.17635016818094573, 0.17394147594001153, 0.20268042657962027, 0.05351282892939524, 0.07096618215184203, 0.06366274175944053, 0.059815160297119974, 0.057973197302232604, 0.053017432462454606, 0.07289074544633645, 0.05649213363916006, 0.06434213002545763]}, "mutation_prompt": null}
{"id": "799b7e71-3880-4ef9-8cf2-1176b13c9782", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * self.exploration_rate_adjustment)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * self.exploration_rate_adjustment)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * self.exploration_rate_adjustment)  # adjust neighborhood size based on fitness of employed bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2 = AHQBACO_DN2_DE2(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization with Dynamic Neighborhoods and Dynamic Exploration-Exploitation Tradeoff and Adaptive Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size (AHQBACO-DN2-DE2)", "configspace": "", "generation": 34, "fitness": 0.1287023346074033, "feedback": "The algorithm AHQBACO_DN2_DE2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "a2c330d5-4fda-49b4-ba82-e00f58d8db00", "metadata": {"aucs": [0.16780065625360818, 0.1728512254514526, 0.15796406485420844, 0.15403403248510572, 0.16485761402461452, 0.15898560438757192, 0.1627064242821089, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030854808682483026, 0.042297665339880997, 0.028707454718879255, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.022839947283892603, 0.015652157900255093, 0.03070596733456854, 0.01969646754387211, 0.033153130081172266, 0.04462367806249967, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9829172344104902, 0.993230649257379, 0.9967314833102295, 0.9906119211312752, 0.9850081882542482, 0.9972717099606738, 0.9984358291545808, 0.9881999830953645, 0.9425127713573196, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15679745376437948, 0.1926773706368211, 0.14946496045600088, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08192269488509862, 0.1279532001971695, 0.08435303557230511, 0.10197157110430566, 0.11190169214133927, 0.10889140837969569, 0.10003046438195728, 0.09345034416849762, 0.10148068022586954, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831658361763817, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.027473647716905747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.1887606785329785, 0.19504302912358873, 0.17135567140838082, 0.18762741510421677, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.0377556675645081, 0.03149234042422633, 0.04231214916752091, 0.13546098245755878, 0.11613641580601763, 0.13256478739748967, 0.1387225781051249, 0.13721084259603444, 0.12436624986425937, 0.14679618405111383, 0.1408041909962432, 0.1193171697755614, 0.16072475734955538, 0.149343332833774, 0.16680700055622488, 0.17532508481131792, 0.16594231784340518, 0.16625828789250285, 0.15127901597955062, 0.17359018863582443, 0.14089341851632475, 0.09990585299789723, 0.08927646262021338, 0.1071630535151673, 0.11757798766198735, 0.12349634022151845, 0.11783613670760373, 0.09812208369943642, 0.12245563847484786, 0.11053134612354043, 0.26018223221605774, 0.26016601643901793, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.2626273777805045, 0.2601875539181707, 0.2601678946548399, 0.2601794947077204, 0.14076595050500396, 0.13800289038965985, 0.14977569096645127, 0.1368227818644322, 0.1366279504079625, 0.140143161101136, 0.12070113971652952, 0.13507824487384246, 0.16005469550930485, 0.12664168960000843, 0.1608047457274011, 0.158102956406742, 0.15135986039941796, 0.1353860294342618, 0.12059711253180116, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.1400986269807849, 0.13406252454194778, 0.13363688966420528, 0.11959952352508518, 0.11993712184786531, 0.13675049794254157, 0.15847568669094436, 0.1582476098530815, 0.109371068465554, 0.1695702756814429, 0.18304729910324014, 0.1765805904024561, 0.1817302811521413, 0.20939390573284133, 0.212076373012152, 0.18260536022978513, 0.1767390197655001, 0.2000745921927376, 0.05363722569402929, 0.1090530951111941, 0.06393293515518395, 0.05837738675643522, 0.06099869662024471, 0.05165859325259592, 0.07015213629518291, 0.05730164562463891, 0.06455736112848753]}, "mutation_prompt": null}
{"id": "e16860d8-3cfe-47db-bf87-109c38372ae7", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Behaved Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * self.exploration_rate_adjustment)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * self.exploration_rate_adjustment)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * self.exploration_rate_adjustment)  # adjust neighborhood size based on fitness of employed bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2 = AHQBACO_DN2_DE2(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2", "description": "Adaptive Hybridization of Quantum-Behaved Harmony Search and Artificial Bee Colony Optimization with Dynamic Neighborhoods and Dynamic Exploration-Exploitation Tradeoff and Adaptive Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size (AHQBACO-DN2-DE2)", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "799b7e71-3880-4ef9-8cf2-1176b13c9782", "metadata": {"aucs": [0.16780065625360818, 0.1728512254514526, 0.15796406485420844, 0.15403403248510572, 0.16485761402461452, 0.15898560438757192, 0.1627064242821089, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030854808682483026, 0.042297665339880997, 0.028707454718879255, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.022839947283892603, 0.015652157900255093, 0.03070596733456854, 0.01969646754387211, 0.033153130081172266, 0.04462367806249967, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9829172344104902, 0.993230649257379, 0.9967314833102295, 0.9906119211312752, 0.9850081882542482, 0.9972717099606738, 0.9984358291545808, 0.9881999830953645, 0.9425127713573196, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15679745376437948, 0.1926773706368211, 0.14946496045600088, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08192269488509862, 0.1279532001971695, 0.08435303557230511, 0.10197157110430566, 0.11190169214133927, 0.10889140837969569, 0.10003046438195728, 0.09345034416849762, 0.10148068022586954, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831658361763817, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.027473647716905747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.1887606785329785, 0.19504302912358873, 0.17135567140838082, 0.18762741510421677, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.0377556675645081, 0.03149234042422633, 0.04231214916752091, 0.13546098245755878, 0.11613641580601763, 0.13256478739748967, 0.1387225781051249, 0.13721084259603444, 0.12436624986425937, 0.14679618405111383, 0.1408041909962432, 0.1193171697755614, 0.16072475734955538, 0.149343332833774, 0.16680700055622488, 0.17532508481131792, 0.16594231784340518, 0.16625828789250285, 0.15127901597955062, 0.17359018863582443, 0.14089341851632475, 0.09990585299789723, 0.08927646262021338, 0.1071630535151673, 0.11757798766198735, 0.12349634022151845, 0.11783613670760373, 0.09812208369943642, 0.12245563847484786, 0.11053134612354043, 0.26018223221605774, 0.26016601643901793, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.2626273777805045, 0.2601875539181707, 0.2601678946548399, 0.2601794947077204, 0.14076595050500396, 0.13800289038965985, 0.14977569096645127, 0.1368227818644322, 0.1366279504079625, 0.140143161101136, 0.12070113971652952, 0.13507824487384246, 0.16005469550930485, 0.12664168960000843, 0.1608047457274011, 0.158102956406742, 0.15135986039941796, 0.1353860294342618, 0.12059711253180116, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.1400986269807849, 0.13406252454194778, 0.13363688966420528, 0.11959952352508518, 0.11993712184786531, 0.13675049794254157, 0.15847568669094436, 0.1582476098530815, 0.109371068465554, 0.1695702756814429, 0.18304729910324014, 0.1765805904024561, 0.1817302811521413, 0.20939390573284133, 0.212076373012152, 0.18260536022978513, 0.1767390197655001, 0.2000745921927376, 0.05363722569402929, 0.1090530951111941, 0.06393293515518395, 0.05837738675643522, 0.06099869662024471, 0.05165859325259592, 0.07015213629518291, 0.05730164562463891, 0.06455736112848753]}, "mutation_prompt": null}
{"id": "4b085de2-0f72-466f-8b2f-b2b86366e09b", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined = AHQBACO_DN2_DE2_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size.", "configspace": "", "generation": 36, "fitness": 0.1287469295118644, "feedback": "The algorithm AHQBACO_DN2_DE2_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "799b7e71-3880-4ef9-8cf2-1176b13c9782", "metadata": {"aucs": [0.16777026064192524, 0.1728663073918313, 0.15942722416770683, 0.15404174970884177, 0.16485277201301995, 0.15898306837794374, 0.16270595287779943, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031398218348746565, 0.042297665339880997, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024990071778364875, 0.0163763884779784, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.04443883784560787, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9652618730334694, 0.9887291511166051, 0.9873753607235634, 0.9903590130890318, 0.9850081882542482, 0.9999001200375565, 0.9984358291545808, 0.9638687151716653, 0.9632352713573192, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15345494377872915, 0.1926773706368211, 0.154999003313671, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08701945904975783, 0.11014199305547534, 0.11275589901584737, 0.14609264979453807, 0.10493177416982002, 0.10884746199862416, 0.10895507997970222, 0.11679709079149958, 0.08506989365538287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18871350186886504, 0.19365306456994724, 0.17638713725373223, 0.1878665300061403, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037738355399636214, 0.03149234042422633, 0.04231214916752091, 0.1357939799439426, 0.11907127164486542, 0.1403075403980727, 0.1387225781051249, 0.1372262786133278, 0.1097355930509093, 0.14680156083880325, 0.1414549001063835, 0.12041721934283778, 0.16076931587688736, 0.14932637916282887, 0.16682391176957478, 0.17487873313206126, 0.16627325686555927, 0.16817781153116773, 0.15127901597955062, 0.17355384695910447, 0.1409469951942578, 0.09990408127128181, 0.08927646262021338, 0.10716775680921653, 0.11174586385911134, 0.12350861660104107, 0.11948223732203389, 0.09812208369943642, 0.12245678839991947, 0.11053631086062154, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.2601665068806729, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.26017816934690785, 0.14076595050500396, 0.13614477447544615, 0.12975720403044255, 0.12702806617791107, 0.13708457610217228, 0.14085960050253765, 0.1182974903379167, 0.12791972836821264, 0.15890532503478294, 0.12912736952395953, 0.1608047457274011, 0.15809829878022652, 0.15133833815034814, 0.13538153959863353, 0.12073046838649348, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13363631093164408, 0.11961705079305107, 0.11993917134603727, 0.13675049794254157, 0.1583239015498873, 0.15621519415389284, 0.10980097721265791, 0.1708211689189182, 0.18298662223703388, 0.1765805904024561, 0.18705664773167208, 0.20939061570930817, 0.2102261280069374, 0.18258671193628362, 0.1733991415989118, 0.20018122492980384, 0.0491930548421855, 0.10906215974178735, 0.06330177998080377, 0.05551436085328865, 0.05836299341733575, 0.04938951367217892, 0.07035130624513697, 0.06273658202727128, 0.053272815479897706]}, "mutation_prompt": null}
{"id": "13fc8351-010a-4752-b3c0-c7cf3c37e847", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined = AHQBACO_DN2_DE2_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4b085de2-0f72-466f-8b2f-b2b86366e09b", "metadata": {"aucs": [0.16777026064192524, 0.1728663073918313, 0.15942722416770683, 0.15404174970884177, 0.16485277201301995, 0.15898306837794374, 0.16270595287779943, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031398218348746565, 0.042297665339880997, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024990071778364875, 0.0163763884779784, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.04443883784560787, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9652618730334694, 0.9887291511166051, 0.9873753607235634, 0.9903590130890318, 0.9850081882542482, 0.9999001200375565, 0.9984358291545808, 0.9638687151716653, 0.9632352713573192, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15345494377872915, 0.1926773706368211, 0.154999003313671, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08701945904975783, 0.11014199305547534, 0.11275589901584737, 0.14609264979453807, 0.10493177416982002, 0.10884746199862416, 0.10895507997970222, 0.11679709079149958, 0.08506989365538287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18871350186886504, 0.19365306456994724, 0.17638713725373223, 0.1878665300061403, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037738355399636214, 0.03149234042422633, 0.04231214916752091, 0.1357939799439426, 0.11907127164486542, 0.1403075403980727, 0.1387225781051249, 0.1372262786133278, 0.1097355930509093, 0.14680156083880325, 0.1414549001063835, 0.12041721934283778, 0.16076931587688736, 0.14932637916282887, 0.16682391176957478, 0.17487873313206126, 0.16627325686555927, 0.16817781153116773, 0.15127901597955062, 0.17355384695910447, 0.1409469951942578, 0.09990408127128181, 0.08927646262021338, 0.10716775680921653, 0.11174586385911134, 0.12350861660104107, 0.11948223732203389, 0.09812208369943642, 0.12245678839991947, 0.11053631086062154, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.2601665068806729, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.26017816934690785, 0.14076595050500396, 0.13614477447544615, 0.12975720403044255, 0.12702806617791107, 0.13708457610217228, 0.14085960050253765, 0.1182974903379167, 0.12791972836821264, 0.15890532503478294, 0.12912736952395953, 0.1608047457274011, 0.15809829878022652, 0.15133833815034814, 0.13538153959863353, 0.12073046838649348, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13363631093164408, 0.11961705079305107, 0.11993917134603727, 0.13675049794254157, 0.1583239015498873, 0.15621519415389284, 0.10980097721265791, 0.1708211689189182, 0.18298662223703388, 0.1765805904024561, 0.18705664773167208, 0.20939061570930817, 0.2102261280069374, 0.18258671193628362, 0.1733991415989118, 0.20018122492980384, 0.0491930548421855, 0.10906215974178735, 0.06330177998080377, 0.05551436085328865, 0.05836299341733575, 0.04938951367217892, 0.07035130624513697, 0.06273658202727128, 0.053272815479897706]}, "mutation_prompt": null}
{"id": "a2f57f81-a3c4-4a5b-ba35-179ba1db8689", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_ADAPTIVE_LEVY:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.levy_flight_step_size = 1.0  # levy flight step size\n        self.levy_flight_probability = 0.1  # levy flight probability\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            # Adaptive Levy Flight Search\n            if random.random() < self.levy_flight_probability and np.linalg.norm(self.harmony_memory[i] - self.best_solution) > 1.0:\n                self.harmony_memory[i] = self.best_solution + self.levy_flight_step_size * np.random.normal(0, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_adaptive_levy = AHQBACO_DN2_DE2_REFINED_ADAPTIVE_LEVY(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_adaptive_levy(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_ADAPTIVE_LEVY", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment, Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, and a new component of Adaptive Levy Flight Search to escape local optima.", "configspace": "", "generation": 38, "fitness": 0.12761915002133636, "feedback": "The algorithm AHQBACO_DN2_DE2_REFINED_ADAPTIVE_LEVY got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "4b085de2-0f72-466f-8b2f-b2b86366e09b", "metadata": {"aucs": [0.16834163588363094, 0.17335489537884208, 0.15968730049529223, 0.15403853358673114, 0.16485277201301995, 0.158979878581736, 0.16270429889919014, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03069753383462781, 0.042297665339880997, 0.028726245370913395, 0.030148243185525447, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.021804487570295517, 0.019061792794462185, 0.030892453833092803, 0.01969646754387211, 0.033153130081172266, 0.0446340152314062, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9389345702618814, 0.9912145245033609, 0.957449035004182, 0.9719819211312751, 0.9587623724866992, 0.9661433754968236, 0.9984358291545808, 0.9911256058148992, 0.9827742825268281, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.14187832132620426, 0.19168567472847786, 0.15686273085597058, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.0949179987589518, 0.12153338201433495, 0.10512286535022108, 0.09523269225085806, 0.13611497840979936, 0.08326078942659332, 0.08645074009757003, 0.1122425159317989, 0.11563032703208742, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831543164293143, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18874635896985426, 0.19407628783479214, 0.1760788339193714, 0.187458198473768, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03780304367199683, 0.03152262647728599, 0.04231214916752091, 0.13553769593213671, 0.11930388027744843, 0.11909411615829124, 0.1387262254078152, 0.1372262786133278, 0.10980446992278814, 0.1457235543067894, 0.14187691740130925, 0.11780038504126733, 0.1610745641389092, 0.14933128488603975, 0.16686424976212888, 0.17063578073158137, 0.1689453738158807, 0.16561290532894768, 0.15127901597955062, 0.17357244887918022, 0.1405982965737539, 0.09989989921586839, 0.08928111045160281, 0.10716775680921653, 0.13644944958461525, 0.118859656268133, 0.11671656623447124, 0.09812208369943642, 0.12245014374148089, 0.1105919194651881, 0.26018223221605774, 0.26016601643901793, 0.2601786226371633, 0.2635870225341066, 0.2601665068806729, 0.2601769605582607, 0.2601875539181707, 0.2601678946548399, 0.2601794947077204, 0.13304269332473795, 0.13614477447544615, 0.13364300413739671, 0.1358734221355451, 0.1332612531301054, 0.14419576581213056, 0.11714822010555981, 0.12901759522265366, 0.15890532503478294, 0.12760328477459892, 0.16103168088397957, 0.1581111966088925, 0.1513356545171608, 0.13538153959863353, 0.12045641090435688, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.1400989037405388, 0.13406252454194778, 0.13372396268040576, 0.1196151491866636, 0.11996053563293785, 0.13675049794254157, 0.15884487873755493, 0.15700256744771302, 0.11013287561666163, 0.1713460968647138, 0.18309896813100435, 0.17423082580943428, 0.18411194298994826, 0.20939060864512649, 0.17627518144341026, 0.17649229018583934, 0.17419715572825667, 0.2002697323585313, 0.055674259096846646, 0.05284650455000106, 0.06345354865684205, 0.052791287611607896, 0.058622693804419757, 0.05022706296830981, 0.07095842984381451, 0.05900625959289196, 0.06401562787774806]}, "mutation_prompt": null}
{"id": "3e62d654-a89f-4438-a575-feb8e1741ecd", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability = 0.1  # probability of changing individual lines\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            if random.random() < self.probability:\n                # 10% chance of changing individual lines\n                if random.random() < 0.3:\n                    # Change exploration rate\n                    self.exploration_rate = random.uniform(0.1, 0.9)\n                elif random.random() < 0.3:\n                    # Change neighborhood size\n                    self.neighborhood_size = random.uniform(0.1 * self.budget, 0.2 * self.budget)\n                elif random.random() < 0.3:\n                    # Change differential evolution parameter\n                    self.F = random.uniform(0.1, 0.9)\n                else:\n                    # Change convergence threshold\n                    self.convergence_threshold = random.uniform(0.01, 0.1)\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * self.budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * self.budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined = AHQBACO_DN2_DE2_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size with a 10% probability of changing individual lines to refine its strategy.", "configspace": "", "generation": 39, "fitness": 0.12868293866807687, "feedback": "The algorithm AHQBACO_DN2_DE2_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "4b085de2-0f72-466f-8b2f-b2b86366e09b", "metadata": {"aucs": [0.16791744477381731, 0.17303682823851851, 0.15913822632408559, 0.15403095327174998, 0.16485277201301995, 0.15898306837794374, 0.16270529397139766, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03093861740882964, 0.042297665339880997, 0.028786365634780098, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024995338660832367, 0.016404343011608757, 0.029927705953796457, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9874001654576415, 0.9887291511166051, 0.9873976530829224, 0.9904714451575286, 0.9850981882542482, 0.9972717099606738, 0.9938949280389165, 0.9638687151716653, 0.9653401775691007, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.1515757234171624, 0.19188751537058824, 0.1581016112977981, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08880750174116037, 0.126571303028996, 0.09918811242132108, 0.09784790385724462, 0.10500696382187702, 0.10728861383244603, 0.11295254232114571, 0.11734569778248882, 0.08930098909624962, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831543164293143, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18873430734613306, 0.1952465446966145, 0.17542611226806182, 0.18787450350182366, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03771420465876418, 0.03149234042422633, 0.04231214916752091, 0.13566589911417104, 0.11615492732627897, 0.1403075403980727, 0.1387225781051249, 0.13721084259603444, 0.10997898183062449, 0.14592403615220917, 0.1409540051082171, 0.1182901064465115, 0.1610745641389092, 0.1493576353589049, 0.16681252075516728, 0.16920417671478372, 0.16749798631992452, 0.16614879850637043, 0.15127901597955062, 0.17357977785564216, 0.14090609057101644, 0.0999016709424837, 0.08928782259693491, 0.1071630535151673, 0.1202574255904677, 0.12007089590984255, 0.11929472649829254, 0.09812208369943642, 0.1224537527043591, 0.11059392574141602, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2601875539181707, 0.2601737466540327, 0.2601794947077204, 0.14285455170247385, 0.13856814490582914, 0.13255337194618855, 0.12482111475884816, 0.13366456216150413, 0.14085960050253765, 0.12623570558600972, 0.13526331024062344, 0.16005469550930485, 0.12834462120830503, 0.16073992857644348, 0.1582074950252207, 0.1513356545171608, 0.1353860294342618, 0.12082248404264118, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.1400989037405388, 0.13407049192775466, 0.13364089626116094, 0.11960477127904323, 0.11996054914979903, 0.13675049794254157, 0.15861987432987767, 0.15660334685698385, 0.10932810137257076, 0.16563123704115024, 0.18304729910324014, 0.1846774426752329, 0.18697243178423184, 0.20660398573121874, 0.20921176836304112, 0.1742910766040905, 0.17641734931738595, 0.2000745921927376, 0.05286048304067936, 0.10905334449523107, 0.06369354359282065, 0.059833557768520174, 0.05847740743192098, 0.05297287771800674, 0.07082769071392436, 0.06367105538332873, 0.06490589824661142]}, "mutation_prompt": null}
{"id": "adce8825-e127-4b77-91e0-3c37cb27f1b9", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.convergence_counter = 0  # counter for convergence\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.convergence_counter += 1\n                if self.convergence_counter >= 10:\n                    self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n                    self.convergence_counter = 0\n            else:\n                self.convergence_counter = 0\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined = AHQBACO_DN2_DE2_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED", "description": "Novel hybridization of Adaptive Harmony Search with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment, and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, and Enhanced Artificial Bee Colony Optimization with Adaptive Dance Memory and Convergence Threshold.", "configspace": "", "generation": 40, "fitness": 0.12847301254560786, "feedback": "The algorithm AHQBACO_DN2_DE2_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "4b085de2-0f72-466f-8b2f-b2b86366e09b", "metadata": {"aucs": [0.1679179937781059, 0.17287831388867902, 0.15952060726604345, 0.15402972853008146, 0.16485414420748767, 0.15898306837794374, 0.1627080782607181, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030854808682483026, 0.042297665339880997, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024930535702026968, 0.019532965195630858, 0.03032117354057351, 0.01969646754387211, 0.033153130081172266, 0.04462538477247513, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.978979769614623, 0.9694925847285517, 0.9967091909508705, 0.9903291137031196, 0.9847288766579783, 0.9999001200375565, 0.9938961284616757, 0.9881932362058072, 0.9651259532542663, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15495133086390545, 0.19205520532700826, 0.1569800270635454, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08460988801336966, 0.11058804795451704, 0.10075510270159138, 0.10423543330437535, 0.11195373172354972, 0.10889140837969569, 0.11166892691732122, 0.1062813636314831, 0.08840040693093765, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831543164293143, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.1774167541950743, 0.18876344404115986, 0.19442998431990366, 0.1763214624486431, 0.18740501849305702, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03774444209317751, 0.03150842159239786, 0.04231214916752091, 0.13568327507783706, 0.11608495146824949, 0.1403075403980727, 0.1387262254078152, 0.1372262786133278, 0.10997898183062449, 0.1457760375692273, 0.1409548205271972, 0.11991776301982604, 0.16076931587688736, 0.14938782888659952, 0.16684772814827575, 0.16947066308966863, 0.16893185126301835, 0.16519528121562266, 0.15127901597955062, 0.17357244887918022, 0.14085225601573892, 0.09989989921586839, 0.08926282734017021, 0.1071630535151673, 0.12010087012544313, 0.11974667832455888, 0.11706672619692671, 0.09812208369943642, 0.12246757639898764, 0.11056919662052134, 0.26018223221605774, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2601875539181707, 0.2601678946548399, 0.26017816934690785, 0.1407555242655073, 0.138573316280035, 0.14977569096645127, 0.13950981028545995, 0.134446969418496, 0.1401296379883603, 0.1166921807739465, 0.13526331024062344, 0.15937956746530713, 0.12999726264968903, 0.16088987652210185, 0.15809772349028206, 0.15137550649944465, 0.1353812470117839, 0.12075018567078477, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.1400989037405388, 0.13406252454194778, 0.1336401190575407, 0.11960477127904323, 0.11996219230734095, 0.13675049794254157, 0.15869027717202278, 0.15809492603969322, 0.10965080659606752, 0.16916741187737638, 0.18298662223703388, 0.18467801093731995, 0.1816984911832107, 0.2095867472928581, 0.21293130750707268, 0.17655545162573794, 0.1761887193681767, 0.20264970129115645, 0.053508303314251826, 0.049201211280228585, 0.06396831182204221, 0.05516563345988601, 0.060679106066936384, 0.05179958104544835, 0.07289074544633645, 0.056818444413144764, 0.059177826530743216]}, "mutation_prompt": null}
{"id": "3147c73a-f23a-4f0e-a62d-23246679d04b", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined = AHQBACO_DN2_DE2_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4b085de2-0f72-466f-8b2f-b2b86366e09b", "metadata": {"aucs": [0.16777026064192524, 0.1728663073918313, 0.15942722416770683, 0.15404174970884177, 0.16485277201301995, 0.15898306837794374, 0.16270595287779943, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031398218348746565, 0.042297665339880997, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024990071778364875, 0.0163763884779784, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.04443883784560787, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9652618730334694, 0.9887291511166051, 0.9873753607235634, 0.9903590130890318, 0.9850081882542482, 0.9999001200375565, 0.9984358291545808, 0.9638687151716653, 0.9632352713573192, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15345494377872915, 0.1926773706368211, 0.154999003313671, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08701945904975783, 0.11014199305547534, 0.11275589901584737, 0.14609264979453807, 0.10493177416982002, 0.10884746199862416, 0.10895507997970222, 0.11679709079149958, 0.08506989365538287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18871350186886504, 0.19365306456994724, 0.17638713725373223, 0.1878665300061403, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037738355399636214, 0.03149234042422633, 0.04231214916752091, 0.1357939799439426, 0.11907127164486542, 0.1403075403980727, 0.1387225781051249, 0.1372262786133278, 0.1097355930509093, 0.14680156083880325, 0.1414549001063835, 0.12041721934283778, 0.16076931587688736, 0.14932637916282887, 0.16682391176957478, 0.17487873313206126, 0.16627325686555927, 0.16817781153116773, 0.15127901597955062, 0.17355384695910447, 0.1409469951942578, 0.09990408127128181, 0.08927646262021338, 0.10716775680921653, 0.11174586385911134, 0.12350861660104107, 0.11948223732203389, 0.09812208369943642, 0.12245678839991947, 0.11053631086062154, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.2601665068806729, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.26017816934690785, 0.14076595050500396, 0.13614477447544615, 0.12975720403044255, 0.12702806617791107, 0.13708457610217228, 0.14085960050253765, 0.1182974903379167, 0.12791972836821264, 0.15890532503478294, 0.12912736952395953, 0.1608047457274011, 0.15809829878022652, 0.15133833815034814, 0.13538153959863353, 0.12073046838649348, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13363631093164408, 0.11961705079305107, 0.11993917134603727, 0.13675049794254157, 0.1583239015498873, 0.15621519415389284, 0.10980097721265791, 0.1708211689189182, 0.18298662223703388, 0.1765805904024561, 0.18705664773167208, 0.20939061570930817, 0.2102261280069374, 0.18258671193628362, 0.1733991415989118, 0.20018122492980384, 0.0491930548421855, 0.10906215974178735, 0.06330177998080377, 0.05551436085328865, 0.05836299341733575, 0.04938951367217892, 0.07035130624513697, 0.06273658202727128, 0.053272815479897706]}, "mutation_prompt": null}
{"id": "73986408-ac84-48e2-aae4-a257898664d4", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined = AHQBACO_DN2_DE2_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4b085de2-0f72-466f-8b2f-b2b86366e09b", "metadata": {"aucs": [0.16777026064192524, 0.1728663073918313, 0.15942722416770683, 0.15404174970884177, 0.16485277201301995, 0.15898306837794374, 0.16270595287779943, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031398218348746565, 0.042297665339880997, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024990071778364875, 0.0163763884779784, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.04443883784560787, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9652618730334694, 0.9887291511166051, 0.9873753607235634, 0.9903590130890318, 0.9850081882542482, 0.9999001200375565, 0.9984358291545808, 0.9638687151716653, 0.9632352713573192, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15345494377872915, 0.1926773706368211, 0.154999003313671, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08701945904975783, 0.11014199305547534, 0.11275589901584737, 0.14609264979453807, 0.10493177416982002, 0.10884746199862416, 0.10895507997970222, 0.11679709079149958, 0.08506989365538287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18871350186886504, 0.19365306456994724, 0.17638713725373223, 0.1878665300061403, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037738355399636214, 0.03149234042422633, 0.04231214916752091, 0.1357939799439426, 0.11907127164486542, 0.1403075403980727, 0.1387225781051249, 0.1372262786133278, 0.1097355930509093, 0.14680156083880325, 0.1414549001063835, 0.12041721934283778, 0.16076931587688736, 0.14932637916282887, 0.16682391176957478, 0.17487873313206126, 0.16627325686555927, 0.16817781153116773, 0.15127901597955062, 0.17355384695910447, 0.1409469951942578, 0.09990408127128181, 0.08927646262021338, 0.10716775680921653, 0.11174586385911134, 0.12350861660104107, 0.11948223732203389, 0.09812208369943642, 0.12245678839991947, 0.11053631086062154, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.2601665068806729, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.26017816934690785, 0.14076595050500396, 0.13614477447544615, 0.12975720403044255, 0.12702806617791107, 0.13708457610217228, 0.14085960050253765, 0.1182974903379167, 0.12791972836821264, 0.15890532503478294, 0.12912736952395953, 0.1608047457274011, 0.15809829878022652, 0.15133833815034814, 0.13538153959863353, 0.12073046838649348, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13363631093164408, 0.11961705079305107, 0.11993917134603727, 0.13675049794254157, 0.1583239015498873, 0.15621519415389284, 0.10980097721265791, 0.1708211689189182, 0.18298662223703388, 0.1765805904024561, 0.18705664773167208, 0.20939061570930817, 0.2102261280069374, 0.18258671193628362, 0.1733991415989118, 0.20018122492980384, 0.0491930548421855, 0.10906215974178735, 0.06330177998080377, 0.05551436085328865, 0.05836299341733575, 0.04938951367217892, 0.07035130624513697, 0.06273658202727128, 0.053272815479897706]}, "mutation_prompt": null}
{"id": "3effb082-c655-460d-9470-864763f8efc1", "solution": "import numpy as np\nimport random\n\nclass NovelHybridAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nnovel_hybrid_algorithm = NovelHybridAlgorithm(budget, dim)\nbest_solution, best_fitness = novel_hybrid_algorithm(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "NovelHybridAlgorithm", "description": "Novel hybridization of Adaptive Harmony Search with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment, and a novel self-adaptive differential evolution with dynamically adjusted exploration rate and neighborhood size.", "configspace": "", "generation": 43, "fitness": 0.11252394542129834, "feedback": "The algorithm NovelHybridAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.11.", "error": "", "parent_id": "4b085de2-0f72-466f-8b2f-b2b86366e09b", "metadata": {"aucs": [0.1838610073920922, 0.1793120707849759, 0.17925399775474238, 0.17888939667535797, 0.18818139055183436, 0.2000134008743415, 0.18569663113586954, 0.17026325707765078, 0.19102805531643763, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.046172291991483316, 0.04947471680881499, 0.03765557444216994, 0.04429004180710727, 0.047073830566923935, 0.04453591032477111, 0.05365729893197746, 0.06702432684758475, 0.05969446741173834, 0.028960386392536952, 0.03804897102901483, 0.0481463786277756, 0.02628141762821945, 0.04926774209271334, 0.05702674525995721, 0.04252029486316955, 0.0400214607891245, 0.029763828138413717, 0.535865358561745, 0.5328756531984553, 0.5411490255957863, 0.4581438907287738, 0.5290964060635459, 0.5386401120803699, 0.49864972309230393, 0.5376576827894812, 0.5362660157581527, 0.07497224974664474, 0.07577845644168357, 0.10285538925361326, 0.0823430851986221, 0.08556460965737, 0.08455444692674041, 0.09683915638154772, 0.062055998807321155, 0.09525662904787824, 0.1330222387934491, 0.19308637766117165, 0.15457554544618668, 0.12476901883216485, 0.10376097723289313, 0.13569193128968005, 0.11776943578138876, 0.14579850607506728, 0.11871160615083298, 0.012625083220351163, 0.006943631695947028, 0.03605146171391116, 0.005078100160334387, 0.009645764497989484, 0.01455104225687287, 9.999999999998899e-05, 0.000672155362200666, 0.019872591751231683, 0.007400385533009812, 0.06957272857429797, 0.01886321506803601, 0.012007987261781095, 0.035362057023575866, 0.0230618898981223, 0.018172291918275518, 0.00862640670892345, 0.0007897305921256148, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05293794841224442, 0.06858859508378334, 0.04788121409256674, 0.06941906045599022, 0.051122359546881824, 0.060541423364661395, 0.05295698494644707, 0.05229195325733127, 0.06421743361722532, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004864634406345214, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0016300885214155514, 0.0008322981510083816, 0.014817611389387642, 0.006754747757416024, 9.999999999998899e-05, 0.22082032439354093, 0.2083096122200604, 0.19046951329060935, 0.20739619741969195, 0.22898383672232292, 0.20724700933075846, 0.21106026379183884, 0.19056476139712475, 0.19877785439501272, 0.0485543123442741, 0.05240226440852125, 0.04634470966123749, 0.051529458969633346, 0.04695605305399553, 0.0489568393131633, 0.073263588849099, 0.04797392201367001, 0.05229792848072812, 0.1370941010055503, 0.12258186970269724, 0.12750450527678026, 0.14419034814174325, 0.1415761014211726, 0.12676931206978592, 0.14963138758589234, 0.14861619065631115, 0.13187167412278433, 0.17305885662024445, 0.16841637250702646, 0.18624203800725547, 0.17203745229553935, 0.18469825102511106, 0.18881660941246137, 0.1656923996173193, 0.17802156880913478, 0.16230697529998162, 0.11404640846140068, 0.10633657796870244, 0.11842275964330096, 0.11002550252717425, 0.13610603218022022, 0.11882267344074904, 0.10984009811175455, 0.1237427242099084, 0.1229185550255375, 0.14241468888117592, 0.1627843992578466, 0.15589351552308695, 0.16293538439343613, 0.1448471391930658, 0.16236042742370171, 0.1496098215765358, 0.17355151355563359, 0.18277724523822958, 0.1471079671116764, 0.14578023879947632, 0.14156479478198125, 0.14164758024276158, 0.14387521216858767, 0.15282202985716775, 0.14311182397460653, 0.14482191202386074, 0.16207881422481074, 0.19700967696179272, 0.19289933525509417, 0.22605850368457459, 0.16360220691511207, 0.1516742273300169, 0.14937790709993937, 0.16638958988603714, 0.1771135228161338, 0.16632340001701718, 0.15672808824074347, 0.15806706581787744, 0.17012138711375135, 0.15348992893193714, 0.14986290682764558, 0.16045374486843178, 0.18441317600638918, 0.17519666076380558, 0.2028812417861957, 0.17628013395777575, 0.19026087781246404, 0.1753713454785668, 0.18683568409856555, 0.2135749380374129, 0.18382439475410084, 0.17594512205278, 0.188688463014553, 0.20568880668582523, 0.058344077551123696, 0.05138086259256147, 0.06585155299632517, 0.052753445631221973, 0.06206830177660427, 0.05387221313135837, 0.07532529613519179, 0.05902000915040839, 0.058304689008996546]}, "mutation_prompt": null}
{"id": "25364252-b0c6-4209-a032-316bb97cf923", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined = AHQBACO_DN2_DE2_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4b085de2-0f72-466f-8b2f-b2b86366e09b", "metadata": {"aucs": [0.16777026064192524, 0.1728663073918313, 0.15942722416770683, 0.15404174970884177, 0.16485277201301995, 0.15898306837794374, 0.16270595287779943, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031398218348746565, 0.042297665339880997, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024990071778364875, 0.0163763884779784, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.04443883784560787, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9652618730334694, 0.9887291511166051, 0.9873753607235634, 0.9903590130890318, 0.9850081882542482, 0.9999001200375565, 0.9984358291545808, 0.9638687151716653, 0.9632352713573192, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15345494377872915, 0.1926773706368211, 0.154999003313671, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08701945904975783, 0.11014199305547534, 0.11275589901584737, 0.14609264979453807, 0.10493177416982002, 0.10884746199862416, 0.10895507997970222, 0.11679709079149958, 0.08506989365538287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18871350186886504, 0.19365306456994724, 0.17638713725373223, 0.1878665300061403, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037738355399636214, 0.03149234042422633, 0.04231214916752091, 0.1357939799439426, 0.11907127164486542, 0.1403075403980727, 0.1387225781051249, 0.1372262786133278, 0.1097355930509093, 0.14680156083880325, 0.1414549001063835, 0.12041721934283778, 0.16076931587688736, 0.14932637916282887, 0.16682391176957478, 0.17487873313206126, 0.16627325686555927, 0.16817781153116773, 0.15127901597955062, 0.17355384695910447, 0.1409469951942578, 0.09990408127128181, 0.08927646262021338, 0.10716775680921653, 0.11174586385911134, 0.12350861660104107, 0.11948223732203389, 0.09812208369943642, 0.12245678839991947, 0.11053631086062154, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.2601665068806729, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.26017816934690785, 0.14076595050500396, 0.13614477447544615, 0.12975720403044255, 0.12702806617791107, 0.13708457610217228, 0.14085960050253765, 0.1182974903379167, 0.12791972836821264, 0.15890532503478294, 0.12912736952395953, 0.1608047457274011, 0.15809829878022652, 0.15133833815034814, 0.13538153959863353, 0.12073046838649348, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13363631093164408, 0.11961705079305107, 0.11993917134603727, 0.13675049794254157, 0.1583239015498873, 0.15621519415389284, 0.10980097721265791, 0.1708211689189182, 0.18298662223703388, 0.1765805904024561, 0.18705664773167208, 0.20939061570930817, 0.2102261280069374, 0.18258671193628362, 0.1733991415989118, 0.20018122492980384, 0.0491930548421855, 0.10906215974178735, 0.06330177998080377, 0.05551436085328865, 0.05836299341733575, 0.04938951367217892, 0.07035130624513697, 0.06273658202727128, 0.053272815479897706]}, "mutation_prompt": null}
{"id": "7962c79d-08b8-4871-9e96-505ba55a3a27", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.cuckoo_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.cuckoo_velocity = np.random.uniform(-1, 1, (budget, dim))\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Cuckoo Optimization\n            if i >= self.budget // 2:\n                # Select a random solution\n                index = random.randint(0, self.budget - 1)\n                # Create a trial solution\n                trial_solution = self.cuckoo_memory[index] + self.cuckoo_velocity[index]\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n                # Update cuckoo memory\n                self.cuckoo_memory[index] = self.harmony_memory[i] if func(self.harmony_memory[i]) < func(self.cuckoo_memory[index]) else self.cuckoo_memory[index]\n                self.cuckoo_velocity[index] = 0.7298 * self.cuckoo_velocity[index] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined = AHQBACO_DN2_DE2_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size is modified to incorporate a novel mechanism of Adaptive Cuckoo Optimization with Dynamic Neighboring and Exploration-Exploitation Tradeoff Adjustment.", "configspace": "", "generation": 45, "fitness": 0.12858701600834477, "feedback": "The algorithm AHQBACO_DN2_DE2_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "4b085de2-0f72-466f-8b2f-b2b86366e09b", "metadata": {"aucs": [0.16827785197228062, 0.1733821186908885, 0.15932288543743456, 0.1540046815235544, 0.16485277201301995, 0.15897823569876146, 0.16270429889919014, 0.1394327624586822, 0.14875755223379306, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031017585816121573, 0.04229676289419204, 0.02876824043043924, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02236538336893068, 0.015490702390117295, 0.029814322655884462, 0.01969646754387211, 0.033153130081172266, 0.04442032952410169, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9996079529016055, 0.9507848309304814, 0.9944201448685165, 0.9984559983690944, 0.9954251082435268, 0.9932682522881124, 0.9957400334711598, 0.9743833469921689, 0.9521507102459867, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16499068422771346, 0.1927111383132749, 0.1598601655298988, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.10745486115648606, 0.11654393814514674, 0.09839777157775498, 0.13319459294815283, 0.1035322347791392, 0.09945566412036444, 0.11372556897519603, 0.11101688404450671, 0.12904459116729738, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831543164293143, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20660032887847724, 0.188352365373191, 0.17579218048408696, 0.1999369180904158, 0.17741582370398223, 0.1887321258068847, 0.19344998725181706, 0.17378760434867713, 0.18677668004578174, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.0377942043862739, 0.03149234042422633, 0.04231214916752091, 0.13570047579924116, 0.1198439075748905, 0.13157694949917675, 0.13872098680283906, 0.13721201770820246, 0.1097355930509093, 0.14596835279661646, 0.14070735224468012, 0.11819099740981542, 0.16086130943339083, 0.14944622430219023, 0.1669146567960792, 0.17845651790709327, 0.17247175024035788, 0.1634105756928118, 0.1512819833735075, 0.1735605385720701, 0.14064607226130343, 0.09997186699667637, 0.08923940364306382, 0.1071844861850978, 0.1272190807888106, 0.12222286738517874, 0.11642108841764853, 0.09812208369943642, 0.12246364723013647, 0.11060034832746746, 0.2601813882744033, 0.26017470446205293, 0.26017666954069796, 0.26018345811568244, 0.26017736316311524, 0.26017153992687414, 0.2601875539181707, 0.2601678946548399, 0.2601799003395322, 0.13899614599046473, 0.13802410484419392, 0.1410394489355502, 0.12594314329769563, 0.13679185723741993, 0.15639318663999724, 0.12867793536858008, 0.1480747205514945, 0.15890532503478294, 0.12796667625441827, 0.16054242792760653, 0.1588292359985466, 0.15135457159402088, 0.1353812470117839, 0.12129738691150438, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14014879460605556, 0.13430474128468073, 0.13354057271869058, 0.11958893379527313, 0.12011780235366876, 0.1367529941883835, 0.15844978834685464, 0.15634971171193757, 0.11029271713039612, 0.16332184703481667, 0.18316328679154303, 0.1718897646594696, 0.1850770645235883, 0.2048364343096234, 0.17190513821295716, 0.17174286659861282, 0.17465155557659873, 0.2000420511886466, 0.0623498926841215, 0.05440074403902384, 0.06327887623821826, 0.05289210782044251, 0.06153703988607995, 0.05117862053887878, 0.07031818768853804, 0.0537887707898983, 0.04672725951398693]}, "mutation_prompt": null}
{"id": "02fc7b6f-f08e-4ded-8fe4-5058ca362e95", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined = AHQBACO_DN2_DE2_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4b085de2-0f72-466f-8b2f-b2b86366e09b", "metadata": {"aucs": [0.16777026064192524, 0.1728663073918313, 0.15942722416770683, 0.15404174970884177, 0.16485277201301995, 0.15898306837794374, 0.16270595287779943, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031398218348746565, 0.042297665339880997, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024990071778364875, 0.0163763884779784, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.04443883784560787, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9652618730334694, 0.9887291511166051, 0.9873753607235634, 0.9903590130890318, 0.9850081882542482, 0.9999001200375565, 0.9984358291545808, 0.9638687151716653, 0.9632352713573192, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15345494377872915, 0.1926773706368211, 0.154999003313671, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08701945904975783, 0.11014199305547534, 0.11275589901584737, 0.14609264979453807, 0.10493177416982002, 0.10884746199862416, 0.10895507997970222, 0.11679709079149958, 0.08506989365538287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18871350186886504, 0.19365306456994724, 0.17638713725373223, 0.1878665300061403, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037738355399636214, 0.03149234042422633, 0.04231214916752091, 0.1357939799439426, 0.11907127164486542, 0.1403075403980727, 0.1387225781051249, 0.1372262786133278, 0.1097355930509093, 0.14680156083880325, 0.1414549001063835, 0.12041721934283778, 0.16076931587688736, 0.14932637916282887, 0.16682391176957478, 0.17487873313206126, 0.16627325686555927, 0.16817781153116773, 0.15127901597955062, 0.17355384695910447, 0.1409469951942578, 0.09990408127128181, 0.08927646262021338, 0.10716775680921653, 0.11174586385911134, 0.12350861660104107, 0.11948223732203389, 0.09812208369943642, 0.12245678839991947, 0.11053631086062154, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.2601665068806729, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.26017816934690785, 0.14076595050500396, 0.13614477447544615, 0.12975720403044255, 0.12702806617791107, 0.13708457610217228, 0.14085960050253765, 0.1182974903379167, 0.12791972836821264, 0.15890532503478294, 0.12912736952395953, 0.1608047457274011, 0.15809829878022652, 0.15133833815034814, 0.13538153959863353, 0.12073046838649348, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13363631093164408, 0.11961705079305107, 0.11993917134603727, 0.13675049794254157, 0.1583239015498873, 0.15621519415389284, 0.10980097721265791, 0.1708211689189182, 0.18298662223703388, 0.1765805904024561, 0.18705664773167208, 0.20939061570930817, 0.2102261280069374, 0.18258671193628362, 0.1733991415989118, 0.20018122492980384, 0.0491930548421855, 0.10906215974178735, 0.06330177998080377, 0.05551436085328865, 0.05836299341733575, 0.04938951367217892, 0.07035130624513697, 0.06273658202727128, 0.053272815479897706]}, "mutation_prompt": null}
{"id": "149d24d6-3535-4b03-90ad-862303dbf900", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined = AHQBACO_DN2_DE2_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4b085de2-0f72-466f-8b2f-b2b86366e09b", "metadata": {"aucs": [0.16777026064192524, 0.1728663073918313, 0.15942722416770683, 0.15404174970884177, 0.16485277201301995, 0.15898306837794374, 0.16270595287779943, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031398218348746565, 0.042297665339880997, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024990071778364875, 0.0163763884779784, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.04443883784560787, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9652618730334694, 0.9887291511166051, 0.9873753607235634, 0.9903590130890318, 0.9850081882542482, 0.9999001200375565, 0.9984358291545808, 0.9638687151716653, 0.9632352713573192, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15345494377872915, 0.1926773706368211, 0.154999003313671, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08701945904975783, 0.11014199305547534, 0.11275589901584737, 0.14609264979453807, 0.10493177416982002, 0.10884746199862416, 0.10895507997970222, 0.11679709079149958, 0.08506989365538287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18871350186886504, 0.19365306456994724, 0.17638713725373223, 0.1878665300061403, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037738355399636214, 0.03149234042422633, 0.04231214916752091, 0.1357939799439426, 0.11907127164486542, 0.1403075403980727, 0.1387225781051249, 0.1372262786133278, 0.1097355930509093, 0.14680156083880325, 0.1414549001063835, 0.12041721934283778, 0.16076931587688736, 0.14932637916282887, 0.16682391176957478, 0.17487873313206126, 0.16627325686555927, 0.16817781153116773, 0.15127901597955062, 0.17355384695910447, 0.1409469951942578, 0.09990408127128181, 0.08927646262021338, 0.10716775680921653, 0.11174586385911134, 0.12350861660104107, 0.11948223732203389, 0.09812208369943642, 0.12245678839991947, 0.11053631086062154, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.2601665068806729, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.26017816934690785, 0.14076595050500396, 0.13614477447544615, 0.12975720403044255, 0.12702806617791107, 0.13708457610217228, 0.14085960050253765, 0.1182974903379167, 0.12791972836821264, 0.15890532503478294, 0.12912736952395953, 0.1608047457274011, 0.15809829878022652, 0.15133833815034814, 0.13538153959863353, 0.12073046838649348, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13363631093164408, 0.11961705079305107, 0.11993917134603727, 0.13675049794254157, 0.1583239015498873, 0.15621519415389284, 0.10980097721265791, 0.1708211689189182, 0.18298662223703388, 0.1765805904024561, 0.18705664773167208, 0.20939061570930817, 0.2102261280069374, 0.18258671193628362, 0.1733991415989118, 0.20018122492980384, 0.0491930548421855, 0.10906215974178735, 0.06330177998080377, 0.05551436085328865, 0.05836299341733575, 0.04938951367217892, 0.07035130624513697, 0.06273658202727128, 0.053272815479897706]}, "mutation_prompt": null}
{"id": "212d6f81-6775-4f2d-a5a9-9af56fe58ff8", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.random_walk_step_size = 1.0  # initial step size for random walk\n        self.random_walk_convergence_threshold = 0.01  # convergence threshold for random walk\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            # Random Walk\n            if random.random() < 0.2:\n                self.random_walk_step_size *= 0.9\n                self.harmony_memory[i] += np.random.uniform(-self.random_walk_step_size, self.random_walk_step_size, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n                if np.linalg.norm(self.harmony_memory[i] - self.best_solution) < self.random_walk_convergence_threshold:\n                    self.random_walk_step_size = 1.0\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined = AHQBACO_DN2_DE2_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED", "description": "Novel hybridization of Adaptive Harmony Search with Quantum-Inspired Particle Swarm Optimization and Dynamic Neighborhoods, and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, and Random Walk with Adaptive Step Size.", "configspace": "", "generation": 48, "fitness": 0.12819290487415974, "feedback": "The algorithm AHQBACO_DN2_DE2_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "4b085de2-0f72-466f-8b2f-b2b86366e09b", "metadata": {"aucs": [0.16780213016712153, 0.17282268104077103, 0.15907186261870143, 0.15404297445051018, 0.16485967231631604, 0.158979878581736, 0.1627053838589576, 0.1394327624586822, 0.14875543656335266, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030962439943388875, 0.04229694976081633, 0.028707454718879255, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.021765029859766583, 0.017542119175218196, 0.029585810372624866, 0.01969646754387211, 0.033153130081172266, 0.044611993450156984, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9964500899966794, 0.9692452180846514, 0.9854429685720406, 0.9925019211312752, 0.9599541204010593, 0.9999001200375565, 0.9925456086862107, 0.9510599744755672, 0.9870005588234693, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.0318552420317727, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15062265778356432, 0.19000536847910476, 0.15110549625773673, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.10689396636170401, 0.09330931408212562, 0.10007177604707174, 0.14448849742781422, 0.08436103617568658, 0.11490777548903319, 0.12061070202448376, 0.09722029500550011, 0.09244796789474219, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831543164293143, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17744380521238579, 0.18877138341422484, 0.19357512882870043, 0.17595132043721318, 0.18647263877124054, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03822830275258715, 0.03149234042422633, 0.04231214916752091, 0.13618246158354597, 0.11587195565355124, 0.11802671587038838, 0.1387225781051249, 0.1372262786133278, 0.10989101811223245, 0.14679030995852305, 0.14068999312185693, 0.12045409190350309, 0.16073270252535554, 0.14935875308925228, 0.16679844311504277, 0.17133819586471932, 0.16346384155440774, 0.17167170990588654, 0.15127901597955062, 0.17355384695910447, 0.14060396083946325, 0.0999016709424837, 0.08925971897779694, 0.10716775680921653, 0.12427606750997366, 0.12407383907049074, 0.11848746691752854, 0.09812208369943642, 0.12246601612611141, 0.11055859672213142, 0.2601813882744033, 0.26016601643901793, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.2612099357552392, 0.26310324642000515, 0.2601737466540327, 0.2601794947077204, 0.1463400272170695, 0.1375387878509453, 0.13676651777889415, 0.1264322992896847, 0.14565965903507783, 0.14147487943956472, 0.12671244837122864, 0.1343375338012751, 0.15890532503478294, 0.12632542575961303, 0.16079848578121836, 0.15845570014998267, 0.15147393069350223, 0.1353860294342618, 0.1206689483147868, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14015548582218795, 0.13406252454194778, 0.13407664017592247, 0.11958317610989566, 0.119938562100809, 0.13675049794254157, 0.1582069868599898, 0.15854148200878504, 0.10980097721265791, 0.16721158646619683, 0.18297812867283236, 0.1680619573677461, 0.18861140863360248, 0.20943392962208696, 0.17366498243958062, 0.1811248537775919, 0.17320880108851922, 0.20025002587377094, 0.052058258118769296, 0.05749275019415345, 0.06393448549541203, 0.05700275402490518, 0.06124588339589787, 0.05213469866238685, 0.07208511690110608, 0.07316400796199818, 0.061824483210626724]}, "mutation_prompt": null}
{"id": "419051af-fcd7-4a6f-95a7-e7d81d15ce5c", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined = AHQBACO_DN2_DE2_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4b085de2-0f72-466f-8b2f-b2b86366e09b", "metadata": {"aucs": [0.16777026064192524, 0.1728663073918313, 0.15942722416770683, 0.15404174970884177, 0.16485277201301995, 0.15898306837794374, 0.16270595287779943, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031398218348746565, 0.042297665339880997, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024990071778364875, 0.0163763884779784, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.04443883784560787, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9652618730334694, 0.9887291511166051, 0.9873753607235634, 0.9903590130890318, 0.9850081882542482, 0.9999001200375565, 0.9984358291545808, 0.9638687151716653, 0.9632352713573192, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15345494377872915, 0.1926773706368211, 0.154999003313671, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08701945904975783, 0.11014199305547534, 0.11275589901584737, 0.14609264979453807, 0.10493177416982002, 0.10884746199862416, 0.10895507997970222, 0.11679709079149958, 0.08506989365538287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18871350186886504, 0.19365306456994724, 0.17638713725373223, 0.1878665300061403, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037738355399636214, 0.03149234042422633, 0.04231214916752091, 0.1357939799439426, 0.11907127164486542, 0.1403075403980727, 0.1387225781051249, 0.1372262786133278, 0.1097355930509093, 0.14680156083880325, 0.1414549001063835, 0.12041721934283778, 0.16076931587688736, 0.14932637916282887, 0.16682391176957478, 0.17487873313206126, 0.16627325686555927, 0.16817781153116773, 0.15127901597955062, 0.17355384695910447, 0.1409469951942578, 0.09990408127128181, 0.08927646262021338, 0.10716775680921653, 0.11174586385911134, 0.12350861660104107, 0.11948223732203389, 0.09812208369943642, 0.12245678839991947, 0.11053631086062154, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.2601665068806729, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.26017816934690785, 0.14076595050500396, 0.13614477447544615, 0.12975720403044255, 0.12702806617791107, 0.13708457610217228, 0.14085960050253765, 0.1182974903379167, 0.12791972836821264, 0.15890532503478294, 0.12912736952395953, 0.1608047457274011, 0.15809829878022652, 0.15133833815034814, 0.13538153959863353, 0.12073046838649348, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13363631093164408, 0.11961705079305107, 0.11993917134603727, 0.13675049794254157, 0.1583239015498873, 0.15621519415389284, 0.10980097721265791, 0.1708211689189182, 0.18298662223703388, 0.1765805904024561, 0.18705664773167208, 0.20939061570930817, 0.2102261280069374, 0.18258671193628362, 0.1733991415989118, 0.20018122492980384, 0.0491930548421855, 0.10906215974178735, 0.06330177998080377, 0.05551436085328865, 0.05836299341733575, 0.04938951367217892, 0.07035130624513697, 0.06273658202727128, 0.053272815479897706]}, "mutation_prompt": null}
{"id": "8a571b78-3555-450b-a454-8b1a12d86942", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined = AHQBACO_DN2_DE2_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4b085de2-0f72-466f-8b2f-b2b86366e09b", "metadata": {"aucs": [0.16777026064192524, 0.1728663073918313, 0.15942722416770683, 0.15404174970884177, 0.16485277201301995, 0.15898306837794374, 0.16270595287779943, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031398218348746565, 0.042297665339880997, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024990071778364875, 0.0163763884779784, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.04443883784560787, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9652618730334694, 0.9887291511166051, 0.9873753607235634, 0.9903590130890318, 0.9850081882542482, 0.9999001200375565, 0.9984358291545808, 0.9638687151716653, 0.9632352713573192, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15345494377872915, 0.1926773706368211, 0.154999003313671, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08701945904975783, 0.11014199305547534, 0.11275589901584737, 0.14609264979453807, 0.10493177416982002, 0.10884746199862416, 0.10895507997970222, 0.11679709079149958, 0.08506989365538287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18871350186886504, 0.19365306456994724, 0.17638713725373223, 0.1878665300061403, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037738355399636214, 0.03149234042422633, 0.04231214916752091, 0.1357939799439426, 0.11907127164486542, 0.1403075403980727, 0.1387225781051249, 0.1372262786133278, 0.1097355930509093, 0.14680156083880325, 0.1414549001063835, 0.12041721934283778, 0.16076931587688736, 0.14932637916282887, 0.16682391176957478, 0.17487873313206126, 0.16627325686555927, 0.16817781153116773, 0.15127901597955062, 0.17355384695910447, 0.1409469951942578, 0.09990408127128181, 0.08927646262021338, 0.10716775680921653, 0.11174586385911134, 0.12350861660104107, 0.11948223732203389, 0.09812208369943642, 0.12245678839991947, 0.11053631086062154, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.2601665068806729, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.26017816934690785, 0.14076595050500396, 0.13614477447544615, 0.12975720403044255, 0.12702806617791107, 0.13708457610217228, 0.14085960050253765, 0.1182974903379167, 0.12791972836821264, 0.15890532503478294, 0.12912736952395953, 0.1608047457274011, 0.15809829878022652, 0.15133833815034814, 0.13538153959863353, 0.12073046838649348, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13363631093164408, 0.11961705079305107, 0.11993917134603727, 0.13675049794254157, 0.1583239015498873, 0.15621519415389284, 0.10980097721265791, 0.1708211689189182, 0.18298662223703388, 0.1765805904024561, 0.18705664773167208, 0.20939061570930817, 0.2102261280069374, 0.18258671193628362, 0.1733991415989118, 0.20018122492980384, 0.0491930548421855, 0.10906215974178735, 0.06330177998080377, 0.05551436085328865, 0.05836299341733575, 0.04938951367217892, 0.07035130624513697, 0.06273658202727128, 0.053272815479897706]}, "mutation_prompt": null}
{"id": "5dc130b9-bbab-4785-9034-ac6f284b8f1c", "solution": "import numpy as np\nimport random\n\nclass HybridAHQBACO_DN2_DE2_LEVY:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.levy_flight_rate = 0.1  # levy flight rate\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            # Levy Flight\n            if random.random() < self.levy_flight_rate and i >= self.budget // 2:\n                self.harmony_memory[i] = self.best_solution + np.random.normal(0, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nhybrid_ahqbaco_dn2_de2_levy = HybridAHQBACO_DN2_DE2_LEVY(budget, dim)\nbest_solution, best_fitness = hybrid_ahqbaco_dn2_de2_levy(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "HybridAHQBACO_DN2_DE2_LEVY", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment, Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, and Levy Flight.", "configspace": "", "generation": 51, "fitness": 0.12770993522733937, "feedback": "The algorithm HybridAHQBACO_DN2_DE2_LEVY got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "4b085de2-0f72-466f-8b2f-b2b86366e09b", "metadata": {"aucs": [0.16791463472217605, 0.17288698349899112, 0.15952660369708793, 0.15402972853008146, 0.16485761402461452, 0.158979878581736, 0.16270741935431654, 0.1394327624586822, 0.14875543656335266, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03135287374124596, 0.042297665339880997, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02484300085510005, 0.019532965195630858, 0.030678370800673815, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9874018730334693, 0.9932423229580043, 0.9819291790076472, 0.9754919211312751, 0.9850081882542482, 0.992629164969221, 0.9797329492070225, 0.9005898894522851, 0.9648001775691007, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16510447922108817, 0.1926773706368211, 0.1564729651985015, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08841043355651146, 0.0997365341098837, 0.08667961767266208, 0.09568269945012375, 0.10487949477386649, 0.10915419873952703, 0.11257161969472085, 0.11074093345433333, 0.08286861468269102, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831658361763817, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.1887606785329785, 0.19431961353032945, 0.17294921085722603, 0.1878665300061403, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.0377556675645081, 0.03152262647728599, 0.04231214916752091, 0.1357939799439426, 0.11923457031083451, 0.11795695037128207, 0.1387225781051249, 0.1372262786133278, 0.10980446992278814, 0.14685190152952476, 0.14083349344053753, 0.12034906348645569, 0.1610745641389092, 0.1493576353589049, 0.16679844311504277, 0.16966806836545567, 0.16815402160609882, 0.16818367977906634, 0.15127901597955062, 0.1735744920708273, 0.14093854746742585, 0.0999016709424837, 0.08928782259693491, 0.10716775680921653, 0.11903796952418466, 0.12285572287122815, 0.11984852365940546, 0.09812208369943642, 0.12245060681819309, 0.11055027958593144, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.26262195714911796, 0.2733117796270077, 0.2601678946548399, 0.2601794947077204, 0.13241387296270368, 0.13614994584965479, 0.14977569096645127, 0.12588511326748397, 0.14530790731369103, 0.140143161101136, 0.12623570558600972, 0.13507824487384246, 0.16005469550930485, 0.12811725785696582, 0.16088914454037617, 0.15824761802136778, 0.15135986039941796, 0.1353860294342618, 0.12081813713387368, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016292494871996, 0.13406252454194778, 0.1334911955949205, 0.11960477127904323, 0.119938562100809, 0.13675049794254157, 0.15880611152986535, 0.15863188580695564, 0.10980097721265791, 0.1657882940038482, 0.18305443369716945, 0.16822191262871944, 0.18224243657096473, 0.209714772193884, 0.1709704186306018, 0.1825771303940884, 0.17395506455535337, 0.20019328210623644, 0.0534457875656037, 0.07020730348893556, 0.06392937919534236, 0.056328134636400295, 0.06093232322539899, 0.05126944587937121, 0.06993049950555996, 0.0637075349442664, 0.06455230463230488]}, "mutation_prompt": null}
{"id": "ca223def-584f-44c3-81db-1da4709ac4c0", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined = AHQBACO_DN2_DE2_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4b085de2-0f72-466f-8b2f-b2b86366e09b", "metadata": {"aucs": [0.16777026064192524, 0.1728663073918313, 0.15942722416770683, 0.15404174970884177, 0.16485277201301995, 0.15898306837794374, 0.16270595287779943, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031398218348746565, 0.042297665339880997, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024990071778364875, 0.0163763884779784, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.04443883784560787, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9652618730334694, 0.9887291511166051, 0.9873753607235634, 0.9903590130890318, 0.9850081882542482, 0.9999001200375565, 0.9984358291545808, 0.9638687151716653, 0.9632352713573192, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15345494377872915, 0.1926773706368211, 0.154999003313671, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08701945904975783, 0.11014199305547534, 0.11275589901584737, 0.14609264979453807, 0.10493177416982002, 0.10884746199862416, 0.10895507997970222, 0.11679709079149958, 0.08506989365538287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18871350186886504, 0.19365306456994724, 0.17638713725373223, 0.1878665300061403, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037738355399636214, 0.03149234042422633, 0.04231214916752091, 0.1357939799439426, 0.11907127164486542, 0.1403075403980727, 0.1387225781051249, 0.1372262786133278, 0.1097355930509093, 0.14680156083880325, 0.1414549001063835, 0.12041721934283778, 0.16076931587688736, 0.14932637916282887, 0.16682391176957478, 0.17487873313206126, 0.16627325686555927, 0.16817781153116773, 0.15127901597955062, 0.17355384695910447, 0.1409469951942578, 0.09990408127128181, 0.08927646262021338, 0.10716775680921653, 0.11174586385911134, 0.12350861660104107, 0.11948223732203389, 0.09812208369943642, 0.12245678839991947, 0.11053631086062154, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.2601665068806729, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.26017816934690785, 0.14076595050500396, 0.13614477447544615, 0.12975720403044255, 0.12702806617791107, 0.13708457610217228, 0.14085960050253765, 0.1182974903379167, 0.12791972836821264, 0.15890532503478294, 0.12912736952395953, 0.1608047457274011, 0.15809829878022652, 0.15133833815034814, 0.13538153959863353, 0.12073046838649348, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13363631093164408, 0.11961705079305107, 0.11993917134603727, 0.13675049794254157, 0.1583239015498873, 0.15621519415389284, 0.10980097721265791, 0.1708211689189182, 0.18298662223703388, 0.1765805904024561, 0.18705664773167208, 0.20939061570930817, 0.2102261280069374, 0.18258671193628362, 0.1733991415989118, 0.20018122492980384, 0.0491930548421855, 0.10906215974178735, 0.06330177998080377, 0.05551436085328865, 0.05836299341733575, 0.04938951367217892, 0.07035130624513697, 0.06273658202727128, 0.053272815479897706]}, "mutation_prompt": null}
{"id": "8f928bb8-32fe-45cc-ae73-f0b6a4538ecb", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined = AHQBACO_DN2_DE2_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4b085de2-0f72-466f-8b2f-b2b86366e09b", "metadata": {"aucs": [0.16777026064192524, 0.1728663073918313, 0.15942722416770683, 0.15404174970884177, 0.16485277201301995, 0.15898306837794374, 0.16270595287779943, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031398218348746565, 0.042297665339880997, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024990071778364875, 0.0163763884779784, 0.03073680786764288, 0.01969646754387211, 0.033153130081172266, 0.04443883784560787, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9652618730334694, 0.9887291511166051, 0.9873753607235634, 0.9903590130890318, 0.9850081882542482, 0.9999001200375565, 0.9984358291545808, 0.9638687151716653, 0.9632352713573192, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15345494377872915, 0.1926773706368211, 0.154999003313671, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08701945904975783, 0.11014199305547534, 0.11275589901584737, 0.14609264979453807, 0.10493177416982002, 0.10884746199862416, 0.10895507997970222, 0.11679709079149958, 0.08506989365538287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18871350186886504, 0.19365306456994724, 0.17638713725373223, 0.1878665300061403, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037738355399636214, 0.03149234042422633, 0.04231214916752091, 0.1357939799439426, 0.11907127164486542, 0.1403075403980727, 0.1387225781051249, 0.1372262786133278, 0.1097355930509093, 0.14680156083880325, 0.1414549001063835, 0.12041721934283778, 0.16076931587688736, 0.14932637916282887, 0.16682391176957478, 0.17487873313206126, 0.16627325686555927, 0.16817781153116773, 0.15127901597955062, 0.17355384695910447, 0.1409469951942578, 0.09990408127128181, 0.08927646262021338, 0.10716775680921653, 0.11174586385911134, 0.12350861660104107, 0.11948223732203389, 0.09812208369943642, 0.12245678839991947, 0.11053631086062154, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.2601665068806729, 0.2626273777805045, 0.2733117796270077, 0.2601737466540327, 0.26017816934690785, 0.14076595050500396, 0.13614477447544615, 0.12975720403044255, 0.12702806617791107, 0.13708457610217228, 0.14085960050253765, 0.1182974903379167, 0.12791972836821264, 0.15890532503478294, 0.12912736952395953, 0.1608047457274011, 0.15809829878022652, 0.15133833815034814, 0.13538153959863353, 0.12073046838649348, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14016320170847407, 0.13407049192775466, 0.13363631093164408, 0.11961705079305107, 0.11993917134603727, 0.13675049794254157, 0.1583239015498873, 0.15621519415389284, 0.10980097721265791, 0.1708211689189182, 0.18298662223703388, 0.1765805904024561, 0.18705664773167208, 0.20939061570930817, 0.2102261280069374, 0.18258671193628362, 0.1733991415989118, 0.20018122492980384, 0.0491930548421855, 0.10906215974178735, 0.06330177998080377, 0.05551436085328865, 0.05836299341733575, 0.04938951367217892, 0.07035130624513697, 0.06273658202727128, 0.053272815479897706]}, "mutation_prompt": null}
{"id": "1f4c30d2-2d4c-4bcf-9a0a-03d85d111096", "solution": "import numpy as np\nimport random\n\nclass NovelAHQBACO_DN2_DE2_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.levy_flight_probability = 0.2  # probability of using levy flight crossover\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                if random.random() < self.levy_flight_probability:\n                    # Levy flight crossover\n                    alpha = 1.5\n                    beta = 1.5\n                    gamma = 0.1\n                    trial_solution = self.harmony_memory[i] + gamma * (np.random.normal(0, 1, self.dim) ** alpha) * (self.harmony_memory[index1] - self.harmony_memory[index2])\n                    trial_solution = np.clip(trial_solution, -5, 5)\n                else:\n                    # Standard crossover\n                    trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                    trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nnovel_ahqbaco_dn2_de2_refined = NovelAHQBACO_DN2_DE2_REFINED(budget, dim)\nbest_solution, best_fitness = novel_ahqbaco_dn2_de2_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "NovelAHQBACO_DN2_DE2_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, but with a 20% probability of using a novel crossover operator based on the Levy flight distribution.", "configspace": "", "generation": 54, "fitness": 0.128377822117358, "feedback": "The algorithm NovelAHQBACO_DN2_DE2_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "4b085de2-0f72-466f-8b2f-b2b86366e09b", "metadata": {"aucs": [0.16791744477381731, 0.17285257930925124, 0.1594190502109083, 0.15404605366386603, 0.1648562418301468, 0.15898306837794374, 0.16270529397139766, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03097175095894089, 0.04229676289419204, 0.028786365634780098, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024930535702026968, 0.015748484635406235, 0.030360433677669052, 0.01969646754387211, 0.033153130081172266, 0.04443883784560787, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9867083045144949, 0.988670649257379, 0.9967284333325023, 0.975493045612868, 0.9792636980619426, 0.9926544310576021, 0.9984358291545808, 0.9882286573759829, 0.9648001775691007, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15263722644832156, 0.1925096806804013, 0.1562697097581326, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08049079121699199, 0.11047309544132189, 0.11275589901584737, 0.0960570963357793, 0.11190169214133927, 0.10902236237996388, 0.11299501642284782, 0.1027260526927175, 0.08517924897396967, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831543164293143, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20661818808493548, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.1774167541950743, 0.18876344404115986, 0.19411878415979977, 0.17638713725373223, 0.1873876606847069, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.0377649045012558, 0.03152262647728599, 0.04231214916752091, 0.13578299041779696, 0.11608495146824949, 0.1403075403980727, 0.1387262254078152, 0.1372262786133278, 0.10997898183062449, 0.14601782842642952, 0.14098006428049126, 0.12049400851875691, 0.16079070961891062, 0.14937621116201716, 0.16682901591594668, 0.17386074553132536, 0.16897844249367977, 0.16571084216999443, 0.15127901597955062, 0.17359018863582443, 0.14065569160780944, 0.0999016709424837, 0.08926975047488117, 0.10716775680921653, 0.11699613697200018, 0.11952725559868393, 0.12147642641313583, 0.09812208369943642, 0.12246757639898764, 0.11059326643358969, 0.26018223221605774, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.2601665068806729, 0.2601769605582607, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.14285455170247385, 0.13800289038965985, 0.13007796919182513, 0.12959590800232146, 0.13432756175815486, 0.14084817961805252, 0.12383205620739679, 0.12791972836821264, 0.15890532503478294, 0.12913624468740692, 0.16109499936412963, 0.15820513340439923, 0.15133833815034814, 0.1353860294342618, 0.12067952257722414, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013945494570657, 0.13407049192775466, 0.13363631093164408, 0.1196151491866636, 0.11996219230734095, 0.13675049794254157, 0.15847568669094436, 0.15624795739842445, 0.10980097721265791, 0.17072734671065426, 0.18555709813015586, 0.1765805904024561, 0.18711550394143628, 0.20726229579215227, 0.21509098342273114, 0.17631909437162163, 0.17353228252664754, 0.20268042657962027, 0.05283351172893003, 0.06370042678392729, 0.06387314123021437, 0.053723328321416686, 0.05845903114328299, 0.04767341633703304, 0.07011123716002499, 0.058006501015298584, 0.05780732398778332]}, "mutation_prompt": null}
{"id": "b33d6de0-7151-4d73-8f66-3be8b1ee4b5d", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_threshold = 0.7  # probability threshold for local search\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            # Local Search\n            if random.random() < self.probability_threshold and np.linalg.norm(self.harmony_memory[i] - self.best_solution) > 1e-6:\n                gradient = np.zeros(self.dim)\n                for j in range(self.dim):\n                    self.harmony_memory[i, j] += 1e-6\n                    gradient[j] = (func(self.harmony_memory[i]) - func(self.harmony_memory[i] - 1e-6)) / 1e-6\n                    self.harmony_memory[i, j] -= 1e-6\n                self.harmony_memory[i] = self.harmony_memory[i] - 0.1 * gradient\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined = AHQBACO_DN2_DE2_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment, Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, and a new Local Search component based on Probability-Driven Gradient Descent.", "configspace": "", "generation": 55, "fitness": 0.12178124251073157, "feedback": "The algorithm AHQBACO_DN2_DE2_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "4b085de2-0f72-466f-8b2f-b2b86366e09b", "metadata": {"aucs": [0.16016226762394037, 0.16229325988069343, 0.13024932994785954, 0.14943223879868328, 0.16172928645900864, 0.17257065811858974, 0.16277006894952906, 0.13140189444912265, 0.15247077028773015, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.054899501650684024, 0.033782830508234496, 0.03725285582420934, 0.03011769924665675, 0.030160057511132266, 0.04106726037184849, 0.03642786429561351, 0.02543332180840807, 0.029188673011341204, 0.014244109260646787, 0.013104935854665878, 0.034216402073179, 0.034117812900974376, 0.0139801952500902, 0.021946461141779894, 0.025430591547877524, 0.010966022976241718, 0.020732592852489518, 0.9581504279724303, 0.9458882539870109, 0.9599216161192781, 0.917994670649452, 0.9546753512367689, 0.9999001200375565, 0.9965193204000536, 0.8911791009770702, 0.9095343808843305, 0.07700538142222646, 0.056661349498198454, 0.08777148320105976, 0.038929688505643156, 0.08200452593361862, 0.04783841517748133, 0.06367386099169814, 0.04772588014822099, 0.08183656342851287, 0.14063865931294384, 0.18301885219246516, 0.15458187619172659, 0.09731575583071439, 0.10168680127865559, 0.09966035870829004, 0.08589967851693514, 0.10325502629563577, 0.0972316876657131, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07962639027447571, 0.06943336620166551, 0.08169656457050256, 0.08688729963220942, 0.07424193774321663, 0.10017960783527069, 0.08572475583458694, 0.07819183694372445, 0.08194755206034732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05196667889089035, 0.029980036633557416, 0.03730373533939002, 0.015708687474555894, 0.00463512201113081, 0.022209102353304866, 0.024200274748105044, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1635416912219556, 0.23847206908864482, 0.16892930582992938, 0.19893137163789953, 0.1640576832070375, 0.17742844262963553, 0.19031225895402515, 0.16254220877407022, 0.17538037248189664, 0.03568840853411437, 0.032158468789322825, 0.03074005555468795, 0.036766128107185825, 0.020326128210437888, 0.0350188135482562, 0.029197327818058505, 0.03006637790370492, 0.06006306149928986, 0.14575129263000186, 0.1068681231315668, 0.11646714165951966, 0.1471518218307477, 0.1328932498890124, 0.11752667437938746, 0.13245778602036695, 0.11814102836713025, 0.1302279924886377, 0.1488977489375326, 0.14415017974109745, 0.16247295706178588, 0.17075554824493755, 0.15982647297327857, 0.1648050691863242, 0.13810397388441453, 0.17304923024796315, 0.1466479596915633, 0.0833294055122209, 0.07344127486258445, 0.09332834337328244, 0.11405079194973156, 0.10836197283487103, 0.11382650184976939, 0.09182850635980089, 0.11859169695331306, 0.08267169239069971, 0.26018223221605774, 0.26016601643901793, 0.2601786226371633, 0.26018132180600584, 0.2601665068806729, 0.26017153992687414, 0.2601875539181707, 0.2601737466540327, 0.2601794947077204, 0.06810592000069049, 0.13470514512524845, 0.10389609263405453, 0.08354871614601056, 0.13621308703421187, 0.11752681487853167, 0.1559702503557443, 0.12077399377644649, 0.15177010574103023, 0.11523122876724667, 0.15716723601121463, 0.1614482150603046, 0.1343334092424937, 0.14460343459326008, 0.10640963302894302, 0.11171185329997502, 0.1620643545368039, 0.14661600734699753, 0.10950808330917461, 0.11426894757459938, 0.15758832802125322, 0.10656663010562095, 0.14607172945136193, 0.09822091930181631, 0.15084214697430454, 0.11774581200606449, 0.15698764158752188, 0.15724351091182853, 0.18366734167404042, 0.17487619907537644, 0.19601943690899903, 0.1877259984762617, 0.1947074483003879, 0.17568527145139923, 0.17728199063349626, 0.18975952514867378, 0.04222462002948246, 0.05686903609191718, 0.05536044313552124, 0.0467513211900481, 0.05644720313302609, 0.048080249123250596, 0.06001149051554511, 0.05696630656705148, 0.049062610901525305]}, "mutation_prompt": null}
{"id": "d772febf-70af-4a55-bddb-9ff4eca3ca54", "solution": "import numpy as np\nimport random\n\nclass HybridAHQBACO_DN2_DE2_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_of_change = 0.2  # probability of changing individual lines of the selected solution\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.exploration_rate:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.random.rand() < self.probability_of_change:\n                # Change individual lines of the selected solution\n                if random.random() < 0.5:\n                    self.exploration_rate = random.uniform(0.1, 0.9)\n                else:\n                    self.neighborhood_size = random.uniform(0.1 * budget, 0.2 * budget)\n                if random.random() < 0.5:\n                    self.F = random.uniform(0.1, 0.9)\n                else:\n                    self.CR = random.uniform(0.1, 0.9)\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nhybrid_ahqbaco_dn2_de2_refined = HybridAHQBACO_DN2_DE2_REFINED(budget, dim)\nbest_solution, best_fitness = hybrid_ahqbaco_dn2_de2_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "HybridAHQBACO_DN2_DE2_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, with a 20% probability of changing the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 56, "fitness": 0.12836015427024985, "feedback": "The algorithm HybridAHQBACO_DN2_DE2_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "4b085de2-0f72-466f-8b2f-b2b86366e09b", "metadata": {"aucs": [0.16791529639335245, 0.17346261374148764, 0.1593759084999239, 0.15405238223001705, 0.1648562418301468, 0.15895784043151506, 0.16271273968323074, 0.13943411862139565, 0.14875543656335266, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031022559335539324, 0.04229676289419204, 0.028707454718879255, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02178208214173105, 0.018511448296195332, 0.03137956530848751, 0.01969646754387211, 0.03324513954635677, 0.04442032952410169, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9993148187926667, 0.9884458378389943, 0.9968709440910021, 0.9266956573025207, 0.9996055742421913, 0.9999001200375565, 0.9778154205160934, 0.9928559762258491, 0.9954162071247977, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16312457933343716, 0.19142682164611857, 0.15771735466904935, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08922851242079799, 0.11964830440789176, 0.11551537586422977, 0.09047855012555595, 0.0956349165646927, 0.0918955565608498, 0.09212415804947993, 0.11081451553011523, 0.1100850463876546, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831543164293143, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20661818808493548, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18873784167704932, 0.19344848845220008, 0.1746828488007992, 0.18644216933932956, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.032419446337311086, 0.039398907522902316, 0.037794243218465806, 0.03151703417838947, 0.04231214916752091, 0.13585993105217753, 0.12361876666937133, 0.11817877885897177, 0.13871562955069006, 0.13722937929628498, 0.10987993813879493, 0.14634597764256918, 0.1407379942299638, 0.12109652242998414, 0.16145770102643853, 0.14942171512287383, 0.16683886657230818, 0.16846823934819877, 0.16852489141780969, 0.17979409429143978, 0.15127901597955062, 0.17353975153293155, 0.14064537840320768, 0.0999016709424837, 0.0893446337525784, 0.10716775680921653, 0.11697141538789824, 0.12091398447333046, 0.11967943550008875, 0.09812208369943642, 0.12246444542744772, 0.11050343727451528, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26109075047500996, 0.2601665068806729, 0.2601769605582607, 0.2601875539181707, 0.2601737466540327, 0.26017816934690785, 0.1314521557080276, 0.13614477447544615, 0.1336290705092953, 0.1251639339503965, 0.13289564873324067, 0.1428344399723226, 0.14013433183058732, 0.1410443344906538, 0.15890532503478294, 0.12658608830338436, 0.1606698510174076, 0.15831556643104727, 0.15146986796005601, 0.1353812470117839, 0.12045109541648635, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14023872121217518, 0.13406252454194778, 0.13425563783144645, 0.11958557474746156, 0.11993691894326708, 0.13675049794254157, 0.15850380580919843, 0.15730007018919934, 0.11004032902772465, 0.17476636264313805, 0.18321936050720233, 0.16799917534186537, 0.1824480442168661, 0.20766600784104616, 0.2108646344860441, 0.1862005153883315, 0.17335823321451171, 0.2000835132293154, 0.0540419248345303, 0.05721749017845501, 0.06346836254784483, 0.050582504908077475, 0.05845914590316059, 0.05423639114207979, 0.07085621615440629, 0.06370596426857134, 0.05244774213551284]}, "mutation_prompt": null}
{"id": "ae42cd47-728a-4fdc-ac5f-6476f6bd181c", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.95  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.8:  # adjust the probability of exploration\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, refined by adjusting the probability of exploration in Harmony Search to 0.8 and the exploration rate adjustment rate to 0.95.", "configspace": "", "generation": 57, "fitness": 0.12874864043339007, "feedback": "The algorithm AHQBACO_DN2_DE2_REFINED_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "4b085de2-0f72-466f-8b2f-b2b86366e09b", "metadata": {"aucs": [0.1678349328959614, 0.17279750639161406, 0.1595184715833271, 0.15402651240797094, 0.1648562418301468, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030926406351440172, 0.04229676289419204, 0.028726245370913395, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015819282273171642, 0.029664245482800333, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9867674543946731, 0.9525436988420015, 0.9717376530829223, 0.9903302381847126, 0.9850981882542482, 0.9972648919717684, 0.9984356409844637, 0.9553412151716654, 0.9645859532542663, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.19251264416280434, 0.15652811510721387, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08676953325769732, 0.11907231038975785, 0.10057548328576271, 0.14897534770098486, 0.10493177416982002, 0.10346286426108486, 0.09679865740757176, 0.11358190921115785, 0.09682496974428945, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.033198415640640855, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18871626737704628, 0.19428978787791196, 0.17312656805426563, 0.18780975933274735, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03149234042422633, 0.04231214916752091, 0.13568153332214972, 0.11905403678117366, 0.1403075403980727, 0.13871562955069006, 0.1372262786133278, 0.10974092177683303, 0.14685264999665137, 0.14082534460781315, 0.11880798383977931, 0.16076931587688736, 0.14938292316338864, 0.16681481982739899, 0.17389160256634073, 0.16533924594492366, 0.16925040185192686, 0.15127901597955062, 0.17359018863582443, 0.14089303387979657, 0.09990585299789723, 0.08926705538892332, 0.1071630535151673, 0.12070091051728737, 0.11973285755571361, 0.12082456924785745, 0.09812208369943642, 0.1224537527043591, 0.1105919194651881, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.26017734341597376, 0.26017153992687414, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1407555242655073, 0.13800289038965985, 0.14977569096645127, 0.13693995517714885, 0.14569881022274822, 0.140143161101136, 0.11628393443071672, 0.12773466300142378, 0.16012466570397244, 0.1283716653776582, 0.16109499936412963, 0.15820226210876076, 0.1513356545171608, 0.1353860294342618, 0.12040482243876283, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013973170546046, 0.13406252454194778, 0.13364278059408274, 0.11960477127904323, 0.11996033272833961, 0.13675049794254157, 0.15880611152986535, 0.15863188580695564, 0.10980097721265791, 0.17066892194230676, 0.18555709813015586, 0.16799860707977843, 0.18177874436835761, 0.20561058129684395, 0.20990868327844703, 0.1814683966752314, 0.17626403684905056, 0.20264458112034267, 0.053161201534176916, 0.10905280314177068, 0.06372468227507866, 0.058303961801324244, 0.05847740743192098, 0.05073019180702398, 0.07289275853335497, 0.05085306921687838, 0.06373961691120422]}, "mutation_prompt": null}
{"id": "78aed87e-7ff9-49a4-b046-ba8d6a88296a", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_PS2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n        self.probability_of_exploration = 0.2  # probability of exploration in Harmony Search\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.probability_of_exploration:  # adjust the probability of exploration\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n                else:\n                    self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            else:\n                # Employed bees\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-self.neighborhood_size, self.neighborhood_size, self.dim)\n                    self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n                else:\n                    self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_ps2_refined_refined = AHQBACO_DN2_PS2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_ps2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_PS2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search with Quantum-Inspired Particle Swarm Optimization and Dynamic Neighborhoods, and Probability-Driven Exploration Adjustment, refined by adjusting the probability of exploration in Harmony Search to 0.2 and the exploration rate adjustment rate to 0.9.", "configspace": "", "generation": 58, "fitness": 0.11065079843984309, "feedback": "The algorithm AHQBACO_DN2_PS2_REFINED_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.11.", "error": "", "parent_id": "ae42cd47-728a-4fdc-ac5f-6476f6bd181c", "metadata": {"aucs": [0.18740906923011724, 0.17937259925987314, 0.17348356317761704, 0.16845369514743413, 0.195642257888336, 0.1743435064021196, 0.1785507992358102, 0.18477436301026162, 0.1900640255741839, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.042054227992728954, 0.046372490884433515, 0.03618932539327069, 0.04102267921387792, 0.038225115592033565, 0.03662342001376073, 0.0528437448134802, 0.06702432684758475, 0.058711088734964334, 0.027566402497813614, 0.03232720275426726, 0.0481463786277756, 0.03146852612341822, 0.04926774209271334, 0.05702674525995721, 0.0372192476810449, 0.03992308285267243, 0.0317632798327111, 0.5282832649490385, 0.5205070213500134, 0.5410976174162372, 0.5389846949196448, 0.5328126779278581, 0.5303792763634787, 0.5162862667888761, 0.5303188799202587, 0.5259874340293653, 0.07100348741188589, 0.07510940173832203, 0.10171882691615464, 0.06144059103237409, 0.07587204370378298, 0.08442693333027163, 0.09472457566024695, 0.057034870011662187, 0.0928167823142052, 0.12553619411724048, 0.19308637766117165, 0.1481850439168273, 0.12359296344983084, 0.10174722586456086, 0.13671867179896613, 0.13211696527699301, 0.1368487698841222, 0.11560122303050135, 0.020015679940319053, 0.0043068668032033575, 0.003689195106263865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019872591751231683, 0.021766146145215104, 0.06957272857429797, 9.999999999998899e-05, 0.015137189132617968, 0.03855246283177527, 0.01682952018717898, 0.027532916537795105, 0.006568189490159582, 0.01065615866875902, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05293794841224442, 0.06858859508378334, 0.04571874532595466, 0.06941906045599022, 0.036931638753652574, 0.055770453722678415, 0.05816220282856843, 0.05068838877835591, 0.06421743361722532, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012032290185809424, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011289424049593433, 9.999999999998899e-05, 0.22082032439354093, 0.19298032777251062, 0.18220190403863534, 0.2133225244707888, 0.18923395481742278, 0.20724700933075846, 0.20917258250258197, 0.1784211624537766, 0.19784484171535732, 0.0485543123442741, 0.036156308771396306, 0.04401887178405428, 0.04417593056904556, 0.0409159884930852, 0.046009660620107806, 0.073263588849099, 0.045860883560428944, 0.05229792848072812, 0.1370941010055503, 0.12215519156917909, 0.12750450527678026, 0.14106301975521696, 0.14544319451312604, 0.12445999599376578, 0.15027263737726138, 0.14861619065631115, 0.13257079566458507, 0.1712073162864719, 0.15950729452706813, 0.175518321616434, 0.1701858050886027, 0.1821496595795835, 0.1769644640004372, 0.1654627495076827, 0.17816757565282948, 0.15770292499255045, 0.1126696177892671, 0.10786632740539881, 0.11799495475492272, 0.11002550252717425, 0.13610603218022022, 0.11676919299387534, 0.1053444895868817, 0.1237427242099084, 0.1285117324451961, 0.14070386949613822, 0.16233450221944246, 0.1546871744625118, 0.1609002631703106, 0.1415099797008903, 0.16236042742370171, 0.1486169952402574, 0.17355151355563359, 0.18277724523822958, 0.14195011305864957, 0.14578023879947632, 0.14006577975982915, 0.14105241710696592, 0.14379058119127952, 0.15336536329377393, 0.13899579643200377, 0.14968601939859694, 0.16207881422481074, 0.18402833448490363, 0.16680801270540468, 0.16657141521439822, 0.15904372527167143, 0.15640738274619248, 0.14813193354786325, 0.16238939326431734, 0.1634028490223587, 0.16672101968820607, 0.15672808824074347, 0.15806706581787744, 0.2174368483115452, 0.150330135465925, 0.14999838070070493, 0.16060578171257034, 0.16855947523118198, 0.1766289360417892, 0.2028812417861957, 0.1695321598857874, 0.19026087781246404, 0.17532276127552104, 0.18683568409856555, 0.2135749380374129, 0.18382439475410084, 0.17594512205278, 0.18895060956686383, 0.20568880668582523, 0.058344077551123696, 0.05523908670968358, 0.06585155299632517, 0.05186305593955043, 0.05938246283312221, 0.0533550031798079, 0.07532529613519179, 0.05491659739916577, 0.058304689008996546]}, "mutation_prompt": null}
{"id": "57f1306d-1d90-4406-8176-b71291654c87", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.95  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.9:  # adjust the probability of exploration to 0.9\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.92)  # adjust the exploration rate adjustment rate to 0.92\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, refined by adjusting the probability of exploration in Harmony Search to 0.9 and the exploration rate adjustment rate to 0.92.", "configspace": "", "generation": 59, "fitness": 0.12852194537572137, "feedback": "The algorithm AHQBACO_DN2_DE2_REFINED_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "ae42cd47-728a-4fdc-ac5f-6476f6bd181c", "metadata": {"aucs": [0.16780065625360818, 0.17303456140539053, 0.1574186308722081, 0.15404297445051018, 0.16485761402461452, 0.15898560438757192, 0.16270529397139766, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03134638260856604, 0.04229676289419204, 0.028726245370913395, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.01940358245762619, 0.03036015159562444, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9830818730334692, 0.988670649257379, 0.9967507256918613, 0.990613045612868, 0.9850981882542482, 0.9863583391041915, 0.9939307850609067, 0.9881982963729752, 0.9651477713573191, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16414139141597284, 0.19193382649276214, 0.1559926796524458, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.0795871574812611, 0.0997365341098837, 0.08801549208071013, 0.09716675594371338, 0.10472706939600229, 0.09930271760407572, 0.11288397364696467, 0.1178318544096354, 0.09557267232127453, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831543164293143, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.18876344404115986, 0.19506610541315217, 0.1754957212932735, 0.18710781838199886, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03771420465876418, 0.03150842159239786, 0.04231214916752091, 0.1357939799439426, 0.11563967589428903, 0.11795695037128207, 0.1387225781051249, 0.1372262786133278, 0.10980446992278814, 0.14596061401376514, 0.14118192295201848, 0.12096229367026046, 0.16077495963113175, 0.14934823855698487, 0.1668289698075489, 0.16768003728667902, 0.16449099178121618, 0.16888707735071895, 0.15127901597955062, 0.17359018863582443, 0.14089756187467606, 0.09990585299789723, 0.08915517958795594, 0.1071630535151673, 0.12021431750926637, 0.11982157300413332, 0.11782512888511898, 0.09812208369943642, 0.12245563847484786, 0.11053707970590654, 0.26018223221605774, 0.26016601643901793, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.26262195714911796, 0.2601875539181707, 0.2601737466540327, 0.26017816934690785, 0.14285455170247385, 0.13614477447544615, 0.14977569096645127, 0.12658163638864917, 0.14588425013855377, 0.14084817961805252, 0.12623570558600972, 0.12773466300142378, 0.15937956746530713, 0.1280772125006906, 0.1611091241891076, 0.15824819331131224, 0.15137819013263176, 0.13538153959863353, 0.1208216737633242, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013945494570657, 0.13406252454194778, 0.13364278059408274, 0.11960232997649911, 0.119938562100809, 0.13675049794254157, 0.15881046962968215, 0.15863123297644888, 0.10988046452472044, 0.16981878455408528, 0.1854964212639495, 0.16822191262871944, 0.18258969108337653, 0.2066006886435039, 0.2102261280069374, 0.18260266678130732, 0.17635471181300078, 0.20019328210623644, 0.05393169430774725, 0.10910642640898427, 0.06310989823171242, 0.05362215181674379, 0.05847740743192098, 0.04945861903600013, 0.07083586851976797, 0.06270873751980321, 0.06508141038335558]}, "mutation_prompt": null}
{"id": "09a50427-97b8-4019-9f73-7b68892c945d", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.95  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.8:  # adjust the probability of exploration\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, refined by adjusting the probability of exploration in Harmony Search to 0.8 and the exploration rate adjustment rate to 0.95.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae42cd47-728a-4fdc-ac5f-6476f6bd181c", "metadata": {"aucs": [0.1678349328959614, 0.17279750639161406, 0.1595184715833271, 0.15402651240797094, 0.1648562418301468, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030926406351440172, 0.04229676289419204, 0.028726245370913395, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015819282273171642, 0.029664245482800333, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9867674543946731, 0.9525436988420015, 0.9717376530829223, 0.9903302381847126, 0.9850981882542482, 0.9972648919717684, 0.9984356409844637, 0.9553412151716654, 0.9645859532542663, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.19251264416280434, 0.15652811510721387, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08676953325769732, 0.11907231038975785, 0.10057548328576271, 0.14897534770098486, 0.10493177416982002, 0.10346286426108486, 0.09679865740757176, 0.11358190921115785, 0.09682496974428945, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.033198415640640855, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18871626737704628, 0.19428978787791196, 0.17312656805426563, 0.18780975933274735, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03149234042422633, 0.04231214916752091, 0.13568153332214972, 0.11905403678117366, 0.1403075403980727, 0.13871562955069006, 0.1372262786133278, 0.10974092177683303, 0.14685264999665137, 0.14082534460781315, 0.11880798383977931, 0.16076931587688736, 0.14938292316338864, 0.16681481982739899, 0.17389160256634073, 0.16533924594492366, 0.16925040185192686, 0.15127901597955062, 0.17359018863582443, 0.14089303387979657, 0.09990585299789723, 0.08926705538892332, 0.1071630535151673, 0.12070091051728737, 0.11973285755571361, 0.12082456924785745, 0.09812208369943642, 0.1224537527043591, 0.1105919194651881, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.26017734341597376, 0.26017153992687414, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1407555242655073, 0.13800289038965985, 0.14977569096645127, 0.13693995517714885, 0.14569881022274822, 0.140143161101136, 0.11628393443071672, 0.12773466300142378, 0.16012466570397244, 0.1283716653776582, 0.16109499936412963, 0.15820226210876076, 0.1513356545171608, 0.1353860294342618, 0.12040482243876283, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013973170546046, 0.13406252454194778, 0.13364278059408274, 0.11960477127904323, 0.11996033272833961, 0.13675049794254157, 0.15880611152986535, 0.15863188580695564, 0.10980097721265791, 0.17066892194230676, 0.18555709813015586, 0.16799860707977843, 0.18177874436835761, 0.20561058129684395, 0.20990868327844703, 0.1814683966752314, 0.17626403684905056, 0.20264458112034267, 0.053161201534176916, 0.10905280314177068, 0.06372468227507866, 0.058303961801324244, 0.05847740743192098, 0.05073019180702398, 0.07289275853335497, 0.05085306921687838, 0.06373961691120422]}, "mutation_prompt": null}
{"id": "de89c2a3-467c-4379-9f2d-14d0fdac781a", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.95  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.8:  # adjust the probability of exploration\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, refined by adjusting the probability of exploration in Harmony Search to 0.8 and the exploration rate adjustment rate to 0.95.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae42cd47-728a-4fdc-ac5f-6476f6bd181c", "metadata": {"aucs": [0.1678349328959614, 0.17279750639161406, 0.1595184715833271, 0.15402651240797094, 0.1648562418301468, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030926406351440172, 0.04229676289419204, 0.028726245370913395, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015819282273171642, 0.029664245482800333, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9867674543946731, 0.9525436988420015, 0.9717376530829223, 0.9903302381847126, 0.9850981882542482, 0.9972648919717684, 0.9984356409844637, 0.9553412151716654, 0.9645859532542663, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.19251264416280434, 0.15652811510721387, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08676953325769732, 0.11907231038975785, 0.10057548328576271, 0.14897534770098486, 0.10493177416982002, 0.10346286426108486, 0.09679865740757176, 0.11358190921115785, 0.09682496974428945, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.033198415640640855, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18871626737704628, 0.19428978787791196, 0.17312656805426563, 0.18780975933274735, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03149234042422633, 0.04231214916752091, 0.13568153332214972, 0.11905403678117366, 0.1403075403980727, 0.13871562955069006, 0.1372262786133278, 0.10974092177683303, 0.14685264999665137, 0.14082534460781315, 0.11880798383977931, 0.16076931587688736, 0.14938292316338864, 0.16681481982739899, 0.17389160256634073, 0.16533924594492366, 0.16925040185192686, 0.15127901597955062, 0.17359018863582443, 0.14089303387979657, 0.09990585299789723, 0.08926705538892332, 0.1071630535151673, 0.12070091051728737, 0.11973285755571361, 0.12082456924785745, 0.09812208369943642, 0.1224537527043591, 0.1105919194651881, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.26017734341597376, 0.26017153992687414, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1407555242655073, 0.13800289038965985, 0.14977569096645127, 0.13693995517714885, 0.14569881022274822, 0.140143161101136, 0.11628393443071672, 0.12773466300142378, 0.16012466570397244, 0.1283716653776582, 0.16109499936412963, 0.15820226210876076, 0.1513356545171608, 0.1353860294342618, 0.12040482243876283, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013973170546046, 0.13406252454194778, 0.13364278059408274, 0.11960477127904323, 0.11996033272833961, 0.13675049794254157, 0.15880611152986535, 0.15863188580695564, 0.10980097721265791, 0.17066892194230676, 0.18555709813015586, 0.16799860707977843, 0.18177874436835761, 0.20561058129684395, 0.20990868327844703, 0.1814683966752314, 0.17626403684905056, 0.20264458112034267, 0.053161201534176916, 0.10905280314177068, 0.06372468227507866, 0.058303961801324244, 0.05847740743192098, 0.05073019180702398, 0.07289275853335497, 0.05085306921687838, 0.06373961691120422]}, "mutation_prompt": null}
{"id": "1c7c100f-81de-4bb5-a1e1-0affbb7e4fa3", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.95  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.8:  # adjust the probability of exploration\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, refined by adjusting the probability of exploration in Harmony Search to 0.8 and the exploration rate adjustment rate to 0.95.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae42cd47-728a-4fdc-ac5f-6476f6bd181c", "metadata": {"aucs": [0.1678349328959614, 0.17279750639161406, 0.1595184715833271, 0.15402651240797094, 0.1648562418301468, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030926406351440172, 0.04229676289419204, 0.028726245370913395, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015819282273171642, 0.029664245482800333, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9867674543946731, 0.9525436988420015, 0.9717376530829223, 0.9903302381847126, 0.9850981882542482, 0.9972648919717684, 0.9984356409844637, 0.9553412151716654, 0.9645859532542663, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.19251264416280434, 0.15652811510721387, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08676953325769732, 0.11907231038975785, 0.10057548328576271, 0.14897534770098486, 0.10493177416982002, 0.10346286426108486, 0.09679865740757176, 0.11358190921115785, 0.09682496974428945, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.033198415640640855, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18871626737704628, 0.19428978787791196, 0.17312656805426563, 0.18780975933274735, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03149234042422633, 0.04231214916752091, 0.13568153332214972, 0.11905403678117366, 0.1403075403980727, 0.13871562955069006, 0.1372262786133278, 0.10974092177683303, 0.14685264999665137, 0.14082534460781315, 0.11880798383977931, 0.16076931587688736, 0.14938292316338864, 0.16681481982739899, 0.17389160256634073, 0.16533924594492366, 0.16925040185192686, 0.15127901597955062, 0.17359018863582443, 0.14089303387979657, 0.09990585299789723, 0.08926705538892332, 0.1071630535151673, 0.12070091051728737, 0.11973285755571361, 0.12082456924785745, 0.09812208369943642, 0.1224537527043591, 0.1105919194651881, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.26017734341597376, 0.26017153992687414, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1407555242655073, 0.13800289038965985, 0.14977569096645127, 0.13693995517714885, 0.14569881022274822, 0.140143161101136, 0.11628393443071672, 0.12773466300142378, 0.16012466570397244, 0.1283716653776582, 0.16109499936412963, 0.15820226210876076, 0.1513356545171608, 0.1353860294342618, 0.12040482243876283, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013973170546046, 0.13406252454194778, 0.13364278059408274, 0.11960477127904323, 0.11996033272833961, 0.13675049794254157, 0.15880611152986535, 0.15863188580695564, 0.10980097721265791, 0.17066892194230676, 0.18555709813015586, 0.16799860707977843, 0.18177874436835761, 0.20561058129684395, 0.20990868327844703, 0.1814683966752314, 0.17626403684905056, 0.20264458112034267, 0.053161201534176916, 0.10905280314177068, 0.06372468227507866, 0.058303961801324244, 0.05847740743192098, 0.05073019180702398, 0.07289275853335497, 0.05085306921687838, 0.06373961691120422]}, "mutation_prompt": null}
{"id": "a73039a9-3eb6-4955-ae01-5d284006bd35", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.95  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.9:  # adjust the probability of exploration to 0.9\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.97)  # adjust the exploration rate adjustment rate to 0.97\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, refined by adjusting the probability of exploration in Harmony Search to 0.9 and the exploration rate adjustment rate to 0.97.", "configspace": "", "generation": 63, "fitness": 0.12859769620698455, "feedback": "The algorithm AHQBACO_DN2_DE2_REFINED_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "ae42cd47-728a-4fdc-ac5f-6476f6bd181c", "metadata": {"aucs": [0.1679179937781059, 0.17303469099573143, 0.15916125652734991, 0.15403403248510572, 0.16485414420748767, 0.15898306837794374, 0.16270529397139766, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03130279744519415, 0.042299821549620864, 0.028726245370913395, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.022839947283892603, 0.015621273886195386, 0.03072392987722683, 0.01969646754387211, 0.033153130081172266, 0.04462367806249967, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9867083045144949, 0.9689428644625155, 0.9967507256918613, 0.9903291137031196, 0.9794281882542482, 0.9999001200375565, 0.9938951162090337, 0.9544266841207879, 0.9651259532542663, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15459629695608967, 0.18964305666499237, 0.15709921857435816, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08547952917290258, 0.11940255173198311, 0.09732308954530111, 0.14778730641906257, 0.11181381051149053, 0.10848163825881785, 0.0958808315325883, 0.10403671073126697, 0.09540251428682955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831543164293143, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.1887606785329785, 0.19352903582994851, 0.17631317141787972, 0.1878350291398171, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.0377556675645081, 0.03149234042422633, 0.04231214916752091, 0.13566589911417104, 0.11608495146824949, 0.11795695037128207, 0.1387220562751541, 0.13721084259603444, 0.10997898183062449, 0.14685264999665137, 0.14146874559029698, 0.12107675785842109, 0.1610745641389092, 0.14933128488603975, 0.16684734563472814, 0.17532727757374866, 0.16663119260156545, 0.16385174500844202, 0.15127901597955062, 0.17354213888016823, 0.14085298684340652, 0.09990585299789723, 0.08915889672401478, 0.10716775680921653, 0.11731056036873289, 0.11871558244032754, 0.11846986036457074, 0.09812208369943642, 0.12245014374148089, 0.1105919194651881, 0.2601813882744033, 0.2601763462457861, 0.26017666954069796, 0.26018132180600584, 0.26017734341597376, 0.2626273777805045, 0.2733117796270077, 0.2601678946548399, 0.26017816934690785, 0.1428554788833184, 0.138573316280035, 0.13255337194618855, 0.12456545809705166, 0.14542731497403238, 0.14084817961805252, 0.1182974903379167, 0.12773466300142378, 0.15937956746530713, 0.12999661918880046, 0.16093728167522203, 0.15809772349028206, 0.15135986039941796, 0.1353812470117839, 0.1206017820247891, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.1400989037405388, 0.13407049192775466, 0.1334911955949205, 0.11960286967265588, 0.11996219230734095, 0.13675049794254157, 0.15813299887902177, 0.15611764225915448, 0.10958501630763473, 0.16538868154792397, 0.18555709813015586, 0.1846774426752329, 0.18223665834163416, 0.2095867472928581, 0.21235658472594254, 0.18253128247108852, 0.17339502488044423, 0.20264970129115645, 0.05240819748416159, 0.10905933953581248, 0.06373250652646745, 0.0514013021159071, 0.05842960233959571, 0.048894861392773104, 0.07284048589835002, 0.06273658202727128, 0.06455230463230488]}, "mutation_prompt": null}
{"id": "a7e5f485-9711-487d-b70c-1b7a53a980be", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.95  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.8:  # adjust the probability of exploration\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, refined by adjusting the probability of exploration in Harmony Search to 0.8 and the exploration rate adjustment rate to 0.95.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae42cd47-728a-4fdc-ac5f-6476f6bd181c", "metadata": {"aucs": [0.1678349328959614, 0.17279750639161406, 0.1595184715833271, 0.15402651240797094, 0.1648562418301468, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030926406351440172, 0.04229676289419204, 0.028726245370913395, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015819282273171642, 0.029664245482800333, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9867674543946731, 0.9525436988420015, 0.9717376530829223, 0.9903302381847126, 0.9850981882542482, 0.9972648919717684, 0.9984356409844637, 0.9553412151716654, 0.9645859532542663, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.19251264416280434, 0.15652811510721387, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08676953325769732, 0.11907231038975785, 0.10057548328576271, 0.14897534770098486, 0.10493177416982002, 0.10346286426108486, 0.09679865740757176, 0.11358190921115785, 0.09682496974428945, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.033198415640640855, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18871626737704628, 0.19428978787791196, 0.17312656805426563, 0.18780975933274735, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03149234042422633, 0.04231214916752091, 0.13568153332214972, 0.11905403678117366, 0.1403075403980727, 0.13871562955069006, 0.1372262786133278, 0.10974092177683303, 0.14685264999665137, 0.14082534460781315, 0.11880798383977931, 0.16076931587688736, 0.14938292316338864, 0.16681481982739899, 0.17389160256634073, 0.16533924594492366, 0.16925040185192686, 0.15127901597955062, 0.17359018863582443, 0.14089303387979657, 0.09990585299789723, 0.08926705538892332, 0.1071630535151673, 0.12070091051728737, 0.11973285755571361, 0.12082456924785745, 0.09812208369943642, 0.1224537527043591, 0.1105919194651881, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.26017734341597376, 0.26017153992687414, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1407555242655073, 0.13800289038965985, 0.14977569096645127, 0.13693995517714885, 0.14569881022274822, 0.140143161101136, 0.11628393443071672, 0.12773466300142378, 0.16012466570397244, 0.1283716653776582, 0.16109499936412963, 0.15820226210876076, 0.1513356545171608, 0.1353860294342618, 0.12040482243876283, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013973170546046, 0.13406252454194778, 0.13364278059408274, 0.11960477127904323, 0.11996033272833961, 0.13675049794254157, 0.15880611152986535, 0.15863188580695564, 0.10980097721265791, 0.17066892194230676, 0.18555709813015586, 0.16799860707977843, 0.18177874436835761, 0.20561058129684395, 0.20990868327844703, 0.1814683966752314, 0.17626403684905056, 0.20264458112034267, 0.053161201534176916, 0.10905280314177068, 0.06372468227507866, 0.058303961801324244, 0.05847740743192098, 0.05073019180702398, 0.07289275853335497, 0.05085306921687838, 0.06373961691120422]}, "mutation_prompt": null}
{"id": "1c6718fa-f67c-4520-b2b2-3dc9a5327bb8", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.92  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.9:  # adjust the probability of exploration\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.85)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.05)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.95)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.05)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, refined by adjusting the probability of exploration in Harmony Search to 0.9 and the exploration rate adjustment rate to 0.92.", "configspace": "", "generation": 65, "fitness": 0.128447613601671, "feedback": "The algorithm AHQBACO_DN2_DE2_REFINED_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "ae42cd47-728a-4fdc-ac5f-6476f6bd181c", "metadata": {"aucs": [0.16791463472217605, 0.17287870265970118, 0.15954351657358878, 0.15404174970884177, 0.16485761402461452, 0.15895711396412404, 0.16270708318851046, 0.13944035079784867, 0.14875543656335266, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03097175095894089, 0.042297665339880997, 0.028707454718879255, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02484300085510005, 0.01624046958871095, 0.0306804344690792, 0.01969646754387211, 0.033153130081172266, 0.04462367806249967, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9625601654576418, 0.9887093105162332, 0.9967314833102295, 0.990613045612868, 0.978842128743618, 0.9757346342084302, 0.9760183613015685, 0.9637142276134363, 0.9646077713573191, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.1657343030247983, 0.1926773706368211, 0.15495049911782421, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08749316792424155, 0.1258326455977674, 0.10276907979083805, 0.10217242132148752, 0.11181381051149053, 0.09884261800131988, 0.10290057619890725, 0.1178318544096354, 0.08895010955518534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.033198415640640855, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20661818808493548, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18876344404115986, 0.19442998431990366, 0.17137595477101641, 0.1878726978464088, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037737225736343305, 0.03152262647728599, 0.04231214916752091, 0.13526864060271415, 0.11879001598398042, 0.1403075403980727, 0.1387225781051249, 0.1372262786133278, 0.10991010495874565, 0.14593016140702508, 0.14146874559029698, 0.11947149011406766, 0.16079070961891062, 0.14938782888659952, 0.16684316589609638, 0.16751639688529774, 0.16743553462769722, 0.1677561893790771, 0.15127901597955062, 0.17355384695910447, 0.14087059458559126, 0.09990585299789723, 0.08915889672401478, 0.10716775680921653, 0.12003970226464955, 0.1231492209308237, 0.12081265838169497, 0.09812208369943642, 0.12246757639898764, 0.1105305319269635, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.26262195714911796, 0.2733117796270077, 0.2601678946548399, 0.26017816934690785, 0.12821954655013268, 0.138573316280035, 0.12739941219488515, 0.1268243897200909, 0.14600365779889524, 0.14084817961805252, 0.12623570558600972, 0.12773466300142378, 0.15937956746530713, 0.12912771814670143, 0.16111021637023348, 0.15821036632085905, 0.1513625440326054, 0.1353860294342618, 0.1204052362879503, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.1400986269807849, 0.13406252454194778, 0.13348718899796475, 0.11959952352508518, 0.11996054914979903, 0.13675049794254157, 0.15881046962968215, 0.15603777172547284, 0.10919329752694062, 0.16916804209687364, 0.18305443369716945, 0.17658002214036916, 0.18697639454652515, 0.20502607160092934, 0.21452641686538387, 0.18263288539414557, 0.17625069708871377, 0.20002145927501347, 0.05300874938321776, 0.10905933953581248, 0.063866904706537, 0.05543466342795289, 0.06091000440407002, 0.05166014493695659, 0.0700245036531354, 0.0636578816796971, 0.052791263669677235]}, "mutation_prompt": null}
{"id": "05c5238f-3217-4e41-be97-46315ea575ec", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.95  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.8:  # adjust the probability of exploration\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, refined by adjusting the probability of exploration in Harmony Search to 0.8 and the exploration rate adjustment rate to 0.95.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae42cd47-728a-4fdc-ac5f-6476f6bd181c", "metadata": {"aucs": [0.1678349328959614, 0.17279750639161406, 0.1595184715833271, 0.15402651240797094, 0.1648562418301468, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030926406351440172, 0.04229676289419204, 0.028726245370913395, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015819282273171642, 0.029664245482800333, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9867674543946731, 0.9525436988420015, 0.9717376530829223, 0.9903302381847126, 0.9850981882542482, 0.9972648919717684, 0.9984356409844637, 0.9553412151716654, 0.9645859532542663, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.19251264416280434, 0.15652811510721387, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08676953325769732, 0.11907231038975785, 0.10057548328576271, 0.14897534770098486, 0.10493177416982002, 0.10346286426108486, 0.09679865740757176, 0.11358190921115785, 0.09682496974428945, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.033198415640640855, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18871626737704628, 0.19428978787791196, 0.17312656805426563, 0.18780975933274735, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03149234042422633, 0.04231214916752091, 0.13568153332214972, 0.11905403678117366, 0.1403075403980727, 0.13871562955069006, 0.1372262786133278, 0.10974092177683303, 0.14685264999665137, 0.14082534460781315, 0.11880798383977931, 0.16076931587688736, 0.14938292316338864, 0.16681481982739899, 0.17389160256634073, 0.16533924594492366, 0.16925040185192686, 0.15127901597955062, 0.17359018863582443, 0.14089303387979657, 0.09990585299789723, 0.08926705538892332, 0.1071630535151673, 0.12070091051728737, 0.11973285755571361, 0.12082456924785745, 0.09812208369943642, 0.1224537527043591, 0.1105919194651881, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.26017734341597376, 0.26017153992687414, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1407555242655073, 0.13800289038965985, 0.14977569096645127, 0.13693995517714885, 0.14569881022274822, 0.140143161101136, 0.11628393443071672, 0.12773466300142378, 0.16012466570397244, 0.1283716653776582, 0.16109499936412963, 0.15820226210876076, 0.1513356545171608, 0.1353860294342618, 0.12040482243876283, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013973170546046, 0.13406252454194778, 0.13364278059408274, 0.11960477127904323, 0.11996033272833961, 0.13675049794254157, 0.15880611152986535, 0.15863188580695564, 0.10980097721265791, 0.17066892194230676, 0.18555709813015586, 0.16799860707977843, 0.18177874436835761, 0.20561058129684395, 0.20990868327844703, 0.1814683966752314, 0.17626403684905056, 0.20264458112034267, 0.053161201534176916, 0.10905280314177068, 0.06372468227507866, 0.058303961801324244, 0.05847740743192098, 0.05073019180702398, 0.07289275853335497, 0.05085306921687838, 0.06373961691120422]}, "mutation_prompt": null}
{"id": "dc72e657-2100-4417-b9a7-4c16027889a0", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.95  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.8:  # adjust the probability of exploration\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, refined by adjusting the probability of exploration in Harmony Search to 0.8 and the exploration rate adjustment rate to 0.95.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae42cd47-728a-4fdc-ac5f-6476f6bd181c", "metadata": {"aucs": [0.1678349328959614, 0.17279750639161406, 0.1595184715833271, 0.15402651240797094, 0.1648562418301468, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030926406351440172, 0.04229676289419204, 0.028726245370913395, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015819282273171642, 0.029664245482800333, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9867674543946731, 0.9525436988420015, 0.9717376530829223, 0.9903302381847126, 0.9850981882542482, 0.9972648919717684, 0.9984356409844637, 0.9553412151716654, 0.9645859532542663, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.19251264416280434, 0.15652811510721387, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08676953325769732, 0.11907231038975785, 0.10057548328576271, 0.14897534770098486, 0.10493177416982002, 0.10346286426108486, 0.09679865740757176, 0.11358190921115785, 0.09682496974428945, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.033198415640640855, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18871626737704628, 0.19428978787791196, 0.17312656805426563, 0.18780975933274735, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03149234042422633, 0.04231214916752091, 0.13568153332214972, 0.11905403678117366, 0.1403075403980727, 0.13871562955069006, 0.1372262786133278, 0.10974092177683303, 0.14685264999665137, 0.14082534460781315, 0.11880798383977931, 0.16076931587688736, 0.14938292316338864, 0.16681481982739899, 0.17389160256634073, 0.16533924594492366, 0.16925040185192686, 0.15127901597955062, 0.17359018863582443, 0.14089303387979657, 0.09990585299789723, 0.08926705538892332, 0.1071630535151673, 0.12070091051728737, 0.11973285755571361, 0.12082456924785745, 0.09812208369943642, 0.1224537527043591, 0.1105919194651881, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.26017734341597376, 0.26017153992687414, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1407555242655073, 0.13800289038965985, 0.14977569096645127, 0.13693995517714885, 0.14569881022274822, 0.140143161101136, 0.11628393443071672, 0.12773466300142378, 0.16012466570397244, 0.1283716653776582, 0.16109499936412963, 0.15820226210876076, 0.1513356545171608, 0.1353860294342618, 0.12040482243876283, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013973170546046, 0.13406252454194778, 0.13364278059408274, 0.11960477127904323, 0.11996033272833961, 0.13675049794254157, 0.15880611152986535, 0.15863188580695564, 0.10980097721265791, 0.17066892194230676, 0.18555709813015586, 0.16799860707977843, 0.18177874436835761, 0.20561058129684395, 0.20990868327844703, 0.1814683966752314, 0.17626403684905056, 0.20264458112034267, 0.053161201534176916, 0.10905280314177068, 0.06372468227507866, 0.058303961801324244, 0.05847740743192098, 0.05073019180702398, 0.07289275853335497, 0.05085306921687838, 0.06373961691120422]}, "mutation_prompt": null}
{"id": "d7faaedb-398a-4fa2-99e5-d6618f50800e", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.2:  # adjust the probability of exploration\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, refined by adjusting the probability of exploration in Harmony Search to 0.2 and the exploration rate adjustment rate to 0.9.", "configspace": "", "generation": 68, "fitness": 0.12863656555908548, "feedback": "The algorithm AHQBACO_DN2_DE2_REFINED_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "ae42cd47-728a-4fdc-ac5f-6476f6bd181c", "metadata": {"aucs": [0.16791744477381731, 0.17303469099573143, 0.15954351657358878, 0.15403853358673114, 0.16485761402461452, 0.15898306837794374, 0.1627049578055918, 0.13944035079784867, 0.14875543656335266, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030687720146829855, 0.04229920659856412, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024861641190549788, 0.019414335336780053, 0.03031044143233652, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9868363961698443, 0.9932423229580043, 0.9819514713670061, 0.9906119211312752, 0.9849569511723854, 0.9972717099606738, 0.9938949280389165, 0.9882307362058073, 0.9642186805532483, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15954354197604115, 0.19081465688539123, 0.15709921857435816, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08794109919897475, 0.10544465410102821, 0.10798113014886968, 0.14714604513893625, 0.11193548551186416, 0.10258935047875273, 0.10132261529437314, 0.11425575421940248, 0.08800883608902188, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831658361763817, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18876344404115986, 0.19365273942065264, 0.1763214624486431, 0.18739287391311266, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03775841439762828, 0.03150842159239786, 0.04231214916752091, 0.1357939799439426, 0.11569241688862697, 0.1403075403980727, 0.1387220562751541, 0.1372262786133278, 0.1097355930509093, 0.1460170799593028, 0.14082534460781315, 0.11788519870121872, 0.1606950954948081, 0.14937621116201716, 0.16684772814827575, 0.16787884304627876, 0.16726410278645598, 0.16885102611399783, 0.15127901597955062, 0.17357244887918022, 0.1409469951942578, 0.09989989921586839, 0.08926975047488117, 0.10716775680921653, 0.12111720574002849, 0.11965676188405028, 0.12070305045499863, 0.09812208369943642, 0.1224537527043591, 0.11056736998689409, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.26017153992687414, 0.2733117796270077, 0.2601678946548399, 0.2601794947077204, 0.1407555242655073, 0.13856814490582914, 0.12902859008533485, 0.127596628524817, 0.1366279504079625, 0.14085960050253765, 0.11868758380932964, 0.12773466300142378, 0.16005469550930485, 0.13000336256963307, 0.16110948438850792, 0.1582109416108034, 0.15133833815034814, 0.13538153959863353, 0.12072691433798499, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013870492952119, 0.13407049192775466, 0.13348985053450702, 0.11960286967265588, 0.11996054914979903, 0.13675049794254157, 0.15868787212298918, 0.15826003763145524, 0.10988046452472044, 0.16557155183380834, 0.18556423272408507, 0.16822191262871944, 0.18746457392088522, 0.20561058129684395, 0.20962847156465625, 0.17199439086911084, 0.17619914272361004, 0.20264970129115645, 0.054090173137916975, 0.07016332879116238, 0.06394762718395086, 0.05951603922563187, 0.05842960233959571, 0.05151773669285997, 0.07285460909842856, 0.063695895505406, 0.05239362170154016]}, "mutation_prompt": null}
{"id": "6f7414de-c241-4264-95d3-aab06e89c353", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.9  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.2:  # adjust the probability of exploration to 0.2\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 0.9)  # adjust exploration rate to 0.9\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 0.9)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, refined by adjusting the probability of exploration in Harmony Search to 0.2 and the exploration rate adjustment rate to 0.9.", "configspace": "", "generation": 69, "fitness": 0.1286933761184911, "feedback": "The algorithm AHQBACO_DN2_DE2_REFINED_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "ae42cd47-728a-4fdc-ac5f-6476f6bd181c", "metadata": {"aucs": [0.1679206248099212, 0.1730397538914542, 0.15940624335943376, 0.1540448289221975, 0.16485761402461452, 0.15898560438757192, 0.1627049578055918, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03091841247445737, 0.042297665339880997, 0.028786365634780098, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.021475879672443576, 0.01934687512141431, 0.0306804344690792, 0.01969646754387211, 0.033153130081172266, 0.04462538477247513, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.965449631013602, 0.9932167240644891, 0.9870718925371817, 0.9904703206759358, 0.9792869511723854, 0.9972648919717684, 0.9984356409844637, 0.9882296487836116, 0.9501019733548204, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.14932168128418544, 0.19135673309206136, 0.15773552571088345, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.0878701608434882, 0.12806815271036465, 0.10798113014886968, 0.090819173606699, 0.11190169214133927, 0.09930228332522661, 0.09760800161426253, 0.10402070354861281, 0.10104058073204847, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831543164293143, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.027473647716905747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.1774167541950743, 0.18871626737704628, 0.19518322556558043, 0.17637893313611497, 0.1875889377578811, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037738355399636214, 0.03150842159239786, 0.04231214916752091, 0.1357925092864174, 0.11949803569855721, 0.1403075403980727, 0.1387220562751541, 0.1372262786133278, 0.1097355930509093, 0.1457767860363539, 0.14080906521945402, 0.12061348301080399, 0.1610745641389092, 0.14938292316338864, 0.16682863340239906, 0.16660862380532349, 0.16594392542518377, 0.1663100123280048, 0.15127901597955062, 0.17357244887918022, 0.1408917460144241, 0.09989989921586839, 0.0892556954122018, 0.10716775680921653, 0.11462438268367237, 0.11974148571168186, 0.11817114612951296, 0.09812208369943642, 0.1224537527043591, 0.11051053612814776, 0.2601813882744033, 0.2601763462457861, 0.26017666954069796, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2733117796270077, 0.2601737466540327, 0.26017816934690785, 0.1407555242655073, 0.13800806176386649, 0.14977569096645127, 0.12980680664451372, 0.13674735806830374, 0.14085960050253765, 0.11828367643100524, 0.13507824487384246, 0.16012466570397244, 0.13000336256963307, 0.1609599715251916, 0.15809829878022652, 0.1513814835885421, 0.13538153959863353, 0.12075058210091416, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013973170546046, 0.13407049192775466, 0.1336387739971271, 0.11961705079305107, 0.11996219230734095, 0.13675049794254157, 0.15880611152986535, 0.15816412315294381, 0.10980097721265791, 0.17088221481591082, 0.18297812867283236, 0.17658002214036916, 0.18699458370178634, 0.20502607160092934, 0.2140753624011127, 0.1814397193700361, 0.1767390197655001, 0.20005730473429095, 0.05255086196774261, 0.10910671837840769, 0.06400317697986391, 0.05534820662427409, 0.060561593356709964, 0.05376369966345662, 0.07019709346429603, 0.0626347899444718, 0.06508141038335558]}, "mutation_prompt": null}
{"id": "232e5402-7262-470b-9152-b083c1b75b9a", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.92  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.2:  # adjust the probability of exploration to 0.2\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, refined by adjusting the probability of exploration in Harmony Search to 0.2 and the exploration rate adjustment rate to 0.92.", "configspace": "", "generation": 70, "fitness": 0.12837457537282893, "feedback": "The algorithm AHQBACO_DN2_DE2_REFINED_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "ae42cd47-728a-4fdc-ac5f-6476f6bd181c", "metadata": {"aucs": [0.1678054355233347, 0.17286659968246276, 0.15954138089087244, 0.15403403248510572, 0.16485761402461452, 0.158979878581736, 0.16270529397139766, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031028738164775693, 0.042297665339880997, 0.028726245370913395, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.021533927838008116, 0.01585614567852167, 0.02993853791020884, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9795718730334692, 0.993262163558376, 0.9873976530829224, 0.9753503206759356, 0.9850081882542482, 0.9999001200375565, 0.9938283270383974, 0.9637112151716652, 0.9010801775691023, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16188797025608614, 0.19251264416280434, 0.1559926796524458, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08519243499597795, 0.12806815271036465, 0.10848236017349189, 0.10173268170337646, 0.11207037063532244, 0.10178431170145885, 0.1021792792742583, 0.1178318544096354, 0.09557267232127453, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831658361763817, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20661818808493548, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.1774167541950743, 0.1887370728543144, 0.19376311021022674, 0.175786571683468, 0.18787167109753122, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03774444209317751, 0.03152262647728599, 0.04231214916752091, 0.13566589911417104, 0.11544563095512916, 0.1403075403980727, 0.13871562955069006, 0.13721084259603444, 0.10997898183062449, 0.14601782842642952, 0.14144675127365913, 0.11934602818214024, 0.1610745641389092, 0.14937621116201716, 0.16682999104958385, 0.16716886941791875, 0.16933329834897703, 0.16749615383347338, 0.15127901597955062, 0.17354213888016823, 0.1409469951942578, 0.09990585299789723, 0.08928111045160281, 0.1071630535151673, 0.12119021791483375, 0.11887085773744022, 0.11725480562581048, 0.09812208369943642, 0.12246601612611141, 0.11057311574602335, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.2601769605582607, 0.2601875539181707, 0.2601737466540327, 0.26017816934690785, 0.13427826654680952, 0.138573316280035, 0.12813631101770429, 0.1301026596537329, 0.14581821788308957, 0.14085960050253765, 0.12383205620739679, 0.13507824487384246, 0.15890532503478294, 0.12911897462762623, 0.16055548870001934, 0.15824238510490796, 0.15137550649944465, 0.13538153959863353, 0.12058523398100018, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013973170546046, 0.13407049192775466, 0.13348907333088667, 0.11958367314107421, 0.11996033272833961, 0.13675049794254157, 0.15813540392805536, 0.1586401383565157, 0.10945843123692778, 0.17087959368726569, 0.1854964212639495, 0.1846774426752329, 0.18707975121021236, 0.2099163930368073, 0.20990868327844703, 0.171715928693165, 0.17633764880141667, 0.20014537947052635, 0.052919094121867016, 0.10905280314177068, 0.06353471522934939, 0.05830773497706887, 0.05839781458803095, 0.05226501278820084, 0.0728421452509388, 0.06269974017943136, 0.058313954452841266]}, "mutation_prompt": null}
{"id": "a71dcb73-7179-46aa-a149-c75a53f4e071", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.95  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.8:  # adjust the probability of exploration\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, refined by adjusting the probability of exploration in Harmony Search to 0.8 and the exploration rate adjustment rate to 0.95.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae42cd47-728a-4fdc-ac5f-6476f6bd181c", "metadata": {"aucs": [0.1678349328959614, 0.17279750639161406, 0.1595184715833271, 0.15402651240797094, 0.1648562418301468, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030926406351440172, 0.04229676289419204, 0.028726245370913395, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015819282273171642, 0.029664245482800333, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9867674543946731, 0.9525436988420015, 0.9717376530829223, 0.9903302381847126, 0.9850981882542482, 0.9972648919717684, 0.9984356409844637, 0.9553412151716654, 0.9645859532542663, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.19251264416280434, 0.15652811510721387, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08676953325769732, 0.11907231038975785, 0.10057548328576271, 0.14897534770098486, 0.10493177416982002, 0.10346286426108486, 0.09679865740757176, 0.11358190921115785, 0.09682496974428945, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.033198415640640855, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18871626737704628, 0.19428978787791196, 0.17312656805426563, 0.18780975933274735, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03149234042422633, 0.04231214916752091, 0.13568153332214972, 0.11905403678117366, 0.1403075403980727, 0.13871562955069006, 0.1372262786133278, 0.10974092177683303, 0.14685264999665137, 0.14082534460781315, 0.11880798383977931, 0.16076931587688736, 0.14938292316338864, 0.16681481982739899, 0.17389160256634073, 0.16533924594492366, 0.16925040185192686, 0.15127901597955062, 0.17359018863582443, 0.14089303387979657, 0.09990585299789723, 0.08926705538892332, 0.1071630535151673, 0.12070091051728737, 0.11973285755571361, 0.12082456924785745, 0.09812208369943642, 0.1224537527043591, 0.1105919194651881, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.26017734341597376, 0.26017153992687414, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1407555242655073, 0.13800289038965985, 0.14977569096645127, 0.13693995517714885, 0.14569881022274822, 0.140143161101136, 0.11628393443071672, 0.12773466300142378, 0.16012466570397244, 0.1283716653776582, 0.16109499936412963, 0.15820226210876076, 0.1513356545171608, 0.1353860294342618, 0.12040482243876283, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013973170546046, 0.13406252454194778, 0.13364278059408274, 0.11960477127904323, 0.11996033272833961, 0.13675049794254157, 0.15880611152986535, 0.15863188580695564, 0.10980097721265791, 0.17066892194230676, 0.18555709813015586, 0.16799860707977843, 0.18177874436835761, 0.20561058129684395, 0.20990868327844703, 0.1814683966752314, 0.17626403684905056, 0.20264458112034267, 0.053161201534176916, 0.10905280314177068, 0.06372468227507866, 0.058303961801324244, 0.05847740743192098, 0.05073019180702398, 0.07289275853335497, 0.05085306921687838, 0.06373961691120422]}, "mutation_prompt": null}
{"id": "67d0bc30-b1f7-483b-a4a2-bd1691a10571", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.95  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.8:  # adjust the probability of exploration\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, refined by adjusting the probability of exploration in Harmony Search to 0.8 and the exploration rate adjustment rate to 0.95.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae42cd47-728a-4fdc-ac5f-6476f6bd181c", "metadata": {"aucs": [0.1678349328959614, 0.17279750639161406, 0.1595184715833271, 0.15402651240797094, 0.1648562418301468, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030926406351440172, 0.04229676289419204, 0.028726245370913395, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015819282273171642, 0.029664245482800333, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9867674543946731, 0.9525436988420015, 0.9717376530829223, 0.9903302381847126, 0.9850981882542482, 0.9972648919717684, 0.9984356409844637, 0.9553412151716654, 0.9645859532542663, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.19251264416280434, 0.15652811510721387, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08676953325769732, 0.11907231038975785, 0.10057548328576271, 0.14897534770098486, 0.10493177416982002, 0.10346286426108486, 0.09679865740757176, 0.11358190921115785, 0.09682496974428945, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.033198415640640855, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18871626737704628, 0.19428978787791196, 0.17312656805426563, 0.18780975933274735, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03149234042422633, 0.04231214916752091, 0.13568153332214972, 0.11905403678117366, 0.1403075403980727, 0.13871562955069006, 0.1372262786133278, 0.10974092177683303, 0.14685264999665137, 0.14082534460781315, 0.11880798383977931, 0.16076931587688736, 0.14938292316338864, 0.16681481982739899, 0.17389160256634073, 0.16533924594492366, 0.16925040185192686, 0.15127901597955062, 0.17359018863582443, 0.14089303387979657, 0.09990585299789723, 0.08926705538892332, 0.1071630535151673, 0.12070091051728737, 0.11973285755571361, 0.12082456924785745, 0.09812208369943642, 0.1224537527043591, 0.1105919194651881, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.26017734341597376, 0.26017153992687414, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1407555242655073, 0.13800289038965985, 0.14977569096645127, 0.13693995517714885, 0.14569881022274822, 0.140143161101136, 0.11628393443071672, 0.12773466300142378, 0.16012466570397244, 0.1283716653776582, 0.16109499936412963, 0.15820226210876076, 0.1513356545171608, 0.1353860294342618, 0.12040482243876283, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013973170546046, 0.13406252454194778, 0.13364278059408274, 0.11960477127904323, 0.11996033272833961, 0.13675049794254157, 0.15880611152986535, 0.15863188580695564, 0.10980097721265791, 0.17066892194230676, 0.18555709813015586, 0.16799860707977843, 0.18177874436835761, 0.20561058129684395, 0.20990868327844703, 0.1814683966752314, 0.17626403684905056, 0.20264458112034267, 0.053161201534176916, 0.10905280314177068, 0.06372468227507866, 0.058303961801324244, 0.05847740743192098, 0.05073019180702398, 0.07289275853335497, 0.05085306921687838, 0.06373961691120422]}, "mutation_prompt": null}
{"id": "7073c40c-23e2-4ccf-b2a9-2d0f34c4ca26", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.95  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.8:  # adjust the probability of exploration\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, refined by adjusting the probability of exploration in Harmony Search to 0.8 and the exploration rate adjustment rate to 0.95.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae42cd47-728a-4fdc-ac5f-6476f6bd181c", "metadata": {"aucs": [0.1678349328959614, 0.17279750639161406, 0.1595184715833271, 0.15402651240797094, 0.1648562418301468, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030926406351440172, 0.04229676289419204, 0.028726245370913395, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015819282273171642, 0.029664245482800333, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9867674543946731, 0.9525436988420015, 0.9717376530829223, 0.9903302381847126, 0.9850981882542482, 0.9972648919717684, 0.9984356409844637, 0.9553412151716654, 0.9645859532542663, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.19251264416280434, 0.15652811510721387, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08676953325769732, 0.11907231038975785, 0.10057548328576271, 0.14897534770098486, 0.10493177416982002, 0.10346286426108486, 0.09679865740757176, 0.11358190921115785, 0.09682496974428945, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.033198415640640855, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18871626737704628, 0.19428978787791196, 0.17312656805426563, 0.18780975933274735, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03149234042422633, 0.04231214916752091, 0.13568153332214972, 0.11905403678117366, 0.1403075403980727, 0.13871562955069006, 0.1372262786133278, 0.10974092177683303, 0.14685264999665137, 0.14082534460781315, 0.11880798383977931, 0.16076931587688736, 0.14938292316338864, 0.16681481982739899, 0.17389160256634073, 0.16533924594492366, 0.16925040185192686, 0.15127901597955062, 0.17359018863582443, 0.14089303387979657, 0.09990585299789723, 0.08926705538892332, 0.1071630535151673, 0.12070091051728737, 0.11973285755571361, 0.12082456924785745, 0.09812208369943642, 0.1224537527043591, 0.1105919194651881, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.26017734341597376, 0.26017153992687414, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1407555242655073, 0.13800289038965985, 0.14977569096645127, 0.13693995517714885, 0.14569881022274822, 0.140143161101136, 0.11628393443071672, 0.12773466300142378, 0.16012466570397244, 0.1283716653776582, 0.16109499936412963, 0.15820226210876076, 0.1513356545171608, 0.1353860294342618, 0.12040482243876283, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013973170546046, 0.13406252454194778, 0.13364278059408274, 0.11960477127904323, 0.11996033272833961, 0.13675049794254157, 0.15880611152986535, 0.15863188580695564, 0.10980097721265791, 0.17066892194230676, 0.18555709813015586, 0.16799860707977843, 0.18177874436835761, 0.20561058129684395, 0.20990868327844703, 0.1814683966752314, 0.17626403684905056, 0.20264458112034267, 0.053161201534176916, 0.10905280314177068, 0.06372468227507866, 0.058303961801324244, 0.05847740743192098, 0.05073019180702398, 0.07289275853335497, 0.05085306921687838, 0.06373961691120422]}, "mutation_prompt": null}
{"id": "bac05158-d11f-4bcf-b466-b65162ed782f", "solution": "import numpy as np\nimport random\n\nclass Refined_AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.95  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.change_probability = 0.01  # probability of changing individual lines of the selected solution\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            if random.random() < self.change_probability:\n                # Randomly change one of the lines of the selected solution\n                line_to_change = random.randint(0, self.dim - 1)\n                self.best_solution[line_to_change] = np.random.uniform(-5, 5)\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.8:  # adjust the probability of exploration\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nrefined_ahqbaco_dn2_de2_refined_refined = Refined_AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = refined_ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "Refined_AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, refined by adjusting the probability of exploration in Harmony Search to 0.8 and the exploration rate adjustment rate to 0.95, with a 1% chance of changing individual lines of the selected solution.", "configspace": "", "generation": 74, "fitness": 0.128519546417707, "feedback": "The algorithm Refined_AHQBACO_DN2_DE2_REFINED_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "ae42cd47-728a-4fdc-ac5f-6476f6bd181c", "metadata": {"aucs": [0.16839464756854372, 0.17303456140539053, 0.15936576467676755, 0.1540328077434373, 0.16485414420748767, 0.15897100690557542, 0.16270741935431654, 0.13944035079784867, 0.14875543656335266, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03076758186844586, 0.04229676289419204, 0.028751486390701797, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.021219916781381687, 0.016140059874222068, 0.029656273253444443, 0.01969646754387211, 0.033153130081172266, 0.044730209932289156, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9874001654576415, 0.9932423229580043, 0.9933695291969336, 0.9779453206759356, 0.9637354126702125, 0.9999001200375565, 0.9878792066508106, 0.9794469371776802, 0.9780301775691005, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.17049666251918372, 0.19106774504847945, 0.150713368289069, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.09237489589199499, 0.08412631069967669, 0.12267099950960325, 0.11610388892444223, 0.12450760194978683, 0.09664812428512015, 0.11639729052188263, 0.09782046581747039, 0.10193838453458304, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831543164293143, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.18871350186886504, 0.19349396167165045, 0.17615763271189822, 0.18795613769091002, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03771420465876418, 0.03150842159239786, 0.04231214916752091, 0.13578299041779696, 0.1181006918980031, 0.1315760178737304, 0.1387220562751541, 0.1372262786133278, 0.11877133514352123, 0.14581275535860772, 0.1409239497742545, 0.1216215823609973, 0.1610745641389092, 0.14934823855698487, 0.16680452365995024, 0.16822631400324994, 0.16884761389159686, 0.17092283083322324, 0.15127901597955062, 0.17359018863582443, 0.14092805271434972, 0.0999016709424837, 0.08926705538892332, 0.10716775680921653, 0.12551763773281166, 0.12070345105817837, 0.11918459291977945, 0.09812208369943642, 0.12246601612611141, 0.11059126015736165, 0.2601813882744033, 0.2601763462457861, 0.26017666954069796, 0.26018132180600584, 0.26017734341597376, 0.2601769605582607, 0.2601875539181707, 0.2601737466540327, 0.2601794947077204, 0.1420371304987983, 0.1380808516972858, 0.1361966823208728, 0.1250099301598646, 0.13776281677537716, 0.14691175531981882, 0.1328470457611376, 0.13573783470807121, 0.16005469550930485, 0.12599111473274638, 0.16130174257841956, 0.1582429603948523, 0.1513625440326054, 0.1353860294342618, 0.12039495234474384, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14050169832407045, 0.13406252454194778, 0.13349307992784254, 0.11959708222254117, 0.11993712184786531, 0.13675049794254157, 0.1589384059703398, 0.15909161748064782, 0.10950327163147844, 0.16341281032366228, 0.18297812867283236, 0.1765805904024561, 0.18172631838984799, 0.20548141264131892, 0.17039569584947112, 0.17175930845382814, 0.17769530053848526, 0.20002145927501347, 0.05519418319249636, 0.10906245171121076, 0.06514571486444909, 0.049977602616954386, 0.05844692541957042, 0.05054656751937203, 0.07409876966639162, 0.05168706181750693, 0.054131321752577954]}, "mutation_prompt": null}
{"id": "f656ac15-6ecc-43ee-9801-1891a34f16b2", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.95  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.8:  # adjust the probability of exploration\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search and Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhoods and Exploration-Exploitation Tradeoff Adjustment and Differential Evolution with Dynamically Adjusted Exploration Rate and Neighborhood Size, refined by adjusting the probability of exploration in Harmony Search to 0.8 and the exploration rate adjustment rate to 0.95.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae42cd47-728a-4fdc-ac5f-6476f6bd181c", "metadata": {"aucs": [0.1678349328959614, 0.17279750639161406, 0.1595184715833271, 0.15402651240797094, 0.1648562418301468, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030926406351440172, 0.04229676289419204, 0.028726245370913395, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015819282273171642, 0.029664245482800333, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9867674543946731, 0.9525436988420015, 0.9717376530829223, 0.9903302381847126, 0.9850981882542482, 0.9972648919717684, 0.9984356409844637, 0.9553412151716654, 0.9645859532542663, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16576037720750336, 0.19251264416280434, 0.15652811510721387, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08676953325769732, 0.11907231038975785, 0.10057548328576271, 0.14897534770098486, 0.10493177416982002, 0.10346286426108486, 0.09679865740757176, 0.11358190921115785, 0.09682496974428945, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.033198415640640855, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18871626737704628, 0.19428978787791196, 0.17312656805426563, 0.18780975933274735, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03149234042422633, 0.04231214916752091, 0.13568153332214972, 0.11905403678117366, 0.1403075403980727, 0.13871562955069006, 0.1372262786133278, 0.10974092177683303, 0.14685264999665137, 0.14082534460781315, 0.11880798383977931, 0.16076931587688736, 0.14938292316338864, 0.16681481982739899, 0.17389160256634073, 0.16533924594492366, 0.16925040185192686, 0.15127901597955062, 0.17359018863582443, 0.14089303387979657, 0.09990585299789723, 0.08926705538892332, 0.1071630535151673, 0.12070091051728737, 0.11973285755571361, 0.12082456924785745, 0.09812208369943642, 0.1224537527043591, 0.1105919194651881, 0.2601813882744033, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.26017734341597376, 0.26017153992687414, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.1407555242655073, 0.13800289038965985, 0.14977569096645127, 0.13693995517714885, 0.14569881022274822, 0.140143161101136, 0.11628393443071672, 0.12773466300142378, 0.16012466570397244, 0.1283716653776582, 0.16109499936412963, 0.15820226210876076, 0.1513356545171608, 0.1353860294342618, 0.12040482243876283, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013973170546046, 0.13406252454194778, 0.13364278059408274, 0.11960477127904323, 0.11996033272833961, 0.13675049794254157, 0.15880611152986535, 0.15863188580695564, 0.10980097721265791, 0.17066892194230676, 0.18555709813015586, 0.16799860707977843, 0.18177874436835761, 0.20561058129684395, 0.20990868327844703, 0.1814683966752314, 0.17626403684905056, 0.20264458112034267, 0.053161201534176916, 0.10905280314177068, 0.06372468227507866, 0.058303961801324244, 0.05847740743192098, 0.05073019180702398, 0.07289275853335497, 0.05085306921687838, 0.06373961691120422]}, "mutation_prompt": null}
{"id": "919f92ff-0903-4853-bbde-7ea35688871f", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.92  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_of_exploration = 0.3  # probability of exploration in Harmony Search\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.probability_of_exploration:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search, Quantum-Inspired Particle Swarm Optimization, Artificial Bee Colony Optimization, and Adaptive Differential Evolution with Dynamically Adjusted Exploration Rate, Neighborhood Size, and Probability of Exploration, refined by adjusting the probability of exploration in Harmony Search to 0.3 and the exploration rate adjustment rate to 0.92.", "configspace": "", "generation": 76, "fitness": 0.12904998435834644, "feedback": "The algorithm AHQBACO_DN2_DE2_REFINED_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "ae42cd47-728a-4fdc-ac5f-6476f6bd181c", "metadata": {"aucs": [0.16791463472217605, 0.17303456140539053, 0.15751406432259996, 0.15402651240797094, 0.16485414420748767, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03097175095894089, 0.04229676289419204, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015461003664911765, 0.030527650940410433, 0.01969646754387211, 0.033153130081172266, 0.04462538477247513, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9868363961698443, 0.9932423229580043, 0.9967507256918613, 0.9906119211312752, 0.9850981882542482, 0.9999001200375565, 0.9984356409844637, 0.988199287780604, 0.9651477713573191, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15992888980280417, 0.19115953589611245, 0.15456498203766134, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08637246507304841, 0.10897624575995402, 0.11275589901584737, 0.14714604513893625, 0.1119824890054737, 0.10329312357011478, 0.11299922382094196, 0.11734569778248882, 0.09417485131860359, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831658361763817, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.1887370728543144, 0.19352871068065391, 0.16887764079650736, 0.18786755675501787, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03774444209317751, 0.03152262647728599, 0.04231214916752091, 0.13568153332214972, 0.1194993123551269, 0.11795695037128207, 0.13871562955069006, 0.13721084259603444, 0.10980446992278814, 0.1457760375692273, 0.14069261272339006, 0.11891066490337965, 0.1610745641389092, 0.14937621116201716, 0.1668244536637674, 0.16908774946579108, 0.1675139234496843, 0.1638625886356505, 0.15127901597955062, 0.17357244887918022, 0.1408942418583361, 0.0999016709424837, 0.08926282734017021, 0.1071630535151673, 0.1203156725712985, 0.11984530657403325, 0.11747123262071923, 0.09812208369943642, 0.12245014374148089, 0.11057733542366877, 0.2601813882744033, 0.26016601643901793, 0.2601786226371633, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.12821954655013268, 0.13716321690826827, 0.13255337194618855, 0.13963129667695395, 0.13540357832789718, 0.14084817961805252, 0.12383205620739679, 0.13526331024062344, 0.16005469550930485, 0.12760741005012766, 0.1608043855280008, 0.1582429603948523, 0.15137550649944465, 0.1353860294342618, 0.12059230836089974, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013945494570657, 0.13406252454194778, 0.13363799679350685, 0.11958313344491767, 0.11996033272833961, 0.13675049794254157, 0.15868485304836355, 0.15649285239177557, 0.10919045241018943, 0.17072734671065426, 0.18298662223703388, 0.18519976647975844, 0.18259150655041378, 0.2095867472928581, 0.20966156144958992, 0.1766079398057453, 0.1732666504430761, 0.20002145927501347, 0.05289953130640801, 0.10910671837840769, 0.06373250652646745, 0.05895802407947737, 0.06069417504582275, 0.052043981605300216, 0.07281469896024884, 0.06371327234900925, 0.06255519730698467]}, "mutation_prompt": null}
{"id": "8455fd4d-5857-462f-901b-139034d6fe7c", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.92  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_of_exploration = 0.3  # probability of exploration in Harmony Search\n        self.mutation_pressure = 0.01  # mutation pressure parameter\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.probability_of_exploration:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            # Adaptive mutation\n            if random.random() < self.mutation_pressure:\n                self.harmony_memory[i] += np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search with Dynamically Adjusted Exploration Rate and Neighborhood Size, and a novel adaptive mutation operator inspired by the concept of \"mutation pressure\" in evolutionary biology.", "configspace": "", "generation": 77, "fitness": 0.12829236967016228, "feedback": "The algorithm AHQBACO_DN2_DE2_REFINED_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "919f92ff-0903-4853-bbde-7ea35688871f", "metadata": {"aucs": [0.16783230186414622, 0.17287899495033265, 0.15784806952572594, 0.1540328077434373, 0.16485761402461452, 0.15897100690557542, 0.1627080782607181, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03130279744519415, 0.04230024949390554, 0.028759103192957824, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024990071778364875, 0.017659721152958774, 0.029619821916641698, 0.01969646754387211, 0.033153130081172266, 0.04443895162627287, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9852401654576416, 0.9932423229580043, 0.9873514713670062, 0.934430320675936, 0.9848643004622303, 0.9562951223863811, 0.9984356409844637, 0.9882587151716651, 0.9645301775691008, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03138024100827386, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.1677251765350094, 0.19120249087849184, 0.162822129663998, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.0856452574893054, 0.10556299923383938, 0.11593362952445163, 0.09974445605840587, 0.11217564870423136, 0.13201042674221175, 0.10313822238635606, 0.11160757882037775, 0.09447938561737501, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03326744523057912, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.1887606785329785, 0.19352228646709446, 0.1764437294979816, 0.18882758636040897, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776121636782259, 0.03152262647728599, 0.04231214916752091, 0.1386709458042138, 0.12111211189150639, 0.11804307204674191, 0.1387225781051249, 0.13721084259603444, 0.10980446992278814, 0.14624603323114482, 0.14070660939607627, 0.12085173568349417, 0.16069290542311943, 0.14930042609085936, 0.16683123298749636, 0.1714034657700717, 0.16322250257971682, 0.16529524373716997, 0.15127901597955062, 0.17357244887918022, 0.14111807788352415, 0.09989989921586839, 0.08926975047488117, 0.1071630535151673, 0.11782581364448474, 0.12376448431214127, 0.11747440990806357, 0.09812208369943642, 0.1224537527043591, 0.11050910075473275, 0.26018223221605774, 0.26016601643901793, 0.2601786226371633, 0.26018132180600584, 0.2601665068806729, 0.2601769605582607, 0.2601875539181707, 0.2601737466540327, 0.2601794947077204, 0.13498719732069753, 0.14546772609031522, 0.13742500273278635, 0.1370711448050531, 0.13633177163130716, 0.14136653784617925, 0.1234114488748852, 0.1329956831554906, 0.15890532503478294, 0.12813062470043313, 0.16126987171189322, 0.15824819331131224, 0.15135986039941796, 0.1353812470117839, 0.12040128580931231, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013870492952119, 0.1343083201571562, 0.13404477503392698, 0.11959952352508518, 0.11993691894326708, 0.13675049794254157, 0.15847809173997796, 0.15896541872567682, 0.10924981817973112, 0.16331909776617526, 0.18419581992733358, 0.18519976647975844, 0.18217269956180404, 0.20492702294005294, 0.17358327513831795, 0.1716908036695044, 0.17813125714774902, 0.20005730473429095, 0.053199803813797186, 0.10899554050312033, 0.06433127131101046, 0.053396166094637154, 0.05861422527376292, 0.05456975870521874, 0.07289275853335497, 0.055348364664179694, 0.05660078968860793]}, "mutation_prompt": null}
{"id": "9a924176-bfa8-49f4-81a7-512ca9a3bce8", "solution": "import numpy as np\nimport random\n\nclass NovelHybridAHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.92  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_of_exploration = 0.3  # probability of exploration in Harmony Search\n        self.new_exploration_strategy_probability = 0.2  # probability of using new exploration strategy\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.probability_of_exploration:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            # New exploration strategy\n            if random.random() < self.new_exploration_strategy_probability:\n                self.exploration_rate = self.exploration_rate * 0.8\n                self.neighborhood_size = self.neighborhood_size * 0.9\n                self.dynamic_neighborhood_size = self.dynamic_neighborhood_size * 1.1\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nnovel_hybrid_ahqbaco_dn2_de2_refined_refined = NovelHybridAHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = novel_hybrid_ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "NovelHybridAHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search, Quantum-Inspired Particle Swarm Optimization, Artificial Bee Colony Optimization, and Adaptive Differential Evolution with Dynamically Adjusted Exploration Rate, Neighborhood Size, and Probability of Exploration, refined by adjusting the probability of exploration in Harmony Search to 0.3 and the exploration rate adjustment rate to 0.92, with a 20% chance of using a new exploration strategy inspired by the selected solution's exploration rate adjustment.", "configspace": "", "generation": 78, "fitness": 0.12826149407335996, "feedback": "The algorithm NovelHybridAHQBACO_DN2_DE2_REFINED_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "919f92ff-0903-4853-bbde-7ea35688871f", "metadata": {"aucs": [0.16777664488368504, 0.17287141966910202, 0.15939226050908506, 0.15403975832839967, 0.16485761402461452, 0.15898560438757192, 0.16270529397139766, 0.1394327624586822, 0.14875543656335266, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03131440962239995, 0.04229920659856412, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.021286519091107237, 0.019550862899680888, 0.030365597106732256, 0.01969646754387211, 0.033153130081172266, 0.04462538477247513, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9652618730334694, 0.9887291511166051, 0.9711716010425111, 0.9749603206759356, 0.93527824578734, 0.9927334308650716, 0.9794661284616756, 0.9553702237640366, 0.9642804900617183, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16356056852619583, 0.19170990431494583, 0.15609979666469986, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08880750174116037, 0.12594759811096268, 0.10057548328576271, 0.14602175534220785, 0.09432301093610551, 0.10497615987511921, 0.11251118013182693, 0.11734569778248882, 0.09557267232127453, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831658361763817, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20661818808493548, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18873430734613306, 0.1936020620672253, 0.17306283362226405, 0.18783660734578944, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03771420465876418, 0.03149234042422633, 0.04231214916752091, 0.13578299041779696, 0.11907127164486542, 0.1403075403980727, 0.13871562955069006, 0.13721084259603444, 0.10980446992278814, 0.14685190152952476, 0.14066799788891893, 0.12078820707269078, 0.16079070961891062, 0.149343332833774, 0.16682542879740447, 0.17529089341500292, 0.16860407857168624, 0.16767996306963484, 0.15127901597955062, 0.1735744920708273, 0.14094129698813318, 0.09989989921586839, 0.08927646262021338, 0.1071630535151673, 0.12118072295148685, 0.12352016381719477, 0.12017702769468197, 0.09812208369943642, 0.12246757639898764, 0.11059126015736165, 0.26018223221605774, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.2601665068806729, 0.2626273777805045, 0.26263770681344867, 0.2601678946548399, 0.2601794947077204, 0.12822997278962944, 0.13716321690826827, 0.14977569096645127, 0.1285909059425594, 0.13528417066755605, 0.14084817961805252, 0.1166909919888196, 0.12791972836821264, 0.15890532503478294, 0.12937206566686654, 0.16088914454037617, 0.1582074950252207, 0.15133833815034814, 0.13538153959863353, 0.12040482243876283, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.1400989037405388, 0.13406252454194778, 0.1334911955949205, 0.11958557474746156, 0.11996219230734095, 0.13675049794254157, 0.15846885286667933, 0.15863188580695564, 0.10980097721265791, 0.1653296265600791, 0.18304729910324014, 0.16799917534186537, 0.18664784897653586, 0.20939061570930817, 0.21235658472594254, 0.1814415206500003, 0.17637495480761411, 0.20003874673346, 0.05373875913862325, 0.10901891445764522, 0.062956564578034, 0.051609389926656535, 0.0609191090416894, 0.05185617547000254, 0.07018622989782908, 0.05723887495050839, 0.06369412517159345]}, "mutation_prompt": null}
{"id": "dcbf0d1f-cc84-42ee-8fe7-a77862b615ee", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.92  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_of_exploration = 0.3  # probability of exploration in Harmony Search\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.probability_of_exploration:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search, Quantum-Inspired Particle Swarm Optimization, Artificial Bee Colony Optimization, and Adaptive Differential Evolution with Dynamically Adjusted Exploration Rate, Neighborhood Size, and Probability of Exploration, refined by adjusting the probability of exploration in Harmony Search to 0.3 and the exploration rate adjustment rate to 0.92.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "919f92ff-0903-4853-bbde-7ea35688871f", "metadata": {"aucs": [0.16791463472217605, 0.17303456140539053, 0.15751406432259996, 0.15402651240797094, 0.16485414420748767, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03097175095894089, 0.04229676289419204, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015461003664911765, 0.030527650940410433, 0.01969646754387211, 0.033153130081172266, 0.04462538477247513, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9868363961698443, 0.9932423229580043, 0.9967507256918613, 0.9906119211312752, 0.9850981882542482, 0.9999001200375565, 0.9984356409844637, 0.988199287780604, 0.9651477713573191, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15992888980280417, 0.19115953589611245, 0.15456498203766134, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08637246507304841, 0.10897624575995402, 0.11275589901584737, 0.14714604513893625, 0.1119824890054737, 0.10329312357011478, 0.11299922382094196, 0.11734569778248882, 0.09417485131860359, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831658361763817, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.1887370728543144, 0.19352871068065391, 0.16887764079650736, 0.18786755675501787, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03774444209317751, 0.03152262647728599, 0.04231214916752091, 0.13568153332214972, 0.1194993123551269, 0.11795695037128207, 0.13871562955069006, 0.13721084259603444, 0.10980446992278814, 0.1457760375692273, 0.14069261272339006, 0.11891066490337965, 0.1610745641389092, 0.14937621116201716, 0.1668244536637674, 0.16908774946579108, 0.1675139234496843, 0.1638625886356505, 0.15127901597955062, 0.17357244887918022, 0.1408942418583361, 0.0999016709424837, 0.08926282734017021, 0.1071630535151673, 0.1203156725712985, 0.11984530657403325, 0.11747123262071923, 0.09812208369943642, 0.12245014374148089, 0.11057733542366877, 0.2601813882744033, 0.26016601643901793, 0.2601786226371633, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.12821954655013268, 0.13716321690826827, 0.13255337194618855, 0.13963129667695395, 0.13540357832789718, 0.14084817961805252, 0.12383205620739679, 0.13526331024062344, 0.16005469550930485, 0.12760741005012766, 0.1608043855280008, 0.1582429603948523, 0.15137550649944465, 0.1353860294342618, 0.12059230836089974, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013945494570657, 0.13406252454194778, 0.13363799679350685, 0.11958313344491767, 0.11996033272833961, 0.13675049794254157, 0.15868485304836355, 0.15649285239177557, 0.10919045241018943, 0.17072734671065426, 0.18298662223703388, 0.18519976647975844, 0.18259150655041378, 0.2095867472928581, 0.20966156144958992, 0.1766079398057453, 0.1732666504430761, 0.20002145927501347, 0.05289953130640801, 0.10910671837840769, 0.06373250652646745, 0.05895802407947737, 0.06069417504582275, 0.052043981605300216, 0.07281469896024884, 0.06371327234900925, 0.06255519730698467]}, "mutation_prompt": null}
{"id": "93b3e2b5-ce8c-4922-92c6-62c9128e8968", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.92  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_of_exploration = 0.3  # probability of exploration in Harmony Search\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.probability_of_exploration:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search, Quantum-Inspired Particle Swarm Optimization, Artificial Bee Colony Optimization, and Adaptive Differential Evolution with Dynamically Adjusted Exploration Rate, Neighborhood Size, and Probability of Exploration, refined by adjusting the probability of exploration in Harmony Search to 0.3 and the exploration rate adjustment rate to 0.92.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "919f92ff-0903-4853-bbde-7ea35688871f", "metadata": {"aucs": [0.16791463472217605, 0.17303456140539053, 0.15751406432259996, 0.15402651240797094, 0.16485414420748767, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03097175095894089, 0.04229676289419204, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015461003664911765, 0.030527650940410433, 0.01969646754387211, 0.033153130081172266, 0.04462538477247513, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9868363961698443, 0.9932423229580043, 0.9967507256918613, 0.9906119211312752, 0.9850981882542482, 0.9999001200375565, 0.9984356409844637, 0.988199287780604, 0.9651477713573191, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15992888980280417, 0.19115953589611245, 0.15456498203766134, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08637246507304841, 0.10897624575995402, 0.11275589901584737, 0.14714604513893625, 0.1119824890054737, 0.10329312357011478, 0.11299922382094196, 0.11734569778248882, 0.09417485131860359, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831658361763817, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.1887370728543144, 0.19352871068065391, 0.16887764079650736, 0.18786755675501787, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03774444209317751, 0.03152262647728599, 0.04231214916752091, 0.13568153332214972, 0.1194993123551269, 0.11795695037128207, 0.13871562955069006, 0.13721084259603444, 0.10980446992278814, 0.1457760375692273, 0.14069261272339006, 0.11891066490337965, 0.1610745641389092, 0.14937621116201716, 0.1668244536637674, 0.16908774946579108, 0.1675139234496843, 0.1638625886356505, 0.15127901597955062, 0.17357244887918022, 0.1408942418583361, 0.0999016709424837, 0.08926282734017021, 0.1071630535151673, 0.1203156725712985, 0.11984530657403325, 0.11747123262071923, 0.09812208369943642, 0.12245014374148089, 0.11057733542366877, 0.2601813882744033, 0.26016601643901793, 0.2601786226371633, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.12821954655013268, 0.13716321690826827, 0.13255337194618855, 0.13963129667695395, 0.13540357832789718, 0.14084817961805252, 0.12383205620739679, 0.13526331024062344, 0.16005469550930485, 0.12760741005012766, 0.1608043855280008, 0.1582429603948523, 0.15137550649944465, 0.1353860294342618, 0.12059230836089974, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013945494570657, 0.13406252454194778, 0.13363799679350685, 0.11958313344491767, 0.11996033272833961, 0.13675049794254157, 0.15868485304836355, 0.15649285239177557, 0.10919045241018943, 0.17072734671065426, 0.18298662223703388, 0.18519976647975844, 0.18259150655041378, 0.2095867472928581, 0.20966156144958992, 0.1766079398057453, 0.1732666504430761, 0.20002145927501347, 0.05289953130640801, 0.10910671837840769, 0.06373250652646745, 0.05895802407947737, 0.06069417504582275, 0.052043981605300216, 0.07281469896024884, 0.06371327234900925, 0.06255519730698467]}, "mutation_prompt": null}
{"id": "0f06c606-8ce3-4e21-8872-fa243c787389", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.92  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_of_exploration = 0.7  # probability of exploration in Harmony Search\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.probability_of_exploration:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search, Quantum-Inspired Particle Swarm Optimization, Artificial Bee Colony Optimization, and Adaptive Differential Evolution with Dynamically Adjusted Exploration Rate, Neighborhood Size, and Probability of Exploration, refined by adjusting the probability of exploration in Harmony Search to 0.7 and the exploration rate adjustment rate to 0.95.", "configspace": "", "generation": 81, "fitness": 0.12868385631541088, "feedback": "The algorithm AHQBACO_DN2_DE2_REFINED_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "919f92ff-0903-4853-bbde-7ea35688871f", "metadata": {"aucs": [0.16783230186414622, 0.17286937752522313, 0.157826395425273, 0.15404605366386603, 0.16485761402461452, 0.15895744989843097, 0.16270708318851046, 0.13944035079784867, 0.14875543656335266, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03135287374124596, 0.04229920659856412, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02498701875837106, 0.019480065261915258, 0.030734235189924797, 0.01969646754387211, 0.033153130081172266, 0.04443883784560787, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9830818730334692, 0.9932167240644891, 0.9967507256918613, 0.9395830456128689, 0.9850081882542482, 0.950976878948301, 0.9984356409844637, 0.988194227613436, 0.9648001775691007, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16133770662730695, 0.19205520532700826, 0.15709921857435816, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08335536118150011, 0.1258326455977674, 0.10130927377412169, 0.14876590781501986, 0.11190169214133927, 0.1116077384712082, 0.11212914473314195, 0.1093027207704117, 0.10153214644166964, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.033198415640640855, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20661818808493548, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.18873430734613306, 0.1949068570933109, 0.17195803172542068, 0.18731231835267415, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03152262647728599, 0.04231214916752091, 0.13544999293141302, 0.11570965175231873, 0.1403075403980727, 0.1387225781051249, 0.1372262786133278, 0.10997898183062449, 0.14685190152952476, 0.14119007178474274, 0.11979629261751323, 0.1610745641389092, 0.14937621116201716, 0.16684772814827575, 0.1675290769832416, 0.16550989015009876, 0.1689897440379593, 0.15127901597955062, 0.17355384695910447, 0.14094974471496513, 0.09990585299789723, 0.08916653956467746, 0.1071630535151673, 0.11899339423505007, 0.1199015230405821, 0.1202179003413919, 0.09812208369943642, 0.1224537527043591, 0.11059392574141602, 0.2601813882744033, 0.26016601643901793, 0.2601786226371633, 0.26018132180600584, 0.26017734341597376, 0.2601769605582607, 0.2601875539181707, 0.2601678946548399, 0.26017816934690785, 0.14076595050500396, 0.13614477447544615, 0.14977569096645127, 0.12633773669989745, 0.14542731497403238, 0.14084817961805252, 0.12383205620739679, 0.12791972836821264, 0.16005469550930485, 0.12999661918880046, 0.16111021637023348, 0.15820807031516504, 0.1513356545171608, 0.1353860294342618, 0.1206017820247891, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013870492952119, 0.13406252454194778, 0.13363631093164408, 0.11960232997649911, 0.11994081450357896, 0.13675049794254157, 0.15834517139785698, 0.15820905269873653, 0.10980097721265791, 0.16956828477229502, 0.1854964212639495, 0.1846774426752329, 0.18656759579138893, 0.20939390573284133, 0.21190553026167147, 0.17656347904295566, 0.17380704617223985, 0.20268042657962027, 0.05349547011943645, 0.06639893964004495, 0.06373007248492746, 0.0599454391468105, 0.06069417504582275, 0.05193457209171304, 0.07289275853335497, 0.06037727546917582, 0.055471469186195055]}, "mutation_prompt": null}
{"id": "9c918b02-cf4f-4b59-8cce-d06e4c1fbbef", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.92  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_of_exploration = 0.3  # probability of exploration in Harmony Search\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.probability_of_exploration:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search, Quantum-Inspired Particle Swarm Optimization, Artificial Bee Colony Optimization, and Adaptive Differential Evolution with Dynamically Adjusted Exploration Rate, Neighborhood Size, and Probability of Exploration, refined by adjusting the probability of exploration in Harmony Search to 0.3 and the exploration rate adjustment rate to 0.92.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "919f92ff-0903-4853-bbde-7ea35688871f", "metadata": {"aucs": [0.16791463472217605, 0.17303456140539053, 0.15751406432259996, 0.15402651240797094, 0.16485414420748767, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03097175095894089, 0.04229676289419204, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015461003664911765, 0.030527650940410433, 0.01969646754387211, 0.033153130081172266, 0.04462538477247513, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9868363961698443, 0.9932423229580043, 0.9967507256918613, 0.9906119211312752, 0.9850981882542482, 0.9999001200375565, 0.9984356409844637, 0.988199287780604, 0.9651477713573191, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15992888980280417, 0.19115953589611245, 0.15456498203766134, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08637246507304841, 0.10897624575995402, 0.11275589901584737, 0.14714604513893625, 0.1119824890054737, 0.10329312357011478, 0.11299922382094196, 0.11734569778248882, 0.09417485131860359, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831658361763817, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.1887370728543144, 0.19352871068065391, 0.16887764079650736, 0.18786755675501787, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03774444209317751, 0.03152262647728599, 0.04231214916752091, 0.13568153332214972, 0.1194993123551269, 0.11795695037128207, 0.13871562955069006, 0.13721084259603444, 0.10980446992278814, 0.1457760375692273, 0.14069261272339006, 0.11891066490337965, 0.1610745641389092, 0.14937621116201716, 0.1668244536637674, 0.16908774946579108, 0.1675139234496843, 0.1638625886356505, 0.15127901597955062, 0.17357244887918022, 0.1408942418583361, 0.0999016709424837, 0.08926282734017021, 0.1071630535151673, 0.1203156725712985, 0.11984530657403325, 0.11747123262071923, 0.09812208369943642, 0.12245014374148089, 0.11057733542366877, 0.2601813882744033, 0.26016601643901793, 0.2601786226371633, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.12821954655013268, 0.13716321690826827, 0.13255337194618855, 0.13963129667695395, 0.13540357832789718, 0.14084817961805252, 0.12383205620739679, 0.13526331024062344, 0.16005469550930485, 0.12760741005012766, 0.1608043855280008, 0.1582429603948523, 0.15137550649944465, 0.1353860294342618, 0.12059230836089974, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013945494570657, 0.13406252454194778, 0.13363799679350685, 0.11958313344491767, 0.11996033272833961, 0.13675049794254157, 0.15868485304836355, 0.15649285239177557, 0.10919045241018943, 0.17072734671065426, 0.18298662223703388, 0.18519976647975844, 0.18259150655041378, 0.2095867472928581, 0.20966156144958992, 0.1766079398057453, 0.1732666504430761, 0.20002145927501347, 0.05289953130640801, 0.10910671837840769, 0.06373250652646745, 0.05895802407947737, 0.06069417504582275, 0.052043981605300216, 0.07281469896024884, 0.06371327234900925, 0.06255519730698467]}, "mutation_prompt": null}
{"id": "4737c8ce-a0bd-46bd-b05b-7102b8d426e2", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.92  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_of_exploration = 0.3  # probability of exploration in Harmony Search\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.probability_of_exploration:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search, Quantum-Inspired Particle Swarm Optimization, Artificial Bee Colony Optimization, and Adaptive Differential Evolution with Dynamically Adjusted Exploration Rate, Neighborhood Size, and Probability of Exploration, refined by adjusting the probability of exploration in Harmony Search to 0.3 and the exploration rate adjustment rate to 0.92.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "919f92ff-0903-4853-bbde-7ea35688871f", "metadata": {"aucs": [0.16791463472217605, 0.17303456140539053, 0.15751406432259996, 0.15402651240797094, 0.16485414420748767, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03097175095894089, 0.04229676289419204, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015461003664911765, 0.030527650940410433, 0.01969646754387211, 0.033153130081172266, 0.04462538477247513, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9868363961698443, 0.9932423229580043, 0.9967507256918613, 0.9906119211312752, 0.9850981882542482, 0.9999001200375565, 0.9984356409844637, 0.988199287780604, 0.9651477713573191, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15992888980280417, 0.19115953589611245, 0.15456498203766134, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08637246507304841, 0.10897624575995402, 0.11275589901584737, 0.14714604513893625, 0.1119824890054737, 0.10329312357011478, 0.11299922382094196, 0.11734569778248882, 0.09417485131860359, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831658361763817, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.1887370728543144, 0.19352871068065391, 0.16887764079650736, 0.18786755675501787, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03774444209317751, 0.03152262647728599, 0.04231214916752091, 0.13568153332214972, 0.1194993123551269, 0.11795695037128207, 0.13871562955069006, 0.13721084259603444, 0.10980446992278814, 0.1457760375692273, 0.14069261272339006, 0.11891066490337965, 0.1610745641389092, 0.14937621116201716, 0.1668244536637674, 0.16908774946579108, 0.1675139234496843, 0.1638625886356505, 0.15127901597955062, 0.17357244887918022, 0.1408942418583361, 0.0999016709424837, 0.08926282734017021, 0.1071630535151673, 0.1203156725712985, 0.11984530657403325, 0.11747123262071923, 0.09812208369943642, 0.12245014374148089, 0.11057733542366877, 0.2601813882744033, 0.26016601643901793, 0.2601786226371633, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.12821954655013268, 0.13716321690826827, 0.13255337194618855, 0.13963129667695395, 0.13540357832789718, 0.14084817961805252, 0.12383205620739679, 0.13526331024062344, 0.16005469550930485, 0.12760741005012766, 0.1608043855280008, 0.1582429603948523, 0.15137550649944465, 0.1353860294342618, 0.12059230836089974, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013945494570657, 0.13406252454194778, 0.13363799679350685, 0.11958313344491767, 0.11996033272833961, 0.13675049794254157, 0.15868485304836355, 0.15649285239177557, 0.10919045241018943, 0.17072734671065426, 0.18298662223703388, 0.18519976647975844, 0.18259150655041378, 0.2095867472928581, 0.20966156144958992, 0.1766079398057453, 0.1732666504430761, 0.20002145927501347, 0.05289953130640801, 0.10910671837840769, 0.06373250652646745, 0.05895802407947737, 0.06069417504582275, 0.052043981605300216, 0.07281469896024884, 0.06371327234900925, 0.06255519730698467]}, "mutation_prompt": null}
{"id": "cb041e53-90ec-4647-a277-140d63642f49", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.92  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_of_exploration = 0.3  # probability of exploration in Harmony Search\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.probability_of_exploration:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search, Quantum-Inspired Particle Swarm Optimization, Artificial Bee Colony Optimization, and Adaptive Differential Evolution with Dynamically Adjusted Exploration Rate, Neighborhood Size, and Probability of Exploration, refined by adjusting the probability of exploration in Harmony Search to 0.3 and the exploration rate adjustment rate to 0.92.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "919f92ff-0903-4853-bbde-7ea35688871f", "metadata": {"aucs": [0.16791463472217605, 0.17303456140539053, 0.15751406432259996, 0.15402651240797094, 0.16485414420748767, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03097175095894089, 0.04229676289419204, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015461003664911765, 0.030527650940410433, 0.01969646754387211, 0.033153130081172266, 0.04462538477247513, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9868363961698443, 0.9932423229580043, 0.9967507256918613, 0.9906119211312752, 0.9850981882542482, 0.9999001200375565, 0.9984356409844637, 0.988199287780604, 0.9651477713573191, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15992888980280417, 0.19115953589611245, 0.15456498203766134, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08637246507304841, 0.10897624575995402, 0.11275589901584737, 0.14714604513893625, 0.1119824890054737, 0.10329312357011478, 0.11299922382094196, 0.11734569778248882, 0.09417485131860359, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831658361763817, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.1887370728543144, 0.19352871068065391, 0.16887764079650736, 0.18786755675501787, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03774444209317751, 0.03152262647728599, 0.04231214916752091, 0.13568153332214972, 0.1194993123551269, 0.11795695037128207, 0.13871562955069006, 0.13721084259603444, 0.10980446992278814, 0.1457760375692273, 0.14069261272339006, 0.11891066490337965, 0.1610745641389092, 0.14937621116201716, 0.1668244536637674, 0.16908774946579108, 0.1675139234496843, 0.1638625886356505, 0.15127901597955062, 0.17357244887918022, 0.1408942418583361, 0.0999016709424837, 0.08926282734017021, 0.1071630535151673, 0.1203156725712985, 0.11984530657403325, 0.11747123262071923, 0.09812208369943642, 0.12245014374148089, 0.11057733542366877, 0.2601813882744033, 0.26016601643901793, 0.2601786226371633, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.12821954655013268, 0.13716321690826827, 0.13255337194618855, 0.13963129667695395, 0.13540357832789718, 0.14084817961805252, 0.12383205620739679, 0.13526331024062344, 0.16005469550930485, 0.12760741005012766, 0.1608043855280008, 0.1582429603948523, 0.15137550649944465, 0.1353860294342618, 0.12059230836089974, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013945494570657, 0.13406252454194778, 0.13363799679350685, 0.11958313344491767, 0.11996033272833961, 0.13675049794254157, 0.15868485304836355, 0.15649285239177557, 0.10919045241018943, 0.17072734671065426, 0.18298662223703388, 0.18519976647975844, 0.18259150655041378, 0.2095867472928581, 0.20966156144958992, 0.1766079398057453, 0.1732666504430761, 0.20002145927501347, 0.05289953130640801, 0.10910671837840769, 0.06373250652646745, 0.05895802407947737, 0.06069417504582275, 0.052043981605300216, 0.07281469896024884, 0.06371327234900925, 0.06255519730698467]}, "mutation_prompt": null}
{"id": "699c47cb-b322-4d8b-ad53-4f80ddf20a31", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED_ADAPTIVE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.92  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_of_exploration = 0.3  # probability of exploration in Harmony Search\n        self.convergence_count = 0\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.probability_of_exploration:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            # Adaptive probability of exploration\n            if np.mean(convergence) < self.convergence_threshold:\n                self.convergence_count += 1\n                if self.convergence_count > 10:\n                    self.probability_of_exploration = max(0.1, self.probability_of_exploration * 0.8)\n                    self.convergence_count = 0\n            else:\n                self.convergence_count = 0\n                self.probability_of_exploration = min(0.9, self.probability_of_exploration * 1.1)\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined_adaptive = AHQBACO_DN2_DE2_REFINED_REFINED_ADAPTIVE(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined_adaptive(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED_ADAPTIVE", "description": "Novel hybridization of Adaptive Harmony Search, Quantum-Inspired Particle Swarm Optimization, Artificial Bee Colony Optimization, and Adaptive Differential Evolution with Dynamically Adjusted Exploration Rate, Neighborhood Size, and Probability of Exploration, refined by adjusting the probability of exploration in Harmony Search to 0.3 and the exploration rate adjustment rate to 0.92, and incorporating a new adaptive mechanism to dynamically adjust the probability of exploration based on the convergence of the algorithm.", "configspace": "", "generation": 85, "fitness": 0.12894656746903277, "feedback": "The algorithm AHQBACO_DN2_DE2_REFINED_REFINED_ADAPTIVE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "919f92ff-0903-4853-bbde-7ea35688871f", "metadata": {"aucs": [0.16791744477381731, 0.17303682823851851, 0.15947094725455868, 0.15402773714963935, 0.16485277201301995, 0.15897100690557542, 0.1627064242821089, 0.13944035079784867, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03143133387113628, 0.04229920659856412, 0.028726245370913395, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024930535702026968, 0.019471753927483904, 0.030434921026740946, 0.01969646754387211, 0.033153130081172266, 0.044467510574209834, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9830801654576415, 0.9932167240644891, 0.9722314713670062, 0.9903291137031196, 0.9790336378947746, 0.9999001200375565, 0.9984356409844637, 0.9882286573759829, 0.9651477713573191, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.1598868545407124, 0.19189047885299138, 0.16068382576428608, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08735802407539162, 0.11014199305547534, 0.11275589901584737, 0.14750581183579603, 0.1119824890054737, 0.10423040205172296, 0.11243074472142056, 0.10319735080676351, 0.1030295861565792, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831543164293143, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20661818808493548, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18876344404115986, 0.1950415576480593, 0.16985922357459182, 0.1878262887808022, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.0377556675645081, 0.03152262647728599, 0.04231214916752091, 0.13568153332214972, 0.11900129578683571, 0.1403075403980727, 0.1387220562751541, 0.1372262786133278, 0.1097355930509093, 0.14679587168067576, 0.14146874559029698, 0.12081206473225303, 0.1610745641389092, 0.14938782888659952, 0.16682571278855396, 0.16853517392608408, 0.1670573327741024, 0.1651094732058953, 0.15127901597955062, 0.17359018863582443, 0.1408942418583361, 0.0999016709424837, 0.08928111045160281, 0.1071630535151673, 0.12114972598668117, 0.12308809222014605, 0.12056795862035141, 0.09812208369943642, 0.12245678839991947, 0.11049263350195415, 0.26018223221605774, 0.2601763462457861, 0.26017666954069796, 0.26018132180600584, 0.2601665068806729, 0.2601769605582607, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.12107421755248937, 0.13614477447544615, 0.13255337194618855, 0.1367342965194973, 0.1460492704677927, 0.140143161101136, 0.1166921807739465, 0.12854224622931976, 0.15890532503478294, 0.1291287068127156, 0.16111021637023348, 0.15824238510490796, 0.1513356545171608, 0.13538153959863353, 0.12073465125907801, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.1400986269807849, 0.13406252454194778, 0.13349139406597965, 0.11961705079305107, 0.11996197588588142, 0.13675049794254157, 0.15880913060449076, 0.1582601435575891, 0.10958405126677095, 0.1694185418786639, 0.1854964212639495, 0.16822191262871944, 0.18259150655041378, 0.2095867472928581, 0.21455027575041663, 0.17326691957471363, 0.176246580370246, 0.20018122492980384, 0.05189898647952995, 0.10905933953581248, 0.06369771261933688, 0.059868513861656925, 0.06099869662024471, 0.05311770109428271, 0.07290093633919859, 0.05661880729720192, 0.060283898760524424]}, "mutation_prompt": null}
{"id": "cd94ce99-e23a-46bd-b06f-0dec6c7e4013", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.85  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_of_exploration = 0.7  # probability of exploration in Harmony Search\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.probability_of_exploration:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "A novel metaheuristic algorithm that combines Adaptive Harmony Search, Quantum-Inspired Particle Swarm Optimization, Artificial Bee Colony Optimization, and Adaptive Differential Evolution with Dynamically Adjusted Exploration Rate, Neighborhood Size, and Probability of Exploration, and refines the selected solution by adjusting the probability of exploration in Harmony Search to 0.7 and the exploration rate adjustment rate to 0.85.", "configspace": "", "generation": 86, "fitness": 0.12831438461889408, "feedback": "The algorithm AHQBACO_DN2_DE2_REFINED_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "919f92ff-0903-4853-bbde-7ea35688871f", "metadata": {"aucs": [0.16791463472217605, 0.17303084734230656, 0.15765993409453072, 0.1540328077434373, 0.16485414420748767, 0.15897100690557542, 0.1627049578055918, 0.1394327624586822, 0.14875543656335266, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03134638260856604, 0.042299821549620864, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024930535702026968, 0.016387750030765758, 0.03032117354057351, 0.01969646754387211, 0.033153130081172266, 0.04442032952410169, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9795701654576415, 0.9932167240644891, 0.9814721933730214, 0.9754919211312751, 0.9140102357932971, 0.9926544310576021, 0.9984358291545808, 0.9637688980446547, 0.9637201775691008, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16422260403501365, 0.19189047885299138, 0.15685038253676797, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.07961762107736925, 0.11058804795451704, 0.09918811242132108, 0.10365746049893931, 0.11186585009370098, 0.09676672188984214, 0.09939508995252722, 0.10927776727902128, 0.08971920995909399, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20661818808493548, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.1774167541950743, 0.1887606785329785, 0.1952465446966145, 0.17638713725373223, 0.18782037030340626, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03152262647728599, 0.04231214916752091, 0.13577660398027658, 0.1194993123551269, 0.1403075403980727, 0.1387225781051249, 0.1372262786133278, 0.10991010495874565, 0.14592941293989847, 0.1411203160788156, 0.11977544415337904, 0.1610745641389092, 0.14938111688522804, 0.16684734563472814, 0.17519091513369733, 0.16548974416406725, 0.16807707638410452, 0.15127901597955062, 0.17357977785564216, 0.14089222316529626, 0.0999016709424837, 0.08928782259693491, 0.1071630535151673, 0.12010244012501592, 0.12309604537464836, 0.11933210961350882, 0.09812208369943642, 0.12246601612611141, 0.1105305319269635, 0.26018223221605774, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.26017734341597376, 0.26262195714911796, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.12481322358383473, 0.13800289038965985, 0.14977569096645127, 0.13979322800927452, 0.13674735806830374, 0.140143161101136, 0.11428853139533368, 0.13526331024062344, 0.16012466570397244, 0.12668863547257792, 0.16110839220738193, 0.15810353169668634, 0.15137819013263176, 0.13538153959863353, 0.12051781968187736, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013945494570657, 0.13407049192775466, 0.13363688966420528, 0.11960232997649911, 0.11994081450357896, 0.13675049794254157, 0.15847568669094436, 0.15557980254980464, 0.10906615017501575, 0.16981878455408528, 0.1854964212639495, 0.1852003347418455, 0.18223665834163416, 0.2097235550088813, 0.21484386159387414, 0.1765720820505059, 0.17628897488001782, 0.20005730473429095, 0.050773335997726265, 0.1090045000338945, 0.0635003377739527, 0.0582476741497614, 0.060916070357223906, 0.05238390548970073, 0.07284102124127889, 0.06270873751980321, 0.06433929143344119]}, "mutation_prompt": null}
{"id": "f0222fe3-ccd4-40f5-8402-717e3e34c0e7", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.92  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_of_exploration = 0.3  # probability of exploration in Harmony Search\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.probability_of_exploration:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search, Quantum-Inspired Particle Swarm Optimization, Artificial Bee Colony Optimization, and Adaptive Differential Evolution with Dynamically Adjusted Exploration Rate, Neighborhood Size, and Probability of Exploration, refined by adjusting the probability of exploration in Harmony Search to 0.3 and the exploration rate adjustment rate to 0.92.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "919f92ff-0903-4853-bbde-7ea35688871f", "metadata": {"aucs": [0.16791463472217605, 0.17303456140539053, 0.15751406432259996, 0.15402651240797094, 0.16485414420748767, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03097175095894089, 0.04229676289419204, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015461003664911765, 0.030527650940410433, 0.01969646754387211, 0.033153130081172266, 0.04462538477247513, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9868363961698443, 0.9932423229580043, 0.9967507256918613, 0.9906119211312752, 0.9850981882542482, 0.9999001200375565, 0.9984356409844637, 0.988199287780604, 0.9651477713573191, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15992888980280417, 0.19115953589611245, 0.15456498203766134, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08637246507304841, 0.10897624575995402, 0.11275589901584737, 0.14714604513893625, 0.1119824890054737, 0.10329312357011478, 0.11299922382094196, 0.11734569778248882, 0.09417485131860359, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831658361763817, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.1887370728543144, 0.19352871068065391, 0.16887764079650736, 0.18786755675501787, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03774444209317751, 0.03152262647728599, 0.04231214916752091, 0.13568153332214972, 0.1194993123551269, 0.11795695037128207, 0.13871562955069006, 0.13721084259603444, 0.10980446992278814, 0.1457760375692273, 0.14069261272339006, 0.11891066490337965, 0.1610745641389092, 0.14937621116201716, 0.1668244536637674, 0.16908774946579108, 0.1675139234496843, 0.1638625886356505, 0.15127901597955062, 0.17357244887918022, 0.1408942418583361, 0.0999016709424837, 0.08926282734017021, 0.1071630535151673, 0.1203156725712985, 0.11984530657403325, 0.11747123262071923, 0.09812208369943642, 0.12245014374148089, 0.11057733542366877, 0.2601813882744033, 0.26016601643901793, 0.2601786226371633, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.12821954655013268, 0.13716321690826827, 0.13255337194618855, 0.13963129667695395, 0.13540357832789718, 0.14084817961805252, 0.12383205620739679, 0.13526331024062344, 0.16005469550930485, 0.12760741005012766, 0.1608043855280008, 0.1582429603948523, 0.15137550649944465, 0.1353860294342618, 0.12059230836089974, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013945494570657, 0.13406252454194778, 0.13363799679350685, 0.11958313344491767, 0.11996033272833961, 0.13675049794254157, 0.15868485304836355, 0.15649285239177557, 0.10919045241018943, 0.17072734671065426, 0.18298662223703388, 0.18519976647975844, 0.18259150655041378, 0.2095867472928581, 0.20966156144958992, 0.1766079398057453, 0.1732666504430761, 0.20002145927501347, 0.05289953130640801, 0.10910671837840769, 0.06373250652646745, 0.05895802407947737, 0.06069417504582275, 0.052043981605300216, 0.07281469896024884, 0.06371327234900925, 0.06255519730698467]}, "mutation_prompt": null}
{"id": "ca374fc0-41c0-4435-a4ce-3c966712f749", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.95  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_of_exploration = 0.2  # probability of exploration in Harmony Search\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.probability_of_exploration:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search, Quantum-Inspired Particle Swarm Optimization, Artificial Bee Colony Optimization, and Adaptive Differential Evolution with Dynamically Adjusted Exploration Rate, Neighborhood Size, and Probability of Exploration, refined by adjusting the probability of exploration in Harmony Search to 0.2 and the exploration rate adjustment rate to 0.95.", "configspace": "", "generation": 88, "fitness": 0.1287998564092183, "feedback": "The algorithm AHQBACO_DN2_DE2_REFINED_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "919f92ff-0903-4853-bbde-7ea35688871f", "metadata": {"aucs": [0.16773675172533586, 0.17280254249240556, 0.15942227456237068, 0.15403095327174998, 0.16485277201301995, 0.15895779236722718, 0.1627049578055918, 0.13944035079784867, 0.14875543656335266, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03088794223259428, 0.042299821549620864, 0.028726245370913395, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.022831627381431074, 0.019354629695872982, 0.030439780828330876, 0.01969646754387211, 0.033153130081172266, 0.044467510574209834, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9868346885940167, 0.993262163558376, 0.9967314833102295, 0.9901539325198666, 0.9791806882542481, 0.9972648919717684, 0.9939409053952426, 0.988199287780604, 0.9648001775691007, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.031375444761688076, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16338530511301175, 0.19205520532700826, 0.16018883838255427, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08701945904975783, 0.10897624575995402, 0.10413916044007276, 0.09157168790313919, 0.07969081742578343, 0.10995964086157206, 0.11212914473314195, 0.10816009003352978, 0.10170230447611506, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.03319853083811142, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18876344404115986, 0.1950976718094286, 0.1693019685317786, 0.1878433459676635, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03771420465876418, 0.03149234042422633, 0.04231214916752091, 0.13568153332214972, 0.11880725084767219, 0.1403075403980727, 0.1387262254078152, 0.13721084259603444, 0.10980446992278814, 0.14597975363062, 0.14069324164221286, 0.11991561629572678, 0.1610745641389092, 0.14937621116201716, 0.16684734563472814, 0.17531278234374892, 0.1675755249851112, 0.1682672178705279, 0.15127901597955062, 0.17357977785564216, 0.14092457236597455, 0.09990408127128181, 0.0892556954122018, 0.10716775680921653, 0.11800305246523168, 0.1235130033332027, 0.12040123266543656, 0.09812208369943642, 0.12246601612611141, 0.11059326643358969, 0.2601813882744033, 0.2601763462457861, 0.2601786226371633, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2733117796270077, 0.2601678946548399, 0.26017816934690785, 0.13427826654680952, 0.13614994584965479, 0.13255337194618855, 0.13963129667695395, 0.14581821788308957, 0.14085960050253765, 0.1188165136071706, 0.12854224622931976, 0.15890532503478294, 0.1291353452534364, 0.16071455458498463, 0.1582109416108034, 0.15135986039941796, 0.1353860294342618, 0.12071452012559936, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013973170546046, 0.13406252454194778, 0.1336387739971271, 0.11959952352508518, 0.11993691894326708, 0.13675049794254157, 0.15881153565352435, 0.15621437608207567, 0.10988046452472044, 0.1655721820533056, 0.18304729910324014, 0.18467801093731995, 0.18181053433728822, 0.20747477870176545, 0.2118724403767378, 0.17350232357978546, 0.17400405319501422, 0.20015743664695884, 0.052910657715781184, 0.10905280314177068, 0.06362498022398266, 0.05142005792740734, 0.06057184768843127, 0.05190259471354197, 0.07281496953663968, 0.06268810074057107, 0.06264583797303713]}, "mutation_prompt": null}
{"id": "c6348694-6500-41ec-8411-340ad44a78c0", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.92  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_of_exploration = 0.3  # probability of exploration in Harmony Search\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.probability_of_exploration:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search, Quantum-Inspired Particle Swarm Optimization, Artificial Bee Colony Optimization, and Adaptive Differential Evolution with Dynamically Adjusted Exploration Rate, Neighborhood Size, and Probability of Exploration, refined by adjusting the probability of exploration in Harmony Search to 0.3 and the exploration rate adjustment rate to 0.92.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "919f92ff-0903-4853-bbde-7ea35688871f", "metadata": {"aucs": [0.16791463472217605, 0.17303456140539053, 0.15751406432259996, 0.15402651240797094, 0.16485414420748767, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03097175095894089, 0.04229676289419204, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015461003664911765, 0.030527650940410433, 0.01969646754387211, 0.033153130081172266, 0.04462538477247513, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9868363961698443, 0.9932423229580043, 0.9967507256918613, 0.9906119211312752, 0.9850981882542482, 0.9999001200375565, 0.9984356409844637, 0.988199287780604, 0.9651477713573191, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15992888980280417, 0.19115953589611245, 0.15456498203766134, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08637246507304841, 0.10897624575995402, 0.11275589901584737, 0.14714604513893625, 0.1119824890054737, 0.10329312357011478, 0.11299922382094196, 0.11734569778248882, 0.09417485131860359, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831658361763817, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.1887370728543144, 0.19352871068065391, 0.16887764079650736, 0.18786755675501787, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03774444209317751, 0.03152262647728599, 0.04231214916752091, 0.13568153332214972, 0.1194993123551269, 0.11795695037128207, 0.13871562955069006, 0.13721084259603444, 0.10980446992278814, 0.1457760375692273, 0.14069261272339006, 0.11891066490337965, 0.1610745641389092, 0.14937621116201716, 0.1668244536637674, 0.16908774946579108, 0.1675139234496843, 0.1638625886356505, 0.15127901597955062, 0.17357244887918022, 0.1408942418583361, 0.0999016709424837, 0.08926282734017021, 0.1071630535151673, 0.1203156725712985, 0.11984530657403325, 0.11747123262071923, 0.09812208369943642, 0.12245014374148089, 0.11057733542366877, 0.2601813882744033, 0.26016601643901793, 0.2601786226371633, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.12821954655013268, 0.13716321690826827, 0.13255337194618855, 0.13963129667695395, 0.13540357832789718, 0.14084817961805252, 0.12383205620739679, 0.13526331024062344, 0.16005469550930485, 0.12760741005012766, 0.1608043855280008, 0.1582429603948523, 0.15137550649944465, 0.1353860294342618, 0.12059230836089974, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013945494570657, 0.13406252454194778, 0.13363799679350685, 0.11958313344491767, 0.11996033272833961, 0.13675049794254157, 0.15868485304836355, 0.15649285239177557, 0.10919045241018943, 0.17072734671065426, 0.18298662223703388, 0.18519976647975844, 0.18259150655041378, 0.2095867472928581, 0.20966156144958992, 0.1766079398057453, 0.1732666504430761, 0.20002145927501347, 0.05289953130640801, 0.10910671837840769, 0.06373250652646745, 0.05895802407947737, 0.06069417504582275, 0.052043981605300216, 0.07281469896024884, 0.06371327234900925, 0.06255519730698467]}, "mutation_prompt": null}
{"id": "43d82c01-0a62-4281-bfb8-d4227eca70dc", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.92  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_of_exploration = 0.3  # probability of exploration in Harmony Search\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.probability_of_exploration:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search, Quantum-Inspired Particle Swarm Optimization, Artificial Bee Colony Optimization, and Adaptive Differential Evolution with Dynamically Adjusted Exploration Rate, Neighborhood Size, and Probability of Exploration, refined by adjusting the probability of exploration in Harmony Search to 0.3 and the exploration rate adjustment rate to 0.92.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "919f92ff-0903-4853-bbde-7ea35688871f", "metadata": {"aucs": [0.16791463472217605, 0.17303456140539053, 0.15751406432259996, 0.15402651240797094, 0.16485414420748767, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03097175095894089, 0.04229676289419204, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015461003664911765, 0.030527650940410433, 0.01969646754387211, 0.033153130081172266, 0.04462538477247513, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9868363961698443, 0.9932423229580043, 0.9967507256918613, 0.9906119211312752, 0.9850981882542482, 0.9999001200375565, 0.9984356409844637, 0.988199287780604, 0.9651477713573191, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15992888980280417, 0.19115953589611245, 0.15456498203766134, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08637246507304841, 0.10897624575995402, 0.11275589901584737, 0.14714604513893625, 0.1119824890054737, 0.10329312357011478, 0.11299922382094196, 0.11734569778248882, 0.09417485131860359, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831658361763817, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.1887370728543144, 0.19352871068065391, 0.16887764079650736, 0.18786755675501787, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03774444209317751, 0.03152262647728599, 0.04231214916752091, 0.13568153332214972, 0.1194993123551269, 0.11795695037128207, 0.13871562955069006, 0.13721084259603444, 0.10980446992278814, 0.1457760375692273, 0.14069261272339006, 0.11891066490337965, 0.1610745641389092, 0.14937621116201716, 0.1668244536637674, 0.16908774946579108, 0.1675139234496843, 0.1638625886356505, 0.15127901597955062, 0.17357244887918022, 0.1408942418583361, 0.0999016709424837, 0.08926282734017021, 0.1071630535151673, 0.1203156725712985, 0.11984530657403325, 0.11747123262071923, 0.09812208369943642, 0.12245014374148089, 0.11057733542366877, 0.2601813882744033, 0.26016601643901793, 0.2601786226371633, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.12821954655013268, 0.13716321690826827, 0.13255337194618855, 0.13963129667695395, 0.13540357832789718, 0.14084817961805252, 0.12383205620739679, 0.13526331024062344, 0.16005469550930485, 0.12760741005012766, 0.1608043855280008, 0.1582429603948523, 0.15137550649944465, 0.1353860294342618, 0.12059230836089974, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013945494570657, 0.13406252454194778, 0.13363799679350685, 0.11958313344491767, 0.11996033272833961, 0.13675049794254157, 0.15868485304836355, 0.15649285239177557, 0.10919045241018943, 0.17072734671065426, 0.18298662223703388, 0.18519976647975844, 0.18259150655041378, 0.2095867472928581, 0.20966156144958992, 0.1766079398057453, 0.1732666504430761, 0.20002145927501347, 0.05289953130640801, 0.10910671837840769, 0.06373250652646745, 0.05895802407947737, 0.06069417504582275, 0.052043981605300216, 0.07281469896024884, 0.06371327234900925, 0.06255519730698467]}, "mutation_prompt": null}
{"id": "915a0131-15a2-4dc0-98ce-02b47c68ec40", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.92  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_of_exploration = 0.4  # probability of exploration in Harmony Search\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.probability_of_exploration:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search, Quantum-Inspired Particle Swarm Optimization, Artificial Bee Colony Optimization, and Adaptive Differential Evolution with Dynamically Adjusted Exploration Rate, Neighborhood Size, and Probability of Exploration, refined by adjusting the probability of exploration in Harmony Search to 0.4 and the exploration rate adjustment rate to 0.93.", "configspace": "", "generation": 91, "fitness": 0.12872179404015635, "feedback": "The algorithm AHQBACO_DN2_DE2_REFINED_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "919f92ff-0903-4853-bbde-7ea35688871f", "metadata": {"aucs": [0.16779781178565756, 0.17303456140539053, 0.15750505957464322, 0.15402651240797094, 0.16485277201301995, 0.15898306837794374, 0.16270429889919014, 0.13944035079784867, 0.14875543656335266, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030771528873176246, 0.04229676289419204, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024995338660832367, 0.019334975875246685, 0.029627328870527547, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9369953587552984, 0.9689161988420018, 0.9967507256918613, 0.9903728206759358, 0.9790368004622302, 0.9999001200375565, 0.9984358291545808, 0.988199287780604, 0.9503727713573186, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.16334437461570217, 0.19205520532700826, 0.15912874652007925, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08676953325769732, 0.10976013725932299, 0.11275589901584737, 0.14483187560737643, 0.09408464218055324, 0.10500390652831793, 0.09640710602019642, 0.10628729436986106, 0.08971920995909399, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.033198415640640855, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.18871626737704628, 0.1950729320097664, 0.17168466038939023, 0.1878726978464088, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037737225736343305, 0.03152262647728599, 0.04231214916752091, 0.13578299041779696, 0.11924919107290044, 0.1403075403980727, 0.1387262254078152, 0.1372262786133278, 0.10991010495874565, 0.14572644534563262, 0.1406761467216433, 0.12025956746513, 0.1606950954948081, 0.149343332833774, 0.16682863340239906, 0.16903966467021803, 0.16549574363508923, 0.1661906505428673, 0.15127901597955062, 0.17357977785564216, 0.14098282474331114, 0.09990585299789723, 0.08910219350883197, 0.1071630535151673, 0.1199210537187193, 0.11887912890281982, 0.12153912291884228, 0.09812208369943642, 0.12245060681819309, 0.11056438674338531, 0.2601813882744033, 0.2601763462457861, 0.26017666954069796, 0.26018132180600584, 0.26017734341597376, 0.2601769605582607, 0.2733117796270077, 0.2601737466540327, 0.26017816934690785, 0.12422797827345822, 0.13800289038965985, 0.14977569096645127, 0.13950981028545995, 0.14600365779889524, 0.140143161101136, 0.12623570558600972, 0.12773466300142378, 0.15890532503478294, 0.12916429153470832, 0.16060208652480346, 0.15809829878022652, 0.15137879995535475, 0.13538153959863353, 0.12074591260792622, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.1400986269807849, 0.13406252454194778, 0.13349139406597965, 0.11959708222254117, 0.11993917134603727, 0.13675049794254157, 0.15847568669094436, 0.15558775627668398, 0.10980097721265791, 0.16962670954064252, 0.1854964212639495, 0.18519976647975844, 0.18746275845384797, 0.20527722614795307, 0.21509098342273114, 0.1809019512841601, 0.17373241873726442, 0.20002145927501347, 0.052571972160876945, 0.10901891445764522, 0.06375376366099517, 0.05829669062364651, 0.05797320256756755, 0.04990408959650394, 0.07022128820029905, 0.06270127460431774, 0.0636608336655401]}, "mutation_prompt": null}
{"id": "f167be76-16b8-4f77-b838-dfbea987b4fc", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.92  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_of_exploration = 0.3  # probability of exploration in Harmony Search\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.probability_of_exploration:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search, Quantum-Inspired Particle Swarm Optimization, Artificial Bee Colony Optimization, and Adaptive Differential Evolution with Dynamically Adjusted Exploration Rate, Neighborhood Size, and Probability of Exploration, refined by adjusting the probability of exploration in Harmony Search to 0.3 and the exploration rate adjustment rate to 0.92.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "919f92ff-0903-4853-bbde-7ea35688871f", "metadata": {"aucs": [0.16791463472217605, 0.17303456140539053, 0.15751406432259996, 0.15402651240797094, 0.16485414420748767, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03097175095894089, 0.04229676289419204, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015461003664911765, 0.030527650940410433, 0.01969646754387211, 0.033153130081172266, 0.04462538477247513, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9868363961698443, 0.9932423229580043, 0.9967507256918613, 0.9906119211312752, 0.9850981882542482, 0.9999001200375565, 0.9984356409844637, 0.988199287780604, 0.9651477713573191, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15992888980280417, 0.19115953589611245, 0.15456498203766134, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08637246507304841, 0.10897624575995402, 0.11275589901584737, 0.14714604513893625, 0.1119824890054737, 0.10329312357011478, 0.11299922382094196, 0.11734569778248882, 0.09417485131860359, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831658361763817, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.1887370728543144, 0.19352871068065391, 0.16887764079650736, 0.18786755675501787, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03774444209317751, 0.03152262647728599, 0.04231214916752091, 0.13568153332214972, 0.1194993123551269, 0.11795695037128207, 0.13871562955069006, 0.13721084259603444, 0.10980446992278814, 0.1457760375692273, 0.14069261272339006, 0.11891066490337965, 0.1610745641389092, 0.14937621116201716, 0.1668244536637674, 0.16908774946579108, 0.1675139234496843, 0.1638625886356505, 0.15127901597955062, 0.17357244887918022, 0.1408942418583361, 0.0999016709424837, 0.08926282734017021, 0.1071630535151673, 0.1203156725712985, 0.11984530657403325, 0.11747123262071923, 0.09812208369943642, 0.12245014374148089, 0.11057733542366877, 0.2601813882744033, 0.26016601643901793, 0.2601786226371633, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.12821954655013268, 0.13716321690826827, 0.13255337194618855, 0.13963129667695395, 0.13540357832789718, 0.14084817961805252, 0.12383205620739679, 0.13526331024062344, 0.16005469550930485, 0.12760741005012766, 0.1608043855280008, 0.1582429603948523, 0.15137550649944465, 0.1353860294342618, 0.12059230836089974, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013945494570657, 0.13406252454194778, 0.13363799679350685, 0.11958313344491767, 0.11996033272833961, 0.13675049794254157, 0.15868485304836355, 0.15649285239177557, 0.10919045241018943, 0.17072734671065426, 0.18298662223703388, 0.18519976647975844, 0.18259150655041378, 0.2095867472928581, 0.20966156144958992, 0.1766079398057453, 0.1732666504430761, 0.20002145927501347, 0.05289953130640801, 0.10910671837840769, 0.06373250652646745, 0.05895802407947737, 0.06069417504582275, 0.052043981605300216, 0.07281469896024884, 0.06371327234900925, 0.06255519730698467]}, "mutation_prompt": null}
{"id": "8f86d7d3-d29c-4a56-bb5e-0e5c63292590", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.92  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_of_exploration = 0.3  # probability of exploration in Harmony Search\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.probability_of_exploration:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search, Quantum-Inspired Particle Swarm Optimization, Artificial Bee Colony Optimization, and Adaptive Differential Evolution with Dynamically Adjusted Exploration Rate, Neighborhood Size, and Probability of Exploration, refined by adjusting the probability of exploration in Harmony Search to 0.3 and the exploration rate adjustment rate to 0.92.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "919f92ff-0903-4853-bbde-7ea35688871f", "metadata": {"aucs": [0.16791463472217605, 0.17303456140539053, 0.15751406432259996, 0.15402651240797094, 0.16485414420748767, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03097175095894089, 0.04229676289419204, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015461003664911765, 0.030527650940410433, 0.01969646754387211, 0.033153130081172266, 0.04462538477247513, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9868363961698443, 0.9932423229580043, 0.9967507256918613, 0.9906119211312752, 0.9850981882542482, 0.9999001200375565, 0.9984356409844637, 0.988199287780604, 0.9651477713573191, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15992888980280417, 0.19115953589611245, 0.15456498203766134, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08637246507304841, 0.10897624575995402, 0.11275589901584737, 0.14714604513893625, 0.1119824890054737, 0.10329312357011478, 0.11299922382094196, 0.11734569778248882, 0.09417485131860359, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831658361763817, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.1887370728543144, 0.19352871068065391, 0.16887764079650736, 0.18786755675501787, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03774444209317751, 0.03152262647728599, 0.04231214916752091, 0.13568153332214972, 0.1194993123551269, 0.11795695037128207, 0.13871562955069006, 0.13721084259603444, 0.10980446992278814, 0.1457760375692273, 0.14069261272339006, 0.11891066490337965, 0.1610745641389092, 0.14937621116201716, 0.1668244536637674, 0.16908774946579108, 0.1675139234496843, 0.1638625886356505, 0.15127901597955062, 0.17357244887918022, 0.1408942418583361, 0.0999016709424837, 0.08926282734017021, 0.1071630535151673, 0.1203156725712985, 0.11984530657403325, 0.11747123262071923, 0.09812208369943642, 0.12245014374148089, 0.11057733542366877, 0.2601813882744033, 0.26016601643901793, 0.2601786226371633, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.12821954655013268, 0.13716321690826827, 0.13255337194618855, 0.13963129667695395, 0.13540357832789718, 0.14084817961805252, 0.12383205620739679, 0.13526331024062344, 0.16005469550930485, 0.12760741005012766, 0.1608043855280008, 0.1582429603948523, 0.15137550649944465, 0.1353860294342618, 0.12059230836089974, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013945494570657, 0.13406252454194778, 0.13363799679350685, 0.11958313344491767, 0.11996033272833961, 0.13675049794254157, 0.15868485304836355, 0.15649285239177557, 0.10919045241018943, 0.17072734671065426, 0.18298662223703388, 0.18519976647975844, 0.18259150655041378, 0.2095867472928581, 0.20966156144958992, 0.1766079398057453, 0.1732666504430761, 0.20002145927501347, 0.05289953130640801, 0.10910671837840769, 0.06373250652646745, 0.05895802407947737, 0.06069417504582275, 0.052043981605300216, 0.07281469896024884, 0.06371327234900925, 0.06255519730698467]}, "mutation_prompt": null}
{"id": "abc84c1d-06b8-4e12-b40a-d802878a19f7", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.92  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < 0.3:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Differential Evolution\n            else:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search with Dynamically Adjusted Exploration Rate, Neighborhood Size, and Probability of Exploration, and Differential Evolution with Dynamically Adjusted Exploration Rate, Neighborhood Size, and Probability of Exploration.", "configspace": "", "generation": 94, "fitness": 0.08887820844070593, "feedback": "The algorithm AHQBACO_DN2_DE2_REFINED_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": "919f92ff-0903-4853-bbde-7ea35688871f", "metadata": {"aucs": [0.1714216388359786, 0.17896356217942888, 0.16554718239591204, 0.15482392537999934, 0.17330183264073462, 0.1662685768611365, 0.16737935966266393, 0.16125919200115169, 0.1723904165685315, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.041599742037987, 0.04376759169529432, 0.03761546032389396, 0.03632585431715307, 0.04241316767017467, 0.045674918339783876, 0.05135434222833335, 0.06088371469792475, 0.04903030934537833, 0.03698880374303537, 0.04502352714994873, 0.03502020273172424, 0.02045666887177744, 0.0414443072551578, 0.052493071716358086, 0.03466185199805172, 0.04208924138483838, 0.03613322118784523, 0.06899545012250963, 0.08219479368697469, 0.10564819641254164, 0.09007307460903324, 0.07964478337257419, 0.07933933623862177, 0.08197706399305882, 0.07459910829740524, 0.11633636488688537, 0.06788521945883019, 0.07043758594494887, 0.1019439188698672, 0.052863101832220094, 0.06361409479442615, 0.05650374773536404, 0.08958422953466505, 0.03880077963576822, 0.08910994654334115, 0.12102966165773998, 0.18797294705309364, 0.1414882216302673, 0.09826080607663557, 0.08637319163738577, 0.12356203769089447, 0.12694778210656565, 0.11504875808904269, 0.12922818176061956, 9.999999999998899e-05, 9.999999999998899e-05, 0.001052642205844112, 0.021049193819314915, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015477754195025173, 0.07672149903379866, 0.05449263046562103, 9.999999999998899e-05, 0.010497594893980722, 0.03346805603454994, 0.008512658151510588, 0.017508644518540728, 0.003952912970828559, 0.010676013242222893, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04837138957502107, 0.0651128867115136, 0.042596052812731044, 0.055605828808289015, 0.02282603430918373, 0.04876147414408227, 0.047144454109007916, 0.0321190146342184, 0.06865670748617925, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0027104488875283606, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007621044575245595, 9.999999999998899e-05, 0.21182960960501374, 0.19020677264995578, 0.1915884258749163, 0.2018530140084599, 0.1844705747434786, 0.19167267235108343, 0.1946667985871925, 0.19893636143182514, 0.18851682765451128, 0.02813157640537356, 0.03533016961818847, 0.048286360594268496, 0.03538888770884896, 0.03594882381697739, 0.041965896512968004, 0.0513414029974254, 0.05705400802429905, 0.04433738878222082, 0.1357242266319183, 0.1291799349363466, 0.12424110065291039, 0.13950004937468619, 0.13842986288577597, 0.11728931286287458, 0.14752714783376009, 0.14302528461733421, 0.137649765911403, 0.16302790187983596, 0.1950256431432138, 0.167359234908934, 0.16625087642110958, 0.16285073449595078, 0.17055836595483231, 0.1549818936772781, 0.173581231749648, 0.14700645435964632, 0.10352342677300475, 0.09668886693064782, 0.10913194833315065, 0.10846450579318101, 0.12290592936890676, 0.10654576066394073, 0.11511208375905935, 0.1283701818550841, 0.11555586915126437, 0.15260166336854564, 0.16322280975347836, 0.1591474138887079, 0.15499129108038212, 0.1418015293227749, 0.17990233339113726, 0.19088240545963453, 0.15173941787007916, 0.17728292396902112, 0.13784169600087148, 0.1429771245421978, 0.14558279948076802, 0.1414012012629271, 0.15133624160224113, 0.14501472843361352, 0.13385440613306765, 0.1371040998328522, 0.16028445160460847, 0.16179971180926134, 0.16318625654919616, 0.16268587125628187, 0.15406899628964943, 0.21599163466922755, 0.1291204265672966, 0.1829861030963631, 0.16847216416225053, 0.15453795046873897, 0.1477885560294402, 0.16502541202962473, 0.1440254884129788, 0.18188977059027367, 0.14311435973713527, 0.152259729850321, 0.15987194168374386, 0.1614648230812099, 0.16114288722262848, 0.17962233835100838, 0.1837180257030092, 0.17112346141663315, 0.18373778224736337, 0.20905324778123702, 0.1757589327397061, 0.18287196033872355, 0.18227028531519296, 0.20166305809442608, 0.052824277552253274, 0.05014200600761376, 0.06322940598324989, 0.051998717681539186, 0.058318952851902806, 0.05116199520191145, 0.07123626474967804, 0.05201547729528688, 0.05354298472851915]}, "mutation_prompt": null}
{"id": "cb3298f9-6970-4236-a02f-5438d77d87b5", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.92  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_of_exploration = 0.3  # probability of exploration in Harmony Search\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.probability_of_exploration:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search, Quantum-Inspired Particle Swarm Optimization, Artificial Bee Colony Optimization, and Adaptive Differential Evolution with Dynamically Adjusted Exploration Rate, Neighborhood Size, and Probability of Exploration, refined by adjusting the probability of exploration in Harmony Search to 0.3 and the exploration rate adjustment rate to 0.92.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "919f92ff-0903-4853-bbde-7ea35688871f", "metadata": {"aucs": [0.16791463472217605, 0.17303456140539053, 0.15751406432259996, 0.15402651240797094, 0.16485414420748767, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03097175095894089, 0.04229676289419204, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015461003664911765, 0.030527650940410433, 0.01969646754387211, 0.033153130081172266, 0.04462538477247513, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9868363961698443, 0.9932423229580043, 0.9967507256918613, 0.9906119211312752, 0.9850981882542482, 0.9999001200375565, 0.9984356409844637, 0.988199287780604, 0.9651477713573191, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15992888980280417, 0.19115953589611245, 0.15456498203766134, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08637246507304841, 0.10897624575995402, 0.11275589901584737, 0.14714604513893625, 0.1119824890054737, 0.10329312357011478, 0.11299922382094196, 0.11734569778248882, 0.09417485131860359, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831658361763817, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.1887370728543144, 0.19352871068065391, 0.16887764079650736, 0.18786755675501787, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03774444209317751, 0.03152262647728599, 0.04231214916752091, 0.13568153332214972, 0.1194993123551269, 0.11795695037128207, 0.13871562955069006, 0.13721084259603444, 0.10980446992278814, 0.1457760375692273, 0.14069261272339006, 0.11891066490337965, 0.1610745641389092, 0.14937621116201716, 0.1668244536637674, 0.16908774946579108, 0.1675139234496843, 0.1638625886356505, 0.15127901597955062, 0.17357244887918022, 0.1408942418583361, 0.0999016709424837, 0.08926282734017021, 0.1071630535151673, 0.1203156725712985, 0.11984530657403325, 0.11747123262071923, 0.09812208369943642, 0.12245014374148089, 0.11057733542366877, 0.2601813882744033, 0.26016601643901793, 0.2601786226371633, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.12821954655013268, 0.13716321690826827, 0.13255337194618855, 0.13963129667695395, 0.13540357832789718, 0.14084817961805252, 0.12383205620739679, 0.13526331024062344, 0.16005469550930485, 0.12760741005012766, 0.1608043855280008, 0.1582429603948523, 0.15137550649944465, 0.1353860294342618, 0.12059230836089974, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013945494570657, 0.13406252454194778, 0.13363799679350685, 0.11958313344491767, 0.11996033272833961, 0.13675049794254157, 0.15868485304836355, 0.15649285239177557, 0.10919045241018943, 0.17072734671065426, 0.18298662223703388, 0.18519976647975844, 0.18259150655041378, 0.2095867472928581, 0.20966156144958992, 0.1766079398057453, 0.1732666504430761, 0.20002145927501347, 0.05289953130640801, 0.10910671837840769, 0.06373250652646745, 0.05895802407947737, 0.06069417504582275, 0.052043981605300216, 0.07281469896024884, 0.06371327234900925, 0.06255519730698467]}, "mutation_prompt": null}
{"id": "48283bf2-899a-4334-9a61-15a41ed27aac", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.92  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_of_exploration = 0.7  # probability of exploration in Harmony Search\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.probability_of_exploration:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search, Quantum-Inspired Particle Swarm Optimization, Artificial Bee Colony Optimization, and Adaptive Differential Evolution with Dynamically Adjusted Exploration Rate, Neighborhood Size, and Probability of Exploration, refined by adjusting the probability of exploration in Harmony Search to 0.7 and the exploration rate adjustment rate to 0.85.", "configspace": "", "generation": 96, "fitness": 0.12841094260571942, "feedback": "The algorithm AHQBACO_DN2_DE2_REFINED_REFINED_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "919f92ff-0903-4853-bbde-7ea35688871f", "metadata": {"aucs": [0.16779781178565756, 0.17303084734230656, 0.15752796888218856, 0.15404174970884177, 0.16485414420748767, 0.15897100690557542, 0.1627049578055918, 0.1394327624586822, 0.14875543656335266, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030814483487962008, 0.042297665339880997, 0.028726245370913395, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.024995338660832367, 0.019550862899680888, 0.03031044143233652, 0.01969646754387211, 0.033153130081172266, 0.044467510574209834, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9868346885940167, 0.9932423229580043, 0.9871180742530979, 0.971713045612868, 0.9139261117743444, 0.9999001200375565, 0.9938281388682803, 0.9882587151716651, 0.9645859532542663, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.1637140079456194, 0.19205520532700826, 0.15912874652007925, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08794109919897475, 0.10909119827314917, 0.08842130708694818, 0.14793652342530672, 0.11193548551186416, 0.10588638189974864, 0.09428118104480532, 0.11679709079149958, 0.08895010955518534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831658361763817, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20661818808493548, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17743341690437042, 0.1887606785329785, 0.1949981789553823, 0.17309629893449752, 0.18786936241043273, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03776563075446249, 0.03150842159239786, 0.04231214916752091, 0.13577660398027658, 0.11615492732627897, 0.11795695037128207, 0.1387220562751541, 0.1372262786133278, 0.10997898183062449, 0.14685190152952476, 0.14115992863538085, 0.1192450101040109, 0.1610745641389092, 0.14937621116201716, 0.16682999104958385, 0.16948680222009882, 0.16521884405541243, 0.1676476686827607, 0.15127901597955062, 0.17355384695910447, 0.14090104222305122, 0.0999016709424837, 0.08926705538892332, 0.1071630535151673, 0.11653395938970756, 0.12351347156073278, 0.11943588835685681, 0.09812208369943642, 0.1224537527043591, 0.11056736998689409, 0.2601813882744033, 0.26016601643901793, 0.2601786226371633, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2601875539181707, 0.2601678946548399, 0.26017816934690785, 0.12821954655013268, 0.13715804553406075, 0.14977569096645127, 0.12985156466411774, 0.14581821788308957, 0.140143161101136, 0.12623570558600972, 0.12854224622931976, 0.15890532503478294, 0.12694647188518393, 0.16109682352698107, 0.15820807031516504, 0.1513356545171608, 0.1353860294342618, 0.12051781968187736, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.1400989037405388, 0.13407049192775466, 0.1336401190575407, 0.11959708222254117, 0.11994081450357896, 0.13675049794254157, 0.15834517139785698, 0.155873636499114, 0.10988046452472044, 0.1707279769301514, 0.18297812867283236, 0.18519976647975844, 0.18217961759890733, 0.20603266146969212, 0.20990868327844703, 0.18258670661879517, 0.17637495480761411, 0.20268554675043404, 0.054018761619939126, 0.10902661917721723, 0.06407334755385286, 0.05530898040954979, 0.06060781381683189, 0.054204062955356624, 0.0708054062535175, 0.05355076252571833, 0.058657563966619475]}, "mutation_prompt": null}
{"id": "5605aaa3-28bc-4b41-939b-e6c77bc614ac", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.92  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_of_exploration = 0.4  # probability of exploration in Harmony Search\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.probability_of_exploration:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search with Dynamically Adjusted Exploration Rate and Neighborhood Size, refined by adjusting the probability of exploration in Harmony Search to 0.4 and the exploration rate adjustment rate to 0.93.", "configspace": "", "generation": 97, "fitness": 0.12804816192349136, "feedback": "The algorithm AHQBACO_DN2_DE2_REFINED_REFINED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "919f92ff-0903-4853-bbde-7ea35688871f", "metadata": {"aucs": [0.16791744477381731, 0.1730397538914542, 0.15767885832810702, 0.1540448289221975, 0.16485414420748767, 0.158979878581736, 0.16270529397139766, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031004866481330606, 0.042299821549620864, 0.028707454718879255, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.022775144325087093, 0.01658037625624509, 0.030445226339438913, 0.01969646754387211, 0.033153130081172266, 0.045351505541815995, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9868346885940167, 0.9686548744112722, 0.9967314833102295, 0.9906119211312752, 0.9850981882542482, 0.9999001200375565, 0.9592783613015688, 0.9469098932948262, 0.9644511805532487, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15898948427355664, 0.1926773706368211, 0.15077765758762707, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.0878701608434882, 0.11058804795451704, 0.1005070497024233, 0.09759550216549728, 0.07256950446913235, 0.1029398736459205, 0.11207720311017988, 0.0990043082940143, 0.10170230447611506, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.033198415640640855, 0.03636281330624447, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20661818808493548, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.18876344404115986, 0.19518322556558043, 0.1754957212932735, 0.18742793766485444, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.037737225736343305, 0.03149234042422633, 0.04231214916752091, 0.13577660398027658, 0.11608495146824949, 0.1403075403980727, 0.1387220562751541, 0.1372262786133278, 0.10991010495874565, 0.14593016140702508, 0.14146874559029698, 0.11939451461331041, 0.16072475734955538, 0.14937621116201716, 0.16684734563472814, 0.1668212601659005, 0.16784475959028444, 0.1661449672543276, 0.15127901597955062, 0.17354213888016823, 0.14093854746742585, 0.09990585299789723, 0.0892556954122018, 0.10716775680921653, 0.12106259331381786, 0.12355305103203373, 0.12091625314511023, 0.09812208369943642, 0.12246601612611141, 0.11056541553730126, 0.26018223221605774, 0.26016601643901793, 0.26017666954069796, 0.26018132180600584, 0.26017734341597376, 0.26262195714911796, 0.2733117796270077, 0.2601678946548399, 0.2601794947077204, 0.1428554788833184, 0.13800806176386649, 0.14977569096645127, 0.1397093564561943, 0.13703625611246606, 0.1401296379883603, 0.12383205620739679, 0.13507824487384246, 0.16005469550930485, 0.1300023739036189, 0.16096796349027442, 0.15809772349028206, 0.15137879995535475, 0.1353812470117839, 0.12051467948255645, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013870492952119, 0.13407049192775466, 0.13363708813526431, 0.1196151491866636, 0.11996197588588142, 0.13675049794254157, 0.15880913060449076, 0.1586304149046318, 0.10980097721265791, 0.17066892194230676, 0.18555709813015586, 0.16799860707977843, 0.18703546089079326, 0.20939390926493218, 0.1709704186306018, 0.1826070865752224, 0.17641734931738595, 0.20264970129115645, 0.05330860165976592, 0.06651648354853334, 0.06399954976933109, 0.05935165328554448, 0.058086524628508385, 0.051912564673990746, 0.07025635095044869, 0.06272191138354988, 0.06415418675485107]}, "mutation_prompt": null}
{"id": "cd6ded3d-f370-4809-9e31-08f04f5990d3", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.92  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_of_exploration = 0.3  # probability of exploration in Harmony Search\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.probability_of_exploration:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search, Quantum-Inspired Particle Swarm Optimization, Artificial Bee Colony Optimization, and Adaptive Differential Evolution with Dynamically Adjusted Exploration Rate, Neighborhood Size, and Probability of Exploration, refined by adjusting the probability of exploration in Harmony Search to 0.3 and the exploration rate adjustment rate to 0.92.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "919f92ff-0903-4853-bbde-7ea35688871f", "metadata": {"aucs": [0.16791463472217605, 0.17303456140539053, 0.15751406432259996, 0.15402651240797094, 0.16485414420748767, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03097175095894089, 0.04229676289419204, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015461003664911765, 0.030527650940410433, 0.01969646754387211, 0.033153130081172266, 0.04462538477247513, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9868363961698443, 0.9932423229580043, 0.9967507256918613, 0.9906119211312752, 0.9850981882542482, 0.9999001200375565, 0.9984356409844637, 0.988199287780604, 0.9651477713573191, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15992888980280417, 0.19115953589611245, 0.15456498203766134, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08637246507304841, 0.10897624575995402, 0.11275589901584737, 0.14714604513893625, 0.1119824890054737, 0.10329312357011478, 0.11299922382094196, 0.11734569778248882, 0.09417485131860359, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831658361763817, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.1887370728543144, 0.19352871068065391, 0.16887764079650736, 0.18786755675501787, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03774444209317751, 0.03152262647728599, 0.04231214916752091, 0.13568153332214972, 0.1194993123551269, 0.11795695037128207, 0.13871562955069006, 0.13721084259603444, 0.10980446992278814, 0.1457760375692273, 0.14069261272339006, 0.11891066490337965, 0.1610745641389092, 0.14937621116201716, 0.1668244536637674, 0.16908774946579108, 0.1675139234496843, 0.1638625886356505, 0.15127901597955062, 0.17357244887918022, 0.1408942418583361, 0.0999016709424837, 0.08926282734017021, 0.1071630535151673, 0.1203156725712985, 0.11984530657403325, 0.11747123262071923, 0.09812208369943642, 0.12245014374148089, 0.11057733542366877, 0.2601813882744033, 0.26016601643901793, 0.2601786226371633, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.12821954655013268, 0.13716321690826827, 0.13255337194618855, 0.13963129667695395, 0.13540357832789718, 0.14084817961805252, 0.12383205620739679, 0.13526331024062344, 0.16005469550930485, 0.12760741005012766, 0.1608043855280008, 0.1582429603948523, 0.15137550649944465, 0.1353860294342618, 0.12059230836089974, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013945494570657, 0.13406252454194778, 0.13363799679350685, 0.11958313344491767, 0.11996033272833961, 0.13675049794254157, 0.15868485304836355, 0.15649285239177557, 0.10919045241018943, 0.17072734671065426, 0.18298662223703388, 0.18519976647975844, 0.18259150655041378, 0.2095867472928581, 0.20966156144958992, 0.1766079398057453, 0.1732666504430761, 0.20002145927501347, 0.05289953130640801, 0.10910671837840769, 0.06373250652646745, 0.05895802407947737, 0.06069417504582275, 0.052043981605300216, 0.07281469896024884, 0.06371327234900925, 0.06255519730698467]}, "mutation_prompt": null}
{"id": "5a51b5da-25a0-4763-9db6-682af9bc9900", "solution": "import numpy as np\nimport random\n\nclass AHQBACO_DN2_DE2_REFINED_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory = np.random.uniform(-5, 5, (budget, dim))\n        self.velocity = np.random.uniform(-1, 1, (budget, dim))\n        self.best_solution = np.zeros(dim)\n        self.best_fitness = np.inf\n        self.employed_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.onlooker_bees = np.random.uniform(-5, 5, (budget, dim))\n        self.dance_memory = np.zeros((budget, dim))\n        self.neighborhood_size = 0.2 * budget  # dynamic neighborhood size\n        self.exploration_rate = 0.5  # dynamic exploration rate\n        self.convergence_threshold = 0.1  # convergence threshold\n        self.F = 0.5  # differential evolution parameter\n        self.CR = 0.5  # differential evolution parameter\n        self.exploration_rate_adjustment = 0.92  # adjustment rate for exploration rate\n        self.dynamic_neighborhood_size = 0.1 * budget  # dynamic neighborhood size for onlooker bees\n        self.probability_of_exploration = 0.3  # probability of exploration in Harmony Search\n\n    def __call__(self, func):\n        convergence = np.zeros(self.budget)\n        for i in range(self.budget):\n            fitness = func(self.harmony_memory[i])\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.harmony_memory[i]\n            # Harmony Search\n            if random.random() < self.probability_of_exploration:\n                self.harmony_memory[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Quantum-Inspired Particle Swarm Optimization\n            else:\n                self.velocity[i] = 0.7298 * self.velocity[i] + 1.49618 * (self.best_solution - self.harmony_memory[i]) + 1.49618 * (np.random.uniform(-1, 1, self.dim))\n                self.harmony_memory[i] = self.harmony_memory[i] + self.velocity[i]\n                self.harmony_memory[i] = np.clip(self.harmony_memory[i], -5, 5)\n            # Artificial Bee Colony Optimization\n            if i < self.budget // 2:\n                # Employed bees\n                self.employed_bees[i] = self.harmony_memory[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            else:\n                # Employed bees\n                self.employed_bees[i] = self.onlooker_bees[i] + np.random.uniform(-1, 1, self.dim)\n                self.employed_bees[i] = np.clip(self.employed_bees[i], -5, 5)\n                # Onlooker bees\n                if random.random() < 0.5:\n                    self.onlooker_bees[i] = self.employed_bees[i] + np.random.uniform(-self.dynamic_neighborhood_size, self.dynamic_neighborhood_size, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                else:\n                    self.onlooker_bees[i] = self.dance_memory[i] + np.random.uniform(-1, 1, self.dim)\n                    self.onlooker_bees[i] = np.clip(self.onlooker_bees[i], -5, 5)\n                # Dance memory\n                self.dance_memory[i] = self.onlooker_bees[i] if func(self.onlooker_bees[i]) < func(self.dance_memory[i]) else self.dance_memory[i]\n                convergence[i] = np.linalg.norm(self.harmony_memory[i] - self.best_solution)\n            # Adaptive Differential Evolution\n            if i >= self.budget // 2:\n                # Select three random solutions\n                index1, index2, index3 = random.sample(range(self.budget), 3)\n                # Create a trial solution\n                trial_solution = self.harmony_memory[i] + self.F * (self.harmony_memory[index1] - self.harmony_memory[index2]) + self.CR * (self.harmony_memory[index3] - self.harmony_memory[i])\n                trial_solution = np.clip(trial_solution, -5, 5)\n                # Evaluate the trial solution\n                trial_fitness = func(trial_solution)\n                # Update the solution if the trial solution is better\n                if trial_fitness < func(self.harmony_memory[i]):\n                    self.harmony_memory[i] = trial_solution\n            if np.mean(convergence) < self.convergence_threshold:\n                self.exploration_rate = max(0.1, self.exploration_rate * 0.8)\n            else:\n                self.exploration_rate = min(0.9, self.exploration_rate * 1.1)\n            self.neighborhood_size = max(0.1 * budget, self.neighborhood_size * 0.9)  # adjust neighborhood size based on fitness of employed bees\n            self.dynamic_neighborhood_size = max(0.1 * budget, self.dynamic_neighborhood_size * 1.1)  # adjust dynamic neighborhood size based on fitness of onlooker bees\n        return self.best_solution, self.best_fitness\n\n# Example usage:\ndef sphere(x):\n    return np.sum(x**2)\n\nbudget = 1000\ndim = 10\nahqbaco_dn2_de2_refined_refined = AHQBACO_DN2_DE2_REFINED_REFINED(budget, dim)\nbest_solution, best_fitness = ahqbaco_dn2_de2_refined_refined(sphere)\nprint(\"Best solution:\", best_solution)\nprint(\"Best fitness:\", best_fitness)", "name": "AHQBACO_DN2_DE2_REFINED_REFINED", "description": "Novel hybridization of Adaptive Harmony Search, Quantum-Inspired Particle Swarm Optimization, Artificial Bee Colony Optimization, and Adaptive Differential Evolution with Dynamically Adjusted Exploration Rate, Neighborhood Size, and Probability of Exploration, refined by adjusting the probability of exploration in Harmony Search to 0.3 and the exploration rate adjustment rate to 0.92.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "919f92ff-0903-4853-bbde-7ea35688871f", "metadata": {"aucs": [0.16791463472217605, 0.17303456140539053, 0.15751406432259996, 0.15402651240797094, 0.16485414420748767, 0.15898560438757192, 0.16270429889919014, 0.1394327624586822, 0.14875659955818987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03097175095894089, 0.04229676289419204, 0.028767574982745958, 0.030147444489367126, 0.03423204244623079, 0.03559272547187042, 0.04263394824411648, 0.05445470516326456, 0.04465656861857947, 0.02495380984739437, 0.015461003664911765, 0.030527650940410433, 0.01969646754387211, 0.033153130081172266, 0.04462538477247513, 0.03353613547250134, 0.026080074937419484, 0.026197081361168384, 0.9868363961698443, 0.9932423229580043, 0.9967507256918613, 0.9906119211312752, 0.9850981882542482, 0.9999001200375565, 0.9984356409844637, 0.988199287780604, 0.9651477713573191, 0.06327105142008482, 0.06721697510924984, 0.09868376693352243, 0.04682316521506413, 0.06098032414479804, 0.03131469230493367, 0.08760288956504869, 0.03242934921204976, 0.08688468824530027, 0.15992888980280417, 0.19115953589611245, 0.15456498203766134, 0.08978602851270656, 0.08299744133218068, 0.1126317008225034, 0.08751079828435271, 0.10611071494075475, 0.10269850481101384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01371349358802576, 0.08637246507304841, 0.10897624575995402, 0.11275589901584737, 0.14714604513893625, 0.1119824890054737, 0.10329312357011478, 0.11299922382094196, 0.11734569778248882, 0.09417485131860359, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02167130277064644, 0.06343546399841216, 0.04161381215727966, 0.0494272710694551, 0.021831658361763817, 0.036241743907918456, 0.013145577149220489, 0.030144279045393296, 0.02743219442430067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2066270982616477, 0.18834777022491744, 0.17579218048408696, 0.1999369180904158, 0.17741712367475304, 0.1887370728543144, 0.19352871068065391, 0.16887764079650736, 0.18786755675501787, 0.025816910901456658, 0.03499033382125216, 0.02530778734618344, 0.032525290286609776, 0.03229621311972519, 0.039398907522902316, 0.03774444209317751, 0.03152262647728599, 0.04231214916752091, 0.13568153332214972, 0.1194993123551269, 0.11795695037128207, 0.13871562955069006, 0.13721084259603444, 0.10980446992278814, 0.1457760375692273, 0.14069261272339006, 0.11891066490337965, 0.1610745641389092, 0.14937621116201716, 0.1668244536637674, 0.16908774946579108, 0.1675139234496843, 0.1638625886356505, 0.15127901597955062, 0.17357244887918022, 0.1408942418583361, 0.0999016709424837, 0.08926282734017021, 0.1071630535151673, 0.1203156725712985, 0.11984530657403325, 0.11747123262071923, 0.09812208369943642, 0.12245014374148089, 0.11057733542366877, 0.2601813882744033, 0.26016601643901793, 0.2601786226371633, 0.26018132180600584, 0.2601665068806729, 0.26262195714911796, 0.2733117796270077, 0.2601737466540327, 0.2601794947077204, 0.12821954655013268, 0.13716321690826827, 0.13255337194618855, 0.13963129667695395, 0.13540357832789718, 0.14084817961805252, 0.12383205620739679, 0.13526331024062344, 0.16005469550930485, 0.12760741005012766, 0.1608043855280008, 0.1582429603948523, 0.15137550649944465, 0.1353860294342618, 0.12059230836089974, 0.14557321055036465, 0.14444836304044384, 0.15294909362803888, 0.14013945494570657, 0.13406252454194778, 0.13363799679350685, 0.11958313344491767, 0.11996033272833961, 0.13675049794254157, 0.15868485304836355, 0.15649285239177557, 0.10919045241018943, 0.17072734671065426, 0.18298662223703388, 0.18519976647975844, 0.18259150655041378, 0.2095867472928581, 0.20966156144958992, 0.1766079398057453, 0.1732666504430761, 0.20002145927501347, 0.05289953130640801, 0.10910671837840769, 0.06373250652646745, 0.05895802407947737, 0.06069417504582275, 0.052043981605300216, 0.07281469896024884, 0.06371327234900925, 0.06255519730698467]}, "mutation_prompt": null}
