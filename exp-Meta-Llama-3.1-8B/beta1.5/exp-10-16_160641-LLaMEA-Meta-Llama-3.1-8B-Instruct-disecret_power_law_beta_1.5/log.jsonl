{"id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/gpfs/scratch1/shared/hyin/LLaMEA/llamea/llamea.py\", line 180, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/gpfs/scratch1/shared/hyin/LLaMEA/llamea/llamea.py\", line 257, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"/gpfs/scratch1/shared/hyin/LLaMEA/mutation_exp.py\", line 44, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 62, in __call__\n  File \"<string>\", line 25, in diffusion\nIndexError: index 38 is out of bounds for axis 0 with size 10\n.", "error": "IndexError('index 38 is out of bounds for axis 0 with size 10')Traceback (most recent call last):\n  File \"/gpfs/scratch1/shared/hyin/LLaMEA/llamea/llamea.py\", line 180, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/gpfs/scratch1/shared/hyin/LLaMEA/llamea/llamea.py\", line 257, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"/gpfs/scratch1/shared/hyin/LLaMEA/mutation_exp.py\", line 44, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 62, in __call__\n  File \"<string>\", line 25, in diffusion\nIndexError: index 38 is out of bounds for axis 0 with size 10\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "5df2892b-dc6c-4a43-bce2-d22b0f37633c", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "7dc162a7-bc14-4e33-9871-c0a7e8e4e3d9", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.diffusion_threshold = 0.5  # new parameter\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            if random.random() < self.diffusion_threshold:  # change the individual lines of the selected solution to refine its strategy\n                self.diffusion_rate = 0.1 + (random.random() - 0.5) * 0.1  # adapt the diffusion rate based on the fitness of individuals\n                for j in range(self.dim):\n                    if random.random() < self.diffusion_rate:\n                        offspring[j] += random.uniform(-1, 1)\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "The Adaptive-Diffusion-Driven Evolution (ADDE) algorithm is enhanced with a probability-based diffusion strategy that adapts the diffusion rate based on the fitness of individuals.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 21 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 21 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "8668e494-21df-4b98-b4e0-acc4e0cca4a5", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_control = 0.8\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            if random.random() < self.probability_control:\n                for j in range(self.dim):\n                    if random.random() < self.diffusion_rate:\n                        offspring[j] += random.uniform(-1, 1)\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            if random.random() < self.probability_control:\n                for j in range(self.dim):\n                    if random.random() < self.driven_evolution_rate:\n                        mutation = random.uniform(-1, 1)\n                        if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                            offspring[j] += mutation\n                            if offspring[j] < self.search_space[0]:\n                                offspring[j] = self.search_space[0]\n                            elif offspring[j] > self.search_space[1]:\n                                offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability control to efficiently explore and exploit the search space.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "920fcff5-8a05-4608-b7dc-8eee7f976346", "solution": "import numpy as np\nimport random\n\nclass ADDEPC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_control_rate = 0.5\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if random.random() < self.probability_control_rate:\n                        if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                            offspring[j] += mutation\n                            if offspring[j] < self.search_space[0]:\n                                offspring[j] = self.search_space[0]\n                            elif offspring[j] > self.search_space[1]:\n                                offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDEPC", "description": "Adaptive-Diffusion-Driven Evolution with Probability Control (ADDE-PC) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability control to efficiently explore and exploit the search space.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 40 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 40 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "96c1fb03-25ce-4b01-8cbc-174942f54c76", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "1aa91248-3b1e-420b-b35d-bdde0839d3ad", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate * (1 - (self.budget - i) / self.budget):\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate * (1 - (self.budget - i) / self.budget):\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) with probability-based mutation rates refinement.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 32 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 32 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "cbae2d18-e501-4348-ba7b-66eac64c716c", "solution": "import numpy as np\nimport random\n\nclass ADDE_SS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.stochastic_sampling_rate = 0.1\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def stochastic_sampling(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.stochastic_sampling_rate:\n                    offspring[j] = random.uniform(self.search_space[0], self.search_space[1])\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.stochastic_sampling(population)\n        return population[0]", "name": "ADDE_SS", "description": "The Adaptive-Diffusion-Driven Evolution with Stochastic Sampling (ADDE-SS) algorithm combines adaptive diffusion and driven evolution with stochastic sampling to efficiently explore and exploit the search space.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 14 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 14 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "1d57557d-448e-4d4d-a908-d9067d59c0eb", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "4946b639-f113-4506-9190-2db09bee3511", "solution": "import numpy as np\nimport random\n\nclass PADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability = 0.17\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if random.random() < self.probability:\n                        if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                            offspring[j] += mutation\n                            if offspring[j] < self.search_space[0]:\n                                offspring[j] = self.search_space[0]\n                            elif offspring[j] > self.search_space[1]:\n                                offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "PADDE", "description": "This novel metaheuristic algorithm, called \"Probabilistic Adaptive-Diffusion-Driven Evolution\" (PADDE), combines adaptive diffusion and driven evolution with a probabilistic approach to efficiently explore and exploit the search space.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 34 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 34 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "3e030d55-03c2-47f0-aab9-e749fa3cc980", "solution": "import numpy as np\nimport random\n\nclass ADDE_PA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_adjustment_rate = 0.01\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def probability_adjustment(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        best_individual = population[sorted_idx[0]]\n        worst_individual = population[sorted_idx[-1]]\n        probability_adjustment = 1 - (fitness[worst_individual] - fitness[best_individual]) / (self.search_space[1] - self.search_space[0])\n        self.diffusion_rate = max(0.01, self.diffusion_rate * (1 + probability_adjustment))\n        self.driven_evolution_rate = max(0.01, self.driven_evolution_rate * (1 + probability_adjustment))\n        self.probability_adjustment_rate = max(0.01, self.probability_adjustment_rate * (1 + probability_adjustment))\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            self.probability_adjustment(population, func)\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE_PA", "description": "Adaptive-Diffusion-Driven Evolution with Probability Adjustment (ADDE-PA) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability adjustment to efficiently explore and exploit the search space.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('arrays used as indices must be of integer (or boolean) type').", "error": "IndexError('arrays used as indices must be of integer (or boolean) type')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "dddcabb7-22d4-4b6b-8faf-2459ed0b51b2", "solution": "import numpy as np\nimport random\n\nclass ADDE_PA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.diffusion_prob = 0.5\n        self.driven_evolution_prob = 0.5\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            if random.random() < self.diffusion_prob:\n                for j in range(self.dim):\n                    if random.random() < self.diffusion_rate:\n                        offspring[j] += random.uniform(-1, 1)\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            if random.random() < self.driven_evolution_prob:\n                for j in range(self.dim):\n                    if random.random() < self.driven_evolution_rate:\n                        mutation = random.uniform(-1, 1)\n                        if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                            offspring[j] += mutation\n                            if offspring[j] < self.search_space[0]:\n                                offspring[j] = self.search_space[0]\n                            elif offspring[j] > self.search_space[1]:\n                                offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def update_probabilities(self, population, func):\n        fitness = self.evaluate(func, population)\n        mean_fitness = np.mean(fitness)\n        std_fitness = np.std(fitness)\n        if std_fitness > 0.1:\n            self.diffusion_prob = 0.7\n            self.driven_evolution_prob = 0.3\n        else:\n            self.diffusion_prob = 0.3\n            self.driven_evolution_prob = 0.7\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            self.update_probabilities(population, func)\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE_PA", "description": "This novel heuristic algorithm, called \"Adaptive-Diffusion-Driven Evolution with Probability Adjustment\" (ADDE-PA), refines the Adaptive-Diffusion-Driven Evolution (ADDE) algorithm by adjusting the probability of diffusion and driven evolution based on the fitness of the population.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 14 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 14 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "650adf5a-ac18-41ae-bac9-520988311fab", "solution": "import numpy as np\nimport random\n\nclass AdaptiveDiffusionDrivenEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_control_rate = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            if random.random() < self.probability_control_rate:\n                for j in range(self.dim):\n                    if random.random() < self.diffusion_rate:\n                        offspring[j] += random.uniform(-1, 1)\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            if random.random() < self.probability_control_rate:\n                for j in range(self.dim):\n                    if random.random() < self.driven_evolution_rate:\n                        mutation = random.uniform(-1, 1)\n                        if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                            offspring[j] += mutation\n                            if offspring[j] < self.search_space[0]:\n                                offspring[j] = self.search_space[0]\n                            elif offspring[j] > self.search_space[1]:\n                                offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "AdaptiveDiffusionDrivenEvolution", "description": "This novel heuristic algorithm combines adaptive diffusion and driven evolution with probability control to efficiently explore and exploit the search space.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 18 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 18 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "eb93c3e7-4ce9-4294-91a7-3f5974b32b6b", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "7f9209d3-5ea3-4e5b-955b-6ce962078550", "solution": "import numpy as np\nimport random\n\nclass ADDE17:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.mutation_rate = 0.17\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def probability_17_mutation(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.mutation_rate:\n                    mutation = random.uniform(-1, 1)\n                    offspring[j] += mutation\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.probability_17_mutation(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE17", "description": "Adaptive-Diffusion-Driven Evolution with Probability 17 Mutation Rate Adaptation (ADDE-17) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability 17 mutation rate adaptation to efficiently explore and exploit the search space.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 12 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 12 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "14a19f7a-a44d-4f64-9a2f-34fc89293b92", "solution": "import numpy as np\nimport random\n\nclass ADDE_APA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_adjustment_rate = 0.01\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def probability_adjustment(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        best_individual = population[sorted_idx[0]]\n        worst_individual = population[sorted_idx[-1]]\n        self.diffusion_rate = max(0.01, self.diffusion_rate - self.probability_adjustment_rate)\n        self.driven_evolution_rate = max(0.01, self.driven_evolution_rate - self.probability_adjustment_rate)\n        if func(best_individual) > func(worst_individual):\n            self.diffusion_rate = min(0.5, self.diffusion_rate + self.probability_adjustment_rate)\n            self.driven_evolution_rate = min(0.5, self.driven_evolution_rate + self.probability_adjustment_rate)\n        return population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.probability_adjustment(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE_APA", "description": "Adaptive-Diffusion-Driven Evolution with Adaptive Probability Adjustment (ADDE-APA) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with adaptive probability adjustment to efficiently explore and exploit the search space.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 41 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 41 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "1c19dc09-3b23-4056-be50-7bf5ba74833d", "solution": "import numpy as np\nimport random\n\nclass ADDE_P:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.mutation_rate = 0.05  # new parameter\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def probabilistic_mutation(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.mutation_rate:\n                    mutation = random.uniform(-1, 1)\n                    new_offspring = offspring + mutation * np.array([0] * self.dim)\n                    if func(new_offspring) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.probabilistic_mutation(population, func)\n        return population[0]", "name": "ADDE_P", "description": "Adaptive-Diffusion-Driven Evolution with Probabilistic Mutation Rate (ADDE-P) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with a probabilistic mutation rate to efficiently explore and exploit the search space.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 11 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 11 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "33d1a3ce-1b26-4b7f-b942-a64f79f9c0af", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_control_rate = 0.1  # new parameter for probability control\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def probability_control(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.probability_control_rate:\n                    if random.random() < 0.5:\n                        offspring[j] += random.uniform(-1, 1)\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n                    else:\n                        mutation = random.uniform(-1, 1)\n                        if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                            offspring[j] += mutation\n                            if offspring[j] < self.search_space[0]:\n                                offspring[j] = self.search_space[0]\n                            elif offspring[j] > self.search_space[1]:\n                                offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.probability_control(population, func)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability control to efficiently explore and exploit the search space.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 38 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 38 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "a2065016-f847-47c0-b56a-27b4d4dc74e3", "solution": "import numpy as np\nimport random\n\nclass ADDE_PA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.prob_adjustment_rate = 0.01\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            prob = random.random()\n            if prob < self.prob_adjustment_rate:\n                self.diffusion_rate *= 1.1\n                if self.diffusion_rate > 1:\n                    self.diffusion_rate = 1\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            prob = random.random()\n            if prob < self.prob_adjustment_rate:\n                self.driven_evolution_rate *= 1.1\n                if self.driven_evolution_rate > 1:\n                    self.driven_evolution_rate = 1\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            self.prob_adjustment_rate *= 1.1\n            if self.prob_adjustment_rate > 1:\n                self.prob_adjustment_rate = 1\n        return population[0]", "name": "ADDE_PA", "description": "Adaptive-Diffusion-Driven Evolution with Probability Adjustment (ADDE-PA) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability adjustment to efficiently explore and exploit the search space.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 15 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 15 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "43eb5347-455b-41c0-98fa-c8b70a0f0bdb", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def mutate_individual(self, individual):\n        for j in range(self.dim):\n            if random.random() < 0.1:\n                mutation = random.uniform(-1, 1)\n                if random.random() < 0.5:\n                    individual[j] += mutation\n                else:\n                    individual[j] -= mutation\n                if individual[j] < self.search_space[0]:\n                    individual[j] = self.search_space[0]\n                elif individual[j] > self.search_space[1]:\n                    individual[j] = self.search_space[1]\n        return individual\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            for i in range(self.num_offspring):\n                population[i] = self.mutate_individual(population[i])\n        return population[0]", "name": "ADDE", "description": "A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space, refined with probability 1 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "8ac1d957-175d-42ea-ac07-1a9b5db3995e", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "e672987e-7cde-454a-b6d0-b2a10c6ad717", "solution": "import numpy as np\nimport random\n\nclass ADDE17:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_17 = 0.17\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def probability_17_mutation(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.probability_17:\n                    mutation = random.uniform(-1, 1)\n                    offspring[j] += mutation\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n                    if func(offspring) < func(population[parent_idx]):\n                        new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.probability_17_mutation(population, func)\n        return population[0]", "name": "ADDE17", "description": "Adaptive-Diffusion-Driven Evolution with Probability 17 Mutation (ADDE-17)", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 18 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 18 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "f38d5e7d-9ab0-48a1-8f6d-e203eb84f470", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "4bd074ad-78e5-4bdb-bbc4-1a05b6113cfd", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "c644b67b-7258-4303-8c17-b35bafa4d832", "solution": "import numpy as np\nimport random\n\nclass ADDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.differential_mutation_rate = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def differential_mutation(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent1_idx = random.randint(0, self.population_size - 1)\n            parent2_idx = random.randint(0, self.population_size - 1)\n            parent1 = population[parent1_idx].copy()\n            parent2 = population[parent2_idx].copy()\n            offspring = parent1.copy()\n            for j in range(self.dim):\n                if random.random() < self.differential_mutation_rate:\n                    mutation = parent2[j] - parent1[j]\n                    offspring[j] += mutation\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.differential_mutation(population)\n        return population[0]", "name": "ADDE_DM", "description": "Adaptive-Diffusion-Driven Evolution with Differential Mutation (ADDE-DM) - A novel metaheuristic algorithm that combines adaptive diffusion, driven evolution, and differential mutation to efficiently explore and exploit the search space.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 11 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 11 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "7a466b6f-1ff3-48e6-b6e6-e47337251b8e", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "6cf77145-1c99-4267-befd-552897c1fcff", "solution": "import numpy as np\nimport random\n\nclass ADDE_PM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.mutation_rate = 0.1\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def probabilistic_mutation(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.mutation_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.probabilistic_mutation(population, func)\n        return population[0]", "name": "ADDE_PM", "description": "Adaptive-Diffusion-Driven Evolution with Probabilistic Mutation (ADDE-PM) - A novel metaheuristic algorithm that combines adaptive diffusion, driven evolution, and probabilistic mutation to efficiently explore and exploit the search space.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 31 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 31 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "9362c4b8-5423-4ef0-ab96-74df1a3a0fbd", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_change = 1.0  # probability to change the individual lines\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            if random.random() < self.probability_change:  # change the individual lines with probability 1\n                new_idx = random.randint(0, self.population_size - 1)\n                new_offspring = population[new_idx].copy()\n                for k in range(self.dim):\n                    if random.random() < self.diffusion_rate:\n                        new_offspring[k] += random.uniform(-1, 1)\n                        if new_offspring[k] < self.search_space[0]:\n                            new_offspring[k] = self.search_space[0]\n                        elif new_offspring[k] > self.search_space[1]:\n                            new_offspring[k] = self.search_space[1]\n                new_population[i] = new_offspring\n            else:\n                new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            if random.random() < self.probability_change:  # change the individual lines with probability 1\n                new_idx = random.randint(0, self.population_size - 1)\n                new_offspring = population[new_idx].copy()\n                for k in range(self.dim):\n                    if random.random() < self.driven_evolution_rate:\n                        mutation = random.uniform(-1, 1)\n                        if func(new_offspring + mutation * np.array([0] * self.dim)) < func(new_offspring):\n                            new_offspring[k] += mutation\n                            if new_offspring[k] < self.search_space[0]:\n                                new_offspring[k] = self.search_space[0]\n                            elif new_offspring[k] > self.search_space[1]:\n                                new_offspring[k] = self.search_space[1]\n                new_population[i] = new_offspring\n            else:\n                new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability 1 to change the individual lines, efficiently exploring and exploiting the search space.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 40 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 40 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "68806161-53f9-40cf-854a-2fd1b02e10e5", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "0c85410c-39ed-41f9-a502-693fecbb2e2e", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "a9a5e20a-5b1b-4ada-b245-d5c7b063910e", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "dc1cfeaa-1668-451f-8e45-d5db043bd563", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "a0781493-f78f-48e0-aa3d-d1d1fdd92975", "solution": "import numpy as np\nimport random\n\nclass ADDE_SSMPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.mutation_rate = 0.1\n        self.probability_adjustment_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def stochastic_sampling(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.mutation_rate:\n                    mutation = random.uniform(-1, 1)\n                    offspring[j] += mutation\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def mutation_probability_adjustment(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.probability_adjustment_rate:\n                    self.mutation_rate += random.uniform(-0.01, 0.01)\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.stochastic_sampling(population)\n            population = self.mutation_probability_adjustment(population, func)\n        return population[0]", "name": "ADDE_SSMPA", "description": "Adaptive-Diffusion-Driven Evolution with Stochastic Sampling and Mutation Probability Adjustment (ADDE-SSMPA) - A novel metaheuristic algorithm that combines adaptive diffusion, driven evolution, stochastic sampling, and mutation probability adjustment to efficiently explore and exploit the search space.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 20 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 20 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "6ee88859-3df0-41bf-bd6d-119da7a23c02", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_control = 0.5\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            if random.random() < self.probability_control:\n                for j in range(self.dim):\n                    if random.random() < self.diffusion_rate:\n                        offspring[j] += random.uniform(-1, 1)\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            if random.random() < self.probability_control:\n                for j in range(self.dim):\n                    if random.random() < self.driven_evolution_rate:\n                        mutation = random.uniform(-1, 1)\n                        if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                            offspring[j] += mutation\n                            if offspring[j] < self.search_space[0]:\n                                offspring[j] = self.search_space[0]\n                            elif offspring[j] > self.search_space[1]:\n                                offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability control to efficiently explore and exploit the search space.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 30 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 30 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "d6d8bddc-2dcd-43dc-bad7-6f0bb9689c8c", "solution": "import numpy as np\nimport random\n\nclass ADDE_PBDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_threshold = 0.8\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            if random.random() < self.driven_evolution_rate:\n                for j in range(self.dim):\n                    if random.random() < self.probability_threshold:\n                        mutation = random.uniform(-1, 1)\n                        if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                            offspring[j] += mutation\n                            if offspring[j] < self.search_space[0]:\n                                offspring[j] = self.search_space[0]\n                            elif offspring[j] > self.search_space[1]:\n                                offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE_PBDE", "description": "Adaptive-Diffusion-Driven Evolution with Probability-Based Driven Evolution (ADDE-PBDE) - A novel metaheuristic algorithm that combines adaptive diffusion and probability-based driven evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "e55bd0ac-a2c7-4f3d-be02-eaa32e98d3fc", "solution": "import numpy as np\nimport random\n\nclass ADDE_SNS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.sns_rate = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def sns(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.sns_rate:\n                    neighbor_idx = random.randint(0, self.population_size - 1)\n                    neighbor = population[neighbor_idx].copy()\n                    if random.random() < 0.5:\n                        offspring[j] = neighbor[j]\n                    else:\n                        offspring[j] += random.uniform(-1, 1)\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.sns(population, func)\n        return population[0]", "name": "ADDE_SNS", "description": "Adaptive-Diffusion-Driven Evolution with Stochastic Neighborhood Search (ADDE-SNS) - A novel metaheuristic algorithm that combines adaptive diffusion, driven evolution, and stochastic neighborhood search to efficiently explore and exploit the search space.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 31 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 31 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "5dce98b3-6ffe-4e07-b5d6-fe85250d5655", "solution": "import numpy as np\nimport random\n\nclass ADDE_PCDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_control_rate = 0.8  # probability control rate\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            if random.random() < self.probability_control_rate:  # probability control\n                for j in range(self.dim):\n                    if random.random() < self.driven_evolution_rate:\n                        mutation = random.uniform(-1, 1)\n                        if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                            offspring[j] += mutation\n                            if offspring[j] < self.search_space[0]:\n                                offspring[j] = self.search_space[0]\n                            elif offspring[j] > self.search_space[1]:\n                                offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE_PCDE", "description": "Adaptive-Diffusion-Driven Evolution with Probability-Controlled Driven Evolution (ADDE-PCDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability control to efficiently explore and exploit the search space.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 34 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 34 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "546e12fb-3962-46aa-a901-7df224ca4624", "solution": "import numpy as np\nimport random\n\nclass ADDEPMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.mutation_rate = 0.2\n        self.crossover_rate = 0.3\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def mutation(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.mutation_rate:\n                    mutation = random.uniform(-1, 1)\n                    offspring[j] += mutation\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def crossover(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx1 = random.randint(0, self.population_size - 1)\n            parent_idx2 = random.randint(0, self.population_size - 1)\n            offspring1 = population[parent_idx1].copy()\n            offspring2 = population[parent_idx2].copy()\n            crossover_point = random.randint(0, self.dim - 1)\n            for j in range(crossover_point):\n                offspring1[j], offspring2[j] = offspring2[j], offspring1[j]\n            new_population[i] = offspring1\n            new_population[self.population_size + i] = offspring2\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.mutation(population)\n            population = self.crossover(population)\n        return population[0]", "name": "ADDEPMC", "description": "Novel Adaptive-Diffusion-Driven Evolution with Probabilistic Mutation and Crossover (ADDE-PMC).", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 23 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 23 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "69f8c84a-e564-4067-8937-4821ec0df061", "solution": "import numpy as np\nimport random\n\nclass ADDE_PA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_adjustment_rate = 0.01\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def probability_adjustment(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.probability_adjustment_rate:\n                    if random.random() < 0.5:\n                        offspring[j] += random.uniform(-1, 1)\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n                    else:\n                        mutation = random.uniform(-1, 1)\n                        if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                            offspring[j] += mutation\n                            if offspring[j] < self.search_space[0]:\n                                offspring[j] = self.search_space[0]\n                            elif offspring[j] > self.search_space[1]:\n                                offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.probability_adjustment(population, func)\n        return population[0]", "name": "ADDE_PA", "description": "Adaptive-Diffusion-Driven Evolution with Probability Adjustment (ADDE-PA) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability adjustment to efficiently explore and exploit the search space.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 14 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 14 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "18d95a5c-17d1-42b8-9853-5164b3a4a9af", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.choices(range(self.population_size), weights=[self.evaluate(func, population)[j] for j in range(self.population_size)], k=1)[0]\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.choices(range(self.population_size), weights=[self.evaluate(func, population)[j] for j in range(self.population_size)], k=1)[0]\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution with Probability-Based Parent Selection", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "ef883751-a113-4ea9-9e42-b869fd0bc795", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "b106955b-f3bb-488d-b165-0732afa8f017", "solution": "import numpy as np\nimport random\n\nclass ADDE_PBSMR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability = 0.17  # probability to change individual lines\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def pbsmr(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.probability:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.pbsmr(population, func)\n        return population[0]", "name": "ADDE_PBSMR", "description": "Adaptive-Diffusion-Driven Evolution with Probability-Based Selection and Mutation Rates (ADDE-PBSMR)", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 43 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 43 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "9493a386-960c-4b0d-9233-ae9eb142ff7e", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.mutation_rate = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def mutation(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.mutation_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.mutation(population, func)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) with Probability-Based Mutation and Selection.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 11 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 11 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "02b1377f-7483-4f2d-93e5-a05588462a00", "solution": "import numpy as np\nimport random\n\nclass ADDE_PCDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_control_rate = 0.5\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.probability_control_rate:\n                    if random.random() < self.driven_evolution_rate:\n                        mutation = random.uniform(-1, 1)\n                        if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                            offspring[j] += mutation\n                            if offspring[j] < self.search_space[0]:\n                                offspring[j] = self.search_space[0]\n                            elif offspring[j] > self.search_space[1]:\n                                offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE_PCDE", "description": "Adaptive-Diffusion-Driven Evolution with Probability-Controlled Driven Evolution (ADDE-PCDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability-controlled mutation to efficiently explore and exploit the search space.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 13 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 13 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "778be99f-7326-4e5a-bb8d-42c3590b5a1f", "solution": "import numpy as np\nimport random\n\nclass ADDE_PCDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_control_rate = 0.8\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def probability_controlled_driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate * self.probability_control_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.probability_controlled_driven_evolution(population, func)\n        return population[0]", "name": "ADDE_PCDE", "description": "Adaptive-Diffusion-Driven Evolution with Probability-Controlled Driven Evolution (ADDE-PCDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability-controlled driven evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 16 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 16 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "eb7d2699-fab7-481d-a816-f30053eba8c3", "solution": "import numpy as np\nimport random\n\nclass ADDE_PA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.prob_adjustment_rate = 0.01\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def prob_adjustment(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        self.diffusion_rate = max(0.01, self.diffusion_rate - self.prob_adjustment_rate * (fitness[sorted_idx[0]] - fitness[sorted_idx[-1]]))\n        self.driven_evolution_rate = max(0.01, self.driven_evolution_rate - self.prob_adjustment_rate * (fitness[sorted_idx[0]] - fitness[sorted_idx[-1]]))\n        return population\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.prob_adjustment(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE_PA", "description": "Adaptive-Diffusion-Driven Evolution with Probability Adjustment (ADDE-PA) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability adjustment to efficiently explore and exploit the search space.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 48 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 48 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "228bb427-088f-43b3-8d06-0f71faec8a6e", "solution": "import numpy as np\nimport random\n\nclass ADDE_PM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.mutation_rate = 0.1\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def probability_informed_mutation(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.mutation_rate:\n                    probability = 0.5 + 0.5 * (func(offspring) - np.min(self.evaluate(func, population))) / (np.max(self.evaluate(func, population)) - np.min(self.evaluate(func, population)))\n                    if random.random() < probability:\n                        mutation = random.uniform(-1, 1)\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.probability_informed_mutation(population, func)\n        return population[0]", "name": "ADDE_PM", "description": "Adaptive-Diffusion-Driven Evolution with Probability-Informed Mutation (ADDE-PM) - A novel metaheuristic algorithm that combines adaptive diffusion, driven evolution, and probability-informed mutation to efficiently explore and exploit the search space.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 24 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 24 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "405fe9f9-a328-42da-9aee-1b4dc64bbbf7", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.diffusion_probability = 0.1\n        self.driven_evolution_probability = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            if random.random() < self.diffusion_probability:\n                parent_idx = random.randint(0, self.population_size - 1)\n                offspring = population[parent_idx].copy()\n                for j in range(self.dim):\n                    if random.random() < self.diffusion_rate:\n                        offspring[j] += random.uniform(-1, 1)\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n                new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            if random.random() < self.driven_evolution_probability:\n                parent_idx = random.randint(0, self.population_size - 1)\n                offspring = population[parent_idx].copy()\n                for j in range(self.dim):\n                    if random.random() < self.driven_evolution_rate:\n                        mutation = random.uniform(-1, 1)\n                        if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                            offspring[j] += mutation\n                            if offspring[j] < self.search_space[0]:\n                                offspring[j] = self.search_space[0]\n                            elif offspring[j] > self.search_space[1]:\n                                offspring[j] = self.search_space[1]\n                new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability control to efficiently explore and exploit the search space with a probability of 0.1 for diffusion and 0.05 for driven evolution.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 48 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 48 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "db64d9b6-a34b-4ecf-a916-656c9caae24d", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_adjustment = 0.01\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def probability_adjustment(self, func, population):\n        fitness = self.evaluate(func, population)\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.probability_adjustment:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            population[i] = offspring\n        return population\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.probability_adjustment(func, population)\n        return population[0]", "name": "ADDE", "description": "Novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability adjustment to efficiently explore and exploit the search space.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 40 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 40 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "a70d0782-6047-4e20-a528-2fbca94461ac", "solution": "import numpy as np\nimport random\n\nclass ADDE_PA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.prob_adjustment_rate = 0.1\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def adjust_probabilities(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        top_idx = sorted_idx[:self.num_parents]\n        bottom_idx = sorted_idx[-self.num_offspring:]\n        for i in range(self.num_offspring):\n            parent_idx = random.choice(top_idx)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.prob_adjustment_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            population[bottom_idx[i]] = offspring\n        return population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.adjust_probabilities(population, func)\n        return population[0]", "name": "ADDE_PA", "description": "Adaptive-Diffusion-Driven Evolution with Probability Adjustment (ADDE-PA) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability adjustment to efficiently explore and exploit the search space.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 44 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 44 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "c3db154e-a927-451e-b4aa-d8511269e2c5", "solution": "import numpy as np\nimport random\n\nclass ADDE_PB:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.mutation_rate = 0.05\n        self.adaptive_mutation_rate = 0.01\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.mutation_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def adaptive_mutation(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.adaptive_mutation_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n                    self.mutation_rate += 0.001\n                    if self.mutation_rate > 0.1:\n                        self.mutation_rate = 0.1\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.adaptive_mutation(population, func)\n        return population[0]", "name": "ADDE_PB", "description": "Adaptive-Diffusion-Driven Evolution with Probability-Based Selection and Adaptive Mutation Rates (ADDE-PB)", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 13 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 13 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "952be2c3-31fb-4522-97af-6b0d698ef5cd", "solution": "import numpy as np\nimport random\n\nclass ADDE_PBD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.diffusion_prob = 0.5  # probability of diffusion\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            if random.random() < self.diffusion_prob:\n                for j in range(self.dim):\n                    if random.random() < self.diffusion_rate:\n                        offspring[j] += random.uniform(-1, 1)\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE_PBD", "description": "Adaptive-Diffusion-Driven Evolution with Probability-Based Diffusion (ADDE-PBD): A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability-based diffusion to efficiently explore and exploit the search space.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 27 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 27 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "6f15e0d4-897f-47de-84a7-7fdc14f908da", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_control_rate = 0.1  # New parameter for probability control\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def probability_control(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.probability_control_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.probability_control(population, func)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability control to efficiently explore and exploit the search space.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 44 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 44 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "fae2164f-09a0-4985-8220-da8eb08e0bec", "solution": "import numpy as np\nimport random\n\nclass ADDE_PA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_adjustment_rate = 0.01\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def probability_adjustment(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        top_idx = sorted_idx[:int(0.1 * self.population_size)]\n        for i in top_idx:\n            self.diffusion_rate *= (1 + self.probability_adjustment_rate)\n            self.driven_evolution_rate *= (1 + self.probability_adjustment_rate)\n        return population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.probability_adjustment(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE_PA", "description": "Adaptive-Diffusion-Driven Evolution with Probability Adjustment (ADDE-PA) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability adjustment to efficiently explore and exploit the search space.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 21 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 21 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "e45b6c40-5698-4ea4-868a-c6762fe43508", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "e56f481f-083c-4427-a6f7-4451ff197339", "solution": "import numpy as np\nimport random\n\nclass ADDE_PA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_adjustment_rate = 0.01\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def probability_adjustment(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.probability_adjustment_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            population[i] = offspring\n        return population\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.probability_adjustment(population, func)\n        return population[0]", "name": "ADDE_PA", "description": "Adaptive-Diffusion-Driven Evolution with Probability Adjustment (ADDE-PA) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability adjustment to efficiently explore and exploit the search space.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 29 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 29 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "5b20c2bd-7555-4df7-aee4-08c38480799a", "solution": "import numpy as np\nimport random\n\nclass ADDE_AP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_rate = 0.1\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            prob = random.random()\n            if prob < self.probability_rate:\n                for j in range(self.dim):\n                    if random.random() < self.diffusion_rate:\n                        offspring[j] += random.uniform(-1, 1)\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            prob = random.random()\n            if prob < self.probability_rate:\n                for j in range(self.dim):\n                    if random.random() < self.driven_evolution_rate:\n                        mutation = random.uniform(-1, 1)\n                        if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                            offspring[j] += mutation\n                            if offspring[j] < self.search_space[0]:\n                                offspring[j] = self.search_space[0]\n                            elif offspring[j] > self.search_space[1]:\n                                offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE_AP", "description": "Adaptive-Diffusion-Driven Evolution with Adaptive Probability (ADDE-AP) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with adaptive probability to efficiently explore and exploit the search space.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 25 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 25 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "7c3e8831-f692-4d98-bf24-af300fe089a6", "solution": "import numpy as np\nimport random\n\nclass ADDE_PC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_control_rate = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def probability_control(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            if random.random() < self.probability_control_rate:\n                parent_idx = random.randint(0, self.population_size - 1)\n                offspring = population[parent_idx].copy()\n                for j in range(self.dim):\n                    mutation = random.uniform(-1, 1)\n                    offspring[j] += mutation\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n                new_population[i] = offspring\n        return new_population\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.probability_control(population)\n        return population[0]", "name": "ADDE_PC", "description": "This novel metaheuristic algorithm, called Adaptive-Diffusion-Driven Evolution with Probability Control (ADDE-PC), combines adaptive diffusion and driven evolution with probability control to efficiently explore and exploit the search space.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 33 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 33 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "8b10c094-b5e8-42d6-b465-31228e653642", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.mutation_probability = 0.5  # new parameter\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if random.random() < self.mutation_probability:  # new mutation probability\n                        if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                            offspring[j] += mutation\n                            if offspring[j] < self.search_space[0]:\n                                offspring[j] = self.search_space[0]\n                            elif offspring[j] > self.search_space[1]:\n                                offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) with Probability-Controlled Mutation", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 22 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 22 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "9a7e3b1e-9915-473e-85aa-2cf1335e1788", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability = 0.5  # probability to change individual in diffusion process\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.probability:  # probability-driven diffusion process\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Novel Adaptive-Diffusion-Driven Evolution (ADDE) algorithm that incorporates a probability-driven diffusion process and adaptive driven evolution to balance exploration and exploitation.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 20 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 20 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "875832ab-c3d2-4d7e-a4e4-714b19bd7223", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "c73ad537-e409-41dc-ac66-73d65c0e2e73", "solution": "import numpy as np\nimport random\n\nclass ADDE_PBS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.mutation_rate = 0.2\n        self.probability_threshold = 0.17\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def probability_based_mutation(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.mutation_rate:\n                    if random.random() < self.probability_threshold:\n                        mutation = random.uniform(-1, 1)\n                        if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                            offspring[j] += mutation\n                            if offspring[j] < self.search_space[0]:\n                                offspring[j] = self.search_space[0]\n                            elif offspring[j] > self.search_space[1]:\n                                offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.probability_based_mutation(population, func)\n        return population[0]", "name": "ADDE_PBS", "description": "Adaptive-Diffusion-Driven Evolution with Probability-Based Mutation and Selection (ADDE-PBS)", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 13 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 13 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "80212b6f-7cbe-4b8a-ab25-55f122509f51", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "86c25dba-afa8-41cc-af59-bcec0aba16fa", "solution": "import numpy as np\nimport random\n\nclass ADDE_P:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.mutation_rate = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def probabilistic_mutation(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.mutation_rate:\n                    mutation = random.uniform(-1, 1)\n                    if random.random() < 0.5:\n                        offspring[j] += mutation\n                    else:\n                        offspring[j] -= mutation\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.probabilistic_mutation(population, func)\n        return population[0]", "name": "ADDE_P", "description": "Adaptive-Diffusion-Driven Evolution with Probabilistic Mutation (ADDE-P) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probabilistic mutation to efficiently explore and exploit the search space.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "8879f333-3391-4d31-842f-094bcf355c39", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_adjustment_rate = 0.1  # new parameter\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def probability_adjustment(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        top_idx = sorted_idx[:int(0.1 * self.population_size)]  # top 10%\n        bottom_idx = sorted_idx[-int(0.1 * self.population_size):]  # bottom 10%\n        for i in top_idx:\n            self.diffusion_rate += self.probability_adjustment_rate\n        for i in bottom_idx:\n            self.diffusion_rate -= self.probability_adjustment_rate\n        if self.diffusion_rate < 0:\n            self.diffusion_rate = 0\n        elif self.diffusion_rate > 1:\n            self.diffusion_rate = 1\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.probability_adjustment(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability adjustment to efficiently explore and exploit the search space.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'NoneType' object has no attribute 'copy'\").", "error": "AttributeError(\"'NoneType' object has no attribute 'copy'\")", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "dd3ec06c-8f00-459b-b5c6-7d1b451cdcc3", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_control_rate = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def probability_control(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.probability_control_rate:\n                    if random.random() < 0.5:\n                        offspring[j] += random.uniform(-1, 1)\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n                    else:\n                        mutation = random.uniform(-1, 1)\n                        if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                            offspring[j] += mutation\n                            if offspring[j] < self.search_space[0]:\n                                offspring[j] = self.search_space[0]\n                            elif offspring[j] > self.search_space[1]:\n                                offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.probability_control(population, func)\n        return population[0]", "name": "ADDE", "description": "A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability control to efficiently explore and exploit the search space.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "30c7b11e-a9b5-488f-aa5f-5355921cc07a", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.mutation_rate = 0.05  # new parameter\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def mutation(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.mutation_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.mutation(population, func)  # new line\n        return population[0]", "name": "ADDE", "description": "A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space, with a probability-based mutation operator to refine its strategy.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 14 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 14 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "6d34f13c-50ab-4dfe-bf2a-d613b1e1b954", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.replacement_rate = 0.5  # probability of replacing an offspring with a parent\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def replace_offspring(self, population, new_population):\n        for i in range(self.num_offspring):\n            if random.random() < self.replacement_rate:\n                population[i] = new_population[i]\n        return population\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            new_population = self.diffusion(population)\n            new_population = self.driven_evolution(new_population, func)\n            population = self.replace_offspring(population, new_population)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution with probability-based offspring replacement", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 16 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 16 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "7ecb9289-5b59-456d-85eb-fc8d4bc78854", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "178a2c83-74e7-4baa-9cf8-707966b97962", "solution": "import numpy as np\nimport random\n\nclass ADDE_PDM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.pdm_rate = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def probability_driven_mutation(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.pdm_rate:\n                    mutation = random.uniform(-1, 1)\n                    offspring[j] += mutation\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n                    if random.random() < 0.5:\n                        offspring[j] += random.uniform(-1, 1)\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.probability_driven_mutation(population, func)\n        return population[0]", "name": "ADDE_PDM", "description": "Adaptive-Diffusion-Driven Evolution with Probability-Driven Mutation (ADDE-PDM) - A novel metaheuristic algorithm that combines adaptive diffusion, driven evolution, and probability-driven mutation to efficiently explore and exploit the search space.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 11 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 11 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "5db143fe-cd84-4c6b-806d-12c526c82f5b", "solution": "import numpy as np\nimport random\n\nclass ADDE_PM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.mutation_rate = 0.5  # new parameter\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def probabilistic_mutation(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.mutation_rate:\n                    mutation = random.uniform(-1, 1)\n                    offspring[j] += mutation\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.probabilistic_mutation(population)\n        return population[0]", "name": "ADDE_PM", "description": "Adaptive-Diffusion-Driven Evolution with Probabilistic Mutation (ADDE-PM) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probabilistic mutation to efficiently explore and exploit the search space.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 41 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 41 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "3e826ad0-4337-496e-9ff3-166781a980c1", "solution": "import numpy as np\nimport random\n\nclass ADDEAMP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.mutation_rate = 0.1\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def adaptive_mutation_probability(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        parents = population[sorted_idx[:self.num_parents]]\n        offspring = []\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.num_parents - 1)\n            offspring_idx = random.randint(0, self.num_parents - 1)\n            parent = parents[parent_idx].copy()\n            offspring_idx = sorted_idx[self.num_parents + i]\n            offspring_offspring = population[offspring_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.mutation_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring_offspring + mutation * np.array([0] * self.dim)) < func(offspring_offspring):\n                        offspring_offspring[j] += mutation\n                        if offspring_offspring[j] < self.search_space[0]:\n                            offspring_offspring[j] = self.search_space[0]\n                        elif offspring_offspring[j] > self.search_space[1]:\n                            offspring_offspring[j] = self.search_space[1]\n            offspring.append(offspring_offspring)\n        return np.array(offspring)\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.adaptive_mutation_probability(population, func)\n        return population[0]", "name": "ADDEAMP", "description": "Adaptive-Diffusion-Driven Evolution with Adaptive Mutation Probability (ADDE-AMP) - A novel metaheuristic algorithm that combines adaptive diffusion, driven evolution, and adaptive mutation probability to efficiently explore and exploit the search space.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 49 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 49 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "d4609953-7a7a-496e-b479-2f54003edc17", "solution": "import numpy as np\nimport random\n\nclass ADDE_PWS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_threshold = 0.5\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def probability_weighted_selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        probabilities = np.linspace(0, 1, self.population_size)\n        probabilities[sorted_idx] = np.sort(probabilities[sorted_idx])\n        new_population = population.copy()\n        for i in range(self.num_parents):\n            parent_idx = np.random.choice(self.population_size, p=probabilities)\n            new_population[i] = population[parent_idx]\n        return new_population\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.probability_weighted_selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE_PWS", "description": "Adaptive-Diffusion-Driven Evolution with Probability-Weighted Selection (ADDE-PWS) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability-weighted selection to efficiently explore and exploit the search space.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities do not sum to 1').", "error": "ValueError('probabilities do not sum to 1')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "39505ff8-3630-4107-b1fd-bd7f50bc3701", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "f08e7c1f-6d21-4c28-9781-707f2261b2ff", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.mutation_rate = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def probability_driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    prob = 1 / (1 + np.exp(-(func(offspring + mutation * np.array([0] * self.dim)) - func(offspring)) / (self.diffusion_rate * self.dim)))\n                    if random.random() < prob:\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def probability_controlled_mutation(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.mutation_rate:\n                    mutation = random.uniform(-1, 1)\n                    prob = 1 / (1 + np.exp(-(func(offspring + mutation * np.array([0] * self.dim)) - func(offspring)) / (self.diffusion_rate * self.dim)))\n                    if random.random() < prob:\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.probability_driven_evolution(population, func)\n            population = self.probability_controlled_mutation(population, func)\n        return population[0]", "name": "ADDE", "description": "A novel metaheuristic algorithm that combines Adaptive Diffusion and Probability-Driven Evolution with Probability-Controlled Mutation to efficiently explore and exploit the search space.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 12 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 12 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "7bfb149d-5f28-40e6-a4f0-1f0eee3ac628", "solution": "import numpy as np\nimport random\n\nclass ADDE_PA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_adjustment_rate = 0.1\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def probability_adjustment(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        for i in range(self.num_offspring):\n            parent_idx = sorted_idx[i]\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.probability_adjustment_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            population[parent_idx] = offspring\n        return population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.probability_adjustment(population, func)\n        return population[0]", "name": "ADDE_PA", "description": "This novel heuristic algorithm, called Adaptive-Diffusion-Driven Evolution with Probability Adjustment (ADDE-PA), combines adaptive diffusion and driven evolution with a probability adjustment mechanism to efficiently explore and exploit the search space.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 20 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 20 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "597025e5-2f25-4fe4-a24d-5a7e96c52f06", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.tournament_size = 5\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def tournament_selection(self, population, func):\n        selected_idx = []\n        for _ in range(self.num_parents):\n            tournament_idx = random.sample(range(self.population_size), self.tournament_size)\n            winner_idx = np.argmin([func(population[i]) for i in tournament_idx])\n            selected_idx.append(tournament_idx[winner_idx])\n        return [population[i] for i in selected_idx]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.tournament_selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution with probabilistic diffusion and driven evolution rates, and a novel selection strategy using the tournament selection method.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "161f1c9e-68d5-4054-b2c1-1b943ea73238", "solution": "import numpy as np\nimport random\n\nclass ADDE_PCM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.mutation_rate = 0.1\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def probability_controlled_mutation(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.mutation_rate:\n                    mutation = random.uniform(-1, 1)\n                    offspring[j] += mutation\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n                    if random.random() < 0.5:\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.probability_controlled_mutation(population, func)\n        return population[0]", "name": "ADDE_PCM", "description": "Adaptive-Diffusion-Driven Evolution with Probability-Controlled Mutation (ADDE-PCM) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability-controlled mutation to efficiently explore and exploit the search space.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 44 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 44 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "1c42a4f6-dea5-4427-81f7-7d6be2ef62cb", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.selection_rate = 0.5\n        self.mutation_rate = 0.5\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.mutation_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def update_rates(self):\n        self.diffusion_rate = 0.1 + (random.random() - 0.5) * 0.1\n        self.driven_evolution_rate = 0.05 + (random.random() - 0.5) * 0.05\n        self.selection_rate = 0.5 + (random.random() - 0.5) * 0.5\n        self.mutation_rate = 0.5 + (random.random() - 0.5) * 0.5\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            self.update_rates()\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution with probability-based selection and mutation rates.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 44 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 44 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "14bf88ba-3c46-4c09-ab87-57e04ceafc8b", "solution": "import numpy as np\nimport random\n\nclass ADDE_PA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.prob_adjustment_rate = 0.1\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def prob_adjustment(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.prob_adjustment_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n                        self.diffusion_rate *= 1.1\n                        self.driven_evolution_rate *= 1.1\n                        self.prob_adjustment_rate *= 1.1\n            new_population[i] = offspring\n        return new_population\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.prob_adjustment(population, func)\n        return population[0]", "name": "ADDE_PA", "description": "Adaptive-Diffusion-Driven Evolution with Probability Adjustment (ADDE-PA) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability adjustment to efficiently explore and exploit the search space.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 47 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 47 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "bdd4c212-84f2-4c6f-ba14-7e2e327b0107", "solution": "import numpy as np\nimport random\n\nclass ADDE_PR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.refinement_rate = 0.5  # probability of mutation refinement\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            if random.random() < self.refinement_rate:  # probability of mutation refinement\n                for k in range(self.dim):\n                    if random.random() < 0.1:  # 10% chance of refinement\n                        refinement = random.uniform(-0.1, 0.1)\n                        offspring[k] += refinement\n                        if offspring[k] < self.search_space[0]:\n                            offspring[k] = self.search_space[0]\n                        elif offspring[k] > self.search_space[1]:\n                            offspring[k] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE_PR", "description": "Adaptive-Diffusion-Driven Evolution with Probability of Mutation Refinement (ADDE-PR) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with a probability of mutation refinement to efficiently explore and exploit the search space.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 47 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 47 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "7aae1bfb-71d2-4e88-b0a2-40be1b9a7003", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_change_individual = 1.0\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            if random.random() < self.probability_change_individual:\n                new_parent_idx = random.randint(0, self.population_size - 1)\n                new_offspring = population[new_parent_idx].copy()\n                for k in range(self.dim):\n                    if random.random() < self.diffusion_rate:\n                        new_offspring[k] += random.uniform(-1, 1)\n                        if new_offspring[k] < self.search_space[0]:\n                            new_offspring[k] = self.search_space[0]\n                        elif new_offspring[k] > self.search_space[1]:\n                            new_offspring[k] = self.search_space[1]\n                new_population[i] = new_offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            if random.random() < self.probability_change_individual:\n                new_parent_idx = random.randint(0, self.population_size - 1)\n                new_offspring = population[new_parent_idx].copy()\n                for k in range(self.dim):\n                    if random.random() < self.driven_evolution_rate:\n                        mutation = random.uniform(-1, 1)\n                        if func(new_offspring + mutation * np.array([0] * self.dim)) < func(new_offspring):\n                            new_offspring[k] += mutation\n                            if new_offspring[k] < self.search_space[0]:\n                                new_offspring[k] = self.search_space[0]\n                            elif new_offspring[k] > self.search_space[1]:\n                                new_offspring[k] = self.search_space[1]\n                new_population[i] = new_offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space, with the probability of changing an individual set to 1 to refine its strategy.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 12 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 12 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "45f9e1d9-2c1a-4e5c-b73f-c3d91ff67a36", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "c80218ac-de18-4b3c-b54c-30b6e3463e01", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "0bf59324-08a8-4f23-9895-91080dee532b", "solution": "import numpy as np\nimport random\n\nclass ADDE_PA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_adjustment_rate = 0.01\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def probability_adjustment(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        best_individual = population[sorted_idx[-1]]\n        worst_individual = population[sorted_idx[0]]\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.probability_adjustment_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            if random.random() < 0.5:\n                offspring = (best_individual + offspring) / 2\n            else:\n                offspring = (worst_individual + offspring) / 2\n            population[i] = offspring\n        return population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.probability_adjustment(population, func)\n        return population[0]", "name": "ADDE_PA", "description": "Novel Adaptive-Diffusion-Driven Evolution with Probability Adjustment (ADDE-PA) combines adaptive diffusion and driven evolution with a probability adjustment mechanism to efficiently explore and exploit the search space, while refining the strategy by adjusting the probability of mutation and diffusion.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 11 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 11 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "18ec8328-9a24-48f1-9685-5862352c5db9", "solution": "import numpy as np\nimport random\n\nclass ADDE_P:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.mutation_rate = 0.1\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def probabilistic_mutation(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.mutation_rate:\n                    mutation = random.uniform(-1, 1)\n                    offspring[j] += mutation\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n                    if func(offspring) < func(population[parent_idx]):\n                        new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.probabilistic_mutation(population, func)\n        return population[0]", "name": "ADDE_P", "description": "Adaptive-Diffusion-Driven Evolution with Probabilistic Mutation (ADDE-P) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probabilistic mutation to efficiently explore and exploit the search space.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 15 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 15 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "ed95e4b8-cfca-4412-8802-fe129dc4e632", "solution": "import numpy as np\nimport random\n\nclass ADDE_PDM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.mutation_rate = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def probability_driven_mutation(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.mutation_rate:\n                    mutation = random.uniform(-1, 1)\n                    if random.random() < 0.5:\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n                    else:\n                        offspring[j] -= mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.probability_driven_mutation(population, func)\n        return population[0]", "name": "ADDE_PDM", "description": "Adaptive-Diffusion-Driven Evolution with Probability-Driven Mutation (ADDE-PDM) - A novel metaheuristic algorithm that combines adaptive diffusion, driven evolution, and probability-driven mutation to efficiently explore and exploit the search space.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 45 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 45 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "1dc801d9-ffbd-41c7-95e6-539fc781e7eb", "solution": "import numpy as np\nimport random\n\nclass ADDEPC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_control_rate = 0.8  # probability control rate\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def probability_control(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.probability_control_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.probability_control(population, func)\n        return population[0]", "name": "ADDEPC", "description": "Adaptive-Diffusion-Driven Evolution with Probability Control (ADDE-PC) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability control to efficiently explore and exploit the search space.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "7f5fbc89-bfcf-4dcf-89d7-5b7955de5d9c", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_adjustment_rate = 0.01\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def probability_adjustment(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        for i in range(self.num_parents, self.population_size):\n            if random.random() < self.probability_adjustment_rate:\n                parent_idx = random.randint(0, self.num_parents - 1)\n                offspring = population[parent_idx].copy()\n                for j in range(self.dim):\n                    mutation = random.uniform(-1, 1)\n                    offspring[j] += mutation\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n                population[i] = offspring\n        return population\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.probability_adjustment(population, func)\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability adjustment to efficiently explore and exploit the search space.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 42 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 42 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "c183649d-e50f-4ce5-9d1d-d5b14d7c1525", "solution": "import numpy as np\nimport random\n\nclass ADDE_PBDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_threshold = 0.7  # New parameter for probability-based driven evolution\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if random.random() < self.probability_threshold:  # New probability-based mutation\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE_PBDE", "description": "Adaptive-Diffusion-Driven Evolution with Probability-Based Driven Evolution (ADDE-PBDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability-based mutation to efficiently explore and exploit the search space.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 38 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 38 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "e036960d-546d-4b22-9bcb-3e3ff89cc70d", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "4e6e7aed-81a0-4dfa-a03b-a0b850f2ae51", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability = 0.17  # probability to change individual\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.choices(range(self.population_size), weights=np.exp(-self.evaluate(func, population)), k=1)[0]\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.choices(range(self.population_size), weights=np.exp(-self.evaluate(func, population)), k=1)[0]\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n            if random.random() < self.probability:\n                new_population[i] = np.random.uniform(self.search_space[0], self.search_space[1], self.dim)\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution with Probability-Based Parent Selection and Offspring Replacement.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The number of weights does not match the population').", "error": "ValueError('The number of weights does not match the population')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "2ee499ad-c650-4c61-b501-a06adbdd0882", "solution": "import numpy as np\nimport random\n\nclass ADDE_PC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_control_rate = 0.8\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if random.random() < self.probability_control_rate and func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE_PC", "description": "The novel Adaptive-Diffusion-Driven Evolution with Probability Control (ADDE-PC) algorithm combines adaptive diffusion and driven evolution with probability control to efficiently explore and exploit the search space.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 32 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 32 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "9e8cb008-a2be-44f8-ab67-4880a128e968", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        selection_probabilities = 1 / (1 + np.exp(-fitness[sorted_idx] + fitness[sorted_idx[-1]]))\n        selection_probabilities /= selection_probabilities.sum()\n        selected_idx = np.random.choice(self.population_size, self.num_parents, p=selection_probabilities)\n        return population[sorted_idx[selected_idx]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution with Probability-Based Individual Selection", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 12 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 12 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "2b6367a3-9a67-4ff6-aed1-7c66317d0f08", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_control_rate = 0.2  # New parameter for probability control\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def probability_control(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            if random.random() < self.probability_control_rate:\n                parent_idx = random.randint(0, self.population_size - 1)\n                offspring = population[parent_idx].copy()\n                for j in range(self.dim):\n                    mutation = random.uniform(-1, 1)\n                    offspring[j] += mutation\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n                new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.probability_control(population, func)  # Add probability control\n        return population[0]", "name": "ADDE", "description": "A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability control to efficiently explore and exploit the search space.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 13 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 13 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "4a11dc23-1c25-4021-bbc9-73ad7d54e32f", "solution": "import numpy as np\nimport random\n\nclass ADDE_PA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.probability_adjustment_rate = 0.01\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def probability_adjustment(self, population, func):\n        fitness = self.evaluate(func, population)\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.probability_adjustment_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            population[i] = offspring\n        return population\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.probability_adjustment(population, func)\n        return population[0]", "name": "ADDE_PA", "description": "Adaptive-Diffusion-Driven Evolution with Probability Adjustment (ADDE-PA) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability adjustment to efficiently explore and exploit the search space.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 18 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 18 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "41cf0c48-e5fc-4eb2-85b8-47807a859dab", "solution": "import numpy as np\nimport random\n\nclass ADDE_DPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.prob_adjustment_rate = 0.01\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def adjust_probabilities(self, population, func):\n        fitness = self.evaluate(func, population)\n        self.diffusion_rate = max(0.01, self.diffusion_rate - self.prob_adjustment_rate * np.mean(fitness))\n        self.driven_evolution_rate = max(0.01, self.driven_evolution_rate - self.prob_adjustment_rate * np.mean(fitness))\n        self.prob_adjustment_rate = max(0.001, self.prob_adjustment_rate * 0.9)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            self.adjust_probabilities(population, func)\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE_DPA", "description": "Adaptive-Diffusion-Driven Evolution with Dynamic Probability Adjustment (ADDE-DPA) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with dynamic probability adjustment to efficiently explore and exploit the search space.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 22 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 22 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "e5dbf77f-8b9f-45a8-a62f-76a20d77650f", "solution": "import numpy as np\nimport random\n\nclass ADDE_PCM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.mutation_rate = 0.5\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.diffusion_rate:\n                    offspring[j] += random.uniform(-1, 1)\n                    if offspring[j] < self.search_space[0]:\n                        offspring[j] = self.search_space[0]\n                    elif offspring[j] > self.search_space[1]:\n                        offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.driven_evolution_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def probability_controlled_mutation(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            for j in range(self.dim):\n                if random.random() < self.mutation_rate:\n                    mutation = random.uniform(-1, 1)\n                    if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                        offspring[j] += mutation\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n            population = self.probability_controlled_mutation(population, func)\n        return population[0]", "name": "ADDE_PCM", "description": "Adaptive-Diffusion-Driven Evolution with Probability-Controlled Mutation (ADDE-PCM) - A novel metaheuristic algorithm that combines adaptive diffusion and driven evolution with probability-controlled mutation to efficiently explore and exploit the search space.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 34 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 34 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "772cae62-6191-4867-bcfa-13c4f0738141", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.diffusion_prob = 0.5\n        self.driven_evolution_prob = 0.5\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            if random.random() < self.diffusion_prob:\n                for j in range(self.dim):\n                    if random.random() < self.diffusion_rate:\n                        offspring[j] += random.uniform(-1, 1)\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            parent_idx = random.randint(0, self.population_size - 1)\n            offspring = population[parent_idx].copy()\n            if random.random() < self.driven_evolution_prob:\n                for j in range(self.dim):\n                    if random.random() < self.driven_evolution_rate:\n                        mutation = random.uniform(-1, 1)\n                        if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                            offspring[j] += mutation\n                            if offspring[j] < self.search_space[0]:\n                                offspring[j] = self.search_space[0]\n                            elif offspring[j] > self.search_space[1]:\n                                offspring[j] = self.search_space[1]\n            new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution (ADDE) with probability-based selection and mutation rates.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 32 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 32 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
{"id": "edfdcde8-4ade-49d8-ad27-fb7fc59d8f70", "solution": "import numpy as np\nimport random\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.search_space = [-5.0, 5.0]\n        self.population_size = 50\n        self.num_parents = int(0.2 * self.population_size)\n        self.num_offspring = self.population_size - self.num_parents\n        self.diffusion_rate = 0.1\n        self.driven_evolution_rate = 0.05\n        self.selection_probability = 0.8\n\n    def initialize_population(self):\n        return np.random.uniform(self.search_space[0], self.search_space[1], (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        return np.array([func(ind) for ind in population])\n\n    def diffusion(self, population):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            if random.random() < self.selection_probability:\n                parent_idx = random.randint(0, self.population_size - 1)\n                offspring = population[parent_idx].copy()\n                for j in range(self.dim):\n                    if random.random() < self.diffusion_rate:\n                        offspring[j] += random.uniform(-1, 1)\n                        if offspring[j] < self.search_space[0]:\n                            offspring[j] = self.search_space[0]\n                        elif offspring[j] > self.search_space[1]:\n                            offspring[j] = self.search_space[1]\n                new_population[i] = offspring\n        return new_population\n\n    def driven_evolution(self, population, func):\n        new_population = population.copy()\n        for i in range(self.num_offspring):\n            if random.random() < self.selection_probability:\n                parent_idx = random.randint(0, self.population_size - 1)\n                offspring = population[parent_idx].copy()\n                for j in range(self.dim):\n                    if random.random() < self.driven_evolution_rate:\n                        mutation = random.uniform(-1, 1)\n                        if func(offspring + mutation * np.array([0] * self.dim)) < func(offspring):\n                            offspring[j] += mutation\n                            if offspring[j] < self.search_space[0]:\n                                offspring[j] = self.search_space[0]\n                            elif offspring[j] > self.search_space[1]:\n                                offspring[j] = self.search_space[1]\n                new_population[i] = offspring\n        return new_population\n\n    def selection(self, population, func):\n        fitness = self.evaluate(func, population)\n        sorted_idx = np.argsort(fitness)\n        return population[sorted_idx[:self.num_parents]]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        for _ in range(self.budget):\n            population = self.selection(population, func)\n            population = self.diffusion(population)\n            population = self.driven_evolution(population, func)\n        return population[0]", "name": "ADDE", "description": "Adaptive-Diffusion-Driven Evolution with Probability-Based Individual Selection", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 21 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 21 is out of bounds for axis 0 with size 10')", "parent_id": "d9396a27-4f87-4533-9d9d-453291ba76b8", "metadata": {}, "mutation_prompt": null}
