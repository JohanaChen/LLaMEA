{"id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate (ADE-SACPLR)", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 83, in evaluateBBOB\n    np.save(f\"currentexp/aucs-{algorithm_name}-{i}.npy\", aucs)\n  File \"/root/LLaMEA/venv/lib/python3.11/site-packages/numpy/lib/npyio.py\", line 542, in save\n    file_ctx = open(file, \"wb\")\n               ^^^^^^^^^^^^^^^^\nFileNotFoundError: [Errno 2] No such file or directory: 'currentexp/aucs-ADE_SACPLR-0.npy'\n.", "error": "FileNotFoundError(2, 'No such file or directory')Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 83, in evaluateBBOB\n    np.save(f\"currentexp/aucs-{algorithm_name}-{i}.npy\", aucs)\n  File \"/root/LLaMEA/venv/lib/python3.11/site-packages/numpy/lib/npyio.py\", line 542, in save\n    file_ctx = open(file, \"wb\")\n               ^^^^^^^^^^^^^^^^\nFileNotFoundError: [Errno 2] No such file or directory: 'currentexp/aucs-ADE_SACPLR-0.npy'\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "ee9df995-034f-4392-8693-86463517258a", "solution": "import numpy as np\nimport random\n\nclass ADE_SNSSLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.neighborhood_size = int(self.population_size * 0.2)\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            # Stochastic Neighborhood Search\n            neighborhood = random.sample(range(self.population_size), self.neighborhood_size)\n            for k in neighborhood:\n                if k!= idx:\n                    x_new = self.x[k] + self.F * (self.x[idx] - self.x[k])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[k]:\n                        self.x[k] = x_new\n                        self.fitness[k] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SNSSLR", "description": "Adaptive Differential Evolution with Stochastic Neighborhood Search and Self-Adaptive Learning Rate (ADE-SNSSLR) - A novel hybrid metaheuristic algorithm that combines the exploration capabilities of Stochastic Neighborhood Search with the exploitation capabilities of Adaptive Differential Evolution and Self-Adaptive Learning Rate.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "3a355e1c-541e-4b66-b777-968a18ae0d25", "solution": "import numpy as np\nimport random\n\nclass AMMHSCPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.harm_rate = 0.5\n        self.harmony_memory_size = 10\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            # Update harmony memory\n            for k in range(self.harmony_memory_size):\n                r = random.random()\n                if r < self.harm_rate:\n                    self.harmony_memory[k] = self.x[np.argmin(self.fitness)]\n                else:\n                    self.harmony_memory[k] = np.clip(self.harmony_memory[k] + self.harm_rate * (self.x[np.argmin(self.fitness)] - self.harmony_memory[k]), self.lower_bound, self.upper_bound)\n            # Update parameters\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        # Select best individual from harmony memory\n        best_harmony_idx = np.argmin([func(x) for x in self.harmony_memory])\n        return self.harmony_memory[best_harmony_idx], func(self.harmony_memory[best_harmony_idx])", "name": "AMMHSCPLR", "description": "Adaptive Multi-Modal Harmony Search with Self-Adaptive Parameters and Crossover Probability Learning Rate (AMMHSCPLR) - A novel metaheuristic algorithm that combines harmony search and adaptive differential evolution with a self-adaptive crossover probability and learning rate to solve black box optimization problems.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "6244af0e-4199-4853-9efb-da2f4d072c10", "solution": "import numpy as np\nimport random\n\nclass DAMEHL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.num_ensembles = 5\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.sigma = 0.1\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim, self.num_ensembles))\n        self.fitness = np.inf * np.ones((self.population_size, self.num_ensembles))\n        self.best_x = np.inf * np.ones((self.dim, self.num_ensembles))\n        self.best_fitness = np.inf * np.ones(self.num_ensembles)\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            for j in range(self.num_ensembles):\n                y = func(self.x[:, :, j])\n                self.fitness[:, j] = y\n                idx = np.argmin(y)\n                self.best_x[:, j] = self.x[idx, :, j]\n                self.best_fitness[j] = y[idx]\n            for k in range(self.population_size):\n                for l in range(self.num_ensembles):\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == k or r2 == k or r3 == k:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1, :, l] + self.F * (self.x[r2, :, l] - self.x[r3, :, l])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[k, l]:\n                        self.x[k, :, l] = x_new\n                        self.fitness[k, l] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[np.argmin(self.fitness[:, 0]), 0])\n            if np.min(self.fitness[:, 0]) < self.best_fitness[0]:\n                self.best_fitness[0] = np.min(self.fitness[:, 0])\n                self.best_x[:, 0] = self.x[np.argmin(self.fitness[:, 0]), :, 0]\n        return self.best_x[:, 0], self.best_fitness[0]\n\n    def update_strategy(self, probability):\n        if random.random() < probability:\n            self.learning_rate = self.learning_rate * 0.9\n            self.crossover_probability = self.crossover_probability * 0.9\n            self.sigma = self.sigma * 0.9\n        else:\n            self.learning_rate = self.learning_rate * 1.1\n            self.crossover_probability = self.crossover_probability * 1.1\n            self.sigma = self.sigma * 1.1", "name": "DAMEHL", "description": "Novel \"Dynamically-Adaptive Multi-Agent Ensembles with Hierarchical Learning\" (DAMEHL) algorithm, which adaptively adjusts the learning rate and strategy of multiple ensembles to efficiently explore and exploit the search space.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'DAMEHL' object has no attribute 'F'\").", "error": "AttributeError(\"'DAMEHL' object has no attribute 'F'\")", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "96e7f904-f0bc-4f4f-8a4f-b02ef46c0e25", "solution": "import numpy as np\nimport random\n\nclass HHSADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.harmony_memory_size = 20\n        self.harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.pruning_rate = 0.10869565217391304\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.harmony_memory)\n            idx = np.argmin(y)\n            self.best_x = self.harmony_memory[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.harmony_memory_size):\n                if random.random() < self.pruning_rate:\n                    self.harmony_memory[j] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for j in range(self.harmony_memory_size):\n                r1, r2 = random.sample(range(self.harmony_memory_size), 2)\n                while r1 == r2:\n                    r1, r2 = random.sample(range(self.harmony_memory_size), 2)\n                x_new = self.harmony_memory[r1] + self.F * (self.harmony_memory[r2] - self.best_x)\n                x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                y_new = func(x_new)\n                if y_new < self.best_fitness:\n                    self.best_x = x_new\n                    self.best_fitness = y_new\n                if y_new < self.fitness[j]:\n                    self.harmony_memory[j] = x_new\n                    self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.best_fitness)\n        return self.best_x, self.best_fitness", "name": "HHSADE", "description": "Novel metaheuristic algorithm, \"Hybrid Harmony Search with Adaptive Differential Evolution\" (HHSADE), which combines the benefits of Harmony Search and Adaptive Differential Evolution to efficiently search for optimal solutions in black box optimization problems.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "3782c810-dd15-42f3-8605-5307b8f79596", "solution": "import numpy as np\nimport random\n\nclass ADE_SCPLRU_PM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.prob_mut = 0.08695652173913043  # 1/11.59\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if np.random.rand() < self.prob_mut and self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SCPLRU_PM", "description": "Adaptive Differential Evolution with Stochastic Crossover Probability and Learning Rate Update with Probabilistic Mutation (ADE-SCPLRU-PM) - A novel adaptive differential evolution algorithm that updates the crossover probability and learning rate based on the fitness of the best individual, and introduces a probabilistic mutation operator to refine the strategy of the selected solution.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "09dff5ae-9e34-41e2-a0ba-46740c861137", "solution": "import numpy as np\nimport random\n\nclass DEANLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.neighborhood_size = int(self.population_size * 0.34782608695652173)\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            # Adaptive neighborhood selection\n            neighborhood_idx = np.random.choice(self.population_size, size=self.neighborhood_size, replace=False)\n            for k in neighborhood_idx:\n                if k!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[k]:\n                        self.x[k] = x_new\n                        self.fitness[k] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "DEANLR", "description": "Novel metaheuristic algorithm, \"Differential Evolution with Adaptive Neighborhoods and Learning Rate\" (DEANLR), which combines the strengths of differential evolution and adaptive neighborhoods to efficiently search for the global optimum.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "d6aef4f5-dd8c-4c17-aabe-0047e9286692", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_PSO_CS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_particles = np.inf * np.ones((self.population_size, self.dim))\n        self.best_fitness = np.inf * np.ones(self.population_size)\n        self.global_best = np.inf\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n\n    def __call__(self, func):\n        w = 0.7298\n        c1 = 1.49618\n        c2 = 1.49618\n        pa = 0.5\n        pc = 0.25\n        for i in range(self.budget):\n            for j in range(self.population_size):\n                self.velocities[j] = w * self.velocities[j] + c1 * random.random() * (self.best_particles[j] - self.particles[j]) + c2 * random.random() * (self.global_best - self.particles[j])\n                self.particles[j] = self.particles[j] + self.velocities[j]\n                self.particles[j] = np.clip(self.particles[j], self.lower_bound, self.upper_bound)\n                self.fitness[j] = func(self.particles[j])\n                if self.fitness[j] < self.best_fitness[j]:\n                    self.best_fitness[j] = self.fitness[j]\n                    self.best_particles[j] = self.particles[j]\n                if self.fitness[j] < self.global_best:\n                    self.global_best = self.fitness[j]\n            idx = np.argmin(self.fitness)\n            self.best_x = self.particles[idx]\n            self.best_fitness = self.fitness[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.particles[r1] + self.F * (self.particles[r2] - self.particles[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_PSO_CS", "description": "Novel heuristic algorithm that combines the concepts of Particle Swarm Optimization (PSO) and Cuckoo Search (CS) to adaptively adjust the learning rate and crossover probability for Self-Adaptive Crossover Probability and Learning Rate (SACPLR) in Adaptive Differential Evolution (ADE).", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "96eb3661-8b4c-4efa-9d62-97d5f253cf6a", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if random.random() < 0.021739130434782608:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                else:\n                    x_new = self.x[j] + self.F * (self.x[np.random.randint(0, self.population_size)] - self.x[np.random.randint(0, self.population_size)])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate (ADE-SACPLR) with probability 0.021739130434782608 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "a5b0f6c2-35a8-46cb-a298-38870ee57a64", "solution": "import numpy as np\nimport random\n\nclass AMSHD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.harmony_memory_size = int(0.2 * self.population_size)\n        self.swarm_size = int(0.8 * self.population_size)\n        self.dynamic_neighborhood_size = int(0.1 * self.population_size)\n        self.parsimony_coefficient = 0.01\n        self.harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        self.swarms = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.harmony_memory)\n            self.fitness[:self.harmony_memory_size] = y\n            idx = np.argmin(y)\n            self.best_x = self.harmony_memory[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j < self.harmony_memory_size:\n                    continue\n                swarm_idx = random.randint(0, self.swarm_size - 1)\n                r1, r2 = random.sample(range(self.population_size), 2)\n                while r1 == j or r2 == j:\n                    r1, r2 = random.sample(range(self.population_size), 2)\n                x_new = self.swarms[swarm_idx] + np.random.uniform(-1, 1, self.dim) * (self.swarms[swarm_idx] - self.swarms[random.randint(0, self.swarm_size - 1)])\n                x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                y_new = func(x_new)\n                if y_new < self.fitness[j]:\n                    self.swarms[swarm_idx] = x_new\n                    self.fitness[j] = y_new\n            # Dynamic Neighborhoods\n            for j in range(self.population_size):\n                if j < self.harmony_memory_size:\n                    continue\n                r1, r2, r3 = random.sample(range(self.population_size), 3)\n                while r1 == j or r2 == j or r3 == j:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                x_new = self.swarms[random.randint(0, self.swarm_size - 1)] + np.random.uniform(-1, 1, self.dim) * (self.swarms[random.randint(0, self.swarm_size - 1)] - self.swarms[r1])\n                x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                y_new = func(x_new)\n                if y_new < self.fitness[j]:\n                    self.swarms[random.randint(0, self.swarm_size - 1)] = x_new\n                    self.fitness[j] = y_new\n            # Update Harmony Memory\n            for j in range(self.harmony_memory_size):\n                r1 = random.randint(0, self.population_size - 1)\n                while r1 == j:\n                    r1 = random.randint(0, self.population_size - 1)\n                if self.fitness[r1] < self.fitness[j]:\n                    self.harmony_memory[j] = self.swarms[random.randint(0, self.swarm_size - 1)]\n                    self.fitness[j] = self.fitness[r1]\n            # Update Best Solution\n            if self.fitness[j] < self.best_fitness:\n                self.best_fitness = self.fitness[j]\n                self.best_x = self.swarms[random.randint(0, self.swarm_size - 1)]\n        return self.best_x, self.best_fitness", "name": "AMSHD", "description": "Novel \"Adaptive Multi-Swarm Harmony Search with Dynamic Neighborhoods\" (AMSHD) algorithm, which combines the concepts of harmony search, dynamic neighborhoods, and multi-swarm optimization to solve black box optimization problems.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 40 is out of bounds for axis 0 with size 40').", "error": "IndexError('index 40 is out of bounds for axis 0 with size 40')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "08909700-b21f-41ef-b7cf-0c6fae19893c", "solution": "import numpy as np\nimport random\n\nclass ADE_UCPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.uncertainty_threshold = 0.1\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.uncertainty = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    self.uncertainty[j] = np.std(y - y_new)\n                    if self.uncertainty[j] < self.uncertainty_threshold:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            self.uncertainty_threshold = self.uncertainty_threshold + self.learning_rate * (self.uncertainty_threshold - np.mean(self.uncertainty))\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_UCPLR", "description": "Novel Adaptive Crossover Probability and Learning Rate with Uncertainty-aware Differential Evolution (ADE-UCPLR) is a metaheuristic algorithm that adaptively updates the crossover probability and learning rate based on the uncertainty of the search space and the current population.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'list' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'list' and 'float'\")", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "4f162054-3c77-4ee2-b66d-1b7e163186de", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_NPR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.refine_probability = 0.34782608695652173\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if random.random() < self.refine_probability:\n                # Refine the selected solution by perturbing its parameters\n                for k in range(self.dim):\n                    self.best_x[k] += self.sigma * np.random.normal(0, 1)\n                    self.best_x[k] = np.clip(self.best_x[k], self.lower_bound, self.upper_bound)\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_NPR", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate with Novel Probability-Based Refinement (ADE-SACPLR-NPR)", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "ec0117f1-9064-4f80-b677-88e2de5ca13d", "solution": "import numpy as np\nimport random\n\nclass SADEELM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.memory_size = 10\n        self.memory = np.zeros((self.memory_size, self.dim))\n        self.memory_fitness = np.inf * np.ones(self.memory_size)\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n            # Ensemble learning and memory update\n            if i % 10 == 0 and i > 0:\n                self.memory[i % self.memory_size, :] = self.best_x\n                self.memory_fitness[i % self.memory_size] = self.best_fitness\n                self.memory_fitness = np.sort(self.memory_fitness)\n                self.memory = self.memory[self.memory_fitness < self.memory_fitness[-1]]\n                self.memory = self.memory[:self.memory_size]\n                self.memory_fitness = self.memory_fitness[:self.memory_size]\n                self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for j in range(self.population_size):\n                    x_new = np.zeros(self.dim)\n                    for k in range(self.memory_size):\n                        x_new += self.memory[k] * np.random.uniform(0, 1)\n                    x_new = x_new / self.memory_size\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    self.x[j] = x_new\n                    y_new = func(self.x[j])\n                    self.fitness[j] = y_new\n        return self.best_x, self.best_fitness", "name": "SADEELM", "description": "Self-Adaptive Differential Evolution with Ensemble Learning and Memory (SADEELM) - A novel metaheuristic algorithm that combines self-adaptive differential evolution with ensemble learning and memory to solve black box optimization problems.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 1 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 1 is out of bounds for axis 0 with size 1')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "ca131e8f-4b0f-4c8b-9f57-75f946cc4307", "solution": "import numpy as np\nimport random\n\nclass DCHCS_AN:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.alpha = 1.5\n        self.beta = 0.5\n        self.p_a = 0.5\n        self.p_c = 0.5\n        self.sigma = 0.1\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    if random.random() < self.p_a:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                        while r1 == idx or r2 == idx or r3 == idx:\n                            r1, r2, r3 = random.sample(range(self.population_size), 3)\n                        x_new = self.x[r1] + self.alpha * (self.x[r2] - self.x[r3])\n                        x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                        y_new = func(x_new)\n                        if y_new < self.fitness[j]:\n                            self.x[j] = x_new\n                            self.fitness[j] = y_new\n                    else:\n                        x_new = self.x[j] + self.beta * np.random.normal(0, 1, self.dim)\n                        x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                        y_new = func(x_new)\n                        if y_new < self.fitness[j]:\n                            self.x[j] = x_new\n                            self.fitness[j] = y_new\n            self.p_a = self.p_a + 0.01 * (self.p_a - self.p_c)\n            self.p_c = max(0.1, min(1.0, self.p_a))\n            self.sigma = self.sigma + 0.01 * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "DCHCS_AN", "description": "Novel \"Discrete-Continuous Hybrid Cuckoo Search with Adaptive Neighborhood\" (DCHCS-AN) algorithm, which combines the strengths of discrete and continuous optimization by using a hybrid search strategy that switches between discrete and continuous search spaces based on the problem's characteristics.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "8f4ba1e8-f678-4ef6-a589-2dbdc36f9f46", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.probability = 0.043478260869565216\n\n    def levy_distribution(self, mu, sigma):\n        u = np.random.uniform(0, 1, self.dim)\n        v = np.random.uniform(0, 1, self.dim)\n        z = np.sin(u) * np.exp(v)\n        return mu + sigma * z\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if random.random() < self.probability:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.levy_distribution(0, self.sigma) * self.sigma\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                else:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate with a Novel Mutation Operator Inspired by the Levy Distribution and the Probability of Changing Individual Lines.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "78046623-e5b1-4789-8c44-2a00605ac742", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_HMOO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n            # Refine strategy with a probability of 0.06521739130434782\n            if random.random() < 0.06521739130434782:\n                for k in range(self.dim):\n                    if random.random() < 0.5:\n                        self.x[idx, k] = np.clip(self.x[idx, k] + np.random.normal(0, 0.1), self.lower_bound, self.upper_bound)\n                    else:\n                        self.x[idx, k] = np.clip(self.x[idx, k] - np.random.normal(0, 0.1), self.lower_bound, self.upper_bound)\n                y_new = func(self.x[idx])\n                if y_new < self.best_fitness:\n                    self.best_fitness = y_new\n                    self.best_x = self.x[idx]\n            # Apply hybrid multi-operator optimization\n            for k in range(self.dim):\n                if random.random() < 0.33:\n                    self.x[idx, k] = np.clip(self.x[idx, k] + np.random.normal(0, 0.1), self.lower_bound, self.upper_bound)\n                elif random.random() < 0.66:\n                    self.x[idx, k] = np.clip(self.x[idx, k] - np.random.normal(0, 0.1), self.lower_bound, self.upper_bound)\n                else:\n                    self.x[idx, k] = np.clip(self.x[idx, k] + self.F * (self.x[r1, k] - self.x[r2, k]), self.lower_bound, self.upper_bound)\n                y_new = func(self.x[idx])\n                if y_new < self.best_fitness:\n                    self.best_fitness = y_new\n                    self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_HMOO", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate Refinement using Hybrid Multi-Operator Optimization (ADE-SACPLR-HMOO) - A novel heuristic algorithm that refines the strategy of the selected solution by changing individual lines with a probability of 0.06521739130434782 and applying hybrid multi-operator optimization.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "227c9238-a685-4506-90b8-647401f37aca", "solution": "import numpy as np\nimport random\n\nclass APAQND:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.quantization_levels = 10\n        self.quantized_probabilities = np.linspace(0, 1, self.quantization_levels + 1)\n        self.quantized_normal_distribution = np.random.normal(0, 1, self.quantization_levels)\n        self.quantized_normal_distribution = self.quantized_normal_distribution / np.linalg.norm(self.quantized_normal_distribution)\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            self.quantized_normal_distribution = self.quantized_normal_distribution * 0.99 + np.random.normal(0, 0.01, self.quantization_levels)\n            self.quantized_normal_distribution = self.quantized_normal_distribution / np.linalg.norm(self.quantized_normal_distribution)\n            quantized_value = np.dot(self.quantized_normal_distribution, np.random.normal(0, 1, self.quantization_levels))\n            self.crossover_probability = self.quantized_probabilities[np.argmin(np.abs(quantized_value - self.quantized_probabilities))]\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "APAQND", "description": "Novel \"Adaptive Probability Adjustment using Quantized Normal Distribution\" (APAQND) metaheuristic algorithm that adaptively adjusts the probability of mutation and crossover using a quantized normal distribution, leading to improved convergence rates and robustness.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "2b57e96a-43f4-4e66-ba32-21df0b57ea9b", "solution": "import numpy as np\nimport random\n\nclass ADE_LACL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability_learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.crossover_probability_learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_LACL", "description": "Adaptive Differential Evolution with Learning Rate Adaptation and Crossover Probability Learning (ADE-LACL) - a novel metaheuristic algorithm that adapts the learning rate and crossover probability using a learning rate adaptation strategy and a crossover probability learning mechanism.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "5f7ce5c9-f80f-494c-a58b-47df0aa24bc3", "solution": "import numpy as np\nimport random\n\nclass Hybrid_ADE_SACPLR_BFOA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.chance_to_change = 0.021739130434782608\n        self.n_steps = 0\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            if np.random.rand() < self.chance_to_change:\n                self.n_steps += 1\n                if self.n_steps % 5 == 0:\n                    self.F = self.F + np.random.uniform(-0.1, 0.1)\n                    self.CR = self.CR + np.random.uniform(-0.1, 0.1)\n                    self.sigma = self.sigma + np.random.uniform(-0.1, 0.1)\n                if self.n_steps % 10 == 0:\n                    self.learning_rate = self.learning_rate + np.random.uniform(-0.01, 0.01)\n                    self.crossover_probability = self.crossover_probability + np.random.uniform(-0.1, 0.1)\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness\n\nclass BacterialForagingOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.swarm_size = 50\n        self.c1 = 0.1\n        self.c2 = 0.1\n        self.c3 = 0.1\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.c1 * np.random.normal(0, 1, self.dim) + self.c2 * (self.x[r2] - self.x[r3]) + self.c3 * np.random.normal(0, 1, self.dim)\n                    x_new = x_new + np.random.normal(0, 0.1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n        return self.best_x, self.best_fitness\n\nclass Hybrid_ADE_SACPLR_BFOA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.chance_to_change = 0.021739130434782608\n        self.n_steps = 0\n        self.bfoa = BacterialForagingOptimization(self.budget, self.dim)\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            if np.random.rand() < self.chance_to_change:\n                self.n_steps += 1\n                if self.n_steps % 5 == 0:\n                    self.F = self.F + np.random.uniform(-0.1, 0.1)\n                    self.CR = self.CR + np.random.uniform(-0.1, 0.1)\n                    self.sigma = self.sigma + np.random.uniform(-0.1, 0.1)\n                if self.n_steps % 10 == 0:\n                    self.learning_rate = self.learning_rate + np.random.uniform(-0.01, 0.01)\n                    self.crossover_probability = self.crossover_probability + np.random.uniform(-0.1, 0.1)\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n            self.bfoa.x = self.x\n            self.bfoa.fitness = self.fitness\n            best_x_bfoa, best_fitness_bfoa = self.bfoa(func)\n            if best_fitness_bfoa < self.best_fitness:\n                self.best_x = best_x_bfoa\n                self.best_fitness = best_fitness_bfoa\n        return self.best_x, self.best_fitness", "name": "Hybrid_ADE_SACPLR_BFOA", "description": "A novel metaheuristic algorithm, called \"Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate\" (ADE_SACPLR), is combined with the \"Bacterial Foraging Optimization Algorithm\" (BFOA) to create a hybrid algorithm called \"Hybrid ADE_SACPLR-BFOA\", which uses the probability 0.021739130434782608 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "10b34381-4925-4a80-b691-b9d67ea18b3f", "solution": "import numpy as np\nimport random\n\nclass AMSHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.harmony_memory_size = int(0.021739130434782608 * self.population_size)\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        self.fitness = np.inf * np.ones(self.harmony_memory_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.harmony_memory)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.harmony_memory[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.harmony_memory_size):\n                r1, r2 = random.sample(range(self.harmony_memory_size), 2)\n                while r1 == idx or r2 == idx:\n                    r1, r2 = random.sample(range(self.harmony_memory_size), 2)\n                x_new = self.harmony_memory[r1] + self.F * (self.harmony_memory[r2] - self.best_x)\n                x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                y_new = func(x_new)\n                if y_new < self.fitness[j]:\n                    self.harmony_memory[j] = x_new\n                    self.fitness[j] = y_new\n            self.harmony_memory_size = int(0.021739130434782608 * self.population_size)\n            self.harmony_memory = np.concatenate((self.harmony_memory[:self.harmony_memory_size], [x_new for x_new in self.harmony_memory]))\n            self.fitness = np.concatenate((self.fitness[:self.harmony_memory_size], [y_new for y_new in self.fitness]))\n            self.CR = self.CR + self.learning_rate * (self.CR - self.fitness[idx])\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.harmony_memory[idx]\n        return self.best_x, self.best_fitness", "name": "AMSHS", "description": "Adaptive Multi-Swarm Harmony Search with Dynamically Adjusted Harmony Memory Size and Learning Rate", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "e02defb7-dec2-4f35-9384-aca2a475ec6a", "solution": "import numpy as np\nimport random\n\nclass CoADE_SACPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.cooperation_rate = 0.06521739130434782\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.cooperators = np.random.choice(self.population_size, int(self.population_size * self.cooperation_rate), replace=False)\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                    if j in self.cooperators and random.random() < self.cooperation_rate:\n                        for k in self.cooperators:\n                            if k!= j:\n                                x_coop = self.x[k] + self.F * (self.x[j] - self.x[k])\n                                x_coop = x_coop + self.sigma * np.random.normal(0, 1, self.dim)\n                                x_coop = np.clip(x_coop, self.lower_bound, self.upper_bound)\n                                y_coop = func(x_coop)\n                                if y_coop < self.fitness[k]:\n                                    self.x[k] = x_coop\n                                    self.fitness[k] = y_coop\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "CoADE_SACPLR", "description": "Novel Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate (ADE-SACPLR) and Cooperative Learning (CoADE-SACPLR) for Black Box Optimization.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "d87cbd2f-cd6f-48ae-ac9d-3cef5aef5e79", "solution": "import numpy as np\nimport random\n\nclass ADE_MOLRA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.probability_change = 0.15217391304347827\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.fitness_history = np.inf * np.ones(self.budget)\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            self.fitness_history[i] = self.best_fitness\n            for j in range(self.population_size):\n                if random.random() < self.probability_change:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            self.learning_rate = self.learning_rate * (1 - (self.fitness_history[i] - self.fitness_history[i-1]) / (self.fitness_history[i-1] + 1e-6))\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_MOLRA", "description": "Novel Adaptive Differential Evolution with Multi-Objective Learning Rate and Probability Adjustment (ADE-MOLRA) algorithm that adjusts the learning rate and crossover probability based on the fitness of the best individual and the probability of changing individual lines.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "2c68d60c-0c61-45f1-bfe7-8785b49540f9", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_NA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.noise_injection_probability = 0.021739130434782608\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    if np.random.rand() < self.noise_injection_probability:\n                        x_new += self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_NA", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability, Learning Rate, and Noise Injection (ADE-SACPLR-NA) - a novel heuristic algorithm that combines ADE with self-adaptive crossover probability, learning rate, and noise injection to improve exploration and exploitation.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "18163d1c-a2cf-4ec5-8e52-aaee4f5c5bbf", "solution": "import numpy as np\nimport random\n\nclass HDE_SOSLA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.orthogonal_matrix = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            # Stochastic Orthogonal Sampling\n            orthogonal_matrix = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            self.orthogonal_matrix = 0.17391304347826086 * self.orthogonal_matrix + (1 - 0.17391304347826086) * orthogonal_matrix\n            # Learning Rate Adaptation\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            # Update population using orthogonal matrix\n            for k in range(self.population_size):\n                x_new = self.x[k] + self.F * np.dot(self.orthogonal_matrix[k], (self.x[r1] - self.x[r2]))\n                x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                y_new = func(x_new)\n                if y_new < self.fitness[k]:\n                    self.x[k] = x_new\n                    self.fitness[k] = y_new\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "HDE_SOSLA", "description": "Hybrid Differential Evolution with Stochastic Orthogonal Sampling and Learning Rate Adaptation (HDE-SOSLA) - A novel metaheuristic algorithm that combines the strengths of differential evolution and stochastic orthogonal sampling with learning rate adaptation to efficiently optimize black box functions.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "0b370b77-0709-41e1-a070-4952c1f628cb", "solution": "import numpy as np\nimport random\n\nclass ADE_DCPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.success_rate = 0.0\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            self.success_rate = np.mean(y < self.best_fitness)\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR + 0.2 * (self.success_rate - self.CR)))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_DCPLR", "description": "Novel metaheuristic algorithm: Adaptive Differential Evolution with Dynamic Crossover Probability and Learning Rate (ADE-DCPLR), which combines the strengths of adaptive differential evolution with a dynamic crossover probability and learning rate to efficiently explore the search space.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'<' not supported between instances of 'list' and 'float'\").", "error": "TypeError(\"'<' not supported between instances of 'list' and 'float'\")", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "8abd1963-a0b4-49a5-9a28-b9cae6e5ee98", "solution": "import numpy as np\nimport random\n\nclass DE_ACPLR_T:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.turbulence = 0.1\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = x_new + self.turbulence * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            self.turbulence = self.turbulence + self.learning_rate * (self.turbulence - np.mean(self.fitness))\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "DE_ACPLR_T", "description": "A novel metaheuristic algorithm, \"Differential Evolution with Adaptive Crossover Probability and Learning Rate and Turbulence\" (DE-ACPLR-T), which combines differential evolution with adaptive crossover probability, learning rate, and turbulence to solve black box optimization problems.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "ff15a6aa-ed9b-42de-9d06-4d725b294ed1", "solution": "import numpy as np\nimport random\n\nclass CuckooADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.abandonment_rate = 0.2391304347826087  # probability to change individual lines\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if random.random() < self.abandonment_rate:\n                    r1 = random.randint(0, self.population_size - 1)\n                    while r1 == idx:\n                        r1 = random.randint(0, self.population_size - 1)\n                    self.x[j] = self.x[r1]\n                    self.fitness[j] = self.fitness[r1]\n                else:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "CuckooADE", "description": "Novel metaheuristic algorithm combining Cuckoo Search (CS) with Adaptive Differential Evolution (ADE) to solve black box optimization problems.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "ad3502ff-ed52-444b-8dd7-0b844658935d", "solution": "import numpy as np\nimport random\n\nclass DEANTPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.neighborhood_size = int(self.population_size * 0.2)\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    neighborhood_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                    neighborhood_idx = np.setdiff1d(neighborhood_idx, np.array([idx]))\n                    r1, r2 = random.sample(neighborhood_idx, 2)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[idx])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if np.random.rand() < 0.021739130434782608:  # probability 0.021739130434782608\n                self.F = self.F + self.learning_rate * (self.F - np.random.rand())\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "DEANTPLR", "description": "Differential Evolution with Adaptive Neighborhood Topology and Probabilistic Learning Rate", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "da96ad1e-e81a-4c09-bf48-0e0a51fc27b3", "solution": "import numpy as np\nimport random\n\nclass ADE_MPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate1 = 0.01\n        self.learning_rate2 = 0.001\n        self.crossover_probability1 = 0.5\n        self.crossover_probability2 = 0.2\n        self.phase = 1\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            if self.phase == 1:\n                self.CR = self.CR + self.learning_rate1 * (self.crossover_probability1 - self.CR)\n                self.crossover_probability1 = max(0.1, min(1.0, self.CR))\n                self.sigma = self.sigma + self.learning_rate1 * (self.sigma - self.fitness[idx])\n                if self.fitness[idx] < self.best_fitness:\n                    self.best_fitness = self.fitness[idx]\n                    self.best_x = self.x[idx]\n                if i > 0.43478260869565216 * self.budget:\n                    self.phase = 2\n            elif self.phase == 2:\n                self.CR = self.CR + self.learning_rate2 * (self.crossover_probability2 - self.CR)\n                self.crossover_probability2 = max(0.1, min(1.0, self.CR))\n                self.sigma = self.sigma + self.learning_rate2 * (self.sigma - self.fitness[idx])\n                if self.fitness[idx] < self.best_fitness:\n                    self.best_fitness = self.fitness[idx]\n                    self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_MPLR", "description": "Novel Adaptive Differential Evolution with Multi-Phase Learning Rate (ADE-MPLR) algorithm, which combines adaptive learning rates and multi-phase crossover probabilities to refine the strategy of the selected solution.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "a123204a-f4db-4b8b-b634-14f8f8f9827b", "solution": "import numpy as np\nimport random\n\nclass FLW_ALPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.p_best = np.inf * np.ones(self.population_size)\n        self.g_best = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            self.g_best = np.min(y)\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                        self.p_best[j] = y_new\n            for j in range(self.population_size):\n                if self.p_best[j] < self.g_best:\n                    self.g_best = self.p_best[j]\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "FLW_ALPDE", "description": "Novel \"Fractional Levy Walk with Adaptive Learning Rate and Population-based Differential Evolution\" (FLW-ALPDE) algorithm that combines the exploration capabilities of the Levy flight with the exploitation abilities of Differential Evolution, while adapting the learning rate and using a population-based approach.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "0f35a144-8c21-4094-a098-edac812ba06e", "solution": "import numpy as np\nimport random\n\nclass DE_SACPLR_N:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.neighborhood_size = 5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.neighborhoods = np.array_split(np.arange(self.population_size), self.population_size // self.neighborhood_size)\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    neighborhood = self.neighborhoods[j]\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            self.neighborhood_size = int(self.neighborhood_size * (1 + 0.021739130434782608 * (self.budget - i - 1) / (self.budget - 1)))\n            self.neighborhoods = np.array_split(np.arange(self.population_size), self.population_size // self.neighborhood_size)\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "DE_SACPLR_N", "description": "Differential Evolution with Self-Adaptive Crossover Probability, Learning Rate, and Neighborhood Structure (DE-SACPLR-N)", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "6246910b-1f35-4b3b-86cd-8f270b85a277", "solution": "import numpy as np\nimport random\n\nclass FDE_ACRLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.alpha = 0.021739130434782608  # probability to change individual lines\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if random.random() < self.alpha:  # change individual lines with probability alpha\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                else:\n                    x_new = self.x[j] + self.F * (np.random.uniform(-1, 1, self.dim) * self.x[j] + np.random.uniform(-1, 1, self.dim))\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "FDE_ACRLR", "description": "Novel heuristic algorithm, \"Fractional Differential Evolution with Adaptive Crossover and Learning Rate\" (FDE-ACLR), that combines fractional calculus with adaptive differential evolution to efficiently explore the search space.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "bd80a71f-6b3c-4e82-b98a-a59352a14898", "solution": "import numpy as np\nimport random\n\nclass ADE_LSPLM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def levy_flight(self, x, sigma):\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (abs(v) + 1)\n        return x + sigma * step\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = self.levy_flight(x_new, self.sigma)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_LSPLM", "description": "Adaptive Differential Evolution with Self-Adaptive Learning Rate and Probability of Mutation using Levy Flight (ADE-LSPLM) - A novel heuristic algorithm that combines Adaptive Differential Evolution with a self-adaptive learning rate and probability of mutation using Levy Flight to efficiently search the solution space.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "863d01bf-4a5e-47f2-8be1-fc4d8f35bef9", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness\n\nclass ADE_SACPLR_ProbDrift:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.prob_drift = 0.2391304347826087\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if random.random() < self.prob_drift:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                else:\n                    x_new = self.x[j] + self.F * (self.x[np.random.randint(0, self.population_size)] - self.x[np.random.randint(0, self.population_size)])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate (ADE-SACPLR) with a novel mutation operator inspired by the concept of \"probability drift\" to refine its strategy.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "77bac973-79b4-4080-b9cf-03f7bf87de6d", "solution": "import numpy as np\nimport random\n\nclass AHSDLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.HMCR = 0.9\n        self.PAR = 0.1\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.HMCR_history = np.zeros(self.budget)\n        self.PAR_history = np.zeros(self.budget)\n        self.F_history = np.zeros(self.budget)\n        self.CR_history = np.zeros(self.budget)\n        self.sigma_history = np.zeros(self.budget)\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            self.HMCR_history[i] = self.HMCR\n            self.PAR_history[i] = self.PAR\n            self.F_history[i] = self.F\n            self.CR_history[i] = self.CR\n            self.sigma_history[i] = self.sigma\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.HMCR = self.HMCR + self.learning_rate * (self.HMCR - np.mean(self.fitness))\n            self.PAR = self.PAR + self.learning_rate * (self.PAR - np.mean(self.fitness))\n            self.F = self.F + self.learning_rate * (self.F - np.mean(self.fitness))\n            self.CR = self.CR + self.learning_rate * (self.CR - np.mean(self.fitness))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - np.mean(self.fitness))\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "AHSDLR", "description": "Adaptive Harmony Search with Differential Evolution and Learning Rate (AHSDLR) - A novel metaheuristic algorithm that combines the benefits of Harmony Search and Differential Evolution with a learning rate mechanism to adaptively adjust the harmony memory consideration rate and the mutation strategy.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "66476cd9-9ea1-48c2-b32d-9576f0094f32", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_RPLM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.probability = 0.021739130434782608\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if random.random() < self.probability:\n                    idx1, idx2, idx3 = random.sample(range(self.population_size), 3)\n                    while idx1 == idx or idx2 == idx or idx3 == idx:\n                        idx1, idx2, idx3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[idx1] + self.F * (self.x[idx2] - self.x[idx3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                else:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_RPLM", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate Refinement using Probability-Informed Line Mutation (ADE-SACPLR-RPLM)", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "d1c92f68-a406-4846-82e5-e82060bdd79c", "solution": "import numpy as np\nimport random\n\nclass ADE_DQCPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.quantum_probability = 0.3\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                    # Quantum Mutation Strategy\n                    if random.random() < self.quantum_probability:\n                        x_new = self.x[r1] + self.sigma * np.random.normal(0, 1, self.dim)\n                        x_new = x_new + self.F * (self.x[r2] - self.x[r3])\n                        x_new = x_new + self.F * (self.x[r2] - self.x[r3])\n                        x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                        y_new = func(x_new)\n                        if y_new < self.fitness[j]:\n                            self.x[j] = x_new\n                            self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            self.quantum_probability = self.quantum_probability + self.learning_rate * (0.06521739130434782 - self.quantum_probability)\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_DQCPLR", "description": "Adaptive Differential Evolution with Dynamic Crossover Probability and Learning Rate, and Novel Mutation Strategy inspired by Quantum Computing (ADE_DQCPLR)", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "d44fc149-5ec9-44cf-985c-ceeccb0df883", "solution": "import numpy as np\nimport random\n\nclass LLaMEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def levy_flight(self, x, sigma):\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = np.sqrt(u**2 + v**2)\n        distance = (np.cos(step) + 0.001) / (1 + step)\n        return x + sigma * u * distance\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = self.levy_flight(x_new, self.sigma)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "LLaMEA", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate (ADE-SACPLR) with a novel mutation operator inspired by the concept of Levy flights.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "7c2bbb75-c00c-4b89-ba73-b48e5255ec8b", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_SH:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.success_history = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            self.success_history[idx] += 1\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                        self.success_history[j] += 1\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n            self.CR = self.CR + self.learning_rate * (self.success_history / self.population_size - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.success_history[idx] / (i+1))\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_SH", "description": "Differential Evolution with Adaptive Learning Rate and Crossover Probability, and a Novel \"Success History\" Mechanism to Refine the Strategy.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "e7fc1684-2ba2-4344-9ccd-afdd42782da9", "solution": "import numpy as np\nimport random\n\nclass SocialADE_SACPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.probability_of_change = 0.13043478260869565\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.selected_solution_idx = np.random.randint(0, self.population_size)\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if np.random.rand() < self.probability_of_change:\n                self.x[self.selected_solution_idx] = self.x[idx]\n                self.fitness[self.selected_solution_idx] = self.fitness[idx]\n                self.selected_solution_idx = idx\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "SocialADE_SACPLR", "description": "A novel hybrid metaheuristic algorithm that combines the concept of Social Learning with the Adaptive Differential Evolution algorithm, incorporating a probability of 0.13043478260869565 to change individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "2ca30ddc-f3d1-4787-994d-02d15e7c6eb3", "solution": "import numpy as np\nimport random\n\nclass LFSACPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def levy_flight(self, x, sigma):\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = (np.sin(u) / (np.abs(u))) * ((v ** 2) + 1) ** (-1.5)\n        return x + sigma * step\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = self.levy_flight(x_new, self.sigma)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "LFSACPLR", "description": "Novel metaheuristic algorithm that combines the concept of Levy Flights and Self-Adaptive Crossover Probability with a learning rate to optimize black box functions.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "58692a60-e08d-4d8b-8726-264d6a10b6f2", "solution": "import numpy as np\nimport random\n\nclass DEALC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.probability = 0.2391304347826087\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if random.random() < self.probability:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                else:\n                    x_new = self.x[j] + self.F * (self.x[idx] - self.x[j])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "DEALC", "description": "Novel hybrid metaheuristic algorithm, called Differential Evolution with Adaptive Learning and Crossover (DEALC), combines the strengths of Differential Evolution and Adaptive Learning Rate, and incorporates a novel crossover mechanism based on the probability of changing individual lines.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "b6fa4706-8c3d-4bb8-b4c2-a969d7de2da3", "solution": "import numpy as np\nimport random\n\nclass ADE_MOS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.probability = 0.06521739130434782\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if random.random() < self.probability:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                else:\n                    if random.random() < 0.5:\n                        x_new = self.x[j] + self.F * (self.x[np.random.randint(0, self.population_size)] - self.x[np.random.randint(0, self.population_size)])\n                    else:\n                        x_new = self.x[j] + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_MOS", "description": "Novel Adaptive Differential Evolution with Self-Adaptive Crossover Probability, Learning Rate, and Multi-Operator Selection (ADE-MOS)", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "c2c82b80-e8ba-495d-91a7-809ed0ca4ea9", "solution": "import numpy as np\nimport random\n\nclass DWHS_AN:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.harmony_memory_size = 10\n        self.panning_rate = 0.01\n        self.weight_update_rate = 0.1\n        self.neighborhood_size = 5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1 = random.randint(0, self.population_size - 1)\n                    while r1 == idx:\n                        r1 = random.randint(0, self.population_size - 1)\n                    x_new = self.harmony_memory[random.randint(0, self.harmony_memory_size - 1)]\n                    x_new = x_new + np.random.normal(0, 1, self.dim) * self.panning_rate\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.harmony_memory = np.clip(self.harmony_memory + np.random.normal(0, self.panning_rate, (self.harmony_memory_size, self.dim)), self.lower_bound, self.upper_bound)\n            self.weight_update_rate = self.weight_update_rate * 0.9\n            self.neighborhood_size = int(self.population_size * (1 - self.weight_update_rate))\n            self.x[idx] = self.harmony_memory[random.randint(0, self.harmony_memory_size - 1)]\n            self.fitness[idx] = func(self.x[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "DWHS_AN", "description": "A novel metaheuristic algorithm, called \"Dynamically Weighted Harmony Search with Adaptive Neighborhoods\" (DWHS-AN), which combines the concepts of harmony search and adaptive neighborhoods to efficiently search for the global optimum.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "b1ad5f9c-9fbb-436f-93f6-e9f4f85cb1d0", "solution": "import numpy as np\nimport random\n\nclass HarmonyDE_SACPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            # Update harmony memory\n            self.harmony_memory = np.vstack((self.harmony_memory, self.x[idx]))\n            self.harmony_memory = self.harmony_memory[np.random.choice(self.harmony_memory.shape[0], self.harmony_memory_size, replace=False), :]\n            # Update CR and sigma\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            # Update best solution\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        # Select new individual lines based on probability\n        select_prob = 0.06521739130434782\n        new_individual = self.best_x.copy()\n        for i in range(self.dim):\n            if random.random() < select_prob:\n                new_individual[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        return new_individual, self.best_fitness", "name": "HarmonyDE_SACPLR", "description": "Novel metaheuristic algorithm that combines the concepts of harmony search, differential evolution, and learning rate adaptation to solve black box optimization problems.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'HarmonyDE_SACPLR' object has no attribute 'x'\").", "error": "AttributeError(\"'HarmonyDE_SACPLR' object has no attribute 'x'\")", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "4e0002cb-e721-47c9-9d03-84071df5d1a4", "solution": "import numpy as np\nimport random\n\nclass AHSD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.harmony_memory_size = 20\n        self.harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        self.fitness = np.inf * np.ones(self.harmony_memory_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.harmony_memory)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.harmony_memory[idx]\n            self.best_fitness = y[idx]\n            # Update Harmony Memory using Differential Evolution\n            for j in range(self.harmony_memory_size):\n                r1, r2, r3 = random.sample(range(self.harmony_memory_size), 3)\n                while r1 == idx or r2 == idx or r3 == idx:\n                    r1, r2, r3 = random.sample(range(self.harmony_memory_size), 3)\n                x_new = self.harmony_memory[r1] + self.F * (self.harmony_memory[r2] - self.harmony_memory[r3])\n                x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                y_new = func(x_new)\n                if y_new < self.fitness[j]:\n                    self.harmony_memory[j] = x_new\n                    self.fitness[j] = y_new\n            # Update Harmony Memory using Harmony Search\n            for j in range(self.harmony_memory_size):\n                if random.random() < self.crossover_probability:\n                    r1 = random.randint(0, self.harmony_memory_size - 1)\n                    x_new = self.harmony_memory[j] + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.harmony_memory[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.harmony_memory[idx]\n        return self.best_x, self.best_fitness", "name": "AHSD", "description": "Novel \"Adaptive Harmony Search with Differential Evolution\" (AHSD) algorithm, which combines the global exploration capabilities of Harmony Search with the local search capabilities of Differential Evolution to solve black box optimization problems.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "40165e17-6a57-4d81-8620-47a07407e2d7", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_SSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        selfSpider_web = np.zeros((self.population_size, self.dim))\n        selfSpider_position = np.zeros((self.population_size, self.dim))\n        selfSpider_fitness = np.inf * np.ones(self.population_size)\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n\n            # Social Spider Optimization\n            Spider_web = np.zeros((self.population_size, self.dim))\n            Spider_position = np.zeros((self.population_size, self.dim))\n            Spider_fitness = np.inf * np.ones(self.population_size)\n            for k in range(self.population_size):\n                Spider_web[k] = self.x[k]\n                Spider_position[k] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                Spider_fitness[k] = func(Spider_position[k])\n                if Spider_fitness[k] < self.fitness[k]:\n                    self.x[k] = Spider_position[k]\n                    self.fitness[k] = Spider_fitness[k]\n\n            # Update Spider web and position\n            for k in range(self.population_size):\n                r1, r2, r3 = random.sample(range(self.population_size), 3)\n                while r1 == k or r2 == k or r3 == k:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                Spider_web[k] = (Spider_web[r1] + Spider_web[r2] + Spider_web[r3]) / 3\n                Spider_position[k] = Spider_web[k] + self.sigma * np.random.normal(0, 1, self.dim)\n                Spider_position[k] = np.clip(Spider_position[k], self.lower_bound, self.upper_bound)\n                Spider_fitness[k] = func(Spider_position[k])\n                if Spider_fitness[k] < self.fitness[k]:\n                    self.x[k] = Spider_position[k]\n                    self.fitness[k] = Spider_fitness[k]\n\n            # Update best Spider web and position\n            idx = np.argmin(Spider_fitness)\n            self.best_x = Spider_position[idx]\n            self.best_fitness = Spider_fitness[idx]\n\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_SSO", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate with Novel Hybridization of Social Spider Optimization (ADE-SACPLR-SSO)", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "8a7c72bd-8b33-4263-9e3f-25fa7cb675f0", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.change_probability = 0.021739130434782608\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if random.random() < self.change_probability:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                else:\n                    x_new = self.x[j] + self.F * (self.x[np.random.randint(0, self.population_size)] - self.x[np.random.randint(0, self.population_size)])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            self.mutation_probability = self.mutation_probability + self.learning_rate * (self.mutation_probability - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability, Learning Rate, and Probability of Mutation (ADE-SACPLR) with probability 0.021739130434782608 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "f6c860d2-4fdb-4860-ad09-b2419c69ac44", "solution": "import numpy as np\nimport random\nfrom scipy.stats import norm\n\nclass ADE_SACPLR_Bayes:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.bayes_params = {'F': 0.5, 'CR': 0.5,'sigma': 0.1, 'learning_rate': 0.01, 'crossover_probability': 0.5}\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.bayes_params['F'] * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.bayes_params['sigma'] * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.bayes_params['CR'] = self.bayes_params['CR'] + self.bayes_params['learning_rate'] * (self.bayes_params['crossover_probability'] - self.bayes_params['CR'])\n            self.bayes_params['crossover_probability'] = max(0.1, min(1.0, self.bayes_params['CR']))\n            self.bayes_params['sigma'] = self.bayes_params['sigma'] + self.bayes_params['learning_rate'] * (self.bayes_params['sigma'] - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n            # Update parameters using Bayesian optimization\n            for param in ['F', 'CR','sigma', 'learning_rate', 'crossover_probability']:\n                mean, std = norm.fit(self.bayes_params[param])\n                self.bayes_params[param] = np.random.normal(mean, std)\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_Bayes", "description": "Differential Evolution with Multi-Operator Crossover and Learning Rate Adaptation using Bayesian Optimization", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "6cd41982-01bf-4298-bf11-d66dca01c29b", "solution": "import numpy as np\nimport random\n\nclass HarmonySearchGreyWolfOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.harmONY_rate = 0.01\n        self.HS = 0.5\n        self.GWO = 0.5\n        self.p = 0.021739130434782608\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.selected_solution = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            self.selected_solution = np.random.choice(self.population_size, p=self.fitness / np.sum(self.fitness))\n            self.selected_solution = int(self.selected_solution)\n            for j in range(self.population_size):\n                if j!= self.selected_solution:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == self.selected_solution or r2 == self.selected_solution or r3 == self.selected_solution:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.HS * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.GWO * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            if np.random.rand() < self.p:\n                self.HS = self.HS + 0.01 * (self.HS - np.mean(self.fitness))\n                self.GWO = self.GWO + 0.01 * (self.GWO - np.mean(self.fitness))\n        return self.best_x, self.best_fitness", "name": "HarmonySearchGreyWolfOptimizer", "description": "Novel hybrid metaheuristic algorithm combining Harmony Search and Grey Wolf Optimizer with a probability-based adaptive mechanism to refine the strategy of the selected solution.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "523f99c3-2345-406b-a700-d89a54738bcd", "solution": "import numpy as np\nimport random\n\nclass HarmonySearch_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.pareto_front_size = int(self.population_size * 0.2)\n        self.harmony_memory_size = self.population_size - self.pareto_front_size\n        self.harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.pareto_front = np.inf * np.ones((self.pareto_front_size, self.dim))\n        self.pareto_front_fitness = np.inf * np.ones(self.pareto_front_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.harmony_memory)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.harmony_memory[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.harmony_memory_size):\n                r1, r2, r3 = random.sample(range(self.harmony_memory_size), 3)\n                while r1 == idx or r2 == idx or r3 == idx:\n                    r1, r2, r3 = random.sample(range(self.harmony_memory_size), 3)\n                x_new = self.harmony_memory[r1] + self.F * (self.harmony_memory[r2] - self.harmony_memory[r3])\n                x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                y_new = func(x_new)\n                if y_new < self.fitness[j]:\n                    self.harmony_memory[j] = x_new\n                    self.fitness[j] = y_new\n            # Select the best individuals for the pareto front\n            sorted_idx = np.argsort(self.fitness)\n            self.pareto_front = self.harmony_memory[sorted_idx[:self.pareto_front_size]]\n            self.pareto_front_fitness = self.fitness[sorted_idx[:self.pareto_front_size]]\n            # Update the crossover probability and learning rate\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.harmony_memory[idx]\n        # Select the best individual from the pareto front\n        sorted_idx = np.argsort(self.pareto_front_fitness)\n        self.best_x = self.pareto_front[sorted_idx[0]]\n        self.best_fitness = self.pareto_front_fitness[sorted_idx[0]]\n        return self.best_x, self.best_fitness", "name": "HarmonySearch_DE", "description": "A novel metaheuristic algorithm that combines the concepts of Harmony Search and Differential Evolution to efficiently solve black box optimization problems, with a self-adaptive learning rate and crossover probability to adapt to the search space.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('only integer scalar arrays can be converted to a scalar index').", "error": "TypeError('only integer scalar arrays can be converted to a scalar index')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "51da4ccb-d904-476d-aed4-a59497127551", "solution": "import numpy as np\nimport random\n\nclass PDADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.021739130434782608\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    if np.random.rand() < self.mutation_probability:\n                        x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                        x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    else:\n                        x_new = self.x[r1] + self.CR * (self.x[r2] - self.x[r3])\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "PDADE", "description": "Novel metaheuristic algorithm, Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate with a twist, incorporating a probability-based mutation and crossover strategy, called Probability-Driven Adaptive Differential Evolution (PDADE).", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "8fcc0107-4a0c-48ef-9d02-07af7ce1b936", "solution": "import numpy as np\nimport random\n\nclass ADE_SAPLM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.probability_mutation = 0.17391304347826086\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if random.random() < self.probability_mutation:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                else:\n                    r1, r2 = random.sample(range(self.population_size), 2)\n                    while r1 == idx or r2 == idx:\n                        r1, r2 = random.sample(range(self.population_size), 2)\n                    x_new = self.x[r1] + self.CR * (self.x[r2] - self.x[idx])\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SAPLM", "description": "Novel metaheuristic algorithm, Adaptive Differential Evolution with Self-Adaptive Crossover Probability, Learning Rate, and Probability Mutation (ADE-SAPLM), which adaptively adjusts the crossover probability, learning rate, and probability of mutation to refine its strategy based on the probability 0.17391304347826086.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "3a2e6914-3579-4a0b-a43b-c29995bdef29", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_PBLM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.line_mutation_probability = 0.10869565217391304\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n            if random.random() < self.line_mutation_probability:\n                k = random.randint(0, self.dim - 1)\n                self.x[idx, k] += self.learning_rate * (self.x[idx, k] - self.x[random.randint(0, self.population_size - 1), k])\n                self.x[idx, k] = np.clip(self.x[idx, k], self.lower_bound, self.upper_bound)\n                y_new = func(self.x[idx])\n                if y_new < self.best_fitness:\n                    self.best_fitness = y_new\n                    self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_PBLM", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate with Probability-Based Line Mutation (ADE-SACPLR-PBLM)", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "be615652-c752-4ca4-b0e4-4b29b068b0dd", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_REFINED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.cma_mean = np.zeros(self.dim)\n        self.cma_cov = np.eye(self.dim)\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            self.cma_mean = (1 - 1 / (i + 1)) * self.cma_mean + 1 / (i + 1) * self.x[idx]\n            self.cma_cov = (1 - 1 / (i + 1)) * self.cma_cov + 1 / (i + 1) * np.outer(self.x[idx] - self.cma_mean, self.x[idx] - self.cma_mean)\n            step_size = np.sqrt(2 * np.log(self.dim) / self.dim) / np.sqrt(np.diag(self.cma_cov))\n            x_new_cma = self.cma_mean + step_size * np.random.multivariate_normal(mean=np.zeros(self.dim), cov=self.cma_cov)\n            x_new_cma = np.clip(x_new_cma, self.lower_bound, self.upper_bound)\n            y_new_cma = func(x_new_cma)\n            if y_new_cma < self.fitness[idx]:\n                self.x[idx] = x_new_cma\n                self.fitness[idx] = y_new_cma\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_REFINED", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate (ADE-SACPLR) refinement using a novel hybridization of the 21.74% success probability based on the Fibonacci sequence and the Covariance Matrix Adaptation Evolution Strategy (CMA-ES).", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "55b675b0-7f77-45bd-b71c-7ed4bffb2441", "solution": "import numpy as np\nimport random\n\nclass HSCABC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.harmmony_memory_size = 20\n        self.HS_max_iter = 20\n        self.HS_p = 0.95\n        self.ABC_max_iter = 20\n        self.ABC_limit = 0.01\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.harmony_memory = np.zeros((self.harmmony_memory_size, self.dim))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.x[r2] - self.x[r3]\n                    x_new = x_new + np.random.uniform(-1, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            # Harmony Search\n            for k in range(self.HS_max_iter):\n                for j in range(self.population_size):\n                    if random.random() < self.HS_p:\n                        x_new = self.harmony_memory[np.random.randint(0, self.harmmony_memory_size), :]\n                        x_new = x_new + np.random.uniform(-1, 1, self.dim)\n                        x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                        y_new = func(x_new)\n                        if y_new < self.fitness[j]:\n                            self.x[j] = x_new\n                            self.fitness[j] = y_new\n                # Update Harmony Memory\n                self.harmony_memory[np.argmin(self.fitness)] = self.x[np.argmin(self.fitness)]\n            # Artificial Bee Colony\n            for k in range(self.ABC_max_iter):\n                for j in range(self.population_size):\n                    if random.random() < self.ABC_limit:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                        while r1 == j or r2 == j or r3 == j:\n                            r1, r2, r3 = random.sample(range(self.population_size), 3)\n                        x_new = self.x[r1] + self.x[r2] - self.x[r3]\n                        x_new = x_new + np.random.uniform(-1, 1, self.dim)\n                        x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                        y_new = func(x_new)\n                        if y_new < self.fitness[j]:\n                            self.x[j] = x_new\n                            self.fitness[j] = y_new\n            self.best_fitness = np.min(self.fitness)\n            self.best_x = self.x[np.argmin(self.fitness)]\n        return self.best_x, self.best_fitness", "name": "HSCABC", "description": "Novel Hybrid Metaheuristic Algorithm combining Harmony Search and Artificial Bee Colony (HSCABC) with a Dynamic Neighborhood Search (DNS) for Black Box Optimization.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 21 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 21 is out of bounds for axis 0 with size 20')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "a249cfce-25d5-49f5-9e24-f4de6dc00cfc", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random levy(self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n            # Probability-driven update\n            prob = 0.021739130434782608\n            if random.random() < prob:\n                for k in range(self.dim):\n                    if random.random() < 0.5:\n                        self.x[idx, k] = self.x[idx, k] + self.F * (self.x[r1, k] - self.x[r2, k])\n                    else:\n                        self.x[idx, k] = self.x[idx, k] + self.F * (self.x[r2, k] - self.x[r1, k])\n        return self.best_x, self.best_fitness\n\ndef np_random_levy(dim):\n    u = np.random.normal(0, 1, dim)\n    v = np.random.normal(0, 1, dim)\n    s = np.sum(u**2)\n    while s <= 0:\n        u = np.random.normal(0, 1, dim)\n        s = np.sum(u**2)\n    t = np.sum(v**2) / s\n    f = np.sqrt(t) / (1 + t)\n    g = np.sqrt(t) * u\n    return f * g", "name": "ADE_SACPLR", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate with Novel Mutation Operator based on Levy Distribution and Probability-Driven Update", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 34, 60, '                    x_new = x_new + self.sigma * np.random levy(self.dim)\\n', 34, 64)).", "error": "SyntaxError('invalid syntax', ('<string>', 34, 60, '                    x_new = x_new + self.sigma * np.random levy(self.dim)\\n', 34, 64))", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "53cee7c9-b47f-436e-b980-2464db11119e", "solution": "import numpy as np\nimport random\n\nclass DE_APD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.pde = np.ones(self.population_size)\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                        self.pde[j] = self.pde[j] * 0.06521739130434782 + 0.001\n                    else:\n                        self.pde[j] = self.pde[j] * 0.06521739130434782\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            self.pde[idx] = self.pde[idx] * 0.06521739130434782 + 0.001\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "DE_APD", "description": "A Novel Metaheuristic Algorithm called 'Differential Evolution with Adaptive Mutation and Crossover Probability based on Probability Density Estimation' (DE-APD) which combines the strengths of Differential Evolution with adaptive mutation and crossover probability, and Probability Density Estimation to refine the strategy of the selected solution.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "f06c1a4f-013b-4a74-b945-de51be3e43ad", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def levy_flight(self, x, sigma):\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = (np.sqrt(u**2 + v**2) / np.sqrt(2)) * (sigma * (1 + np.cos(np.pi * u / np.sqrt(u**2 + v**2))) * np.exp(-v**2 / (4 * u**2)))\n        return x + step\n\n    def mutation(self, x, F, sigma):\n        r1, r2, r3 = random.sample(range(self.population_size), 3)\n        while r1 == r2 or r1 == r3 or r2 == r3:\n            r1, r2, r3 = random.sample(range(self.population_size), 3)\n        x_new = self.x[r1] + F * (self.x[r2] - self.x[r3])\n        x_new = self.levy_flight(x_new, sigma)\n        x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n        return x_new\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    x_new = self.mutation(self.x[j], self.F, self.sigma)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR", "description": "A novel metaheuristic algorithm called Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate (ADE-SACPLR) with a novel mutation operator based on the concept of Levy flights and a self-adaptive crossover probability and learning rate.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "8421ea19-be42-4561-96a1-c04996337b54", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_MD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.directions = np.random.normal(0, 1, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                        self.directions[j] = np.random.normal(0, 1, self.dim)\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            self.F = self.F + self.learning_rate * (self.fitness[idx] - self.best_fitness)\n            self.F = max(0.1, min(2.0, self.F))\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness\n\n# To update the selected solution, change the individual lines of the selected solution to refine its strategy with the probability 0.2391304347826087\n# For example:\ndef update_solution(solution, probability):\n    if random.random() < probability:\n        solution.budget = 100  # change the budget\n    if random.random() < probability:\n        solution.F = 0.7  # change the F parameter\n    if random.random() < probability:\n        solution.CR = 0.3  # change the CR parameter\n    if random.random() < probability:\n        solution.sigma = 0.05  # change the sigma parameter\n    return solution\n\n# Usage:\nalgorithm = ADE_SACPLR_MD(budget=100, dim=10)\nbest_x, best_fitness = algorithm(func=your_function)\nprint(\"Best x:\", best_x)\nprint(\"Best fitness:\", best_fitness)", "name": "ADE_SACPLR_MD", "description": "A Novel Metaheuristic Algorithm: Adaptive Differential Evolution with Self-Adaptive Crossover Probability, Learning Rate, and Multi-Directional Mutation (ADE-SACPLR-MD)", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'your_function' is not defined\").", "error": "NameError(\"name 'your_function' is not defined\")", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "f67c01bf-144f-4cd2-a556-13740e8f24bc", "solution": "import numpy as np\nimport random\n\nclass SADELM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.memory_size = 10\n        self.memory = np.inf * np.ones(self.memory_size)\n        self.memory_x = np.inf * np.ones((self.memory_size, self.dim))\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            self.memory[np.argmin(self.memory)] = self.best_fitness\n            self.memory_x[np.argmin(self.memory)] = self.best_x\n            if np.random.rand() < 0.1956521739130435:\n                self.F = self.F + np.random.uniform(-1, 1)\n                self.CR = self.CR + np.random.uniform(-1, 1)\n                self.sigma = self.sigma + np.random.uniform(-1, 1)\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        for k in range(self.memory_size):\n            self.x[k] = self.memory_x[k]\n            self.fitness[k] = self.memory[k]\n        return self.best_x, self.best_fitness", "name": "SADELM", "description": "Self-Adaptive Differential Evolution with Learning and Memory (SADELM) - a novel heuristic algorithm that combines differential evolution with learning and memory mechanisms to adaptively adjust the strategy parameters and maintain a memory of the best solutions found so far.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "411b2d69-e8ba-45f1-9302-7363ac6f179e", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.change_probability = 0.021739130434782608\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if random.random() < self.change_probability:\n                    self.F = self.F + self.learning_rate * (random.uniform(-1, 1))\n                    self.CR = self.CR + self.learning_rate * (random.uniform(-1, 1))\n                    self.sigma = self.sigma + self.learning_rate * (random.uniform(-1, 1))\n                    self.learning_rate = self.learning_rate + self.learning_rate * (random.uniform(-1, 1))\n                    self.crossover_probability = max(0.1, min(1.0, self.CR))\n                r1, r2, r3 = random.sample(range(self.population_size), 3)\n                while r1 == idx or r2 == idx or r3 == idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                y_new = func(x_new)\n                if y_new < self.fitness[j]:\n                    self.x[j] = x_new\n                    self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR", "description": "Novel metaheuristic algorithm, called Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate (ADE-SACPLR) with a probability of 0.021739130434782608 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "06ce64b5-8bc6-472a-8c39-fcf74426e1d4", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_NOV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n            # Update probabilities based on the probability 0.06521739130434782\n            self.F = self.F + (0.06521739130434782) * (self.F - np.mean([self.F, self.F, self.F]))\n            self.CR = self.CR + (0.06521739130434782) * (self.CR - np.mean([self.CR, self.CR, self.CR]))\n            self.sigma = self.sigma + (0.06521739130434782) * (self.sigma - np.mean([self.sigma, self.sigma, self.sigma]))\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_NOV", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability, Learning Rate, and Gaussian Mutation Probability using a Novel Probability-Based Update Rule (ADE-SACPLR-NOV)", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "21cc6522-10d5-451f-a697-973ea65d9dad", "solution": "import numpy as np\n\nclass EHSF:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.harmony_memory_size = 10\n        self.max_frequency = 10.0\n        self.min_frequency = 0.1\n        self.paranoid = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2 = random.sample(range(self.population_size), 2)\n                    while r1 == idx or r2 == idx:\n                        r1, r2 = random.sample(range(self.population_size), 2)\n                    x_new = self.x[r1] + np.random.uniform(-1, 1, self.dim)\n                    x_new = x_new + self.paranoid * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            # Update harmony memory\n            self.harmony_memory = np.vstack((self.harmony_memory, self.x[idx]))\n            self.harmony_memory = np.delete(self.harmony_memory, 0, 0)\n            # Update frequency\n            self.max_frequency = self.max_frequency + 0.01 * (self.max_frequency - self.fitness[idx])\n            self.min_frequency = self.min_frequency + 0.01 * (self.min_frequency - self.fitness[idx])\n            self.paranoid = self.paranoid + 0.01 * (self.paranoid - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "EHSF", "description": "Novel metaheuristic algorithm, \"Evolutionary Harmony Search with Self-Adaptive Frequency Modulation\" (EHSF), which combines harmony search and evolutionary strategies to efficiently search for the optimal solution in the given budget.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "f3c4003d-89af-4663-a2c5-bf1aff02fadf", "solution": "import numpy as np\nimport random\n\nclass DEBO_ADE_SACPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.probability = 0.021739130434782608\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if random.random() < self.probability:\n                self.F = self.F + self.learning_rate * (self.F - np.mean(self.fitness))\n                self.sigma = self.sigma + self.learning_rate * (self.sigma - np.std(self.fitness))\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "DEBO_ADE_SACPLR", "description": "Novel heuristic algorithm that combines the ideas of Differential Evolution and Bayesian Optimization to adaptively learn the probability of crossover and mutation, and to refine the strategy of the selected solution based on the probability of 0.021739130434782608.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "3fe608ad-dac7-479b-b5bd-51c9e2192f80", "solution": "import numpy as np\nimport random\nfrom scipy.stats import norm\nfrom scipy.optimize import minimize\n\nclass HybridADE_SACPLR_GPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.gp_model = None\n        self.gp_noise = 0.1\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n            # Gaussian Process Optimization\n            if self.gp_model is None:\n                self.gp_model = self.train_gp(self.x, self.fitness)\n            x_gp = self.sample_gp(self.gp_model, self.lower_bound, self.upper_bound, self.dim)\n            y_gp = func(x_gp)\n            if y_gp < self.best_fitness:\n                self.best_fitness = y_gp\n                self.best_x = x_gp\n        return self.best_x, self.best_fitness\n\n    def train_gp(self, x, y):\n        gp_model = {'mean': lambda x: np.zeros(self.dim), 'cov': lambda x, x2: np.eye(self.dim)}\n        gp_model['mean'] = lambda x: np.zeros(self.dim)\n        gp_model['cov'] = lambda x, x2: np.eye(self.dim)\n        return gp_model\n\n    def sample_gp(self, gp_model, lower_bound, upper_bound, dim):\n        x_gp = np.zeros(dim)\n        for i in range(dim):\n            x_gp[i] = np.random.uniform(lower_bound, upper_bound)\n        return x_gp\n\n    def optimize_gp(self, gp_model, lower_bound, upper_bound, dim):\n        res = minimize(lambda x: -gp_model['mean'](x), x0=np.zeros(dim), method='SLSQP', bounds=[(lower_bound, upper_bound)]*dim)\n        return res.x", "name": "HybridADE_SACPLR_GPO", "description": "Novel Hybridization of Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate (ADE-SACPLR) and Gaussian Process Optimization (GPO) for Black-Box Optimization.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "7b603f89-e08b-433b-be09-187bf7348321", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.probability = 0.06521739130434782  # probability to change individual lines of the selected solution\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if random.random() < self.probability:  # refine the strategy with probability\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                else:\n                    x_new = self.x[j] + self.F * (self.x[random.randint(0, self.population_size-1)] - self.x[random.randint(0, self.population_size-1)])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR", "description": "A novel metaheuristic algorithm, Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate (ADE-SACPLR), is refined using a probability-based strategy to update the selected solution's parameters.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "090048f9-5e84-4486-8c6e-eaa101a5a0e7", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.probability = 0.06521739130434782\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if random.random() < self.probability:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                else:\n                    for _ in range(10):\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                        while r1 == idx or r2 == idx or r3 == idx:\n                            r1, r2, r3 = random.sample(range(self.population_size), 3)\n                        x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                        x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                        x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                        y_new = func(x_new)\n                        if y_new < self.fitness[j]:\n                            self.x[j] = x_new\n                            self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_", "description": "Novel Adaptive Differential Evolution with Self-Adaptive Crossover Probability, Learning Rate, and Mutation Scaling Factor (ADE-SACPLR+) that uses a probability of 0.06521739130434782 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "17ee1fb3-8e11-4145-a8cd-ecc1b3751450", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_DEN:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.ensemble_size = int(self.population_size * 0.043478260869565216)\n        self.ensemble_x = np.random.uniform(self.lower_bound, self.upper_bound, (self.ensemble_size, self.dim))\n        self.ensemble_fitness = np.inf * np.ones(self.ensemble_size)\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            # Dynamic Ensemble Learning\n            self.ensemble_fitness = func(self.ensemble_x)\n            idx = np.argmin(self.ensemble_fitness)\n            self.ensemble_best_x = self.ensemble_x[idx]\n            self.ensemble_best_fitness = self.ensemble_fitness[idx]\n            for j in range(self.ensemble_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.ensemble_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.ensemble_size), 3)\n                    x_new = self.ensemble_x[r1] + self.F * (self.ensemble_x[r2] - self.ensemble_x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.ensemble_fitness[j]:\n                        self.ensemble_x[j] = x_new\n                        self.ensemble_fitness[j] = y_new\n            # Update the selected solution\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n            # Update the ensemble\n            if self.ensemble_best_fitness < self.best_fitness:\n                self.best_fitness = self.ensemble_best_fitness\n                self.best_x = self.ensemble_best_x\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_DEN", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate with Dynamic Ensemble Learning (ADE-SACPLR-DEN) - An adaptive differential evolution algorithm that incorporates a dynamic ensemble learning strategy to refine the selected solution.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "e7015186-fc34-47be-bd59-10b2d98e27f0", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_LF:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    if np.random.rand() < self.crossover_probability:\n                        x_new = self.x[r1] + np.random.uniform(-1, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n            else:\n                self.sigma = self.sigma * 0.9  # Levy flight\n                for k in range(self.dim):\n                    self.x[idx, k] = self.x[idx, k] + np.random.uniform(-1, 1, 1) * self.sigma\n                    self.x[idx, k] = np.clip(self.x[idx, k], self.lower_bound, self.upper_bound)\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_LF", "description": "Novel Metaheuristic Algorithm: Adaptive Differential Evolution with Self-Adaptive Crossover Probability, Learning Rate, and Levy Flight (ADE-SACPLR-LF)", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "f34f95df-2fa4-4137-83e8-97de53c2cf96", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_LF:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.levy_flight_probability = 0.10869565217391304\n\n    def levy_flight(self):\n        step_size = np.random.gamma(1.5, 1) / (np.sqrt(2 + (self.dim - 1) * np.random.uniform(0, 1)))\n        direction = np.random.uniform(-1, 1, self.dim)\n        return step_size * direction\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if np.random.uniform(0, 1) < self.levy_flight_probability:\n                    x_new = self.x[j] + self.levy_flight()\n                else:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                y_new = func(x_new)\n                if y_new < self.fitness[j]:\n                    self.x[j] = x_new\n                    self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_LF", "description": "Novel hybrid metaheuristic algorithm, Adaptive Differential Evolution with Self-Adaptive Crossover Probability, Learning Rate, and Levy Flight (ADE-SACPLR-LF), which combines the strengths of adaptive differential evolution and levy flight for efficient black-box optimization.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "f5ef7bf8-dae8-4ef6-bdcf-cb757b1787dd", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.probability = 0.043478260869565216\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if random.random() < self.probability:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                else:\n                    self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n                    self.crossover_probability = max(0.1, min(1.0, self.CR))\n                    self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n                    if self.fitness[idx] < self.best_fitness:\n                        self.best_fitness = self.fitness[idx]\n                        self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR", "description": "Novel Metaheuristic Algorithm: Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate (ADE-SACPLR) with Probability-Based Line Refinement", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "4047d12e-45c8-48dd-811b-a2eab0861f07", "solution": "import numpy as np\nimport random\n\nclass HSA_QEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.HS_rate = 0.01\n        self.QEA_rate = 0.1\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.quantum_bit_string = np.random.choice([0, 1], size=(self.population_size, self.dim))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if random.random() < self.HS_rate:\n                    r1 = random.randint(0, self.population_size - 1)\n                    x_new = self.harmony_memory[r1] + np.random.uniform(-1, 1, self.dim) * (self.x[r1] - self.harmony_memory[r1])\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                        self.harmony_memory[j] = x_new\n                else:\n                    for k in range(self.dim):\n                        if random.random() < self.QEA_rate:\n                            self.quantum_bit_string[j, k] = 1 - self.quantum_bit_string[j, k]\n                    x_new = np.zeros(self.dim)\n                    for k in range(self.dim):\n                        if self.quantum_bit_string[j, k] == 1:\n                            x_new[k] = self.x[j, k] + np.random.uniform(-1, 1, 1)[0]\n                        else:\n                            x_new[k] = self.x[j, k] - np.random.uniform(-1, 1, 1)[0]\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.HS_rate = self.HS_rate + self.HS_rate * (self.HS_rate - 0.01)\n            self.HS_rate = max(0.001, min(0.1, self.HS_rate))\n            self.QEA_rate = self.QEA_rate + self.QEA_rate * (self.QEA_rate - 0.1)\n            self.QEA_rate = max(0.001, min(0.5, self.QEA_rate))\n        return self.best_x, self.best_fitness", "name": "HSA_QEA", "description": "Novel metaheuristic algorithm that combines the concepts of Harmony Search and Quantum-Inspired Evolutionary Algorithm (QEA) to solve black box optimization problems.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "52d094d7-94f9-4bb6-a4c3-7883e379dafe", "solution": "import numpy as np\nimport random\n\nclass BEHS_ACLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n            self.harmony_memory[idx] = self.x[idx]\n            self.x[idx] = np.random.choice(self.harmony_memory, p=np.exp(-self.fitness))\n        return self.best_x, self.best_fitness", "name": "BEHS_ACLR", "description": "A novel metaheuristic algorithm called \"BBOB-Enhanced Harmony Search with Adaptive Crossover and Learning Rate\" (BEHS-ACLR) that combines the harmony search algorithm with adaptive crossover probability and learning rate to optimize black box functions on the BBOB test suite.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"bad operand type for unary -: 'list'\").", "error": "TypeError(\"bad operand type for unary -: 'list'\")", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "359afff3-1968-414d-aeb5-f4fb38067a2b", "solution": "import numpy as np\nimport random\n\nclass BBOB_EHSADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.harmony_memory)\n            idx = np.argmin(y)\n            self.best_x = self.harmony_memory[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.harmony_memory[r1] + self.F * (self.harmony_memory[r2] - self.harmony_memory[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.harmony_memory[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.harmony_memory[idx]\n            # Update harmony memory\n            self.harmony_memory = np.concatenate((self.harmony_memory[1:], np.array([self.best_x])))\n            self.harmony_memory = np.clip(self.harmony_memory, self.lower_bound, self.upper_bound)\n        return self.best_x, self.best_fitness", "name": "BBOB_EHSADE", "description": "Novel metaheuristic algorithm, \"BBOB-Enhanced Harmony Search with Adaptive Differential Evolution\" (BBOB-EHSADE), that combines Harmony Search with Adaptive Differential Evolution to efficiently explore the search space and adaptively update parameters for black box optimization problems.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 21 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 21 is out of bounds for axis 0 with size 10')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "2870d6c0-2339-47d3-b8d6-ef0ac893bfbe", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_Perturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.probability = 0.043478260869565216\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n            # Perturbation of individual lines using the given probability\n            if random.random() < self.probability:\n                idx = np.argmin(self.fitness)\n                r1, r2, r3 = random.sample(range(self.population_size), 3)\n                while r1 == idx or r2 == idx or r3 == idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                self.x[idx] = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                self.x[idx] = self.x[idx] + self.sigma * np.random.normal(0, 1, self.dim)\n                self.x[idx] = np.clip(self.x[idx], self.lower_bound, self.upper_bound)\n                self.fitness[idx] = func(self.x[idx])\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_Perturbation", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate (ADE-SACPLR) with perturbation of individual lines using the given probability.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "afad40fc-1420-4b28-9f4e-72e5f77dae65", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_PLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.probability = 0.13043478260869565\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if random.random() < self.probability:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                else:\n                    for k in range(self.dim):\n                        x_new = self.x[j]\n                        x_new[k] = self.x[j][k] + self.F * (self.x[r1][k] - self.x[r2][k])\n                        x_new[k] = x_new[k] + self.sigma * np.random.normal(0, 1)\n                        x_new[k] = np.clip(x_new[k], self.lower_bound, self.upper_bound)\n                        y_new = func(x_new)\n                        if y_new < self.fitness[j]:\n                            self.x[j] = x_new\n                            self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_PLR", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate with Probabilistic Line Refinement (ADE-SACPLR-PLR)", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"cannot access local variable 'r1' where it is not associated with a value\").", "error": "UnboundLocalError(\"cannot access local variable 'r1' where it is not associated with a value\")", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "af23c114-0404-4c82-86c7-07e86b432093", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_DPCPM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.mutation_rate = 0.021739130434782608  # 1/47\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if random.random() < self.mutation_rate:  # Dynamic Population Mutation\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                else:\n                    r1, r2 = random.sample(range(self.population_size), 2)\n                    while r1 == idx or r2 == idx:\n                        r1, r2 = random.sample(range(self.population_size), 2)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[idx])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_DPCPM", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate with Dynamic Population and Crossover Probability Mutation (ADE-SACPLR-DPCPM)", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "ed83aa55-169a-48ab-afc3-4fcf358f6ccb", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.probability = 0.06521739130434782\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n            if random.random() < self.probability:\n                # Refine the strategy by modifying individual lines\n                idx = np.argmin(self.fitness)\n                for k in range(self.dim):\n                    if random.random() < 0.5:\n                        self.x[idx, k] = np.clip(self.x[idx, k] + self.sigma * np.random.normal(0, 1), self.lower_bound, self.upper_bound)\n                    else:\n                        self.x[idx, k] = np.clip(self.x[idx, k] - self.sigma * np.random.normal(0, 1), self.lower_bound, self.upper_bound)\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_Refined", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate (ADE-SACPLR) with Refinement via Probability-Based Line Modification.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "883d60f3-0677-4bf1-babb-443da5ab6381", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_GMM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.gmm_weights = np.random.dirichlet(np.ones(self.population_size), size=1)[0]\n        self.gmm_means = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.gmm_covs = np.random.uniform(0.1, 1.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            self.gmm_weights = self.gmm_weights + self.learning_rate * (self.gmm_weights - self.gmm_weights[idx])\n            self.gmm_means = self.gmm_means + self.learning_rate * (self.gmm_means - self.gmm_means[idx])\n            self.gmm_covs = self.gmm_covs + self.learning_rate * (self.gmm_covs - self.gmm_covs[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n            for k in range(self.population_size):\n                if k!= idx:\n                    gmm_sample = np.random.choice(self.population_size, p=self.gmm_weights)\n                    x_new = self.gmm_means[gmm_sample] + np.random.multivariate_normal(self.gmm_means[gmm_sample], self.gmm_covs[gmm_sample], 1)[0]\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[k]:\n                        self.x[k] = x_new\n                        self.fitness[k] = y_new\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_GMM", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate with Gaussian Mixture Model (ADE-SACPLR-GMM) updates the individual lines of the selected solution using a Gaussian Mixture Model with a probability of 0.021739130434782608.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities do not sum to 1').", "error": "ValueError('probabilities do not sum to 1')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "eb3dfcff-31b0-4807-a7d3-8b34a1e03f90", "solution": "import numpy as np\nimport random\n\nclass HQS_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.harmony_memory_size = 20\n        self.harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.quantum_bit_string = np.random.choice([0, 1], size=(self.population_size, self.dim), p=[0.5, 0.5])\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.harmony_memory)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.harmony_memory[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if self.quantum_bit_string[j, idx] == 1:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.harmony_memory[r1] + self.F * (self.harmony_memory[r2] - self.harmony_memory[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.harmony_memory[j] = x_new\n                        self.fitness[j] = y_new\n                        self.quantum_bit_string[j] = np.random.choice([0, 1], size=self.dim, p=[0.5, 0.5])\n                else:\n                    x_new = self.harmony_memory[j] + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.harmony_memory[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.harmony_memory[idx]\n        return self.best_x, self.best_fitness", "name": "HQS_DE", "description": "Hybridized Quantum-Inspired Harmony Search with Adaptive Differential Evolution (HQS-DE) - A novel metaheuristic algorithm that combines the global search ability of Quantum-Inspired Harmony Search with the local search ability of Adaptive Differential Evolution.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 48 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 48 is out of bounds for axis 0 with size 20')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "613b2ec5-a856-43a6-a43c-0482368d3d66", "solution": "import numpy as np\nimport random\n\nclass ADE_MPLR_SACPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate_1 = 0.01\n        self.learning_rate_2 = 0.001\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.phase = 0\n        self.phase_length = int(self.budget * 0.06521739130434782)\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            if self.phase < self.phase_length:\n                self.sigma = self.sigma + self.learning_rate_1 * (self.sigma - self.fitness[idx])\n                self.CR = self.CR + self.learning_rate_1 * (self.crossover_probability - self.CR)\n                self.crossover_probability = max(0.1, min(1.0, self.CR))\n                for j in range(self.population_size):\n                    if j!= idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                        while r1 == idx or r2 == idx or r3 == idx:\n                            r1, r2, r3 = random.sample(range(self.population_size), 3)\n                        x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                        x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                        x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                        y_new = func(x_new)\n                        if y_new < self.fitness[j]:\n                            self.x[j] = x_new\n                            self.fitness[j] = y_new\n                self.phase += 1\n            else:\n                self.sigma = self.sigma + self.learning_rate_2 * (self.sigma - self.fitness[idx])\n                self.CR = self.CR + self.learning_rate_2 * (self.crossover_probability - self.CR)\n                self.crossover_probability = max(0.1, min(1.0, self.CR))\n                for j in range(self.population_size):\n                    if j!= idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                        while r1 == idx or r2 == idx or r3 == idx:\n                            r1, r2, r3 = random.sample(range(self.population_size), 3)\n                        x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                        x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                        x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                        y_new = func(x_new)\n                        if y_new < self.fitness[j]:\n                            self.x[j] = x_new\n                            self.fitness[j] = y_new\n        return self.best_x, self.best_fitness", "name": "ADE_MPLR_SACPLR", "description": "Adaptive Differential Evolution with Multi-Phase Learning Rate and Self-Adaptive Crossover Probability and Learning Rate (ADE_MPLR-SACPLR) is a novel heuristic algorithm that combines adaptive learning rates and self-adaptive crossover probabilities to efficiently optimize black-box functions.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "9d5672ec-81f4-421a-8e33-31b3c739ac11", "solution": "import numpy as np\nimport random\n\nclass DE_LRAPM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.mutation_probability = 0.021739130434782608\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if random.random() < self.mutation_probability:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                else:\n                    r1 = random.randint(0, self.population_size - 1)\n                    while r1 == idx:\n                        r1 = random.randint(0, self.population_size - 1)\n                    x_new = self.x[r1] + self.F * (self.x[j] - self.x[idx])\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.CR - self.mutation_probability)\n            self.mutation_probability = max(0.0, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "DE_LRAPM", "description": "Differential Evolution with Learning Rate Adaptation and Probabilistic Mutation (DE-LRAPM) - a novel metaheuristic algorithm that adapts the learning rate and incorporates probabilistic mutation to enhance exploration and exploitation.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "5ce3acef-df3f-4218-a31b-78ef4bd26e9a", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_NMPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.probability = 0.06521739130434782\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if random.random() < self.probability:\n                idx1, idx2 = random.sample(range(self.population_size), 2)\n                while idx1 == idx2:\n                    idx1, idx2 = random.sample(range(self.population_size), 2)\n                self.x[idx1] = (self.x[idx1] + self.x[idx2]) / 2\n                self.fitness[idx1] = func(self.x[idx1])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_NMPLR", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate with Novel Mutation Operator and Probabilistic Line Refinement (ADE-SACPLR-NMPLR)", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "eee5ffc9-7ada-40a6-8b7d-033a4665ea54", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_PDR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.probability = 0.043478260869565216\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if random.random() < self.probability:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                else:\n                    if j!= idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                        while r1 == idx or r2 == idx or r3 == idx:\n                            r1, r2, r3 = random.sample(range(self.population_size), 3)\n                        x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                        x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                        x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                        y_new = func(x_new)\n                        if y_new < self.fitness[j]:\n                            self.x[j] = x_new\n                            self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_PDR", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate with Probability-Driven Refinement (ADE-SACPLR-PDR)", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "a461a55e-321a-4304-9e61-6f6e18761e3d", "solution": "import numpy as np\nimport random\nfrom scipy.stats import norm\n\nclass ADE_SACPLR_HBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.acquisition_function = self.pareto_ei\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            self.x[idx] = self.bayesian_optimization(func, self.acquisition_function, self.x[idx], self.lower_bound, self.upper_bound)\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness\n\n    def pareto_ei(self, x, y):\n        mu, sigma = 0, 1\n        return np.exp(-((x - y) / sigma) ** 2) * np.exp(x)\n\n    def bayesian_optimization(self, func, acquisition_function, x, lower_bound, upper_bound):\n        n_samples = 100\n        x_samples = np.random.uniform(lower_bound, upper_bound, (n_samples, self.dim))\n        y_samples = func(x_samples)\n        mu = np.mean(y_samples)\n        sigma = np.std(y_samples)\n        x_new = x + 0.1 * np.random.normal(0, 1, self.dim)\n        x_new = np.clip(x_new, lower_bound, upper_bound)\n        y_new = func(x_new)\n        acquisition_value = acquisition_function(x_new, y_new)\n        return x_new", "name": "ADE_SACPLR_HBO", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate with Novel Hybridization of Bayesian Optimization (ADE-SACPLR-HBO)", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "9bbbdbc2-b581-4622-9286-88b848beecab", "solution": "import numpy as np\nimport random\n\nclass HSABC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.HMS = 10\n        self.HMCR = 0.5\n        self.PAR = 0.5\n        self.bee_population_size = 50\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.bee_x = np.random.uniform(self.lower_bound, self.upper_bound, (self.bee_population_size, self.dim))\n        self.bee_fitness = np.inf * np.ones(self.bee_population_size)\n        self.best_bee_x = np.inf * np.ones(self.dim)\n        self.best_bee_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2 = random.sample(range(self.population_size), 2)\n                    while r1 == idx or r2 == idx:\n                        r1, r2 = random.sample(range(self.population_size), 2)\n                    x_new = self.x[r1] + (self.x[r2] - self.x[idx]) * np.random.uniform(0, 1)\n                    x_new = x_new + np.random.uniform(-1, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.HMCR = self.HMCR + 0.01 * (self.HMCR - 0.5)\n            self.HMCR = max(0.1, min(1.0, self.HMCR))\n            self.PAR = self.PAR + 0.01 * (self.PAR - 0.5)\n            self.PAR = max(0.1, min(1.0, self.PAR))\n            self.HMS = int(self.population_size * self.HMCR)\n            self.bee_x = np.random.uniform(self.lower_bound, self.upper_bound, (self.bee_population_size, self.dim))\n            self.bee_fitness = func(self.bee_x)\n            for j in range(self.bee_population_size):\n                r1, r2 = random.sample(range(self.bee_population_size), 2)\n                while r1 == j or r2 == j:\n                    r1, r2 = random.sample(range(self.bee_population_size), 2)\n                bee_x_new = self.bee_x[r1] + (self.bee_x[r2] - self.bee_x[j]) * np.random.uniform(0, 1)\n                bee_x_new = bee_x_new + np.random.uniform(-1, 1, self.dim)\n                bee_x_new = np.clip(bee_x_new, self.lower_bound, self.upper_bound)\n                y_new = func(bee_x_new)\n                if y_new < self.bee_fitness[j]:\n                    self.bee_x[j] = bee_x_new\n                    self.bee_fitness[j] = y_new\n            idx = np.argmin(self.bee_fitness)\n            self.best_bee_x = self.bee_x[idx]\n            self.best_bee_fitness = self.bee_fitness[idx]\n            if self.best_bee_fitness < self.best_fitness:\n                self.best_fitness = self.best_bee_fitness\n                self.best_x = self.best_bee_x\n        return self.best_x, self.best_fitness", "name": "HSABC", "description": "Hybridization of Harmony Search and Artificial Bee Colony with Dynamic Adjustment of Harmony Memory Size and Bee Population Size", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "059bb0d7-5eda-41bc-96c9-3caa764afa1a", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_R:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.change_probability = 0.06521739130434782\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if random.random() < self.change_probability:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                else:\n                    if j!= idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                        while r1 == idx or r2 == idx or r3 == idx:\n                            r1, r2, r3 = random.sample(range(self.population_size), 3)\n                        x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                        x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                        x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                        y_new = func(x_new)\n                        if y_new < self.fitness[j]:\n                            self.x[j] = x_new\n                            self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_R", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate Refinement (ADE-SACPLR-R) - Refines the crossover probability and learning rate of ADE-SACPLR based on the probability of changing individual lines.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "8f2f8d91-3a8c-4ce9-9cf7-e7523b8070cf", "solution": "import numpy as np\nimport random\n\nclass ADE_DYN:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.dynamic_neighborhood_size = int(self.population_size * 0.1)\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.neighborhoods = [[] for _ in range(self.population_size)]\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                        self.neighborhoods[j].append(idx)\n                        if len(self.neighborhoods[j]) > self.dynamic_neighborhood_size:\n                            self.neighborhoods[j].pop(0)\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n                for j in range(self.population_size):\n                    self.neighborhoods[j] = []\n        return self.best_x, self.best_fitness", "name": "ADE_DYN", "description": "Novel Adaptive Differential Evolution with Self-Adaptive Crossover Probability, Learning Rate, and Dynamic Neighborhoods (ADE-DYN).", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "83e3e9be-1899-4d1b-9eac-48acbca6849e", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_NS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.noise_scale = 0.1\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = x_new + self.noise_scale * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            self.noise_scale = self.noise_scale + self.learning_rate * (self.noise_scale - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_NS", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability, Learning Rate, and Noise Injection (ADE-SACPLR-NS) - A novel metaheuristic algorithm that combines adaptive crossover probability, learning rate, and noise injection to optimize black box functions.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "82a05c5e-5777-44bd-aed1-cca9846d6200", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_Genetic_Drift:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                    # Novel mutation operator inspired by genetic drift\n                    mutation_rate = 0.2391304347826087  # given probability\n                    if random.random() < mutation_rate:\n                        mutation_type = random.choice(['shift','scale', 'rotate'])\n                        if mutation_type =='shift':\n                            shift = np.random.uniform(-1, 1, self.dim)\n                            self.x[j] += shift\n                        elif mutation_type =='scale':\n                            scale = np.random.uniform(0.5, 1.5, self.dim)\n                            self.x[j] *= scale\n                        elif mutation_type == 'rotate':\n                            angle = np.random.uniform(0, 2 * np.pi, 1)\n                            rotation_matrix = np.array([[np.cos(angle), -np.sin(angle)], [np.sin(angle), np.cos(angle)]])\n                            self.x[j] = np.dot(rotation_matrix, self.x[j])\n                        self.x[j] = np.clip(self.x[j], self.lower_bound, self.upper_bound)\n                        y_new = func(self.x[j])\n                        if y_new < self.fitness[j]:\n                            self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_Genetic_Drift", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate (ADE-SACPLR) with a novel mutation operator inspired by the concept of 'genetic drift' in population genetics.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shapes (2,2,1) and (5,) not aligned: 1 (dim 2) != 5 (dim 0)').", "error": "ValueError('shapes (2,2,1) and (5,) not aligned: 1 (dim 2) != 5 (dim 0)')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "144a4aa7-a431-4589-9e29-a34cba70053c", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_PR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.probability_refine = 0.32608695652173914\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n            # Probability-Based Line Refinement\n            if random.random() < self.probability_refine:\n                for k in range(self.dim):\n                    if random.random() < 0.5:\n                        self.best_x[k] += 0.01 * np.random.normal(0, 1)\n                        self.best_x[k] = np.clip(self.best_x[k], self.lower_bound, self.upper_bound)\n                    else:\n                        self.best_x[k] -= 0.01 * np.random.normal(0, 1)\n                        self.best_x[k] = np.clip(self.best_x[k], self.lower_bound, self.upper_bound)\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_PR", "description": "Novel Metaheuristic Algorithm: Adaptive Differential Evolution with Self-Adaptive Crossover Probability, Learning Rate, and Probability-Based Line Refinement (ADE-SACPLR-PR)", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "9fd447b9-3820-4d69-ae90-aef127061644", "solution": "import numpy as np\nimport random\n\nclass ADE_DYN:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.neighborhood_size = 5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.neighborhoods = np.zeros((self.population_size, self.neighborhood_size))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                        self.neighborhoods[j] = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            for j in range(self.population_size):\n                if self.fitness[j] < self.fitness[np.random.choice(self.neighborhoods[j])]:\n                    self.fitness[j] = self.fitness[np.random.choice(self.neighborhoods[j])]\n                    self.x[j] = self.x[np.random.choice(self.neighborhoods[j])]\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_DYN", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability, Learning Rate, and Dynamic Neighborhoods (ADE-DYN).", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('list indices must be integers or slices, not numpy.float64').", "error": "TypeError('list indices must be integers or slices, not numpy.float64')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "97c10fb5-7a6f-4e1b-a4e9-791504fd5ea5", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.probability = 0.15217391304347827\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if random.random() < self.probability:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                else:\n                    x_new = self.x[j] + self.F * np.random.normal(0, 1, self.dim)\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR", "description": "A novel metaheuristic algorithm, called Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate (ADE-SACPLR), which combines the strengths of adaptive differential evolution and self-adaptive crossover probability and learning rate to efficiently solve black box optimization problems.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "540198e5-ff73-4841-ac2b-6ed92100e5a2", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_Probability_Matrix:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.mutation_probability_matrix = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            self.mutation_probability_matrix = np.clip(self.mutation_probability_matrix + self.learning_rate * (np.random.uniform(0, 1, (self.population_size, self.dim)) - self.mutation_probability_matrix), 0, 1)\n            for k in range(self.dim):\n                idx = np.argmin(self.fitness)\n                if random.random() < self.mutation_probability_matrix[idx, k]:\n                    self.x[idx, k] = self.x[idx, k] + self.sigma * np.random.normal(0, 1)\n                    self.x[idx, k] = np.clip(self.x[idx, k], self.lower_bound, self.upper_bound)\n                    y_new = func(self.x[idx])\n                    if y_new < self.fitness[idx]:\n                        self.fitness[idx] = y_new\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_Probability_Matrix", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability, Learning Rate, and Mutation Step, and a novel strategy of using a probability matrix to guide the mutation process.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "26baee50-5e86-476e-95b7-4d6232188893", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR_NOVO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n            # Novel mutation operator\n            for k in range(int(self.population_size * 0.021739130434782608)):\n                idx_mut = random.randint(0, self.population_size - 1)\n                r1, r2 = random.sample(range(self.population_size), 2)\n                while r1 == idx_mut or r2 == idx_mut:\n                    r1, r2 = random.sample(range(self.population_size), 2)\n                x_mut = self.x[r1] + self.F * (self.x[r2] - self.x[idx_mut])\n                x_mut = x_mut + self.sigma * np.random.normal(0, 1, self.dim)\n                x_mut = np.clip(x_mut, self.lower_bound, self.upper_bound)\n                y_mut = func(x_mut)\n                if y_mut < self.fitness[idx_mut]:\n                    self.x[idx_mut] = x_mut\n                    self.fitness[idx_mut] = y_mut\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR_NOVO", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate with Novel Mutation Operator (ADE-SACPLR-NOVO) - A novel metaheuristic algorithm that combines the strengths of Adaptive Differential Evolution with a novel mutation operator to improve the exploration and exploitation capabilities.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "b42f5898-e500-49fa-8ae5-87f1dd264d22", "solution": "import numpy as np\n\nclass HarmonySearch_SimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.harmony_memory_size = 10\n        self.para = 0.5\n        self.max_iter = 100\n        self.t = 100\n        self.alpha = 0.99\n        self.beta = 0.01\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + (self.x[r2] - self.x[r3]) * np.random.uniform(-1, 1)\n                    x_new = x_new + np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            # Harmony Search\n            for j in range(self.harmony_memory_size):\n                x_new = np.mean(self.x, axis=0) + np.random.uniform(-1, 1) * np.std(self.x, axis=0)\n                x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                y_new = func(x_new)\n                if y_new < self.fitness[j]:\n                    self.x[j] = x_new\n                    self.fitness[j] = y_new\n            # Simulated Annealing\n            for j in range(self.population_size):\n                if np.random.uniform(0, 1) < self.para:\n                    r1, r2 = random.sample(range(self.population_size), 2)\n                    while r1 == j or r2 == j:\n                        r1, r2 = random.sample(range(self.population_size), 2)\n                    x_new = self.x[r1] + (self.x[r2] - self.x[j]) * np.random.uniform(-1, 1)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                if self.fitness[j] < self.best_fitness:\n                    self.best_fitness = self.fitness[j]\n                    self.best_x = self.x[j]\n            self.para = self.alpha * self.para + self.beta * (1 - self.para)\n            self.t = self.t * self.alpha\n        return self.best_x, self.best_fitness", "name": "HarmonySearch_SimulatedAnnealing", "description": "Novel hybrid metaheuristic algorithm combining Harmony Search and Simulated Annealing to solve black box optimization problems with a probability of 0.06521739130434782 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "2536cebd-36c4-490a-86a7-5b8ce35113b9", "solution": "import numpy as np\nimport random\n\nclass SAMOELSPBC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.operators = ['ADE', 'PSO', 'GA', 'DE']\n        self.operator_probabilities = [0.21, 0.21, 0.21, 0.37]\n        self.operator_probabilities /= np.sum(self.operator_probabilities)\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if random.random() < self.operator_probabilities[0]:  # ADE\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                elif random.random() < self.operator_probabilities[1]:  # PSO\n                    v = self.x[j] + self.F * np.random.normal(0, 1, self.dim)\n                    v = np.clip(v, self.lower_bound, self.upper_bound)\n                    y_new = func(v)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = v\n                        self.fitness[j] = y_new\n                elif random.random() < self.operator_probabilities[2]:  # GA\n                    x_new = self.x[j] + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                else:  # DE\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "SAMOELSPBC", "description": "Self-Adaptive Multi-Operator Ensemble with Local Search and Probability-Based Crossover (SAMOELSPBC) - A novel ensemble algorithm that combines multiple optimization operators with local search and probability-based crossover to adaptively select the best operators for each problem.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "922bff23-f018-4dde-a192-a6f2497784bb", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n        self.probability = 0.06521739130434782\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if random.random() < self.probability:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n                else:\n                    x_new = self.x[j] + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate (ADE-SACPLR) with Enhanced Mutation Strategy using Probability-Driven Line Refining.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
{"id": "565c0b4f-e816-4710-9c5d-5defe0b5af24", "solution": "import numpy as np\nimport random\n\nclass ADE_SACPLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.5\n        self.CR = 0.5\n        self.sigma = 0.1\n        self.learning_rate = 0.01\n        self.crossover_probability = 0.5\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_x = np.inf * np.ones(self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            y = func(self.x)\n            self.fitness = y\n            idx = np.argmin(y)\n            self.best_x = self.x[idx]\n            self.best_fitness = y[idx]\n            for j in range(self.population_size):\n                if j!= idx:\n                    r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    while r1 == idx or r2 == idx or r3 == idx:\n                        r1, r2, r3 = random.sample(range(self.population_size), 3)\n                    x_new = self.x[r1] + self.F * (self.x[r2] - self.x[r3])\n                    x_new = x_new + self.sigma * np.random.normal(0, 1, self.dim)\n                    x_new = np.clip(x_new, self.lower_bound, self.upper_bound)\n                    y_new = func(x_new)\n                    if y_new < self.fitness[j]:\n                        self.x[j] = x_new\n                        self.fitness[j] = y_new\n            self.CR = self.CR + self.learning_rate * (self.crossover_probability - self.CR)\n            self.crossover_probability = max(0.1, min(1.0, self.CR))\n            self.sigma = self.sigma + self.learning_rate * (self.sigma - self.fitness[idx])\n            if self.fitness[idx] < self.best_fitness:\n                self.best_fitness = self.fitness[idx]\n                self.best_x = self.x[idx]\n            # Change individual lines of the selected solution with a probability of 0.06521739130434782\n            if random.random() < 0.06521739130434782:\n                idx_change = random.randint(0, self.population_size - 1)\n                if idx_change!= idx:\n                    self.x[idx_change] = self.x[idx_change] + np.random.normal(0, 0.1, self.dim)\n                    self.x[idx_change] = np.clip(self.x[idx_change], self.lower_bound, self.upper_bound)\n                    y_new = func(self.x[idx_change])\n                    if y_new < self.fitness[idx_change]:\n                        self.fitness[idx_change] = y_new\n        return self.best_x, self.best_fitness", "name": "ADE_SACPLR", "description": "Novel metaheuristic algorithm: Adaptive Differential Evolution with Self-Adaptive Crossover Probability and Learning Rate (ADE-SACPLR) with a probability of 0.06521739130434782 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bfd7d6d5-984b-4d41-a071-6275a705fad6", "metadata": {}, "mutation_prompt": null}
