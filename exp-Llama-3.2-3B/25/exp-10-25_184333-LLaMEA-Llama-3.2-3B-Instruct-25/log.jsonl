{"id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization\" algorithm.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 84, in <module>\nTypeError: 'DiversityBasedASPSO' object is not callable\n.", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 84, in <module>\nTypeError: 'DiversityBasedASPSO' object is not callable\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "fc652f62-0f87-426e-9a42-3e709260bdec", "solution": "import numpy as np\nimport random\n\nclass MultiObjectiveASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self objectives = np.random.uniform(0, 1, (self.population_size, self.dim))\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n            self.objectives[self.population.index(individual)] = func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n                self.objectives[i] = self.objectives[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([np.sum(obj) for obj in self.objectives])], np.argmin([np.sum(obj) for obj in self.objectives])\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = MultiObjectiveASPO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "MultiObjectiveASPSO", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Diversity and Adaptive Particle Swarm Optimization\" combines diversity-based selection, adaptive particle swarm optimization, and multi-objective optimization to solve black box optimization problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 17, 14, '        self objectives = np.random.uniform(0, 1, (self.population_size, self.dim))\\n', 17, 24)).", "error": "SyntaxError('invalid syntax', ('<string>', 17, 14, '        self objectives = np.random.uniform(0, 1, (self.population_size, self.dim))\\n', 17, 24))", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "0ff42365-fffe-4d82-8e9b-de84a4839cf9", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.refine_probability:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def refine(self):\n        new_population = []\n        for individual in self.population:\n            if individual[0] < self.upper_bound and individual[1] < self.upper_bound:\n                new_individual = individual\n                for _ in range(int(self.refine_probability * self.dim)):\n                    new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                new_population.append(new_individual)\n        self.population = new_population\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n            self.refine()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization\" algorithm with probabilistic refinement.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "1133b3d9-ad52-43db-ba97-63c6d21d2596", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_probability = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.mutation_probability:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def adaptive_diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.adaptive_diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\neiea = EvolutionaryInspiredEvolutionaryAlgorithm(100, 10)\nresult = eiea(func)\nprint(result)", "name": "EvolutionaryInspiredEvolutionaryAlgorithm", "description": "Novel \"Evolutionary- inspired Evolutionary Algorithm\" with adaptive diversity and probability-based mutation.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'EvolutionaryInspiredEvolutionaryAlgorithm' object is not callable\").", "error": "TypeError(\"'EvolutionaryInspiredEvolutionaryAlgorithm' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "1d2983af-d2a4-407a-b4ca-e095fb1a0d96", "solution": "import numpy as np\n\nclass DiversityBasedHSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                probability = np.random.rand()\n                if probability < 0.25:\n                    self.population[i] = self.population[min_index]\n\n    def harmony_search(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nhs = DiversityBasedHSO(100, 10)\nresult = hs(func)\nprint(result)", "name": "DiversityBasedHSO", "description": "Novel \"Diversity-Based Adaptive Harmony Search Optimization\" algorithm.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedHSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedHSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "bf701835-60dc-4647-a708-dffa65ad0bc8", "solution": "import numpy as np\nimport random\nimport copy\n\nclass MetaLearningASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.meta_models = []\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def train_meta_model(self, func):\n        inputs = [individual for individual in self.population]\n        outputs = [func(individual) for individual in inputs]\n        weights = np.random.rand(self.population_size, self.dim)\n        for _ in range(100):\n            predictions = np.dot(inputs, weights)\n            errors = outputs - predictions\n            weights -= 0.1 * np.dot(np.transpose(inputs), errors)\n        self.meta_models.append(weights)\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(10):  # refine strategy\n            for individual in self.population:\n                r = np.random.rand()\n                if r < 0.25:\n                    individual = copy.deepcopy(individual)\n                    weights = np.random.rand(self.population_size, self.dim)\n                    individual = np.dot(individual, weights)\n                    individual = np.clip(individual, self.lower_bound, self.upper_bound)\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = MetaLearningASPO(100, 10)\naspo.train_meta_model(func)\nresult = aspo(func)\nprint(result)", "name": "MetaLearningASPSO", "description": "Novel \"Meta-Learning-Based Adaptive Particle Swarm Optimization\" algorithm", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'MetaLearningASPO' is not defined\").", "error": "NameError(\"name 'MetaLearningASPO' is not defined\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "b51bd27d-aeab-4277-8f9e-894fcfe06df8", "solution": "import numpy as np\nimport random\nfrom scipy.stats import gaussian_kde\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.diversity_model = gaussian_kde(self.diversity())\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            density = self.diversity_model(diversity[i, :])\n            if random.random() < 0.25 * density:\n                min_diversity = np.inf\n                min_index = -1\n                for j in range(self.population_size):\n                    if diversity[j, 0] < min_diversity:\n                        min_diversity = diversity[j, 0]\n                        min_index = j\n                if diversity[min_index, 0] < 0.5:\n                    self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization with Gaussian Mixture Model\" algorithm.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (2,) into shape (10,)').", "error": "ValueError('could not broadcast input array from shape (2,) into shape (10,)')", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "0ab8f621-50af-49a2-a417-fa7eb7b884c4", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedEAA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_prob = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.mutation_prob:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                if random.random() < 0.25:\n                    self.population[i] = self.population[min_index]\n                else:\n                    self.population[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\neaa = DiversityBasedEAA(100, 10)\nresult = eaas(func)\nprint(result)", "name": "DiversityBasedEAA", "description": "Novel \"Diversity-Based Adaptive Evolutionary Algorithm\" with adaptive mutation probability", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'eaas' is not defined\").", "error": "NameError(\"name 'eaas' is not defined\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "3379aa70-75ef-405a-8c00-92613e7ece24", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.adaptive_diversity = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.adaptive_diversity:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def adaptive_diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def refine_strategy(self, diversity):\n        for i in range(self.population_size):\n            if diversity[i, 0] < 0.5:\n                min_diversity = np.inf\n                min_index = -1\n                for j in range(self.population_size):\n                    if diversity[j, 0] < min_diversity:\n                        min_diversity = diversity[j, 0]\n                        min_index = j\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.refine_strategy(self.adaptive_diversity())\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.refine_strategy(self.adaptive_diversity())\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nehs = EvolutionaryHarmonySearch(100, 10)\nresult = ehs(func)\nprint(result)", "name": "EvolutionaryHarmonySearch", "description": "Novel \"Evolutionary Harmony Search\" algorithm with adaptive diversity control.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'EvolutionaryHarmonySearch' object is not callable\").", "error": "TypeError(\"'EvolutionaryHarmonySearch' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "c3b880a5-e5b1-4fcd-b2e5-0cb11730f285", "solution": "import numpy as np\nimport random\n\nclass CognitiveHarmonySearchWithAdaptation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                # Change individual lines with probability 0.25\n                if random.random() < 0.25:\n                    new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    new_individual += np.random.uniform(-1, 1, self.dim) * 0.1\n                    if new_individual[0] < self.lower_bound:\n                        new_individual[0] = self.lower_bound\n                    if new_individual[0] > self.upper_bound:\n                        new_individual[0] = self.upper_bound\n                    if new_individual[1] < self.lower_bound:\n                        new_individual[1] = self.lower_bound\n                    if new_individual[1] > self.upper_bound:\n                        new_individual[1] = self.upper_bound\n                    self.population[i] = new_individual\n                else:\n                    self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nchswa = CognitiveHarmonySearchWithAdaptation(100, 10)\nresult = chswa(func)\nprint(result)", "name": "CognitiveHarmonySearchWithAdaptation", "description": "Novel \"Cognitive Harmony Search with Adaptation\" algorithm.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'CognitiveHarmonySearchWithAdaptation' object is not callable\").", "error": "TypeError(\"'CognitiveHarmonySearchWithAdaptation' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "6c66d17f-b19e-446f-bd02-33e5519be143", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_probability = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.mutation_probability:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization\" algorithm with probabilistic mutation and adaptive diversity.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "13c552db-3936-401c-b55d-87fab3729576", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_prob = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.mutation_prob:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization\" algorithm with probabilistic mutation.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "7083cd78-6993-43b9-a276-9dc7a28018b5", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.probability = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.probability:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization with Probabilistic Mutation\" algorithm", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "b92d8cfb-9fa4-4016-bd13-06e248abc430", "solution": "import numpy as np\nimport random\nimport copy\n\nclass MetaLearnerASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.meta_model = self.initialize_meta_model()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def initialize_meta_model(self):\n        meta_model = []\n        for _ in range(self.population_size):\n            meta_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            meta_model.append(meta_individual)\n        return meta_model\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def meta_learning(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.meta_model = self.update_meta_model(func, self.meta_model)\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.meta_model = self.update_meta_model(func, self.meta_model)\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n    def update_meta_model(self, func, meta_model):\n        new_meta_model = copy.deepcopy(meta_model)\n        for i in range(len(meta_model)):\n            for j in range(len(meta_model)):\n                if i!= j:\n                    distance = np.linalg.norm(meta_model[i] - meta_model[j])\n                    new_meta_model[i] += 0.25 * (func(meta_model[i]) - func(meta_model[j])) * (distance / (distance + 1e-6))\n        return new_meta_model\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = MetaLearnerASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "MetaLearnerASPSO", "description": "Novel \"Meta-Learning-Based Adaptive Particle Swarm Optimization\" algorithm", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'MetaLearnerASPSO' object is not callable\").", "error": "TypeError(\"'MetaLearnerASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "47bb46b3-0eab-4c34-b03b-371db2c93e7a", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedAEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.25:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naea = DiversityBasedAEA(100, 10)\nresult = aea(func)\nprint(result)", "name": "DiversityBasedAEA", "description": "Novel \"Diversity-Based Adaptive Evolutionary Algorithm\" with probabilistic mutation.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedAEA' object is not callable\").", "error": "TypeError(\"'DiversityBasedAEA' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "954efa28-d33f-4082-94f0-f6f91808fc2b", "solution": "import numpy as np\nimport random\n\nclass ProbabilisticDiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.refine_probability:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = ProbabilisticDiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "ProbabilisticDiversityBasedASPSO", "description": "Novel \"Probabilistic Diversity-Based Adaptive Particle Swarm Optimization\" algorithm", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'ProbabilisticDiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'ProbabilisticDiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "02f81daf-a189-40e7-aa6e-a29187ff4c01", "solution": "import numpy as np\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.probability = 0.25\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if np.random.rand() < self.probability:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                if np.random.rand() < self.probability:\n                    self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization with Probability Refinement\" algorithm.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "9103ff21-7546-4595-b344-f8f8344baaec", "solution": "import numpy as np\nimport random\nimport time\n\nclass DiversityBasedAMMO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.objectives = []\n        self.individuals = []\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n            self.objectives.append(func(individual))\n            self.individuals.append(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                probability = 0.25\n                if random.random() < probability:\n                    self.population[i] = self.population[min_index]\n                    self.objectives[i] = self.objectives[min_index]\n                    self.individuals[i] = self.individuals[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.individuals[np.argmin(self.objectives)], self.objectives[np.argmin(self.objectives)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedAMMO(100, 10)\nresult, objectives = aspo(func)\nprint(result, objectives)", "name": "DiversityBasedAMMO", "description": "Novel \"Diversity-Based Adaptive Multi-Objective Optimization\" algorithm", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedAMMO' object is not callable\").", "error": "TypeError(\"'DiversityBasedAMMO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "6f2bfab2-baf4-4c82-a609-c90061222584", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < 0.25:\n                individual[i] += np.random.uniform(-0.1, 0.1)\n                individual[i] = max(self.lower_bound, min(individual[i], self.upper_bound))\n        return individual\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        new_population = []\n        for individual in self.population:\n            new_individual = self.mutation(individual)\n            new_population.append(new_individual)\n        return new_population[np.argmin([func(individual) for individual in new_population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization\" with adaptive mutation strategy and diversity-based selection.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "64de3128-4dc2-4d3e-ab6d-f3f1eb74c338", "solution": "import numpy as np\nimport random\n\nclass EvolutionarySpaceFillingAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                if random.random() < 0.25:\n                    self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = EvolutionarySpaceFillingAlgorithm(100, 10)\nresult = aspo(func)\nprint(result)", "name": "EvolutionarySpaceFillingAlgorithm", "description": "Novel \"Evolutionary Space Filling Algorithm\" for black box optimization.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'EvolutionarySpaceFillingAlgorithm' object is not callable\").", "error": "TypeError(\"'EvolutionarySpaceFillingAlgorithm' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "16adbb00-ba21-4c4e-99c1-2c52f781a68a", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryTreeBasedOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.tree_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.tree = self.initialize_tree()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def initialize_tree(self):\n        tree = []\n        for _ in range(self.tree_size):\n            tree.append(np.random.uniform(self.lower_bound, self.upper_bound, self.dim))\n        return tree\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.tree_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.tree[random.randint(0, self.tree_size - 1)])\n                v2 = r2 * self.c2 * (self.tree[random.randint(0, self.tree_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def mutation(self):\n        mutation_rate = 0.25\n        for individual in self.population:\n            if random.random() < mutation_rate:\n                index = np.random.randint(0, self.dim)\n                individual[index] = self.tree[np.random.randint(0, self.tree_size)]\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n            self.mutation()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n            self.mutation()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nevolutionary_tree_based_optimization = EvolutionaryTreeBasedOptimization(100, 10)\nresult = evolutionary_tree_based_optimization(func)\nprint(result)", "name": "EvolutionaryTreeBasedOptimization", "description": "Novel \"Evolutionary Tree-Based Optimization\" algorithm with adaptive mutation.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'EvolutionaryTreeBasedOptimization' object is not callable\").", "error": "TypeError(\"'EvolutionaryTreeBasedOptimization' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "af236ef8-de9e-4504-9513-8c25dea2de6b", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_prob = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.mutation_prob:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization\" algorithm with probabilistic mutation.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "6241bd02-99be-4369-b9ee-938210834e41", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedAEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self, func):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self, func):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self, func):\n        diversity = self.diversity(func)\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                if random.random() < 0.25:\n                    self.population[i] = self.population[min_index]\n                else:\n                    # adaptive mutation\n                    r = np.random.uniform(0, 1)\n                    if r < 0.5:\n                        self.population[i] = self.population[min_index] + np.random.uniform(-0.5, 0.5, self.dim)\n                    else:\n                        self.population[i] = self.population[min_index] - np.random.uniform(0.5, 1.0, self.dim)\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update(func)\n            self.adaptive(func)\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update(func)\n            self.adaptive(func)\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naea = DiversityBasedAEA(100, 10)\nresult = aea(func)\nprint(result)", "name": "DiversityBasedAEA", "description": "Novel \"Diversity-Based Adaptive Evolutionary Algorithm\" with adaptive mutation strategy", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedAEA' object is not callable\").", "error": "TypeError(\"'DiversityBasedAEA' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "66f4a67b-8fc2-4f99-baee-e6c8c3513388", "solution": "import numpy as np\nimport random\n\nclass AdaptiveDynamicEVA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.diversity = np.zeros((self.population_size, self.dim))\n        self.adaptation_rate = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                self.diversity[i, :] = np.append(distance, 1 - distance)\n\n    def adaptation(self):\n        for i in range(self.population_size):\n            if random.random() < self.adaptation_rate:\n                min_diversity = np.inf\n                min_index = -1\n                for j in range(self.population_size):\n                    if self.diversity[j, 0] < min_diversity:\n                        min_diversity = self.diversity[j, 0]\n                        min_index = j\n                if self.diversity[min_index, 0] < 0.5:\n                    self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptation()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptation()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\neva = AdaptiveDynamicEVA(100, 10)\nresult = eva(func)\nprint(result)", "name": "AdaptiveDynamicEVA", "description": "Novel \"Adaptive Dynamic Evolutionary Algorithm\" with Diversity and Adaptation Mechanism", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'AdaptiveDynamicEVA' object is not callable\").", "error": "TypeError(\"'AdaptiveDynamicEVA' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "49e914b1-1dfb-4c59-80a2-07d353bbe390", "solution": "import numpy as np\n\nclass EHAEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_rate = 0.25\n        self.hybridization_rate = 0.5\n        self.hybrid_population = []\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def hybridize(self):\n        for _ in range(int(self.population_size * self.hybridization_rate)):\n            parent1 = np.random.choice(self.population_size)\n            parent2 = np.random.choice(self.population_size)\n            child = (self.population[parent1] + self.population[parent2]) / 2\n            if np.random.rand() < self.mutation_rate:\n                child += np.random.uniform(-0.1, 0.1, self.dim)\n            self.hybrid_population.append(child)\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n            self.hybridize()\n        self.hybrid_population = [self.evaluate_fitness(individual, func) for individual in self.hybrid_population]\n        best_individual = self.hybrid_population.index(min(self.hybrid_population))\n        return self.hybrid_population[best_individual]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nehaea = EHAEA(100, 10)\nresult = ehaea(func)\nprint(result)", "name": "EHAEA", "description": "Novel \"Evolutionary Adaptive Hybrid Evolutionary Algorithm\" (EHAEA) combines evolutionary strategies with adaptive mutation and hybridization to improve black box optimization.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'EHAEA' object is not callable\").", "error": "TypeError(\"'EHAEA' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "c9d9af2c-e637-443a-837d-6a7c5cdf74fc", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                mutation_probability = 0.25\n                if random.random() < mutation_probability:\n                    self.population[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization\" algorithm with probabilistic mutation.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "9db529e2-8616-4dd3-86bc-e3da16a759e9", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarms = [self.initialize_swarm() for _ in range(5)]\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            swarm.append(individual)\n        return swarm\n\n    def evaluate(self, func):\n        for swarm in self.swarms:\n            for individual in swarm:\n                func(individual)\n\n    def update(self):\n        for swarm in self.swarms:\n            for _ in range(self.swarm_size):\n                for individual in swarm:\n                    r1 = np.random.uniform(0, 1)\n                    r2 = np.random.uniform(0, 1)\n                    v1 = r1 * self.c1 * (individual - self.swarm[random.randint(0, len(self.swarms) - 1)][random.randint(0, len(self.swarm[random.randint(0, len(self.swarms) - 1)]) - 1)])\n                    v2 = r2 * self.c2 * (self.swarm[random.randint(0, len(self.swarms) - 1)][random.randint(0, len(self.swarm[random.randint(0, len(self.swarms) - 1)]) - 1)] - individual)\n                    individual += v1 + v2\n                    if individual[0] < self.lower_bound:\n                        individual[0] = self.lower_bound\n                    if individual[0] > self.upper_bound:\n                        individual[0] = self.upper_bound\n                    if individual[1] < self.lower_bound:\n                        individual[1] = self.lower_bound\n                    if individual[1] > self.upper_bound:\n                        individual[1] = self.upper_bound\n                    if random.random() < 0.2:\n                        individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((len(self.swarms), self.population_size, self.dim))\n        for i in range(len(self.swarms)):\n            for j in range(self.population_size):\n                for k in range(self.population_size):\n                    distance = np.linalg.norm(self.swarms[i][j] - self.swarms[i][k])\n                    diversity[i, j, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(len(self.swarms)):\n            for j in range(self.population_size):\n                min_diversity = np.inf\n                min_index = -1\n                for k in range(self.population_size):\n                    if diversity[i, j, 0] < min_diversity:\n                        min_diversity = diversity[i, j, 0]\n                        min_index = k\n                if diversity[i, j, 0] < 0.5:\n                    self.swarms[i][j] = self.swarms[i][min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            for swarm in self.swarms:\n                self.update()\n                self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            for swarm in self.swarms:\n                self.update()\n                self.adaptive()\n        return self.swarms[np.argmin([func(individual) for individual in [individual for swarm in self.swarms for individual in swarm]])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmEvolution(100, 10)\nresult = ms(func)\nprint(result)", "name": "MultiSwarmEvolution", "description": "Novel \"Multi-Swarm Evolution\" algorithm that combines multiple swarms with diverse strategies to optimize black box functions.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'MultiSwarmEvolution' object is not callable\").", "error": "TypeError(\"'MultiSwarmEvolution' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "7061f55a-bcd3-4944-b4be-bdce1d7d0699", "solution": "import numpy as np\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                probability = np.random.rand()\n                if probability < 0.25:\n                    self.population[i] = self.population[min_index]\n                    self.population[min_index] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Harmony Search Optimization\" algorithm", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "645291d5-87f7-43bb-af0b-6f5cd74ec29b", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryAlgorithmASPR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def adaptive(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        replacement_probabilities = np.random.uniform(0, 1, size=self.population_size)\n        for i in range(self.population_size):\n            if replacement_probabilities[i] < 0.25:\n                min_diversity_index = np.argmin(diversity[i, :])\n                self.population[i] = self.population[min_diversity_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspr = EvolutionaryAlgorithmASPR(100, 10)\nresult = aspr(func)\nprint(result)", "name": "EvolutionaryAlgorithmASPR", "description": "Novel \"Evolutionary Algorithm with Adaptive Search and Probabilistic Replacement\" algorithm.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'EvolutionaryAlgorithmASPR' object is not callable\").", "error": "TypeError(\"'EvolutionaryAlgorithmASPR' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "8b9f19fc-b2fc-43f6-9c2b-d9cd1d9f7d84", "solution": "import numpy as np\n\nclass AdaptiveProbabilityDrivenEVA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.probability = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self, func):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.probability:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update(func)\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update(func)\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\neva = AdaptiveProbabilityDrivenEVA(100, 10)\nresult = eva(func)\nprint(result)", "name": "AdaptiveProbabilityDrivenEVA", "description": "Novel \"Adaptive Probability-Driven Evolutionary Algorithm\" with diversity-based selection and adaptive mutation.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'AdaptiveProbabilityDrivenEVA' object is not callable\").", "error": "TypeError(\"'AdaptiveProbabilityDrivenEVA' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "c7031a4e-1716-4328-b8bb-b37f750e12f9", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.refine_probability:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization\" algorithm with adaptive mutation and refinement probability.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "be0ddfc4-4ced-414b-badf-2b8c285398fc", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.refine_probability:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def refine(self, func):\n        new_population = []\n        for individual in self.population:\n            new_individual = individual\n            if random.random() < self.refine_probability:\n                new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            func(new_individual)\n            new_population.append(new_individual)\n        self.population = new_population\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n            self.refine(func)\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Evolutionary Strategy Optimization\" algorithm.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "7d3338e2-6220-4cfb-be77-a4f70225f809", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_probability = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.mutation_probability:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization\" algorithm with adaptive mutation strategy", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "284d1b58-b673-4d54-b38b-0d5165326173", "solution": "import numpy as np\n\nclass DiversityBasedEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_probability = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if np.random.rand() < self.mutation_probability:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedEvolutionaryAlgorithm(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedEvolutionaryAlgorithm", "description": "Novel \"Diversity-Based Adaptive Evolutionary Algorithm\" using a probabilistic mutation strategy", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedEvolutionaryAlgorithm' object is not callable\").", "error": "TypeError(\"'DiversityBasedEvolutionaryAlgorithm' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "78fc46ba-318f-450d-85ac-24a46d5cadd6", "solution": "import numpy as np\nimport random\n\nclass ATEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.threshold = 0.25\n        self.mutation_rate = 0.2\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.mutation_rate:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def threshold_selection(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        distances = np.sort(diversity, axis=1)[:, 1]\n        threshold = distances[int(self.population_size * self.threshold)]\n        return threshold\n\n    def adaptive(self):\n        threshold = self.threshold_selection()\n        for i in range(self.population_size):\n            if np.linalg.norm(self.population[i] - self.population[random.randint(0, self.population_size - 1)]) < threshold:\n                self.population[i] = self.population[random.randint(0, self.population_size - 1)]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\natea = ATEA(100, 10)\nresult = atea(func)\nprint(result)", "name": "ATEA", "description": "Novel \"Adaptive-Threshold Evolutionary Algorithm\" (ATEA) with adaptive mutation strategy and threshold-based selection.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'ATEA' object is not callable\").", "error": "TypeError(\"'ATEA' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "c4d73d93-b480-426e-87c5-dc69dad31bc4", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_prob = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.refine_prob:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def refine(self):\n        for _ in range(int(self.budget * self.refine_prob)):\n            i = np.random.randint(0, self.population_size)\n            j = np.random.randint(0, self.population_size)\n            self.population[i] = (1 - random.random()) * self.population[i] + (1 - random.random()) * self.population[j]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        self.refine()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Swarm Optimization\" algorithm with probabilistic refinement.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "698260bb-f7b6-4ec5-8724-ff3b8816fc3e", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSOES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.es = self.initialize_es()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def initialize_es(self):\n        es = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            es.append(individual)\n        return es\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def evolutionary_strategy(self):\n        for individual in self.population:\n            if np.random.rand() < 0.25:\n                self.es[np.random.randint(0, self.population_size)] = individual\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n            self.es = self.es\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n            self.es = self.es\n        best_individual = self.population[np.argmin([func(individual) for individual in self.population])]\n        best_es = self.es[np.argmin([func(individual) for individual in self.es])]\n        return best_individual, best_es\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSOES(100, 10)\nbest_individual, best_es = aspo(func)\nprint(best_individual)\nprint(best_es)", "name": "DiversityBasedASPSOES", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization with Evolutionary Strategy\" algorithm.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSOES' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSOES' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "ac2ff48a-7703-400e-958f-800bab820866", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedAQE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_probability = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.mutation_probability:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naqe = DiversityBasedAQE(100, 10)\nresult = aqe(func)\nprint(result)", "name": "DiversityBasedAQE", "description": "Novel \"Diversity-Based Adaptive Quantum Evolutionary Algorithm\" with adaptive mutation strategy and quantum-inspired diversification mechanism.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedAQE' object is not callable\").", "error": "TypeError(\"'DiversityBasedAQE' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "944bbb8b-3abd-434c-9d54-2f3fe388f716", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSORefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.refine_probability:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def refine(self):\n        for _ in range(int(self.budget * 0.25)):\n            new_individuals = []\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < r2:\n                    new_individual = individual + np.random.uniform(-0.1, 0.1, self.dim)\n                    new_individual = np.clip(new_individual, self.lower_bound, self.upper_bound)\n                    new_individuals.append(new_individual)\n                else:\n                    new_individual = individual\n                    new_individuals.append(new_individual)\n            self.population = new_individuals\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n            self.refine()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSORefine(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSORefine", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization with Refinement\" algorithm.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSORefine' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSORefine' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "6ee250e0-bdd0-453c-914f-971a271d4a56", "solution": "import numpy as np\nimport random\n\nclass PBAEASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.probability = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.probability:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = PBAEASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "PBAEASPSO", "description": "Novel \"Probability-Based Adaptive Evolutionary Algorithm\" using Diversity-Based Adaptive Particle Swarm Optimization", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'PBAEASPSO' object is not callable\").", "error": "TypeError(\"'PBAEASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "3ef2bbc5-d202-412f-8fb6-a47beda06c13", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHybridEVA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutate_prob = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.mutate_prob:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = MultiSwarmHybridEVA(100, 10)\nresult = aspo(func)\nprint(result)", "name": "MultiSwarmHybridEVA", "description": "Novel \"Multi-Swarm Hybrid Evolutionary Algorithm\" with adaptive mutation and diversity-based selection.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'MultiSwarmHybridEVA' object is not callable\").", "error": "TypeError(\"'MultiSwarmHybridEVA' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "2d29aa08-004f-4810-8130-55c7940bd592", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryTreeBasedOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.tree_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.tree_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def evolve_tree(self):\n        new_population = []\n        for _ in range(self.population_size):\n            parent1 = np.random.choice(self.population)\n            parent2 = np.random.choice(self.population)\n            child = parent1 + (parent2 - parent1) * np.random.uniform(0, 1)\n            if child[0] < self.lower_bound:\n                child[0] = self.lower_bound\n            if child[0] > self.upper_bound:\n                child[0] = self.upper_bound\n            if child[1] < self.lower_bound:\n                child[1] = self.lower_bound\n            if child[1] > self.upper_bound:\n                child[1] = self.upper_bound\n            new_population.append(child)\n        self.population = new_population\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n            self.evolve_tree()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = EvolutionaryTreeBasedOptimization(100, 10)\nresult = aspo(func)\nprint(result)", "name": "EvolutionaryTreeBasedOptimization", "description": "Novel \"Evolutionary Tree-Based Optimization\" algorithm.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'EvolutionaryTreeBasedOptimization' object is not callable\").", "error": "TypeError(\"'EvolutionaryTreeBasedOptimization' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "ae3814b1-711f-44f4-bb01-e4a53a7cdbe0", "solution": "import numpy as np\n\nclass EvolutionaryGradientASPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.gradients = np.zeros((self.population_size, self.dim))\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.gradients[random.randint(0, self.population_size - 1)] = func(individual) - func(self.population[random.randint(0, self.population_size - 1)])\n\n    def adaptive(self):\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity = 1 - distance\n                if diversity < min_diversity:\n                    min_diversity = diversity\n                    min_index = j\n            if min_diversity < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def refine(self):\n        for _ in range(int(self.budget * 0.25)):\n            for i in range(self.population_size):\n                if random.random() < 0.25:\n                    r1 = np.random.uniform(0, 1)\n                    r2 = np.random.uniform(0, 1)\n                    v1 = r1 * self.c1 * (self.population[i] - self.population[random.randint(0, self.population_size - 1)])\n                    v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - self.population[i])\n                    self.population[i] += v1 + v2\n                    if self.population[i][0] < self.lower_bound:\n                        self.population[i][0] = self.lower_bound\n                    if self.population[i][0] > self.upper_bound:\n                        self.population[i][0] = self.upper_bound\n                    if self.population[i][1] < self.lower_bound:\n                        self.population[i][1] = self.lower_bound\n                    if self.population[i][1] > self.upper_bound:\n                        self.population[i][1] = self.upper_bound\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n            self.refine()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = EvolutionaryGradientASPO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "EvolutionaryGradientASPO", "description": "Novel \"Evolutionary-Gradient-Based Optimization\" algorithm that combines evolutionary strategies with gradient-based optimization to handle black box optimization problems.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'EvolutionaryGradientASPO' object is not callable\").", "error": "TypeError(\"'EvolutionaryGradientASPO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "58716968-67e6-4f16-af5e-eb885b84a58e", "solution": "import numpy as np\nimport random\nfrom scipy.special import expit\n\nclass MetaLearningASPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.meta_model = self.initialize_meta_model()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def initialize_meta_model(self):\n        model = {}\n        for i in range(self.population_size):\n            input_dim = self.dim\n            output_dim = 1\n            model[f'meta_{i}'] = {'weights': np.random.rand(input_dim, output_dim), 'bias': np.random.rand(output_dim)}\n        return model\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def meta_update(self, func):\n        for i in range(self.population_size):\n            input_dim = self.dim\n            output_dim = 1\n            x = self.population[i]\n            y = func(x)\n            z = np.expit(np.dot(x, self.meta_model[f'meta_{i}']['weights']) + self.meta_model[f'meta_{i}']['bias'])\n            self.meta_model[f'meta_{i}']['weights'] += 0.1 * (x - z) * (y - z)\n            self.meta_model[f'meta_{i}']['bias'] += 0.1 * (y - z)\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n            self.meta_update(func)\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = MetaLearningASPO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "MetaLearningASPO", "description": "Novel \"Meta-Learning Based Black Box Optimization\" algorithm", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'MetaLearningASPO' object is not callable\").", "error": "TypeError(\"'MetaLearningASPO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "e61cfff4-0fa7-4ccb-97c5-d913cfb6fb56", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_prob = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.mutation_prob:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization\" algorithm with adaptive mutation probability.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "5b309c46-a37a-4c53-9d60-f0ef20ea1e09", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_prob = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self, func):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.mutation_prob:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update(func)\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update(func)\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedEvolutionaryAlgorithm(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedEvolutionaryAlgorithm", "description": "Novel \"Diversity-Based Adaptive Evolutionary Algorithm\" with probabilistic mutation.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedEvolutionaryAlgorithm' object is not callable\").", "error": "TypeError(\"'DiversityBasedEvolutionaryAlgorithm' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "9ddfe381-eec8-45a2-9d10-ecb42e5cd9d6", "solution": "import numpy as np\n\nclass MultiObjectiveEVA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self, func):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self, func):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                if np.random.rand() < 0.25:\n                    self.population[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                else:\n                    self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update(func)\n            self.adaptive(func)\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update(func)\n            self.adaptive(func)\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\neva = MultiObjectiveEVA(100, 10)\nresult = eva(func)\nprint(result)", "name": "MultiObjectiveEVA", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Diversity and Adaptive Strategy\" combines multiple evolutionary strategies to optimize black box functions.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'MultiObjectiveEVA' object is not callable\").", "error": "TypeError(\"'MultiObjectiveEVA' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "1bc5fa64-bb12-45f4-ba97-553b07f78b71", "solution": "import numpy as np\n\nclass EvolutionaryInformationBottleneck:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.info_bottleneck = np.zeros((self.population_size, self.dim))\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def info_bottleneck_update(self):\n        for i in range(self.population_size):\n            self.info_bottleneck[i, :] = np.sum(np.abs(self.population[i] - self.population[i]), axis=1)\n        for i in range(self.population_size):\n            min_info_bottleneck = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if self.info_bottleneck[j, 0] < min_info_bottleneck:\n                    min_info_bottleneck = self.info_bottleneck[j, 0]\n                    min_index = j\n            if self.info_bottleneck[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.info_bottleneck_update()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.info_bottleneck_update()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\neb = EvolutionaryInformationBottleneck(100, 10)\nresult = eb(func)\nprint(result)", "name": "EvolutionaryInformationBottleneck", "description": "Novel \"Evolutionary Information Bottleneck\" algorithm.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'EvolutionaryInformationBottleneck' object is not callable\").", "error": "TypeError(\"'EvolutionaryInformationBottleneck' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "874bd2b6-dc8b-453f-b8d9-1ffad90b4f5f", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.hybrid_prob = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.hybrid_prob:\n                    individual = self.evolve(individual)\n                else:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def evolve(self, individual):\n        offspring = individual.copy()\n        for _ in range(5):\n            mutation = np.random.uniform(-1, 1, self.dim)\n            offspring += mutation\n            if offspring[0] < self.lower_bound:\n                offspring[0] = self.lower_bound\n            if offspring[0] > self.upper_bound:\n                offspring[0] = self.upper_bound\n            if offspring[1] < self.lower_bound:\n                offspring[1] = self.lower_bound\n            if offspring[1] > self.upper_bound:\n                offspring[1] = self.upper_bound\n        return offspring\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization with Hybrid Evolution Strategy\" algorithm.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "b219671e-65ee-48e7-9340-c2ee5a16858b", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                if random.random() < 0.25:\n                    self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization\" algorithm with probabilistic mutation.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "eb760598-d9ab-4b43-afa5-db7ee1c9e344", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedAMOEVA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self, func):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.25:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self, func):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self, func):\n        diversity = self.diversity(func)\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update(func)\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update(func)\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedAMOEVA(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedAMOEVA", "description": "Novel \"Diversity-Based Adaptive Multi-Objective Evolutionary Algorithm\" with probability 0.25 to refine individual lines.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedAMOEVA' object is not callable\").", "error": "TypeError(\"'DiversityBasedAMOEVA' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "addc9221-79da-460a-aeb4-5ac977c2e21c", "solution": "import numpy as np\nimport random\n\nclass EvolutionarySpaceFillingAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_prob = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.mutation_prob:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = EvolutionarySpaceFillingAlgorithm(100, 10)\nresult = aspo(func)\nprint(result)", "name": "EvolutionarySpaceFillingAlgorithm", "description": "Novel \"Evolutionary Space Filling Algorithm\" with adaptive mutation and diversity-based selection.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'EvolutionarySpaceFillingAlgorithm' object is not callable\").", "error": "TypeError(\"'EvolutionarySpaceFillingAlgorithm' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "eb82b8e5-7775-4073-b17a-4af2406c2a85", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.25:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    if random.random() < 0.5:\n                        individual = self.population[random.randint(0, self.population_size - 1)]\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization\" algorithm with 0.25 probability of changing individual lines.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "34d1dee9-a40e-4e3b-879a-0a4c9569be2a", "solution": "import numpy as np\nimport random\n\nclass MetaLEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.meta_model = self.initialize_meta_model()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def initialize_meta_model(self):\n        meta_model = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            meta_model[i, :] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        return meta_model\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self, func):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.meta_model = self.update_meta_model(func)\n\n    def update_meta_model(self, func):\n        meta_model = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            individual = self.population[i]\n            fitness = func(individual)\n            for j in range(self.population_size):\n                other_individual = self.population[j]\n                other_fitness = func(other_individual)\n                if other_fitness < fitness:\n                    meta_model[i, :] = other_individual\n        return meta_model\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.meta_model[min_index, :]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update(func)\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update(func)\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = MetaLEA(100, 10)\nresult = aspo(func)\nprint(result)", "name": "MetaLEA", "description": "Novel \"Meta-Learning Based Evolutionary Algorithm\" with adaptive mutation and diversity-based selection.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'MetaLEA' object is not callable\").", "error": "TypeError(\"'MetaLEA' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "b54e5650-6fd8-4c19-80b2-2d5a7acdd50e", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self, mutation_prob=0.25):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                new_individual = individual + v1 + v2\n                if new_individual[0] < self.lower_bound:\n                    new_individual[0] = self.lower_bound\n                if new_individual[0] > self.upper_bound:\n                    new_individual[0] = self.upper_bound\n                if new_individual[1] < self.lower_bound:\n                    new_individual[1] = self.lower_bound\n                if new_individual[1] > self.upper_bound:\n                    new_individual[1] = self.upper_bound\n                if random.random() < mutation_prob:\n                    new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                individual = new_individual\n        return self.population\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.population = self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.population = self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization\" algorithm with probabilistic mutation.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "373a5d14-9710-4b42-baf0-69a88864b1e5", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryAdaptation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.refine_probability:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nea = EvolutionaryAdaptation(100, 10)\nresult = ea(func)\nprint(result)", "name": "EvolutionaryAdaptation", "description": "Novel \"Evolutionary Adaptation with Crossover and Mutation\" algorithm.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'EvolutionaryAdaptation' object is not callable\").", "error": "TypeError(\"'EvolutionaryAdaptation' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "6bb11e01-c6fc-45cc-824f-7a33b41c089e", "solution": "import numpy as np\n\nclass ProbabilisticAdaptiveEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.diversity_threshold = 0.5\n        self.mutation_rate = 0.2\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < self.diversity_threshold:\n                self.population[i] = self.population[min_index]\n\n    def mutate(self):\n        for i in range(self.population_size):\n            if np.random.rand() < self.mutation_rate:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (self.population[i] - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - self.population[i])\n                self.population[i] += v1 + v2\n                if self.population[i][0] < self.lower_bound:\n                    self.population[i][0] = self.lower_bound\n                if self.population[i][0] > self.upper_bound:\n                    self.population[i][0] = self.upper_bound\n                if self.population[i][1] < self.lower_bound:\n                    self.population[i][1] = self.lower_bound\n                if self.population[i][1] > self.upper_bound:\n                    self.population[i][1] = self.upper_bound\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n            self.mutate()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\npaea = ProbabilisticAdaptiveEvolutionaryAlgorithm(100, 10)\nresult = paea(func)\nprint(result)", "name": "ProbabilisticAdaptiveEvolutionaryAlgorithm", "description": "Novel \"Probabilistic Adaptive Evolutionary Algorithm\" with adaptive diversity and mutation.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'ProbabilisticAdaptiveEvolutionaryAlgorithm' object is not callable\").", "error": "TypeError(\"'ProbabilisticAdaptiveEvolutionaryAlgorithm' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "952cbb66-b03e-4ca8-b000-e9126ff41f63", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_prob = 0.2\n        self.mutation_count = 0\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.mutation_prob:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    self.mutation_count += 1\n                if self.mutation_count > 10:\n                    self.mutation_prob = max(0.1, self.mutation_prob - 0.1)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization\" algorithm with adaptive mutation probability.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "f328516b-68e4-48a1-b589-2c360d2f791d", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryGradientBasedOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def gradient(self, func):\n        gradient = np.zeros(self.dim)\n        for individual in self.population:\n            gradient -= 2 * (func(individual) - np.min(func(self.population)))\n        return gradient\n\n    def refine(self, func):\n        for _ in range(int(self.budget * 0.25)):\n            new_population = []\n            for _ in range(self.population_size):\n                individual = self.population[np.random.choice(self.population_size)]\n                gradient = self.gradient(func)\n                step_size = np.random.uniform(0, 1)\n                new_individual = individual + step_size * gradient\n                new_individual = np.clip(new_individual, self.lower_bound, self.upper_bound)\n                new_population.append(new_individual)\n            self.population = new_population\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        self.refine(func)\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = EvolutionaryGradientBasedOptimization(100, 10)\nresult = aspo(func)\nprint(result)", "name": "EvolutionaryGradientBasedOptimization", "description": "Novel \"Evolutionary-Gradient-Based Optimization\" algorithm using gradient estimation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'EvolutionaryGradientBasedOptimization' object is not callable\").", "error": "TypeError(\"'EvolutionaryGradientBasedOptimization' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "aed8c227-472e-4cf9-80d0-8d8cb24cd454", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_prob = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.mutation_prob:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                if random.random() < 0.25:\n                    self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization\" algorithm with probabilistic mutation.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "0d8396a4-bf3b-405a-8860-e39badad8a92", "solution": "import numpy as np\nimport random\n\nclass ProbabilisticDiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.refine_probability:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def refine(self):\n        for i in range(self.population_size):\n            if random.random() < self.refine_probability:\n                self.population[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n            self.refine()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n            self.refine()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = ProbabilisticDiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "ProbabilisticDiversityBasedASPSO", "description": "Novel \"Probabilistic Diversity-Based Adaptive Particle Swarm Optimization\" algorithm", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'ProbabilisticDiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'ProbabilisticDiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "9ff362f0-bd38-4627-ad21-7c564995c192", "solution": "import numpy as np\nimport random\nimport copy\n\nclass DiversityBasedAEAO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n                if random.random() < 0.25:\n                    self.population[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naao = DiversityBasedAEAO(100, 10)\nresult = aao(func)\nprint(result)", "name": "DiversityBasedAEAO", "description": "Novel \"Diversity-Based Adaptive Evolutionary Algorithm with Multi-Objective Optimization\"", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedAEAO' object is not callable\").", "error": "TypeError(\"'DiversityBasedAEAO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "05180348-eea6-432c-bcb8-1e397e493720", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryTreeOfBoundedness:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.tree_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.tree_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def evolve_tree(self):\n        new_population = []\n        for _ in range(self.population_size):\n            r = np.random.uniform(0, 1)\n            if r < 0.25:\n                new_individual = self.population[random.randint(0, self.population_size - 1)]\n                new_population.append(new_individual)\n            else:\n                new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                for i in range(self.dim):\n                    if random.random() < 0.5:\n                        new_individual[i] = self.population[random.randint(0, self.population_size - 1)][i]\n                new_population.append(new_individual)\n        self.population = new_population\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n            self.evolve_tree()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\netob = EvolutionaryTreeOfBoundedness(100, 10)\nresult = etob(func)\nprint(result)", "name": "EvolutionaryTreeOfBoundedness", "description": "Novel \"Evolutionary Tree of Boundedness\" algorithm, which utilizes a tree-like structure to explore the search space and adapt to the problem's characteristics.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'EvolutionaryTreeOfBoundedness' object is not callable\").", "error": "TypeError(\"'EvolutionaryTreeOfBoundedness' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "59a2e994-25e7-4ebc-be93-099a8d9ea6ee", "solution": "import numpy as np\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_prob = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if np.random.rand() < self.mutation_prob:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization\" algorithm with probabilistic mutation.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "e43af71a-e193-4e13-b644-5422e8152d7e", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedAMOO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refinement_probability = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def refine(self):\n        for i in range(self.population_size):\n            if random.random() < self.refinement_probability:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (self.population[i] - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - self.population[i])\n                self.population[i] += v1 + v2\n                if self.population[i][0] < self.lower_bound:\n                    self.population[i][0] = self.lower_bound\n                if self.population[i][0] > self.upper_bound:\n                    self.population[i][0] = self.upper_bound\n                if self.population[i][1] < self.lower_bound:\n                    self.population[i][1] = self.lower_bound\n                if self.population[i][1] > self.upper_bound:\n                    self.population[i][1] = self.upper_bound\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n            self.refine()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\namoo = DiversityBasedAMOO(100, 10)\nresult = amoo(func)\nprint(result)", "name": "DiversityBasedAMOO", "description": "Novel \"Diversity-Based Adaptive Multi-Objective Optimization\" algorithm with probabilistic refinement.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedAMOO' object is not callable\").", "error": "TypeError(\"'DiversityBasedAMOO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "9ac5b090-3ada-4de2-addd-3903cb6ca6a4", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryComputationWithRefining:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self, prob_refine=0.25):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < prob_refine:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        return self.population\n\n    def refine(self, func):\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.population = self.update()\n            min_fitness = np.inf\n            min_individual = None\n            for individual in self.population:\n                if func(individual) < min_fitness:\n                    min_fitness = func(individual)\n                    min_individual = individual\n            self.population = [min_individual]\n        return self.population[0]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\necwr = EvolutionaryComputationWithRefining(100, 10)\nresult = ecwr.refine(func)\nprint(result)", "name": "EvolutionaryComputationWithRefining", "description": "Novel \"Evolutionary Computation with Probabilistic Refining\" algorithm", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "4a11a815-ec49-4548-93c7-eaf97e31a853", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedAMOEAA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.p_change = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.p_change:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\namoeea = DiversityBasedAMOEAA(100, 10)\nresult = amoeea(func)\nprint(result)", "name": "DiversityBasedAMOEAA", "description": "Novel \"Diversity-Based Adaptive Multi-Objective Evolutionary Algorithm\" with adaptive probability to change individual lines.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedAMOEAA' object is not callable\").", "error": "TypeError(\"'DiversityBasedAMOEAA' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "2889b2b7-3015-47dc-996b-135e076c9281", "solution": "import numpy as np\nimport random\nimport copy\n\nclass DiversityBasedMultiObjective:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self, func):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def multi_objective(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update(func)\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update(func)\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n    def refine_strategy(self, func):\n        new_population = []\n        for _ in range(self.population_size):\n            individual = copy.deepcopy(self.population[np.random.randint(0, self.population_size)])\n            if random.random() < 0.25:\n                individual += np.random.uniform(-0.5, 0.5, self.dim)\n            new_population.append(individual)\n        self.population = new_population\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2), np.sum(x**3)\n\naspo = DiversityBasedMultiObjective(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedMultiObjective", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Diversity-Based Adaptation\" for Black Box Optimization.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedMultiObjective' object is not callable\").", "error": "TypeError(\"'DiversityBasedMultiObjective' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "09ab50c2-a27a-443a-9f0b-6b165678c8ec", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                p = random.random()\n                if p < 0.25:\n                    self.population[i] = self.population[min_index]\n                else:\n                    self.population[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization with Probability Refinement\" algorithm", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "355ff2ce-c07e-447e-9644-ecbeb8aff6f7", "solution": "import numpy as np\nimport random\n\nclass PBDAASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.refine_probability:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                if random.random() < self.refine_probability:\n                    self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = PBDAASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "PBDAASPSO", "description": "Novel \"Probability-Based Diversity Adaptive Particle Swarm Optimization\" algorithm", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'PBDAASPSO' object is not callable\").", "error": "TypeError(\"'PBDAASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "18002328-d2ec-46b5-a0a7-7f57e5fc673b", "solution": "import numpy as np\n\nclass DiversityBasedEvolvingAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_rate = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if np.random.rand() < self.mutation_rate:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedEvolvingAlgorithm(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedEvolvingAlgorithm", "description": "Novel \"Diversity-Based Adaptive Evolutionary Algorithm with Probabilistic Mutation\" for black box optimization problems.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedEvolvingAlgorithm' object is not callable\").", "error": "TypeError(\"'DiversityBasedEvolvingAlgorithm' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "f22cd77b-9310-4f7d-99be-fbf7c67aaf8a", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.harmony_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.harmony_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                probability = random.random()\n                if probability < 0.25:\n                    self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedHarmonySearch(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedHarmonySearch", "description": "Novel \"Diversity-Based Adaptive Harmony Search Optimization\" algorithm", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedHarmonySearch' object is not callable\").", "error": "TypeError(\"'DiversityBasedHarmonySearch' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "c74322cc-d34f-4a9b-97c4-cc84ef02bb3e", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryGradientBasedOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.grads = None\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def gradient(self, func):\n        if self.grads is None:\n            self.grads = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            self.grads[i] = func(self.population[i]) - func(self.population[i] + 0.1 * np.random.uniform(-1, 1, self.dim))\n\n    def run(self, func):\n        self.grads = None\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n            self.gradient(func)\n        # Refine strategy by changing individual lines with probability 0.25\n        for i in range(self.population_size):\n            if random.random() < 0.25:\n                new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.population[i] = new_individual\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nebbo = EvolutionaryGradientBasedOptimization(100, 10)\nresult = ebbo(func)\nprint(result)", "name": "EvolutionaryGradientBasedOptimization", "description": "Novel \"Evolutionary-Gradient-Based Optimization\" algorithm.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'EvolutionaryGradientBasedOptimization' object is not callable\").", "error": "TypeError(\"'EvolutionaryGradientBasedOptimization' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "fb9df5f6-c1ab-4abe-be41-18985486ed5d", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryDrivenASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.adaptive_prob = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.adaptive_prob:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                if np.random.rand() < self.adaptive_prob:\n                    self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = EvolutionaryDrivenASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "EvolutionaryDrivenASPSO", "description": "Novel \"Evolutionary-Driven Adaptation of Particle Swarm Optimization\" algorithm.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'EvolutionaryDrivenASPSO' object is not callable\").", "error": "TypeError(\"'EvolutionaryDrivenASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "e28ffc97-70df-49d2-96de-f6541db90a20", "solution": "import numpy as np\nimport random\n\nclass ProbabilisticDiversityASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.probability = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self, func):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                new_individual = individual + v1 + v2\n                if new_individual[0] < self.lower_bound:\n                    new_individual[0] = self.lower_bound\n                if new_individual[0] > self.upper_bound:\n                    new_individual[0] = self.upper_bound\n                if new_individual[1] < self.lower_bound:\n                    new_individual[1] = self.lower_bound\n                if new_individual[1] > self.upper_bound:\n                    new_individual[1] = self.upper_bound\n                if random.random() < self.probability:\n                    new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                individual = new_individual\n        self.population = self.population\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update(func)\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update(func)\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = ProbabilisticDiversityASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "ProbabilisticDiversityASPSO", "description": "Novel \"Probabilistic Diversity-Based Adaptive Particle Swarm Optimization\" algorithm.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'ProbabilisticDiversityASPSO' object is not callable\").", "error": "TypeError(\"'ProbabilisticDiversityASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "d90d8136-3e7c-48d1-b9af-7ce1c1b271d0", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def mutate(self, individual):\n        if random.random() < 0.25:\n            new_individual = individual + np.random.uniform(-0.5, 0.5, self.dim)\n            new_individual = np.clip(new_individual, self.lower_bound, self.upper_bound)\n            return new_individual\n        else:\n            return individual\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            for i in range(self.population_size):\n                self.population[i] = self.mutate(self.population[i])\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization\" algorithm with adaptive mutation strategy.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "4935fc1a-32b4-428e-a5bd-ed644208f23d", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryLearningASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.probability = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.probability:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                if random.random() < self.probability:\n                    self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = EvolutionaryLearningASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "EvolutionaryLearningASPSO", "description": "Novel \"Evolutionary Learning with Self-Adaptive Probability\" algorithm.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'EvolutionaryLearningASPSO' object is not callable\").", "error": "TypeError(\"'EvolutionaryLearningASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "c74f8407-0779-4e32-8072-e2d5731275ad", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_prob = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.mutation_prob:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedEA(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedEA", "description": "Novel \"Diversity-Based Adaptive Evolutionary Algorithm\" with adaptive mutation strategy", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedEA' object is not callable\").", "error": "TypeError(\"'DiversityBasedEA' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "07ef0d59-235d-4502-958f-1d2d389b0efd", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedAEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                mutation_prob = random.random()\n                if mutation_prob < 0.25:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    for k in range(self.population_size):\n                        if k!= i:\n                            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                            break\n                self.population[i] = individual\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naea = DiversityBasedAEA(100, 10)\nresult = aea(func)\nprint(result)", "name": "DiversityBasedAEA", "description": "Novel \"Diversity-Based Adaptive Evolutionary Algorithm\" with probabilistic mutation.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedAEA' object is not callable\").", "error": "TypeError(\"'DiversityBasedAEA' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "604e667a-da98-4730-b4c5-744363b9b61f", "solution": "import numpy as np\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_prob = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if np.random.rand() < self.refine_prob:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization\" algorithm with probability 0.25 to refine its strategy.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "e0955cfe-8da3-4144-b1ae-b0fb0c138916", "solution": "import numpy as np\nimport random\n\nclass ProbabilisticDiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.refine_probability:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def refine(self):\n        new_population = []\n        for individual in self.population:\n            r1 = np.random.uniform(0, 1)\n            if r1 < self.refine_probability:\n                new_individual = individual + np.random.uniform(-0.1, 0.1, self.dim)\n                new_individual = np.clip(new_individual, self.lower_bound, self.upper_bound)\n                new_population.append(new_individual)\n            else:\n                new_population.append(individual)\n        self.population = new_population\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n            self.refine()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n            self.refine()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = ProbabilisticDiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "ProbabilisticDiversityBasedASPSO", "description": "Novel \"Probabilistic Diversity-Based Adaptive Particle Swarm Optimization\" algorithm", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'ProbabilisticDiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'ProbabilisticDiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "78d7a3e2-b426-46a8-8737-84b4cc7c798f", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_probability = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.mutation_probability:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization\" with adaptive mutation probability", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "c6ecfa1f-a7ca-4f17-85f0-eb2160d06d90", "solution": "import numpy as np\nimport random\n\nclass AdaptiveMutationDiversityEnhancement:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_rate = 0.25\n        self.diversity_threshold = 0.5\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.mutation_rate:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < self.diversity_threshold:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = AdaptiveMutationDiversityEnhancement(100, 10)\nresult = aspo(func)\nprint(result)", "name": "AdaptiveMutationDiversityEnhancement", "description": "Novel \"Evolutionary Computation with Adaptive Mutation and Diversity Enhancement\" algorithm.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'AdaptiveMutationDiversityEnhancement' object is not callable\").", "error": "TypeError(\"'AdaptiveMutationDiversityEnhancement' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "f9825f27-b728-4259-bde2-97befbeda75a", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.25:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization\" algorithm with probability-based mutation.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "76693d72-af9c-4c97-b086-db91d2ae6a49", "solution": "import numpy as np\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                p = np.random.uniform(0, 1)\n                if p < 0.25:\n                    self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Evolutionary Strategy\" algorithm.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "c6af4926-69e0-4bb9-a53d-f7c4595b437f", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass MOEAD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n    def refine(self):\n        for _ in range(5):\n            new_population = []\n            for _ in range(self.population_size):\n                individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                if random.random() < 0.25:\n                    individual = self.population[random.randint(0, self.population_size - 1)]\n                new_population.append(individual)\n            self.population = new_population\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = MOEAD(100, 10)\naspo.refine()\nresult = aspo(func)\nprint(result)", "name": "MOEAD", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Diversity and Adaptation\" to optimize black box functions.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'MOEAD' object is not callable\").", "error": "TypeError(\"'MOEAD' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "d22e5809-f5ae-4c33-a4c5-5f92bfecfb29", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedEAPE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_prob = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.mutation_prob:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspe = DiversityBasedEAPE(100, 10)\nresult = aspe(func)\nprint(result)", "name": "DiversityBasedEAPE", "description": "Novel \"Diversity-Based Adaptive Evolutionary Algorithm with Probabilistic Mutation\"", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedEAPE' object is not callable\").", "error": "TypeError(\"'DiversityBasedEAPE' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "e2bd7934-c9f6-4a07-8259-3e4a996f2d1a", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                probability = 0.25\n                if random.random() < probability:\n                    self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization\" algorithm with probability 0.25 to refine its strategy.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "495e2cf5-ec55-4356-b506-1348778ac275", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_prob = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.mutation_prob:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization\" algorithm with adaptive mutation strategy and 0.25 probability of line mutation.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "63036e21-58d1-472c-ac54-b1408b84bfe0", "solution": "import numpy as np\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_prob = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self, func):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if np.random.random() < self.refine_prob:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update(func)\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update(func)\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization\" algorithm with probability refinement", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "5964df2f-d7a5-4011-99e2-c8b5bf3c1f1f", "solution": "import numpy as np\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_prob = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if np.random.rand() < self.mutation_prob:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization\" with probabilistic mutation.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "249a24f9-2c8c-4f3a-94ac-8584689d79bd", "solution": "import numpy as np\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.probability = 0.25\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self, func):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                new_individual = individual + v1 + v2\n                if new_individual[0] < self.lower_bound:\n                    new_individual[0] = self.lower_bound\n                if new_individual[0] > self.upper_bound:\n                    new_individual[0] = self.upper_bound\n                if new_individual[1] < self.lower_bound:\n                    new_individual[1] = self.lower_bound\n                if new_individual[1] > self.upper_bound:\n                    new_individual[1] = self.upper_bound\n                if random.random() < self.probability:\n                    new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                individual = new_individual\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update(func)\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update(func)\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization with Probabilistic Mutation\" algorithm.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "8770407b-1941-4214-8f46-04738b2eae54", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.mutation_prob = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.mutation_prob:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                if random.random() < 0.25:\n                    self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization with Probabilistic Mutation\" algorithm.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "098ffd42-8f75-4e8b-90ed-f8fc4ff6a36b", "solution": "import numpy as np\nimport random\n\nclass CrossoverBEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < 0.25:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n            new_population = []\n            for _ in range(self.population_size):\n                parent1, parent2 = random.sample(self.population, 2)\n                child = self.crossover(parent1, parent2)\n                new_population.append(child)\n            self.population = new_population\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nabea = CrossoverBEA(100, 10)\nresult = abea(func)\nprint(result)", "name": "CrossoverBEA", "description": "Novel \"Crossover-Based Evolutionary Algorithm with Adaptive Probability\"", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'CrossoverBEA' object is not callable\").", "error": "TypeError(\"'CrossoverBEA' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "6f807b30-ec66-4c20-be51-2444d1565c4d", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedAMOE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refine_probability = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self, func):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.refine_probability:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update(func)\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update(func)\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\namo = DiversityBasedAMOE(100, 10)\nresult = amo(func)\nprint(result)", "name": "DiversityBasedAMOE", "description": "Novel \"Diversity-Based Adaptive Multi-Objective Evolutionary Algorithm\" with adaptive probability 0.25 for refining individual lines.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedAMOE' object is not callable\").", "error": "TypeError(\"'DiversityBasedAMOE' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "712265e0-6168-41ca-a19c-6d589dff9ddc", "solution": "import numpy as np\nimport random\n\nclass EvolutionarySpaceTimeOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.time = 0\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.time += 1\n                if self.time % 10 == 0:\n                    self.adaptive()\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n                if random.random() < 0.25:\n                    self.population[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = EvolutionarySpaceTimeOptimization(100, 10)\nresult = aspo(func)\nprint(result)", "name": "EvolutionarySpaceTimeOptimization", "description": "Novel \"Evolutionary Space-Time Optimization\" algorithm", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'EvolutionarySpaceTimeOptimization' object is not callable\").", "error": "TypeError(\"'EvolutionarySpaceTimeOptimization' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "ad23a2af-e31c-4d8d-b70f-085780a6e360", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.gene_mutate_prob = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.gene_mutate_prob:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def genetic_drift(self):\n        for i in range(self.population_size):\n            if np.random.rand() < 0.5:\n                self.population[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n            self.genetic_drift()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n            self.genetic_drift()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization with Genetic Drift\" algorithm.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "1aa53d1d-5bcc-4c4e-afde-1b1a42e5af59", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedADHH:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                self.population[i] = self.population[min_index]\n\n    def dynamic_hyper_heuristic(self):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        # Apply probability 0.25 to change individual lines\n        for i in range(self.population_size):\n            if random.random() < 0.25:\n                new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.population[i] = new_individual\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nadhh = DiversityBasedADHH(100, 10)\nresult = adhh(func)\nprint(result)", "name": "DiversityBasedADHH", "description": "Novel \"Diversity-Based Adaptive Dynamic Hyper-Heuristic\" algorithm.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedADHH' object is not callable\").", "error": "TypeError(\"'DiversityBasedADHH' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "b22f1492-2381-4bc6-96f3-dd63dd88a176", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedASPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.refinement_probability = 0.25\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < self.refinement_probability:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                if random.random() < self.refinement_probability:\n                    self.population[i] = self.population[min_index]\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naspo = DiversityBasedASPSO(100, 10)\nresult = aspo(func)\nprint(result)", "name": "DiversityBasedASPSO", "description": "Novel \"Diversity-Based Adaptive Particle Swarm Optimization with Probability Refinement\"", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedASPSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedASPSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
{"id": "a9088e58-0a2c-46d2-aeed-f7466e557e7b", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedACSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm_size = 10\n        self.warmup = 10\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.rho = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population.append(individual)\n        return population\n\n    def evaluate(self, func):\n        for individual in self.population:\n            func(individual)\n\n    def update(self):\n        for _ in range(self.swarm_size):\n            for individual in self.population:\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                v1 = r1 * self.c1 * (individual - self.population[random.randint(0, self.population_size - 1)])\n                v2 = r2 * self.c2 * (self.population[random.randint(0, self.population_size - 1)] - individual)\n                individual += v1 + v2\n                if individual[0] < self.lower_bound:\n                    individual[0] = self.lower_bound\n                if individual[0] > self.upper_bound:\n                    individual[0] = self.upper_bound\n                if individual[1] < self.lower_bound:\n                    individual[1] = self.lower_bound\n                if individual[1] > self.upper_bound:\n                    individual[1] = self.upper_bound\n                if random.random() < 0.2:\n                    individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def diversity(self):\n        diversity = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                distance = np.linalg.norm(self.population[i] - self.population[j])\n                diversity[i, :] = np.append(distance, 1 - distance)\n        return diversity\n\n    def adaptive(self):\n        diversity = self.diversity()\n        for i in range(self.population_size):\n            min_diversity = np.inf\n            min_index = -1\n            for j in range(self.population_size):\n                if diversity[j, 0] < min_diversity:\n                    min_diversity = diversity[j, 0]\n                    min_index = j\n            if diversity[min_index, 0] < 0.5:\n                prob = random.random()\n                if prob < 0.25:\n                    self.population[i] = self.population[min_index]\n                else:\n                    self.population[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def run(self, func):\n        for _ in range(self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        for _ in range(self.budget - self.warmup):\n            self.evaluate(func)\n            self.update()\n            self.adaptive()\n        return self.population[np.argmin([func(individual) for individual in self.population])]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nacso = DiversityBasedACSO(100, 10)\nresult = acso(func)\nprint(result)", "name": "DiversityBasedACSO", "description": "Novel \"Diversity-Based Adaptive Cuckoo Search Optimization\" algorithm", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'DiversityBasedACSO' object is not callable\").", "error": "TypeError(\"'DiversityBasedACSO' object is not callable\")", "parent_id": "fdd7f034-1d54-499b-b279-4012ac5f0413", "metadata": {}, "mutation_prompt": null}
