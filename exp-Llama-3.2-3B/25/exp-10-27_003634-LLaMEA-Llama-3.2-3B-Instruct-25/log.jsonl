{"id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 65\n    hybridHSPSO noiseless_func\n                ^^^^^^^^^^^^^^\nSyntaxError: invalid syntax\n.", "error": "SyntaxError('invalid syntax', ('<string>', 65, 13, 'hybridHSPSO noiseless_func\\n', 65, 27))Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 65\n    hybridHSPSO noiseless_func\n                ^^^^^^^^^^^^^^\nSyntaxError: invalid syntax\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "66bbb41c-8992-419c-bcd2-07342b30ffe2", "solution": "import numpy as np\nimport random\nimport copy\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Refine the strategy by changing 25% of the individuals\n            refine_indices = np.random.choice(self.population_size, size=int(self.population_size * 0.25), replace=False)\n            refine_x = self.x[refine_indices]\n            refine_new_x = np.zeros((len(refine_x), self.dim))\n            for i in range(len(refine_x)):\n                refine_new_x[i, :] = refine_x[i, :] + np.random.uniform(-0.1, 0.1, self.dim)\n                refine_new_x[i, :] = np.clip(refine_new_x[i, :], -5.0, 5.0)\n            self.x[refine_indices] = refine_new_x\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 76, 13, 'hybridHSPSO noiseless_func\\n', 76, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 76, 13, 'hybridHSPSO noiseless_func\\n', 76, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "82bc92a6-6b6e-41ec-90af-397a05dcaf53", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if random.random() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[random.randint(0, len(fittest_x)-1), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if random.random() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO()", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"HybridHSPSO.__call__() missing 1 required positional argument: 'func'\").", "error": "TypeError(\"HybridHSPSO.__call__() missing 1 required positional argument: 'func'\")", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "d1ddbde3-8a35-4c10-941f-333899989ee6", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Refine the strategy with probability 0.25\n            if random.random() < 0.25:\n                for i in range(self.population_size):\n                    new_individual = self.x[i, :]\n                    for j in range(self.dim):\n                        if random.random() < 0.25:\n                            new_individual[j] += np.random.uniform(-0.1, 0.1)\n                    self.x[i, :] = new_individual\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO()", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"HybridHSPSO.__call__() missing 1 required positional argument: 'func'\").", "error": "TypeError(\"HybridHSPSO.__call__() missing 1 required positional argument: 'func'\")", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "e2e3d7d5-0048-44ce-beee-cf2ea6d94bc2", "solution": "import numpy as np\nimport random\nimport re\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.probability = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n                if np.random.rand() < self.probability:\n                    new_x[i, :] = self.x[i, :] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 70, 13, 'hybridHSPSO noiseless_func\\n', 70, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 70, 13, 'hybridHSPSO noiseless_func\\n', 70, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "1e067e58-00b5-43b8-97bd-c14ca21e09f5", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Refine the strategy with a 25% probability\n            if np.random.rand() < 0.25:\n                # Select a random individual\n                selected_index = np.random.randint(0, self.population_size)\n                selected_individual = self.x[selected_index, :]\n\n                # Refine the individual by adding a small perturbation\n                refined_individual = selected_individual + np.random.uniform(-0.01, 0.01, self.dim)\n\n                # Ensure the search space bounds\n                refined_individual = np.clip(refined_individual, -5.0, 5.0, out=refined_individual)\n\n                # Replace the old individual with the refined one\n                self.x[selected_index, :] = refined_individual\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators and probabilistic refinement.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 80, 13, 'hybridHSPSO noiseless_func\\n', 80, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 80, 13, 'hybridHSPSO noiseless_func\\n', 80, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "83482906-999b-43e0-a2f3-dafa6173f354", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Apply probability 0.25 to change the individual lines of the selected solution\n            for i in range(self.population_size):\n                if random.random() < 0.25:\n                    new_x[i, :] = self.x[i, :] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 71, 13, 'hybridHSPSO noiseless_func\\n', 71, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 71, 13, 'hybridHSPSO noiseless_func\\n', 71, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "31665faf-cc80-4977-90b1-33776f092fcb", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy with probabilistic mutation\n            refine_indices = np.random.choice(self.population_size, size=int(self.population_size * 0.25), replace=False)\n            refine_x = self.x[refine_indices]\n            refine_x = refine_x + np.random.uniform(-0.05, 0.05, (self.dim,)) * np.random.rand(self.dim)\n            refine_x = np.clip(refine_x, -5.0, 5.0, out=refine_x)\n\n            # Replace the old population with the new one\n            self.x = np.vstack((self.x, refine_x))\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators and probabilistic refinement.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 71, 13, 'hybridHSPSO noiseless_func\\n', 71, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 71, 13, 'hybridHSPSO noiseless_func\\n', 71, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "fa1e3fff-7547-483c-84ed-d9b7b0456c9f", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy with probabilistic mutation\n            for i in range(self.population_size):\n                if np.random.rand() < 0.25:\n                    new_x[i, :] += np.random.uniform(-0.05, 0.05, self.dim)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators and probabilistic refinement.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 71, 13, 'hybridHSPSO noiseless_func\\n', 71, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 71, 13, 'hybridHSPSO noiseless_func\\n', 71, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "3822f73d-2e8a-4cd7-b25d-d48589412803", "solution": "import numpy as np\nimport random\nimport operator\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.pbest_indices = np.zeros(self.population_size, dtype=int)\n        self.gbest_index = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                    self.pbest_indices[i] = i\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n                    self.gbest_index = i\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy by changing individual lines\n            refine_indices = np.random.choice(self.population_size, size=int(self.population_size * 0.25), replace=False)\n            for i in refine_indices:\n                new_x[i, :] = self.x[refine_indices, :] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                    self.pbest_indices[i] = i\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n                    self.gbest_index = i\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 78, 13, 'hybridHSPSO noiseless_func\\n', 78, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 78, 13, 'hybridHSPSO noiseless_func\\n', 78, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "676feaf7-aa23-4228-ba89-d20fe990ebe4", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy with 25% probability\n            if np.random.rand() < 0.25:\n                for i in range(self.population_size):\n                    new_x[i, :] = (self.x[i, :] + new_x[i, :]) / 2\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 70, 13, 'hybridHSPSO noiseless_func\\n', 70, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 70, 13, 'hybridHSPSO noiseless_func\\n', 70, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "1c23d859-3aca-45c1-962f-9d5fba011c64", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.probability = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Refine the strategy with probability 0.25\n            if np.random.rand() < self.probability:\n                new_x = self.refine_strategy(new_x, fittest_x, fitness)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n    def refine_strategy(self, new_x, fittest_x, fitness):\n        # Select 25% of the fittest individuals\n        selected_indices = np.random.choice(len(fittest_x), size=int(len(fittest_x) * self.probability), replace=False)\n        selected_x = fittest_x[selected_indices]\n\n        # Create a new individual by combining the selected individuals\n        new_individual = np.zeros_like(new_x)\n        for i in range(self.population_size):\n            new_individual[i, :] = new_x[i, :] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Replace the individual with a random selection from the selected individuals\n            if np.random.rand() < 0.5:\n                new_individual[i, :] = selected_x[np.random.randint(0, len(selected_x)), :]\n\n        return new_individual\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 87, 13, 'hybridHSPSO noiseless_func\\n', 87, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 87, 13, 'hybridHSPSO noiseless_func\\n', 87, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "d2c2dcf6-5ab4-4eeb-9258-b9d676158981", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if random.random() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[random.randint(0, len(fittest_x) - 1), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if random.random() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 66, 13, 'hybridHSPSO noiseless_func\\n', 66, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 66, 13, 'hybridHSPSO noiseless_func\\n', 66, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "8c210278-9a12-4843-a649-e1d593554519", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy by changing individual lines with probability 0.25\n            refine_prob = 0.25\n            for i in range(self.population_size):\n                if np.random.rand() < refine_prob:\n                    j = np.random.randint(0, self.dim)\n                    new_x[i, j] = self.x[i, j] + np.random.uniform(-0.05, 0.05)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 73, 13, 'hybridHSPSO noiseless_func\\n', 73, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 73, 13, 'hybridHSPSO noiseless_func\\n', 73, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "081c188e-bebd-409b-a940-63f2e0ff0b8f", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.refine_prob = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy with 25% probability\n            if np.random.rand() < self.refine_prob:\n                refined_x = np.zeros((self.population_size, self.dim))\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        refined_x[i, :] = self.x[i, :]\n                    else:\n                        refined_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                    refined_x[i, :] += np.random.uniform(-0.05, 0.05, self.dim)\n                    refined_x[i, :] = np.clip(refined_x[i, :], -5.0, 5.0, out=refined_x[i, :])\n                self.x = refined_x\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators and probabilistic refinement.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 78, 13, 'hybridHSPSO noiseless_func\\n', 78, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 78, 13, 'hybridHSPSO noiseless_func\\n', 78, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "ffe5de9d-a2a5-41f2-ad0b-006ca14d2c75", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Refine the strategy by changing 25% of the individuals\n            refine_indices = np.random.choice(self.population_size, size=int(self.population_size * 0.25), replace=False)\n            new_x[refine_indices, :] = self.x[refine_indices, :] + np.random.uniform(-0.1, 0.1, (len(refine_indices), self.dim))\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 70, 13, 'hybridHSPSO noiseless_func\\n', 70, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 70, 13, 'hybridHSPSO noiseless_func\\n', 70, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "542ed4ea-a894-4a67-ae01-9e0e1a5784bc", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 65, 13, 'hybridHSPSO noiseless_func\\n', 65, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 65, 13, 'hybridHSPSO noiseless_func\\n', 65, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "d61ed023-eb32-4dd4-91fb-b764a2a0fda1", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if random.random() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[random.randint(0, len(fittest_x)-1), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if random.random() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n                new_x[i, :] = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy with a 25% probability\n            if random.random() < 0.25:\n                for i in range(self.population_size):\n                    if random.random() < 0.5:\n                        new_x[i, :] = self.x[i, :]\n                    else:\n                        new_x[i, :] = fittest_x[random.randint(0, len(fittest_x)-1), :]\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO()", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"HybridHSPSO.__call__() missing 1 required positional argument: 'func'\").", "error": "TypeError(\"HybridHSPSO.__call__() missing 1 required positional argument: 'func'\")", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "199b5591-3b5a-46d3-8b5e-9b5f412df4a8", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 65, 13, 'hybridHSPSO noiseless_func\\n', 65, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 65, 13, 'hybridHSPSO noiseless_func\\n', 65, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "c0e00862-6398-4223-b794-2a2301188fa6", "solution": "import numpy as np\nimport random\nimport operator\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    parent1 = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                    parent2 = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                    child = self.reproduce(parent1, parent2)\n                    new_x[i, :] = child\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n    def reproduce(self, parent1, parent2):\n        child = np.zeros(self.dim)\n        for i in range(self.dim):\n            if random.random() < 0.25:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 79, 13, 'hybridHSPSO noiseless_func\\n', 79, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 79, 13, 'hybridHSPSO noiseless_func\\n', 79, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "b53abf2b-e618-4e27-8bcd-2ccea87678f3", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n                # Refine the strategy by changing individual lines with probability 0.25\n                if np.random.rand() < 0.25:\n                    idx = np.random.randint(0, self.dim)\n                    new_x[i, idx] = self.x[i, idx] + np.random.uniform(-0.1, 0.1)\n                # Ensure the search space bounds\n                new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 69, 13, 'hybridHSPSO noiseless_func\\n', 69, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 69, 13, 'hybridHSPSO noiseless_func\\n', 69, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "65f1026c-aeb1-463a-a1cd-f036090614b4", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy with probabilistic mutation\n            for i in range(self.population_size):\n                if random.random() < 0.25:\n                    new_x[i, :] += np.random.uniform(-0.05, 0.05, self.dim)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators and probabilistic refinement.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 71, 13, 'hybridHSPSO noiseless_func\\n', 71, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 71, 13, 'hybridHSPSO noiseless_func\\n', 71, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "1bda3d05-3f82-49fd-907b-06c923812c68", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Refine the strategy with a probability of 0.25\n            refine_prob = np.random.rand()\n            if refine_prob < 0.25:\n                for i in range(self.population_size):\n                    # Randomly select two individuals\n                    idx1, idx2 = np.random.choice(self.population_size, size=2, replace=False)\n                    # Calculate the average of the two individuals\n                    new_x[i, :] = (self.x[idx1, :] + self.x[idx2, :]) / 2\n                    # Ensure the search space bounds\n                    new_x[i, :] = np.clip(new_x[i, :], -5.0, 5.0, out=new_x[i, :])\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators and probabilistic refinement.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 76, 13, 'hybridHSPSO noiseless_func\\n', 76, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 76, 13, 'hybridHSPSO noiseless_func\\n', 76, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "7f1cc2f6-a8b4-498f-949a-b5e91109b39c", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if random.random() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[random.randint(0, len(fittest_x)-1), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if random.random() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 66, 13, 'hybridHSPSO noiseless_func\\n', 66, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 66, 13, 'hybridHSPSO noiseless_func\\n', 66, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "1e864497-1357-466b-bf04-b24f1ca83ef3", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.probability = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if random.random() < self.probability:\n                    # Refine the strategy by changing the individual lines\n                    new_x[i, :] = self.x[i, :] + random.uniform(-0.1, 0.1, self.dim)\n                else:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                if random.random() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 68, 13, 'hybridHSPSO noiseless_func\\n', 68, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 68, 13, 'hybridHSPSO noiseless_func\\n', 68, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "c60ff6c6-dac3-4cf2-bfc8-be1b7a71942a", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if random.random() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[random.randint(0, len(fittest_x) - 1), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if random.random() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 66, 13, 'hybridHSPSO noiseless_func\\n', 66, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 66, 13, 'hybridHSPSO noiseless_func\\n', 66, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "63d85f2e-3397-456b-99de-b23bdb4249c0", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.probability = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n                if np.random.rand() < self.probability:\n                    new_x[i, :] *= 0.9 + np.random.uniform(-0.1, 0.1, self.dim)\n                new_x[i, :] = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 67, 13, 'hybridHSPSO noiseless_func\\n', 67, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 67, 13, 'hybridHSPSO noiseless_func\\n', 67, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "8d36ff95-2c38-4ee3-8f03-c5b4c77f1e04", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.probability = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n                if np.random.rand() < self.probability:\n                    new_x[i, :] = self.x[i, :] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 68, 13, 'hybridHSPSO noiseless_func\\n', 68, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 68, 13, 'hybridHSPSO noiseless_func\\n', 68, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "61eef163-6e41-4aac-92d6-4e172af612df", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Refine the strategy with probabilistic refinement\n            refine_prob = 0.25\n            for i in range(self.population_size):\n                if np.random.rand() < refine_prob:\n                    # Select a random individual to refine\n                    individual = self.x[i, :]\n                    # Select a random dimension to refine\n                    dim = np.random.randint(0, self.dim)\n                    # Refine the dimension\n                    individual[dim] += np.random.uniform(-0.1, 0.1)\n                    # Ensure the search space bounds\n                    individual = np.clip(individual, -5.0, 5.0, out=individual)\n                    # Replace the individual in the population\n                    self.x[i, :] = individual\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators and probabilistic refinement.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 81, 13, 'hybridHSPSO noiseless_func\\n', 81, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 81, 13, 'hybridHSPSO noiseless_func\\n', 81, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "9fada26a-d802-47de-bdc9-4cd000c400eb", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy with probability 0.25\n            if random.random() < 0.25:\n                # Randomly select an individual to refine\n                refined_index = np.random.randint(0, self.population_size)\n                # Perform adaptive crossover and mutation\n                refined_x = self.x[refined_index, :]\n                refined_x = np.clip(refined_x + np.random.uniform(-0.1, 0.1, self.dim), -5.0, 5.0)\n                self.x[refined_index, :] = refined_x\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators, combined with probability-based refinement.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 75, 13, 'hybridHSPSO noiseless_func\\n', 75, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 75, 13, 'hybridHSPSO noiseless_func\\n', 75, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "a1197431-dc88-4447-8a77-7e0dfcf2fb12", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Refine the strategy by changing individual lines with probability 0.25\n                    if np.random.rand() < 0.25:\n                        new_x[i, :] = new_x[i, :] + np.random.uniform(-0.05, 0.05, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 69, 13, 'hybridHSPSO noiseless_func\\n', 69, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 69, 13, 'hybridHSPSO noiseless_func\\n', 69, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "1b63ed91-9a83-4632-840b-74d266c537ff", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Apply probability 0.25 to change individual lines\n            if np.random.rand() < 0.25:\n                new_x = self.x + np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 70, 13, 'hybridHSPSO noiseless_func\\n', 70, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 70, 13, 'hybridHSPSO noiseless_func\\n', 70, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "46589452-f0b6-4633-8f58-3a719d1d3144", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 65, 13, 'hybridHSPSO noiseless_func\\n', 65, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 65, 13, 'hybridHSPSO noiseless_func\\n', 65, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "a7d7f3b8-feb7-4a4f-9c0b-a4381f056911", "solution": "import numpy as np\nimport random\nimport time\nimport sys\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.pbest_fitness = np.zeros(self.population_size)\n        self.gbest_fitness = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                    self.pbest_fitness[i] = fitness[i]\n                if np.any(fitness[i] < self.gbest_fitness):\n                    self.gbest = self.x[i, :]\n                    self.gbest_fitness = fitness[i]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                    self.pbest_fitness[i] = fitness[i]\n                if np.any(fitness[i] < self.gbest_fitness):\n                    self.gbest = self.x[i, :]\n                    self.gbest_fitness = fitness[i]\n\n            # Refine the strategy by changing individual lines with probability 0.25\n            refine_prob = 0.25\n            refine_indices = np.random.choice(self.population_size, int(self.population_size * refine_prob), replace=False)\n            for i in refine_indices:\n                new_x[i, :] = self.x[i, :] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 86, 13, 'hybridHSPSO noiseless_func\\n', 86, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 86, 13, 'hybridHSPSO noiseless_func\\n', 86, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "5e760371-ce5e-478f-bcf9-e480186f1f6a", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy by changing individual lines with probability 0.25\n            for i in range(self.population_size):\n                if np.random.rand() < 0.25:\n                    j = np.random.randint(0, self.dim)\n                    new_x[i, j] = self.x[i, j] + np.random.uniform(-0.1, 0.1)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 72, 13, 'hybridHSPSO noiseless_func\\n', 72, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 72, 13, 'hybridHSPSO noiseless_func\\n', 72, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "12e77899-9b22-46bf-a2e3-4d96973e9054", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.refine_rate = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy with 25% probability\n            if np.random.rand() < self.refine_rate:\n                new_x = self.refine_strategy(new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n    def refine_strategy(self, x):\n        # Refine the strategy by changing the individual lines\n        refined_x = np.copy(x)\n        for i in range(self.population_size):\n            refined_x[i, :] = np.random.choice(self.x, size=self.dim, replace=True)\n        return refined_x\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 77, 13, 'hybridHSPSO noiseless_func\\n', 77, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 77, 13, 'hybridHSPSO noiseless_func\\n', 77, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "55a8ed9c-41b4-45fd-a3f0-eecea2c459f2", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy with 25% probability\n            if random.random() < 0.25:\n                # Randomly replace 25% of the individuals with new random solutions\n                new_x = self.x.copy()\n                for i in range(self.population_size):\n                    if random.random() < 0.25:\n                        new_x[i, :] = np.random.uniform(-5.0, 5.0, self.dim)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 74, 13, 'hybridHSPSO noiseless_func\\n', 74, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 74, 13, 'hybridHSPSO noiseless_func\\n', 74, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "226a8b33-a6b3-4c2d-ae02-96f27045aaea", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO(noiseless_func)", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "f595d9d9-74ad-453a-a3dd-b6ce5b858936", "solution": "import numpy as np\nimport random\nimport operator\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 67, 13, 'hybridHSPSO noiseless_func\\n', 67, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 67, 13, 'hybridHSPSO noiseless_func\\n', 67, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "11cd28a1-7e06-47b0-b573-52daaf71fcf6", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 65, 13, 'hybridHSPSO noiseless_func\\n', 65, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 65, 13, 'hybridHSPSO noiseless_func\\n', 65, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "996be731-e74f-4587-a07e-4513e9ec2209", "solution": "import numpy as np\nimport random\nimport copy\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if random.random() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[random.randint(0, len(fittest_x)-1), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if random.random() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n                # Refine the strategy with 25% probability\n                if random.random() < 0.25:\n                    new_x[i, :] = self.x[i, :] + np.random.uniform(-0.05, 0.05, self.dim)\n\n                # Ensure the search space bounds\n                new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 71, 13, 'hybridHSPSO noiseless_func\\n', 71, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 71, 13, 'hybridHSPSO noiseless_func\\n', 71, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "3b522af5-32cc-479e-a4d7-a80514979d05", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 66, 13, 'hybridHSPSO noiseless_func\\n', 66, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 66, 13, 'hybridHSPSO noiseless_func\\n', 66, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "a940717e-7d1a-4259-93e4-e1f874d2a830", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Refine the strategy with 25% probability\n            refine_prob = 0.25\n            for i in range(self.population_size):\n                if np.random.rand() < refine_prob:\n                    # Select a random individual\n                    individual = self.x[i, :]\n                    # Select a random dimension\n                    dim = np.random.randint(0, self.dim)\n                    # Change the individual line\n                    individual[dim] += np.random.uniform(-0.1, 0.1)\n                    # Ensure the search space bounds\n                    individual = np.clip(individual, -5.0, 5.0, out=individual)\n\n                    # Replace the old individual with the new one\n                    self.x[i, :] = individual\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 78, 13, 'hybridHSPSO noiseless_func\\n', 78, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 78, 13, 'hybridHSPSO noiseless_func\\n', 78, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "96a6085a-e637-4b07-b17e-8d2f3cfc6ace", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "5b0441d6-6a67-4a95-b3e7-149c83baff1a", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation with probability 0.25\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n                if np.random.rand() < 0.25:\n                    new_x[i, :] = self.x[i, :] * np.random.uniform(0.5, 1.5, self.dim)\n                new_x[i, :] = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators and probability 0.25 to refine strategy", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 65, 13, 'hybridHSPSO noiseless_func\\n', 65, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 65, 13, 'hybridHSPSO noiseless_func\\n', 65, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "d310ee5f-b4c4-40f2-aed8-5fadf59d19cc", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy with 25% probability\n            refine = np.random.rand(self.population_size) < 0.25\n            if refine.any():\n                for i in range(self.population_size):\n                    if refine[i]:\n                        # Randomly select two individuals for crossover\n                        j = np.random.randint(0, self.population_size)\n                        k = np.random.randint(0, self.population_size)\n                        new_x[i, :] = (self.x[i, :] + self.x[j, :]) / 2\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 76, 13, 'hybridHSPSO noiseless_func\\n', 76, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 76, 13, 'hybridHSPSO noiseless_func\\n', 76, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "dc687d30-16b3-42d9-9b88-452e51a3b881", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.probability = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if random.random() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[random.randint(0, len(fittest_x)-1), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if random.random() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy of the selected individual with 25% probability\n            if random.random() < self.probability:\n                self.x[random.randint(0, self.population_size-1), :] = self.x[random.randint(0, self.population_size-1), :] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 71, 13, 'hybridHSPSO noiseless_func\\n', 71, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 71, 13, 'hybridHSPSO noiseless_func\\n', 71, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "efe59b28-0e16-4f97-90ca-5eef97b0cb53", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n            # Refine the strategy with 25% probability\n            if np.random.rand() < 0.25:\n                for i in range(self.population_size):\n                    # Select a random individual to refine\n                    individual = self.x[i, :]\n                    # Evaluate the fitness of the individual\n                    fitness = func(individual)\n                    # Update the individual\n                    individual = self.x[i, :]\n                    # Apply a small perturbation to the individual\n                    individual += np.random.uniform(-0.01, 0.01, self.dim)\n                    # Ensure the search space bounds\n                    individual = np.clip(individual, -5.0, 5.0, out=individual)\n                    # Replace the old individual with the new one\n                    self.x[i, :] = individual\n                    # Evaluate the fitness of the new individual\n                    fitness = func(self.x[i, :])\n                    # Update the pbest and gbest\n                    if np.any(fitness < fitness[self.pbest[i, :]]):\n                        self.pbest[i, :] = self.x[i, :]\n                    if np.any(fitness < fitness[self.gbest]):\n                        self.gbest = self.x[i, :]\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators and probabilistic refinement.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 88, 13, 'hybridHSPSO noiseless_func\\n', 88, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 88, 13, 'hybridHSPSO noiseless_func\\n', 88, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "e0ee75cb-819b-4eda-9c53-031d5055036d", "solution": "import numpy as np\nimport random\nimport operator\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy with a probability of 0.25\n            refine_prob = np.random.rand()\n            if refine_prob < 0.25:\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        new_x[:, j] = self.x[np.random.randint(0, self.population_size), j]\n                    else:\n                        new_x[:, j] = self.x[np.random.randint(0, self.population_size), j] + np.random.uniform(-0.1, 0.1)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 76, 13, 'hybridHSPSO noiseless_func\\n', 76, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 76, 13, 'hybridHSPSO noiseless_func\\n', 76, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "72a3c5a2-8aa1-4aed-a673-0fa4661fbfbc", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Refine the individual lines with a probability of 0.25\n                    if random.random() < 0.25:\n                        new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators, refined to change individual lines with a probability of 0.25.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 69, 13, 'hybridHSPSO noiseless_func\\n', 69, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 69, 13, 'hybridHSPSO noiseless_func\\n', 69, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "f3f54cd1-ce52-4c38-93ab-cc87035362ce", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "f9f9fc1f-9523-4bc2-943f-def20469d765", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Refine the strategy by changing individual lines with a probability of 0.25\n            refine_prob = 0.25\n            refine_mask = np.random.rand(self.population_size, self.dim) < refine_prob\n            new_x[refine_mask] = np.random.uniform(-5.0, 5.0, size=refine_mask.shape)\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 70, 13, 'hybridHSPSO noiseless_func\\n', 70, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 70, 13, 'hybridHSPSO noiseless_func\\n', 70, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "c57861a5-469f-409b-b340-ff04d4311d38", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy with probabilistic mutation\n            for i in range(self.population_size):\n                if np.random.rand() < 0.25:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators and probabilistic refinement.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 71, 13, 'hybridHSPSO noiseless_func\\n', 71, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 71, 13, 'hybridHSPSO noiseless_func\\n', 71, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "877f5756-6bdc-4e76-a302-340c05e23051", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 65, 13, 'hybridHSPSO noiseless_func\\n', 65, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 65, 13, 'hybridHSPSO noiseless_func\\n', 65, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "cab251b6-fda4-40cd-a72f-8eafa8937749", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n                # Refine the strategy by changing individual lines with probability 0.25\n                if np.random.rand() < 0.25:\n                    index = np.random.randint(0, self.dim)\n                    new_x[i, index] = np.random.uniform(-5.0, 5.0)\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 68, 13, 'hybridHSPSO noiseless_func\\n', 68, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 68, 13, 'hybridHSPSO noiseless_func\\n', 68, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "65c9b1bf-65d8-44dd-9edb-62359465d9a6", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO()", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"HybridHSPSO.__call__() missing 1 required positional argument: 'func'\").", "error": "TypeError(\"HybridHSPSO.__call__() missing 1 required positional argument: 'func'\")", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "c13ef131-ae29-4035-ba13-827b294655af", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n                if np.random.rand() < 0.25:\n                    new_x[i, :] = self.x[i, :] + np.random.uniform(-0.1, 0.1, self.dim)\n                new_x[i, :] = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 65, 13, 'hybridHSPSO noiseless_func\\n', 65, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 65, 13, 'hybridHSPSO noiseless_func\\n', 65, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "c37bfd4d-099c-4cc2-b11f-46ac68fc3840", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if random.random() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[random.randint(0, len(fittest_x) - 1), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if random.random() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 66, 13, 'hybridHSPSO noiseless_func\\n', 66, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 66, 13, 'hybridHSPSO noiseless_func\\n', 66, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "a8e0b161-ecd4-4cf0-bce3-9edddb43c0f3", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy with 25% probability\n            if np.random.rand() < 0.25:\n                new_x = self.refine_strategy(new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n    def refine_strategy(self, x):\n        # Select 25% of the individuals and refine their strategy\n        refined_indices = np.random.choice(x.shape[0], size=int(x.shape[0] * 0.25), replace=False)\n        refined_x = x[refined_indices]\n        # Refine the individuals by adjusting their parameters\n        refined_x[:, 0] += np.random.uniform(-0.1, 0.1, refined_x.shape[0])\n        refined_x[:, 1] += np.random.uniform(-0.1, 0.1, refined_x.shape[0])\n        return refined_x\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 79, 13, 'hybridHSPSO noiseless_func\\n', 79, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 79, 13, 'hybridHSPSO noiseless_func\\n', 79, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "f9649b29-844d-4a94-ae7e-e7b71f4d8ef2", "solution": "import numpy as np\nimport random\nimport copy\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy with a probability of 0.25\n            if np.random.rand() < 0.25:\n                new_x = self.refine_strategy(new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n    def refine_strategy(self, new_x):\n        # Select a random individual to refine\n        individual_to_refine = np.random.randint(0, self.population_size)\n        new_x[individual_to_refine, :] = self.x[individual_to_refine, :]\n\n        # Refine the individual using a probability of 0.25\n        if np.random.rand() < 0.25:\n            # Select a random dimension to refine\n            dimension_to_refine = np.random.randint(0, self.dim)\n            # Refine the dimension using a probability of 0.5\n            if np.random.rand() < 0.5:\n                new_x[individual_to_refine, dimension_to_refine] += np.random.uniform(-0.1, 0.1)\n            # Refine the dimension using a probability of 0.5\n            if np.random.rand() < 0.5:\n                new_x[individual_to_refine, dimension_to_refine] -= np.random.uniform(-0.1, 0.1)\n\n        return new_x\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 89, 13, 'hybridHSPSO noiseless_func\\n', 89, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 89, 13, 'hybridHSPSO noiseless_func\\n', 89, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "d214378c-f564-4223-9828-b10c69a405a5", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 65, 13, 'hybridHSPSO noiseless_func\\n', 65, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 65, 13, 'hybridHSPSO noiseless_func\\n', 65, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "f396f784-c52f-4405-b7f9-040583ab42f6", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Refine strategy with probability 0.25\n            refine = np.random.rand(self.population_size) < 0.25\n            new_x[refine, :] = self.x[refine, :] + np.random.uniform(-0.05, 0.05, (refine.sum(), self.dim))\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators and probability 0.25 to refine strategy", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 70, 13, 'hybridHSPSO noiseless_func\\n', 70, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 70, 13, 'hybridHSPSO noiseless_func\\n', 70, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "cc76e33e-b896-490b-b13a-5acfd00f8a4e", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.pbest_indices = np.arange(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[self.pbest_indices[i], :]]):\n                    self.pbest[self.pbest_indices[i], :] = self.x[i, :]\n                    self.pbest_indices[i] = self.pbest_indices[i]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n                if np.random.rand() < 0.25:\n                    new_x[i, :] = self.x[i, :]\n                new_x[i, :] = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[self.pbest_indices[i], :]]):\n                    self.pbest[self.pbest_indices[i], :] = self.x[i, :]\n                    self.pbest_indices[i] = self.pbest_indices[i]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 69, 13, 'hybridHSPSO noiseless_func\\n', 69, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 69, 13, 'hybridHSPSO noiseless_func\\n', 69, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "dc413759-f2d8-4d10-a806-8507d7860e31", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.probability = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy with probability 0.25\n            if np.random.rand() < self.probability:\n                refined_x = self.refine_strategy(new_x)\n                new_x = np.concatenate((new_x, refined_x))\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n    def refine_strategy(self, x):\n        refined_x = []\n        for i in range(len(x)):\n            if np.random.rand() < self.probability:\n                # Perform adaptive crossover and mutation\n                parent1 = self.x[np.random.randint(0, len(self.x))]\n                parent2 = self.x[np.random.randint(0, len(self.x))]\n                child = self.adaptive_crossover(parent1, parent2)\n                child += np.random.uniform(-0.1, 0.1, self.dim)\n                refined_x.append(child)\n        return np.array(refined_x)\n\n    def adaptive_crossover(self, parent1, parent2):\n        child = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 93, 13, 'hybridHSPSO noiseless_func\\n', 93, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 93, 13, 'hybridHSPSO noiseless_func\\n', 93, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "431551b7-afaf-4898-8584-106883dcb218", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Probabilistic refinement\n            if np.random.rand() < 0.25:\n                new_x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n                new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n                new_x = self.x + np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n                self.x = new_x\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators, and probabilistic refinement.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 72, 13, 'hybridHSPSO noiseless_func\\n', 72, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 72, 13, 'hybridHSPSO noiseless_func\\n', 72, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "f5eff914-4e5e-4b6e-b119-c98da8c45b85", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Apply probability 0.25 to change the individual lines of the selected solution\n            for i in range(self.population_size):\n                if np.random.rand() < 0.25:\n                    new_x[i, :] = self.x[i, :] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 71, 13, 'hybridHSPSO noiseless_func\\n', 71, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 71, 13, 'hybridHSPSO noiseless_func\\n', 71, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "bd1498d6-03c7-44ce-9876-b52fa4d8c0dc", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Refine the strategy with 25% probability\n                    if np.random.rand() < 0.25:\n                        new_x[i, :] = self.x[i, :] + np.random.uniform(-0.1, 0.1, self.dim)\n                # Ensure the search space bounds\n                new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 68, 13, 'hybridHSPSO noiseless_func\\n', 68, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 68, 13, 'hybridHSPSO noiseless_func\\n', 68, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "3758001f-3cda-4725-9c8b-3856b3f46ba6", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 65, 13, 'hybridHSPSO noiseless_func\\n', 65, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 65, 13, 'hybridHSPSO noiseless_func\\n', 65, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "2b702995-384b-4c14-a038-dc56b1bf9b88", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy with 25% probability\n            if np.random.rand() < 0.25:\n                for j in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        # Perform adaptive crossover\n                        new_x[j, :] = (self.x[j, :] + self.x[np.random.randint(0, len(self.x)), :]) / 2\n                    else:\n                        # Perform adaptive mutation\n                        new_x[j, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 76, 13, 'hybridHSPSO noiseless_func\\n', 76, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 76, 13, 'hybridHSPSO noiseless_func\\n', 76, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "11c3f216-e2cc-4cf7-8bb5-287143f9edce", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.probability = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if random.random() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[random.randint(0, len(fittest_x) - 1), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if random.random() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n                if random.random() < self.probability:\n                    new_x[i, :] = self.x[i, :] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 69, 13, 'hybridHSPSO noiseless_func\\n', 69, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 69, 13, 'hybridHSPSO noiseless_func\\n', 69, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "9ed6012b-a43a-44b8-b15c-a882874f0e05", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.probability = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if random.random() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[random.randint(0, len(fittest_x) - 1), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if random.random() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n                if random.random() < self.probability:\n                    new_x[i, :] = self.x[i, :] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 69, 13, 'hybridHSPSO noiseless_func\\n', 69, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 69, 13, 'hybridHSPSO noiseless_func\\n', 69, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "68de6d92-3289-4621-86af-4ca2b112fa0c", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.probability = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy with probability 0.25\n            if np.random.rand() < self.probability:\n                for i in range(self.population_size):\n                    new_x[i, :] = self.x[i, :] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 71, 13, 'hybridHSPSO noiseless_func\\n', 71, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 71, 13, 'hybridHSPSO noiseless_func\\n', 71, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "344582aa-53d3-45ee-914e-1a44dbff2da2", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n                if np.random.rand() < 0.25:\n                    new_x[i, :] = self.x[i, :] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 68, 13, 'hybridHSPSO noiseless_func\\n', 68, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 68, 13, 'hybridHSPSO noiseless_func\\n', 68, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "cafe8db7-4750-4fb0-b681-7e8c6716701d", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Apply probability 0.25 to change the individual lines of the selected solution\n            for j in range(self.population_size):\n                if random.random() < 0.25:\n                    new_x[j, :] = self.x[j, :] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 71, 13, 'hybridHSPSO noiseless_func\\n', 71, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 71, 13, 'hybridHSPSO noiseless_func\\n', 71, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "f1b8387c-7351-4b34-a2fa-5ebe6f6745e5", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy with 25% probability\n            refine = np.random.rand(self.population_size) < 0.25\n            for i in range(self.population_size):\n                if refine[i]:\n                    # Randomly change the individual\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 73, 13, 'hybridHSPSO noiseless_func\\n', 73, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 73, 13, 'hybridHSPSO noiseless_func\\n', 73, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "a0024e60-fc3f-47f5-b6d1-17f49877bebb", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy with probability 0.25\n            if random.random() < 0.25:\n                refined_x = np.zeros((self.population_size, self.dim))\n                for i in range(self.population_size):\n                    refined_x[i, :] = self.x[i, :]\n                    for j in range(self.dim):\n                        if np.random.rand() < 0.5:\n                            refined_x[i, j] += np.random.uniform(-0.05, 0.05)\n                            refined_x[i, j] = np.clip(refined_x[i, j], -5.0, 5.0)\n                self.x = refined_x\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators and probability-based refinement.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 77, 13, 'hybridHSPSO noiseless_func\\n', 77, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 77, 13, 'hybridHSPSO noiseless_func\\n', 77, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "4a4618e1-3d77-467f-b930-e6089121400a", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n                if np.random.rand() < 0.25:\n                    # Refine the strategy by changing individual lines\n                    index = np.random.randint(0, self.dim)\n                    new_x[i, index] += np.random.uniform(-0.1, 0.1)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators and probability 0.25 to refine strategy.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 70, 13, 'hybridHSPSO noiseless_func\\n', 70, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 70, 13, 'hybridHSPSO noiseless_func\\n', 70, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "05b33b34-0245-41b6-80f3-a943186d6ea0", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.refinement_prob = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the solution with probability 0.25\n            refine = np.random.rand(self.population_size) < self.refinement_prob\n            new_x[refine, :] = self.x[refine, :] * (1 + np.random.uniform(-0.1, 0.1, (refine, self.dim)))\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators, combined with probability-based refinement.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 70, 13, 'hybridHSPSO noiseless_func\\n', 70, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 70, 13, 'hybridHSPSO noiseless_func\\n', 70, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "bc999af3-5856-4d61-bae1-9fc66912950d", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 65, 13, 'hybridHSPSO noiseless_func\\n', 65, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 65, 13, 'hybridHSPSO noiseless_func\\n', 65, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "502d3e31-69c4-4f6a-b2dc-f0261db596f8", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.probability = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n                    if np.random.rand() < self.probability:\n                        new_x[i, :] = new_x[i, :] * np.random.uniform(0.9, 1.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 68, 13, 'hybridHSPSO noiseless_func\\n', 68, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 68, 13, 'hybridHSPSO noiseless_func\\n', 68, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "0a464292-ca8b-426b-a8c4-9a4d63a13008", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Refine the strategy with 25% probability\n            if np.random.rand() < 0.25:\n                for i in range(self.population_size):\n                    j = np.random.randint(0, self.population_size)\n                    new_x[i, :] = (self.x[i, :] + self.x[j, :]) / 2\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO()", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"HybridHSPSO.__call__() missing 1 required positional argument: 'func'\").", "error": "TypeError(\"HybridHSPSO.__call__() missing 1 required positional argument: 'func'\")", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "ba05f0f9-26be-4ecf-bbcc-b387c10a2872", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if random.random() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if random.random() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 66, 13, 'hybridHSPSO noiseless_func\\n', 66, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 66, 13, 'hybridHSPSO noiseless_func\\n', 66, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "57084829-c58c-41f9-82dc-179ac7780022", "solution": "import numpy as np\nimport random\nimport functools\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Refine the strategy with probability 0.25\n            if random.random() < 0.25:\n                self.refine_strategy()\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n    def refine_strategy(self):\n        for i in range(self.population_size):\n            # Select a random individual to refine\n            individual = self.x[i, :]\n            # Refine the individual by changing 25% of its lines\n            refined_individual = individual.copy()\n            for j in range(self.dim):\n                if np.random.rand() < 0.25:\n                    refined_individual[j] += np.random.uniform(-0.1, 0.1)\n            # Ensure the search space bounds\n            refined_individual = np.clip(refined_individual, -5.0, 5.0, out=refined_individual)\n            # Replace the old individual with the refined one\n            self.x[i, :] = refined_individual\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators, probability-based refinement.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 85, 13, 'hybridHSPSO noiseless_func\\n', 85, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 85, 13, 'hybridHSPSO noiseless_func\\n', 85, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "f4ce3708-6a2f-49d5-9ead-88c6e888175e", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\nclass HybridHSPSORefined(HybridHSPSO):\n    def __init__(self, budget, dim):\n        super().__init__(budget, dim)\n        self.refine_rate = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Refine the strategy of the fittest individuals\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.refine_rate)]\n            for i in fittest_indices:\n                new_x = self.x[i, :]\n                new_x += np.random.uniform(-0.01, 0.01, self.dim)\n                new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n                self.x[i, :] = new_x\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSORefined(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 124, 13, 'hybridHSPSO noiseless_func\\n', 124, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 124, 13, 'hybridHSPSO noiseless_func\\n', 124, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "a53e3fa1-44c3-40f3-8e8c-d376b95628c5", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 65, 13, 'hybridHSPSO noiseless_func\\n', 65, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 65, 13, 'hybridHSPSO noiseless_func\\n', 65, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "e1fc302d-a433-441e-8c12-6121be840313", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n                    if np.random.rand() < 0.25:\n                        new_x[i, :] = self.x[i, :] + np.random.uniform(-0.1, 0.1, self.dim)\n                new_x[i, :] = np.clip(new_x[i, :], -5.0, 5.0)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 66, 13, 'hybridHSPSO noiseless_func\\n', 66, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 66, 13, 'hybridHSPSO noiseless_func\\n', 66, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "f9cba2f9-48d3-4a70-b7af-1bf722a6353a", "solution": "import numpy as np\nimport random\nimport functools\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 67, 13, 'hybridHSPSO noiseless_func\\n', 67, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 67, 13, 'hybridHSPSO noiseless_func\\n', 67, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "8dd12a34-56e2-4f68-8d52-9f7e2d544420", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if random.random() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[random.randint(0, len(fittest_x) - 1), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if random.random() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n                # Refine strategy by changing 25% of the individual lines\n                if random.random() < 0.25:\n                    idx = random.randint(0, self.dim - 1)\n                    new_x[i, idx] = (new_x[i, idx] + np.random.uniform(-0.1, 0.1)) % 10.0 - 5.0\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 70, 13, 'hybridHSPSO noiseless_func\\n', 70, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 70, 13, 'hybridHSPSO noiseless_func\\n', 70, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "9378f77c-6f38-40a7-ae99-7bee1b989497", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.pbest_indices = np.zeros((self.population_size, self.dim))\n        self.gbest_index = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                    self.pbest_indices[i, :] = np.zeros(self.dim)\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n                    self.gbest_index = np.zeros(self.dim)\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n                if np.random.rand() < 0.25:\n                    for j in range(self.dim):\n                        if new_x[i, j] > self.pbest[self.pbest_indices[i, j], j]:\n                            new_x[i, j] = self.pbest[self.pbest_indices[i, j], j]\n                        elif new_x[i, j] < self.gbest[self.gbest_index, j]:\n                            new_x[i, j] = self.gbest[self.gbest_index, j]\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                    self.pbest_indices[i, :] = np.zeros(self.dim)\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n                    self.gbest_index = np.zeros(self.dim)\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 77, 13, 'hybridHSPSO noiseless_func\\n', 77, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 77, 13, 'hybridHSPSO noiseless_func\\n', 77, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "bd6822d5-86cf-49b5-b740-b65429a7a54c", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy with 25% probability\n            refine = np.random.rand(self.population_size) < 0.25\n            new_x[refine, :] = self.x[refine, :] + np.random.uniform(-0.05, 0.05, self.dim)[refine, :]\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 70, 13, 'hybridHSPSO noiseless_func\\n', 70, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 70, 13, 'hybridHSPSO noiseless_func\\n', 70, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "3a54117f-2e72-4df8-b43c-2bad891937e9", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if random.random() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if random.random() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 66, 13, 'hybridHSPSO noiseless_func\\n', 66, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 66, 13, 'hybridHSPSO noiseless_func\\n', 66, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "595e14ab-b3bc-46e0-8348-6d81803c4f3b", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.refine_prob = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Refine the strategy with 25% probability\n            if np.random.rand() < self.refine_prob:\n                for i in range(self.population_size):\n                    # Randomly select two individuals\n                    j = np.random.randint(0, self.population_size)\n                    k = np.random.randint(0, self.population_size)\n                    # Swap the values of the two individuals\n                    new_x[i, :] = self.x[j, :] + (self.x[k, :] - self.x[j, :])\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 75, 13, 'hybridHSPSO noiseless_func\\n', 75, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 75, 13, 'hybridHSPSO noiseless_func\\n', 75, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "724803d6-7495-40f7-8fdd-1a06629ec2a7", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.pbest_indices = np.zeros((self.population_size, self.dim))\n        self.gbest_index = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                    self.pbest_indices[i, :] = np.arange(self.dim)\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n                    self.gbest_index = i\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n                # Refine the strategy by changing individual lines with probability 0.25\n                if np.random.rand() < 0.25:\n                    new_x[i, self.pbest_indices[i, :]] = self.x[i, self.pbest_indices[i, :]]\n                    new_x[i, :] = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                    self.pbest_indices[i, :] = np.arange(self.dim)\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n                    self.gbest_index = i\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 76, 13, 'hybridHSPSO noiseless_func\\n', 76, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 76, 13, 'hybridHSPSO noiseless_func\\n', 76, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "7918dbee-ffca-476b-aeee-d98523171f29", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.probability = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy by changing individual lines with a probability of 0.25\n            for i in range(self.population_size):\n                if np.random.rand() < self.probability:\n                    new_x[i, :] = self.x[i, :] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 72, 13, 'hybridHSPSO noiseless_func\\n', 72, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 72, 13, 'hybridHSPSO noiseless_func\\n', 72, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "7c297960-923f-4ff1-9c8b-3e903ced668c", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n                if np.random.rand() < 0.25:\n                    new_x[i, :] = self.x[i, :] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 67, 13, 'hybridHSPSO noiseless_func\\n', 67, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 67, 13, 'hybridHSPSO noiseless_func\\n', 67, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "4ca8a127-4c79-4caf-8bfc-62004d00fd53", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.probability = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n                if np.random.rand() < self.probability:\n                    # Refine the strategy by changing individual lines\n                    index = np.random.randint(0, self.dim)\n                    new_x[i, index] += np.random.uniform(-0.1, 0.1)\n                new_x[i, :] = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 68, 13, 'hybridHSPSO noiseless_func\\n', 68, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 68, 13, 'hybridHSPSO noiseless_func\\n', 68, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "743ef477-380a-470e-8c7d-b9d1f3f6908a", "solution": "import numpy as np\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy with probabilistic mutation\n            refine_prob = 0.25\n            refine_mask = np.random.rand(self.population_size) < refine_prob\n            new_x[refine_mask, :] *= 1.1 + np.random.uniform(-0.1, 0.1, self.dim)[refine_mask]\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators and probabilistic refinement.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 70, 13, 'hybridHSPSO noiseless_func\\n', 70, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 70, 13, 'hybridHSPSO noiseless_func\\n', 70, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "4f2bf5b0-0de4-4335-a8e8-598d3657825b", "solution": "import numpy as np\nimport random\nimport copy\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 67, 13, 'hybridHSPSO noiseless_func\\n', 67, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 67, 13, 'hybridHSPSO noiseless_func\\n', 67, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "048adfb7-5b38-4327-8a4c-821184323d93", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n                # Refine the strategy by changing individual lines with a probability of 0.25\n                if np.random.rand() < 0.25:\n                    new_x[i, :] = self.x[i, :] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 69, 13, 'hybridHSPSO noiseless_func\\n', 69, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 69, 13, 'hybridHSPSO noiseless_func\\n', 69, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
{"id": "0702bb0d-1819-4b6d-9966-aa34ac2cb315", "solution": "import numpy as np\nimport random\n\nclass HybridHSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual in the population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Select the fittest individuals for crossover and mutation\n            fittest_indices = np.argsort(fitness)[:, ::-1][:, :int(self.population_size * self.crossover_rate)]\n            fittest_x = self.x[fittest_indices]\n\n            # Perform crossover and mutation\n            new_x = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    new_x[i, :] = fittest_x[np.random.randint(0, len(fittest_x)), :]\n                else:\n                    new_x[i, :] = self.x[i, :]\n                if np.random.rand() < self.mutation_rate:\n                    new_x[i, :] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Ensure the search space bounds\n            new_x = np.clip(new_x, -5.0, 5.0, out=new_x)\n\n            # Refine the strategy with probability 0.25\n            if np.random.rand() < 0.25:\n                for i in range(self.population_size):\n                    new_x[i, :] = self.x[i, :] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Replace the old population with the new one\n            self.x = new_x\n\n            # Evaluate the fitness of the new population\n            fitness = func(self.x)\n\n            # Update the pbest and gbest\n            for i in range(self.population_size):\n                if np.any(fitness[i] < fitness[self.pbest[i, :]]):\n                    self.pbest[i, :] = self.x[i, :]\n                if np.any(fitness[i] < fitness[self.gbest]):\n                    self.gbest = self.x[i, :]\n\n            # Check if the optimization is complete\n            if np.all(fitness < 1e-6):\n                break\n\n# Example usage\ndef noiseless_func(x):\n    return np.sum(x**2)\n\nhybridHSPSO = HybridHSPSO(budget=100, dim=10)\nhybridHSPSO noiseless_func", "name": "HybridHSPSO", "description": "Novel hybrid of Harmony Search and Particle Swarm Optimization with adaptive crossover and mutation operators.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 71, 13, 'hybridHSPSO noiseless_func\\n', 71, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 71, 13, 'hybridHSPSO noiseless_func\\n', 71, 27))", "parent_id": "2387feec-4f74-416c-8cc9-a6ab6756323a", "metadata": {}, "mutation_prompt": null}
