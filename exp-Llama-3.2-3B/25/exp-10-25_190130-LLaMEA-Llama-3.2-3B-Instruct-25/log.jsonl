{"id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO).", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 73, in <module>\n  File \"<string>\", line 60, in __call__\n  File \"<string>\", line 46, in crossover\nTypeError: 'float' object is not subscriptable\n.", "error": "TypeError(\"'float' object is not subscriptable\")Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 73, in <module>\n  File \"<string>\", line 60, in __call__\n  File \"<string>\", line 46, in crossover\nTypeError: 'float' object is not subscriptable\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "8d5a6ba1-f58d-4d8d-93ab-4644bdfc8498", "solution": "import numpy as np\nimport random\nimport math\nimport copy\n\nclass HybridHSAMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = copy.deepcopy(solution)\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(self.refine_solution(child))\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSAMutation(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSAMutation", "description": "Hybridizing Harmony Search Algorithm with Adaptive Mutation for Black Box Optimization", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'HybridHSAMutation' object has no attribute 'best_solution'\").", "error": "AttributeError(\"'HybridHSAMutation' object has no attribute 'best_solution'\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "1806b903-3d2c-4983-a11e-15ab952e7bfd", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def probabilistic_crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            elif random.random() < self.probability:\n                child.append(parent2[i])\n            else:\n                child.append(random.uniform(self.lower_bound, self.upper_bound))\n        return child\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.probabilistic_crossover(parent1, parent2)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and probabilistic crossover.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "05d9b11f-1e66-47ad-99a6-c282df0495ae", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.refine_prob = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.refine_prob:\n                refined_solution[i] += random.uniform(-0.1, 0.1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and using probability to refine the strategy.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "34f286ee-5310-417d-aeea-6ac5a84e4933", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                refined_solution[i] += random.uniform(-1, 1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and using probability 0.25 to refine the strategy.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "9dc30f22-d8bc-44a2-9f7f-62cf59553364", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Novel Hybrid Harmony Search Algorithm with Adaptive Mutation for Black Box Optimization.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "59f1feae-e7fa-422a-80da-f75449ca259c", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = []\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                refined_solution.append(solution[i] + random.uniform(-0.25, 0.25))\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n            else:\n                refined_solution.append(solution[i])\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and using probability to refine the strategy.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "24fad54b-303c-4e87-a9d0-9e3d002d7591", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        if random.random() < self.probability:\n            for i in range(self.dim):\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(self.refine_solution(child))\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing Harmony Search Algorithm (HSA) with adaptive mutation for Black Box Optimization (BBO) with probability-based refinement.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "dd8ba3b9-08ff-4461-baa0-46849cf36425", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                if random.random() < self.crossover_rate:\n                    child = self.crossover(parent1, parent2)\n                else:\n                    child = parent1\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and the crossover operator with a probability of 0.25.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "5a33e669-64fc-494b-83af-a1c6aae64298", "solution": "import numpy as np\nimport random\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                refined_solution[i] += random.uniform(-1, 1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and using probability to refine the strategy.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "0f902d02-a3fc-4f0d-9e9d-5e14398a18c1", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.refine_probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        for i in range(self.dim):\n            if random.random() < self.refine_probability:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(self.refine_solution(child))\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and using probability 0.25 to refine the strategy.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "705b2289-d953-428b-8839-a6654891811b", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n        self.crossover_pool = []\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                if parent2 not in self.crossover_pool:\n                    self.crossover_pool.append(parent2)\n                if len(self.crossover_pool) > 10:\n                    self.crossover_pool.pop(0)\n                if len(self.crossover_pool) > 0:\n                    child.append(self.crossover_pool[0][i])\n        return child\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            for i in range(len(self.harmony)):\n                if random.random() < self.probability:\n                    index = np.random.randint(0, len(self.harmony))\n                    self.harmony[i] = self.harmony[index]\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing Harmony Search Algorithm (HSA) with adaptive mutation and crossover for Black Box Optimization (BBO).", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "62555eee-2348-49fe-96b2-b84164165a69", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(self.refine_solution(child))\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) using probability to refine the strategy.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "839282f2-1d99-4cf1-9eef-c642bb92f99a", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n        self.de_params = {'F': 0.5, 'CR': 0.25}\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def differential_evolution(self):\n        new_harmony = []\n        for i in range(self.population_size):\n            parent1 = random.choice(self.harmony)\n            parent2 = random.choice(self.harmony)\n            child = parent1 + self.de_params['F'] * (parent2 - parent1)\n            child = [max(self.lower_bound, min(child_j, self.upper_bound)) for child_j in child]\n            new_harmony.append(child)\n        return new_harmony\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = self.differential_evolution()\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa_de = HybridHSA_DE(budget, dim)\nbest_solution = hsa_de(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA_DE", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and the crossover strategy of Differential Evolution (DE) to improve the search efficiency.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not iterable\").", "error": "TypeError(\"'float' object is not iterable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "5bfea618-398e-42cc-9900-dba4bf2cd192", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        if random.random() < self.probability:\n            i = random.randint(0, self.dim-1)\n            solution[i] += random.uniform(-1, 1)\n            solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing Harmony Search Algorithm (HSA) with adaptive mutation for Black Box Optimization (BBO) using probability 0.25 to refine the strategy.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "f5209edd-5a51-4c2d-b85f-f2c72bfe49ed", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')\n\n# Refine the strategy by changing individual lines with a probability of 0.25\nclass AdaptiveHSA_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_strategy(self):\n        for i in range(self.population_size):\n            if random.random() < 0.25:\n                solution = self.harmony[i]\n                for j in range(self.dim):\n                    solution[j] = random.uniform(self.lower_bound, self.upper_bound)\n                self.harmony[i] = solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            self.refine_strategy()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa_refined = AdaptiveHSA_Refined(budget, dim)\nbest_solution = hsa_refined(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing Harmony Search Algorithm with adaptive mutation for Black Box Optimization", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "3f00f6e9-59c9-4873-b7b7-81b2bbea552e", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.refine_probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.refine_probability:\n                refined_solution[i] += random.uniform(-1, 1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) using probability to refine the solution.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "d7172a64-038b-477e-9168-820e23f59df8", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        if random.random() < self.probability:\n            i = random.randint(0, self.dim-1)\n            solution[i] += random.uniform(-1, 1)\n            solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nahs = AdaptiveHarmonySearch(budget, dim)\nbest_solution = ahs(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHarmonySearch", "description": "Hybridizing Harmony Search Algorithm with Adaptive Mutation for Black Box Optimization", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "c2cdb1a3-dfbf-492e-9157-f3edc648ff9e", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSAMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                refined_solution[i] += random.uniform(-0.25, 0.25)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSAMutation(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSAMutation", "description": "Hybridizing Harmony Search Algorithm with Adaptive Mutation for Black Box Optimization", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "689f414a-3e0c-4f16-81bb-bfe0b03bde60", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing Harmony Search Algorithm (HSA) with adaptive mutation for Black Box Optimization (BBO) with probability 0.25.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "bfbaba8c-edf5-4ccc-9fd1-bb36f2235600", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and crossover using probability.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "fd7d676c-2f86-46d3-9d5e-7f16efa9f2c8", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def probabilistic_crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n            if random.random() < self.probability:\n                child[i] = parent1[i] + (parent2[i] - parent1[i]) * random.uniform(-1, 1)\n        return child\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.probabilistic_crossover(parent1, parent2)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and probabilistic crossover.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "d99156bc-f965-4050-b66a-7a419598142c", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                refined_solution[i] += random.uniform(-1, 1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and using probability to refine the strategy.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "4c52028d-d9d7-440c-aa30-4eb1cbfeaf1b", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                if random.random() < self.probability:\n                    child.append(parent2[i])\n        return child\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing Harmony Search Algorithm (HSA) with adaptive mutation and probability-based crossover.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "09954d9e-3b87-438f-948a-2e34be703881", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and changing the probability of individual line refinement.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "5b5cecd3-f870-4c48-b332-c78577072970", "solution": "import numpy as np\nimport random\nimport math\nimport functools\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                solution[i] = random.uniform(self.lower_bound, self.upper_bound)\n        return solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing Harmony Search Algorithm with Adaptive Mutation for Black Box Optimization", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'HybridHSA' object has no attribute 'best_solution'\").", "error": "AttributeError(\"'HybridHSA' object has no attribute 'best_solution'\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "e6f7c8a4-05ef-4c10-8341-c7166021e8f7", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                if random.random() < self.probability:\n                    child.append(parent2[i])\n                else:\n                    child.append(parent1[i])\n        return child\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing Harmony Search Algorithm (HSA) with adaptive mutation for Black Box Optimization (BBO) using probability-based crossover and mutation.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "101d2214-5a62-471f-ab42-67061ede71a7", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                refined_solution[i] += random.uniform(-1, 1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and changing individual lines according to a probability.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "65c59f94-2e91-45c2-9646-8935865d01c5", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSAMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                new_value = solution[i] + random.uniform(-1, 1)\n                if random.random() < self.probability:\n                    new_value = max(self.lower_bound, min(new_value, self.upper_bound))\n                solution[i] = new_value\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSAMutation(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSAMutation", "description": "Hybridizing Harmony Search Algorithm with adaptive mutation for Black Box Optimization", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "6db7308c-ad11-47dc-9d0c-8cf2fd67af85", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def mutate(self, solution):\n        mutated_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                mutated_solution[i] += random.uniform(-1, 1)\n                mutated_solution[i] = max(self.lower_bound, min(mutated_solution[i], self.upper_bound))\n        return mutated_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                mutated_child = self.mutate(child)\n                new_harmony.append(mutated_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and the idea of changing individual lines with a probability of 0.25.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "1289a88b-18ad-48f0-9b7f-621ab8775d78", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                refined_solution[i] = (solution[i] + parent1[i]) / 2\n            elif random.random() < 0.25:\n                refined_solution[i] = parent2[i]\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(parent1)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and crossover with probability 0.25.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'float' object has no attribute 'copy'\").", "error": "AttributeError(\"'float' object has no attribute 'copy'\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "3033140f-2c38-4d14-9d29-ace38ce9a474", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                refined_solution[i] += random.uniform(-1, 1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Novel Hybrid Harmony Search Algorithm (HSA) with adaptive mutation for Black Box Optimization (BBO)", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "a721706f-66da-4679-82dc-7a36eafafea4", "solution": "import numpy as np\nimport random\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing Harmony Search Algorithm (HSA) with adaptive mutation for Black Box Optimization (BBO) with probability 0.25.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "988a2272-6659-44cc-beed-4a4db98fb3ad", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing Harmony Search Algorithm (HSA) with Adaptive Mutation for Black Box Optimization (BBO) using probability 0.25 for crossover and mutation.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "6e97d6f6-08f0-4509-80ba-2e3153d74bdf", "solution": "import numpy as np\nimport random\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                refined_solution[i] += random.uniform(-1, 1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nahs = AdaptiveHarmonySearch(budget, dim)\nbest_solution = ahs(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHarmonySearch", "description": "Hybridizing Harmony Search Algorithm with adaptive mutation for Black Box Optimization", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "154576c0-58e5-4e46-93f8-c5eb84f393da", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing Harmony Search Algorithm (HSA) with Adaptive Mutation for Black Box Optimization (BBO) using probability 0.25.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "329a9d11-2721-4a9f-b32e-fa053a186b53", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                solution[i] = random.uniform(self.lower_bound, self.upper_bound)\n        return solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                child = self.refine_solution(child)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing Harmony Search Algorithm with adaptive mutation for Black Box Optimization.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "a7d62311-a045-4bd0-82be-9260ed0dc68f", "solution": "import numpy as np\nimport random\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.adaptive_prob = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n            elif random.random() < self.adaptive_prob:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Novel Harmony Search Algorithm with Adaptive Mutation for Black Box Optimization", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "e5b48584-3712-495e-bece-2557753436e3", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                refined_solution[i] += random.uniform(-1, 1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Novel hybridization of Harmony Search Algorithm (HSA) with adaptive mutation for Black Box Optimization (BBO).", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "17b4f43b-642a-461b-9a87-3fafcb3f4a4b", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n        self.iteration = 0\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                solution[i] = (1 - self.probability) * solution[i] + self.probability * random.uniform(self.lower_bound, self.upper_bound)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) to refine the strategy.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "d32e8fb3-fec4-4cfd-95df-8e48273ba840", "solution": "import numpy as np\nimport random\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                refined_solution[i] += random.uniform(-1, 1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Novel Hybrid Harmony Search Algorithm with Adaptive Mutation for Black Box Optimization", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "ab5e58fc-5778-4b85-a84e-32522eac1f89", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                refined_solution[i] += random.uniform(-1, 1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Novel Hybrid Harmony Search Algorithm (HSA) with adaptive mutation for black box optimization.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "244ce18c-99b1-467f-b057-745e4399bcee", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(self.refine_solution(child))\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing Harmony Search Algorithm with adaptive mutation for Black Box Optimization", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "dd5ff37b-6ae8-4369-bf88-0bbf6e563b83", "solution": "import numpy as np\nimport random\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                refined_solution[i] += random.uniform(-1, 1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing Harmony Search Algorithm with adaptive mutation for Black Box Optimization.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "73d506a7-ab4e-4406-a62f-7cb33e32d6ef", "solution": "import numpy as np\nimport random\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(child)\n                if random.random() < self.probability:\n                    new_harmony.append(self.refine_solution(child))\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Novel Hybridization of Harmony Search Algorithm (HSA) and Adaptive Mutation for Black Box Optimization (BBO)", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "af9949eb-4c5e-4d2b-a304-69bdf3a28139", "solution": "import numpy as np\nimport random\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                refined_solution[i] += random.uniform(-1, 1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing Harmony Search Algorithm with Adaptive Mutation for Black Box Optimization", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'HybridHSA' object has no attribute 'best_solution'\").", "error": "AttributeError(\"'HybridHSA' object has no attribute 'best_solution'\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "7e9961fc-e6a4-4176-8520-e8ce8704a4a4", "solution": "import numpy as np\nimport random\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n        self.probability = 0.25\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                refined_solution[i] += random.uniform(-1, 1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO).", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "aa89cabf-7697-4655-9763-dd5c3f998ec7", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n        self.iteration = 0\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            self.iteration += 1\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                child = self.refine_solution(child)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.harmony[0]}, Fitness: {self.fitness(self.harmony[0])}')\n        return self.harmony[0]\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO).", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "0870ea4f-4c5b-4cf1-a140-5821f2e52e64", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                refined_solution[i] += random.uniform(-1, 1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and using probability to refine the solution.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "3c05f5c3-9ae3-485d-b537-6ebcdb8a75d8", "solution": "import numpy as np\nimport random\nimport math\nfrom functools import partial\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n        self.func = partial(func, self.lower_bound, self.upper_bound)\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return self.func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                refined_solution[i] += random.uniform(-1, 1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Novel Hybridization of Harmony Search Algorithm with Adaptive Mutation for Black Box Optimization.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('func() takes 1 positional argument but 3 were given').", "error": "TypeError('func() takes 1 positional argument but 3 were given')", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "8cf3936b-30a5-450f-9daa-007d4aaf0e9a", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing Harmony Search Algorithm (HSA) with adaptive mutation for Black Box Optimization (BBO)", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "ab5f7372-498e-4ee4-9b27-7508316c46cb", "solution": "import numpy as np\nimport random\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and utilizing probability to refine the strategy.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "e31694c0-c600-49c4-9676-cf440a62b526", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                refined_solution[i] += random.uniform(-1, 1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing Harmony Search Algorithm (HSA) with adaptive mutation for Black Box Optimization (BBO) to improve convergence rate.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "b6c83bf1-b9cd-4769-9db3-3bafc7288210", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n        self.refine_probability = 0.25\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine(self):\n        new_harmony = []\n        for i in range(self.population_size):\n            if random.random() < self.refine_probability:\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(child)\n            else:\n                new_harmony.append(self.harmony[i])\n        return new_harmony\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            self.harmony = self.refine()\n            new_harmony = self.harmony\n            for i in range(self.population_size):\n                parent1 = random.choice(new_harmony)\n                parent2 = random.choice(new_harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and using probability to refine the strategy.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "108f6d56-f0d5-44d5-ac79-f360b4eb4621", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        for i in range(self.dim):\n            if random.random() < 0.25:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and crossover with probability 0.25.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "6f43fccb-e686-4d15-961e-75cbb170757c", "solution": "import numpy as np\nimport random\nimport math\n\nclass ProbabilisticHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.25\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def probabilistic_crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                if random.random() < self.probability:\n                    child.append(parent2[i])\n                else:\n                    child.append(parent1[i])\n        return child\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.probabilistic_crossover(parent1, parent2)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = ProbabilisticHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "ProbabilisticHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) using probabilistic crossover.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "6fa08898-4f15-41c7-865d-7682d094386a", "solution": "import numpy as np\nimport random\nimport math\nimport functools\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = list(solution)\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing Harmony Search Algorithm with Adaptive Mutation for Black Box Optimization.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "51855707-36bc-4f25-a3f7-5d9e7669bfcb", "solution": "import numpy as np\nimport random\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n                if random.random() < self.probability:\n                    child[i] += random.uniform(-1, 1)\n                    child[i] = max(self.lower_bound, min(child[i], self.upper_bound))\n        return child\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing Harmony Search Algorithm (HSA) with Adaptive Mutation for Black Box Optimization (BBO)", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'HybridHSA' object has no attribute 'best_solution'\").", "error": "AttributeError(\"'HybridHSA' object has no attribute 'best_solution'\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "7153ece2-dd17-43e5-9ce2-a1570dd21f68", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing Harmony Search Algorithm with adaptive mutation for Black Box Optimization", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "7a800454-5122-482e-9114-873da37c5e70", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                child = self.refine_solution(child)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing Harmony Search Algorithm (HSA) with adaptive mutation for Black Box Optimization (BBO) on BBOB test suite.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "1bff10e6-1ebb-47e8-ab0a-86572e940d26", "solution": "import numpy as np\nimport random\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n        self.fitness_history = []\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n            self.fitness_history.append(self.fitness(self.best_solution))\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')\nprint(f'Fitness History: {hsa.fitness_history}')", "name": "HybridHSA", "description": "Hybridizing Harmony Search Algorithm (HSA) with Adaptive Mutation for Black Box Optimization (BBO)", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "ec767c87-7cc3-4336-a938-2778a093cf28", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.refine_probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.refine_probability:\n                refined_solution[i] += random.uniform(-1, 1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) using probability to refine the solution.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "0c6712d9-8059-47c5-b038-1fe41ff9a854", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.refine_prob = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.refine_prob:\n                new_solution[i] += random.uniform(-0.1, 0.1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(self.refine_solution(child))\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) using probability 0.25 to refine the strategy.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "25c460f6-1c2d-458d-b3de-85322c72e949", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                refined_solution[i] += random.uniform(-1, 1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing Harmony Search Algorithm (HSA) with adaptive mutation for Black Box Optimization (BBO).", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "bb6a7fc0-ed5d-4a28-9b73-f792036ccf14", "solution": "import numpy as np\nimport random\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.refinement_probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.refinement_probability:\n                refined_solution[i] += random.uniform(-0.25, 0.25)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and incorporating probability-based refinement.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "fdccda41-8a16-4d6c-a3ed-ed2b295c9a48", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                refined_solution[i] += random.uniform(-1, 1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) using probability to refine the solution.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "6b0747c5-3c1f-4548-b758-7e9d73e89ec7", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                refined_solution[i] += random.uniform(-1, 1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and crossover strategy.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "527d65b7-9a51-4501-ad6f-a7b43391e948", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                refined_solution[i] += random.uniform(-1, 1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing Harmony Search Algorithm with adaptive mutation for Black Box Optimization", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "5bb4f0b0-e027-4d41-b8e4-f18719b08bb8", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n        self.probability = 0.25\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) to improve the solution's fitness.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "e8bf67db-22aa-48a8-af85-9ed160e2de42", "solution": "import numpy as np\nimport random\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n                if random.random() < self.probability:\n                    child[i] = parent1[i] + random.uniform(-1, 1)\n                    child[i] = max(self.lower_bound, min(child[i], self.upper_bound))\n        return child\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Novel Hybrid Harmony Search Algorithm with Adaptive Mutation for Black Box Optimization", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "95c5132d-8f2e-400a-9fa2-9542ae0b2e43", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution\n        for _ in range(int(self.probability * self.population_size)):\n            i = random.randint(0, self.dim - 1)\n            refined_solution[i] += random.uniform(-1, 1)\n            refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing Harmony Search Algorithm (HSA) with Adaptive Mutation for Black Box Optimization (BBO)", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "1105107b-a746-4adb-ac28-45fa5c970160", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) using probability 0.25 to refine the solution.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "46aabfc6-a64e-45f5-b151-bff291dcee58", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                child = self.refine_solution(child)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and using probability to refine the strategy.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "06252908-c697-4e3f-921e-3dd41c550462", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] = random.uniform(self.lower_bound, self.upper_bound)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing Harmony Search Algorithm with adaptive mutation for Black Box Optimization.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "546bf605-edb3-4193-ae94-e5c66c6f7852", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(self.refine_solution(child))\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO).", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "3898c5c9-e2ef-468a-a87a-a7a727c9c53f", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) using probability to refine the solution.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "e73ec375-d420-441d-abdf-4a51c610cf59", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def probabilistic_crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def probabilistic_mutation(self, solution):\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.probabilistic_crossover(parent1, parent2)\n                child = self.probabilistic_mutation(child)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) using probabilistic crossover and mutation.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "b62d8434-0180-4cc2-bbaa-77fd677163f6", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n                if random.random() < self.probability:\n                    child[i] += random.uniform(-1, 1)\n                    child[i] = max(self.lower_bound, min(child[i], self.upper_bound))\n        return child\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Novel Hybrid Harmony Search Algorithm with Adaptive Mutation for Black Box Optimization", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "2145c445-b660-44ad-b1a2-d60e3d9e14b8", "solution": "import numpy as np\nimport random\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and applying probability to refine the strategy.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "0c083c3e-4d8f-4cc6-93ea-cf68b6f0b3f0", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                refined_solution[i] += random.uniform(-1, 1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) using a probabilistic approach to refine the solution.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "fd0c7e73-7ce4-4888-bd79-5008a3502d9b", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < 0.25:\n                refined_solution[i] += random.uniform(-0.1, 0.1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) using probability to refine the solution.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "00f900b6-20e6-4c18-b06d-59c8a1e7a812", "solution": "import numpy as np\nimport random\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                if random.random() < self.probability:\n                    child.append(parent2[i])\n                else:\n                    child.append(parent1[i])\n        return child\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and the probability-based crossover to refine the strategy.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "3a13d6a0-faab-4d45-8596-6947f3fb1ccf", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                refined_solution[i] += random.uniform(-1, 1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and using probability 0.25 to change individual lines of the selected solution.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "0fce33b0-bf34-49f6-8bd7-7420518654dc", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def probabilistic_crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate * self.probability:\n                child.append(parent1[i])\n            elif random.random() < self.crossover_rate * (1-self.probability):\n                child.append(parent2[i])\n            else:\n                child.append(random.uniform(self.lower_bound, self.upper_bound))\n        return child\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.probabilistic_crossover(parent1, parent2)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) using probabilistic crossover.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "e09d64c9-b22a-4097-a3b5-4ba2a7c35f31", "solution": "import numpy as np\nimport random\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing Harmony Search Algorithm (HSA) with Adaptive Mutation for Black Box Optimization (BBO)", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "ffeddeee-4f63-46bd-ac49-e164ed148412", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                if random.random() < 0.25:\n                    child = self.crossover(parent1, parent2)\n                else:\n                    child = parent1\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Novel Harmony Search Algorithm (HSA) with adaptive mutation for Black Box Optimization (BBO) using probability-based crossover.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "68febbbc-7fda-445c-96d6-fbc53b01227b", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(self.refine_solution(child))\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and using probability to refine the strategy.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "dd88b9bf-2673-4002-96e8-6424aebed8d7", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and crossover with probability 0.25.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "089d05ae-8bd3-4461-9035-1a8033b16b25", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n        self.refine_rate = 0.25\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.refine_rate:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO).", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "3599588c-ea67-4497-bb23-771c3f30d86f", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def probabilistic_crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            elif random.random() < self.probability:\n                child.append(parent2[i])\n            else:\n                child.append(random.uniform(self.lower_bound, self.upper_bound))\n        return child\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.probabilistic_crossover(parent1, parent2)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and probabilistic crossover to refine the solution.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "82a5be30-f4f5-4c00-b4f5-f287d9f7369d", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def probabilistic_crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.probabilistic_crossover(parent1, parent2)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) using probabilistic crossover.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "c26aad4f-c10d-4e81-a69b-79c777d1e0b3", "solution": "import numpy as np\nimport random\nimport math\nimport functools\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.adaptation_rate = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        if random.random() < self.adaptation_rate:\n            for i in range(self.dim):\n                solution[i] += random.uniform(-0.1, 0.1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Novel Hybrid Harmony Search Algorithm with Adaptive Mutation for Black Box Optimization.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "4a71e339-c1c2-4280-822d-fc9ed1f157b1", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n        self.history = []\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def update_history(self, solution):\n        self.history.append(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            self.update_history(self.best_solution)\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing Harmony Search Algorithm with Adaptive Mutation for Black Box Optimization", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "40473f94-aaf3-42ff-8876-5e5be920d713", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                if random.random() < self.crossover_rate:\n                    child = self.crossover(parent1, parent2)\n                else:\n                    child = parent1\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing Harmony Search Algorithm (HSA) with Adaptive Mutation for Black Box Optimization (BBO) with 25% probability crossover and adaptive mutation.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "24accc60-a992-4546-b05c-e9489a6b894d", "solution": "import numpy as np\nimport random\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < 0.25:\n                refined_solution[i] += random.uniform(-1, 1)\n                refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and using a crossover strategy based on the probability 0.25.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "1b3b614c-4a5f-4edc-9af7-6785f5a7d7d3", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution\n        for _ in range(int(self.probability * self.population_size)):\n            i = random.randint(0, self.dim - 1)\n            refined_solution[i] += random.uniform(-1, 1)\n            refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) using probability to refine the solution.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "0aec72a4-9287-4a80-9f33-2aea81296e68", "solution": "import numpy as np\nimport random\nimport math\n\nclass HybridHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] += random.uniform(-0.25, 0.25)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                new_harmony.append(self.refine_solution(child))\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = HybridHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "HybridHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) to improve the convergence rate.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "c35850c1-f6ee-43ff-bd94-e9e7d47597c6", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                child = self.refine_solution(child)\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and using probability to refine the strategy.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "e32d0331-3fb4-48a2-a058-eefd6ef4d5e6", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        refined_solution = solution\n        for _ in range(int(self.probability * self.dim)):\n            i = random.randint(0, self.dim - 1)\n            delta = random.uniform(-1, 1)\n            refined_solution[i] += delta\n            refined_solution[i] = max(self.lower_bound, min(refined_solution[i], self.upper_bound))\n        return refined_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.crossover(parent1, parent2)\n                refined_child = self.refine_solution(child)\n                new_harmony.append(refined_child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) and incorporating probability-based refinement.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
{"id": "db750676-719a-403f-9fea-46bc8a377665", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveHSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.harmony_size = 50\n        self.crossover_rate = 0.8\n        self.probability = 0.25\n        self.harmony = self.initialize_harmony()\n        self.best_solution = None\n\n    def initialize_harmony(self):\n        harmony = []\n        for _ in range(self.population_size):\n            solution = [random.uniform(self.lower_bound, self.upper_bound) for _ in range(self.dim)]\n            harmony.append(solution)\n        return harmony\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def evaluate(self):\n        fitness_values = [self.fitness(solution) for solution in self.harmony]\n        best_index = np.argmax(fitness_values)\n        self.harmony[best_index] = self.adapt_best_solution(best_index)\n        return fitness_values\n\n    def adapt_best_solution(self, index):\n        solution = self.harmony[index]\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def refine_solution(self, solution):\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_solution is None or self.fitness(self.best_solution) < self.fitness(self.harmony[0]):\n                self.best_solution = self.harmony[0]\n            self.harmony = self.evaluate()\n            new_harmony = []\n            for i in range(self.population_size):\n                parent1 = random.choice(self.harmony)\n                parent2 = random.choice(self.harmony)\n                child = self.refine_solution(self.crossover(parent1, parent2))\n                new_harmony.append(child)\n            self.harmony = new_harmony\n            print(f'Iteration {_+1}, Best Solution: {self.best_solution}, Fitness: {self.fitness(self.best_solution)}')\n        return self.best_solution\n\ndef func(solution):\n    return sum([s**2 for s in solution])\n\n# Example usage:\nbudget = 100\ndim = 10\nhsa = AdaptiveHSA(budget, dim)\nbest_solution = hsa(func)\nprint(f'Best Solution: {best_solution}, Fitness: {func(best_solution)}')", "name": "AdaptiveHSA", "description": "Hybridizing the principles of Harmony Search Algorithm (HSA) with the concept of adaptive mutation for Black Box Optimization (BBO) using probability 0.25 to refine the strategy.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not subscriptable\").", "error": "TypeError(\"'float' object is not subscriptable\")", "parent_id": "65e59e41-36bf-4511-b011-34de9e08e8c5", "metadata": {}, "mutation_prompt": null}
