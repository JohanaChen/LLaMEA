{"id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "solution": "import numpy as np\nimport random\nimport operator\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    self.particles[i] = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover\" algorithm", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 57, in <module>\n  File \"<string>\", line 27, in __call__\nIndexError: list index out of range\n.", "error": "IndexError('list index out of range')Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 57, in <module>\n  File \"<string>\", line 27, in __call__\nIndexError: list index out of range\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "5bad5ffc-f6b7-4c38-95df-51cf39c14aa1", "solution": "import numpy as np\nimport random\nimport operator\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.probability = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                    if np.random.rand() < self.probability:\n                        self.particles[i] = new_particle\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    mutation_factor = np.random.uniform(-0.1, 0.1, self.dim)\n                    self.particles[i] = self.particles[i] + mutation_factor\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Probabilistic Mutation\" algorithm", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "61dd7634-1075-4e23-8fed-aceeb71e2348", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmAM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.adaptation_rate = 0.1\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                    if random.random() < self.adaptation_rate:\n                        new_particle = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    self.particles[i] = new_particle\n\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmAM(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmAM", "description": "Novel \"Multi-Swarm Adaptive Crossover and Mutation\" algorithm", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "b5ef08c1-7a70-4060-bc04-9fce6b6a093a", "solution": "import numpy as np\nimport random\nimport operator\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.adaptation_rate = 0.1\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    self.particles[i] = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n            # Adaptation\n            for i in range(self.swarm_size):\n                if random.random() < self.adaptation_rate:\n                    # Adapt the particle's velocity\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Adaptation\" algorithm", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "7bae3200-4f32-4885-b2bd-1330366e6784", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    self.particles[i] = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n            # Adaptive crossover and mutation probabilities\n            r3 = np.random.uniform(0, 1)\n            r4 = np.random.uniform(0, 1)\n            if r3 < self.adaptive_probability:\n                self.crossover_probability = max(0.1, self.crossover_probability - 0.05)\n            if r4 < self.adaptive_probability:\n                self.mutation_probability = max(0.1, self.mutation_probability - 0.05)\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Adaptive Probability\"", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "a67196db-a2fe-4d2c-840b-20562941877f", "solution": "import numpy as np\n\nclass MultiSwarmDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                if np.random.rand() < self.crossover_probability:\n                    # Crossover\n                    r1, r2 = np.random.permutation(self.dim)\n                    particle[r1], particle[r2] = particle[r2], particle[r1]\n                if np.random.rand() < self.mutation_probability:\n                    # Mutation\n                    r = np.random.randint(0, self.dim)\n                    particle[r] += np.random.uniform(-0.1, 0.1)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmDE(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmDE", "description": "Novel \"Multi-Swarm Differential Evolution with Crossover\" algorithm", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "27ff1042-777e-49ea-9073-49d7dc07d610", "solution": "import numpy as np\nimport random\nimport operator\n\nclass MultiSwarmAC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.adaptive_crossover = False\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                if self.adaptive_crossover:\n                    r1 = np.random.uniform(0, 1)\n                    if r1 < self.crossover_probability:\n                        # Crossover\n                        self.particles[i] = np.array([\n                            particle[0] + np.random.uniform(-1, 1),\n                            particle[1] + np.random.uniform(-1, 1)\n                        ])\n                else:\n                    r2 = np.random.uniform(0, 1)\n                    if r2 < self.crossover_probability:\n                        # Crossover\n                        self.particles[i] = np.array([\n                            particle[0] + np.random.uniform(-1, 1),\n                            particle[1] + np.random.uniform(-1, 1)\n                        ])\n\n                if self.mutation_probability > 0 and np.random.uniform(0, 1) < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmAC(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmAC", "description": "Novel \"Multi-Swarm Adaptive Crossover\" algorithm with adaptive crossover probability", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "c8427059-f1aa-4c1e-80de-43bdcdeb0dd5", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.crossover_rate = 0.5\n        self.mutation_rate = 0.1\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                    if np.random.rand() < self.crossover_rate:\n                        self.particles[i] = new_particle\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Mutation\"", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "f04847d2-8dd2-4173-a7d1-4db6a62e722c", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.probability_threshold = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    new_particle = particle + np.random.uniform(-1, 1, self.dim)\n                    if np.random.rand() < self.probability_threshold:\n                        new_particle = self.particles[i]\n                    self.particles[i] = new_particle\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Probabilistic Mutation\" algorithm", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "239e2150-d5b2-4319-8c2b-e27e220e4946", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.pbest_history = []\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n                    self.pbest_history.append((self.best_particles[i], fitness))\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    self.particles[i] = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=lambda x: func(x))\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Mutation\" algorithm", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "d51ed112-c13c-43a2-ad95-e6944c52fcfa", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.adaptive_mutation = 0.2\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                    if np.random.uniform(0, 1) < self.adaptive_mutation:\n                        new_particle = new_particle + np.random.uniform(-0.1, 0.1, self.dim)\n                    self.particles[i] = new_particle\n\n                # Mutation\n                if r2 < self.mutation_probability:\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Adaptive Mutation\" algorithm", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "6c041d4a-7741-4eae-bea9-fa88603f30b7", "solution": "import numpy as np\nimport random\nimport operator\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.probability_threshold = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                    if random.random() < self.probability_threshold:\n                        self.particles[i] = new_particle\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    mutation = np.random.uniform(-0.1, 0.1, self.dim)\n                    if random.random() < self.probability_threshold:\n                        self.particles[i] = self.particles[i] + mutation\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Probabilistic Mutation\" algorithm", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "567278b1-f367-4503-9fa8-b80c7ceb8079", "solution": "import numpy as np\nimport random\nimport operator\n\nclass MultiSwarmQuantumInspiredOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.quantum_bits = 10\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    self.particles[i] = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n                # Quantum Inspired Update\n                quantum_bits = np.random.choice([0, 1], size=self.quantum_bits, p=[0.5, 0.5])\n                quantum_particle = np.zeros(self.dim)\n                for j in range(self.dim):\n                    if quantum_bits[j] == 1:\n                        quantum_particle[j] = particle[j] + np.random.uniform(-0.1, 0.1)\n                self.particles[i] = np.array([quantum_particle[0], quantum_particle[1]])\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQuantumInspiredOptimization(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQuantumInspiredOptimization", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Crossover and Mutation\" algorithm", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "cda277d1-296c-40b4-9a41-be0d6a61b78a", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.probability = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                    if np.random.rand() < self.probability:\n                        self.particles[i] = new_particle\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Probabilistic Mutation\"", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "ab51f5cb-f57b-4fd4-bda5-ced13cac409f", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                    if r2 < self.adaptive_probability:\n                        self.crossover_probability = (self.crossover_probability + np.random.uniform(-0.05, 0.05))\n                    self.particles[i] = new_particle\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Adaptive Probability\"", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "a8d6da41-1e24-472a-b23c-95939610d7bf", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.gaussian_std_dev = 0.1\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    self.particles[i] = np.array([\n                        particle[0] + np.random.normal(0, self.gaussian_std_dev),\n                        particle[1] + np.random.normal(0, self.gaussian_std_dev)\n                    ])\n                if r2 < self.mutation_probability:\n                    # Gaussian mutation\n                    self.particles[i] = self.particles[i] + np.random.normal(0, self.gaussian_std_dev, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Gaussian Mutation\" algorithm", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "b9e0f121-a25a-46e0-838c-f49bda1af85d", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                    if r2 < self.adaptive_probability:\n                        new_particle = new_particle * self.mutation_probability + particle * (1 - self.mutation_probability)\n                    self.particles[i] = new_particle\n                else:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Adaptive Probability\"", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "18f62bdd-6c38-47ef-9e87-8e8483d74de4", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                    if r2 < self.adaptive_probability:\n                        new_particle = new_particle + np.random.uniform(-0.1, 0.1, self.dim)\n                    self.particles[i] = new_particle\n                elif r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Adaptive Probability\"", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "780885ff-2a1a-4d14-9c6d-bbdeae3a8873", "solution": "import numpy as np\nimport random\nimport operator\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.adaptive_mutation = 0.5\n        self.adaptive_mutation_decay = 0.99\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                    if random.random() < self.adaptive_mutation:\n                        new_particle = new_particle + np.random.uniform(-0.1, 0.1, self.dim)\n                    self.particles[i] = new_particle\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Adaptive Mutation\"", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "8d5e5538-eef7-409b-9d82-13fc22af0c46", "solution": "import numpy as np\nimport random\nimport operator\n\nclass MultiSwarmPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.de_probability = 0.2\n        self.de_weight = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    self.particles[i] = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n                # Differential Evolution\n                if np.random.uniform(0, 1) < self.de_probability:\n                    # Select three random particles\n                    rand_indices = np.random.choice(self.swarm_size, 3, replace=False)\n                    rand_particles = self.particles[rand_indices]\n\n                    # Calculate the difference vector\n                    diff_vector = rand_particles[0] - rand_particles[1]\n                    diff_vector = diff_vector * self.de_weight\n\n                    # Update the particle\n                    self.particles[i] = self.particles[i] + diff_vector\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO_DE(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO_DE", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Differential Evolution\" algorithm", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "9c764317-7651-416e-81e0-978986c4db1b", "solution": "import numpy as np\nimport random\nimport operator\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.probability = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    self.particles[i] = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                if r2 < self.mutation_probability:\n                    # Probabilistic mutation\n                    if np.random.rand() < self.probability:\n                        self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Probabilistic Mutation\" algorithm", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "61c0bd11-708e-4dbd-ad89-1a4cf4eebccf", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.probability = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    self.particles[i] = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                if r2 < self.mutation_probability:\n                    # Probabilistic mutation\n                    for j in range(self.dim):\n                        if np.random.rand() < self.probability[j]:\n                            self.particles[i][j] += np.random.uniform(-0.1, 0.1)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Update the probability of mutation\n        for i in range(self.swarm_size):\n            for j in range(self.dim):\n                if self.particles[i][j] < -5.0 or self.particles[i][j] > 5.0:\n                    self.probability[j] += 0.01\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Probabilistic Mutation\"", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "ccf59897-044f-456e-84a9-92162d72e17e", "solution": "import numpy as np\nimport random\nimport operator\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.quantum_bits = 10\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    self.particles[i] = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n            # Quantum Inspired Optimization\n            for _ in range(self.quantum_bits):\n                self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Crossover\" algorithm", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "97dc955b-6bfc-4c8f-bc7c-be0db845b93e", "solution": "import numpy as np\nimport random\nimport operator\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.adaptive_mutation = 0.01\n        self.adaptive_mutation_counter = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    self.particles[i] = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    if self.adaptive_mutation_counter < 10:\n                        self.adaptive_mutation_counter += 1\n                        self.mutation_probability = np.random.uniform(0.01, 0.1)\n                    self.particles[i] = self.particles[i] + np.random.uniform(-self.adaptive_mutation, self.adaptive_mutation, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Adaptive Mutation\"", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "e524f750-6898-43e6-8c72-49d533f7968e", "solution": "import numpy as np\nimport random\nimport operator\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    self.particles[i] = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n                # Adaptive crossover and mutation probability\n                if r3 < self.adaptive_probability:\n                    self.crossover_probability += 0.01\n                    self.mutation_probability += 0.01\n                if r4 < self.adaptive_probability:\n                    self.crossover_probability -= 0.01\n                    self.mutation_probability -= 0.01\n                if self.crossover_probability > 1:\n                    self.crossover_probability = 1\n                if self.mutation_probability > 1:\n                    self.mutation_probability = 1\n                if self.crossover_probability < 0:\n                    self.crossover_probability = 0\n                if self.mutation_probability < 0:\n                    self.mutation_probability = 0\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Adaptive Probability\"", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "9286e5bf-f1cc-4d13-88d4-3a0d87a2d0d2", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.probability_threshold = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                    if r2 < self.probability_threshold:\n                        new_particle = self.particles[i]\n                    self.particles[i] = new_particle\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Probabilistic Mutation\"", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "28d62048-eee6-4a79-9700-ecec7debc4b6", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.probability = np.zeros(self.swarm_size)\n        self.initialize_probability()\n\n    def initialize_probability(self):\n        self.probability = np.random.uniform(0, 1, self.swarm_size)\n        self.probability /= self.probability.sum()\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for i in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    self.particles[i] = self.particles[i] + np.random.uniform(-1, 1, self.dim) * self.probability[i]\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim) * (1 - self.probability[i])\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Probabilistic Mutation\"", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "40582ca9-6cb6-45ee-9d77-21f29058ae04", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    if random.random() < self.adaptive_probability:\n                        self.particles[i] = np.array([\n                            particle[0] + np.random.uniform(-1, 1),\n                            particle[1] + np.random.uniform(-1, 1)\n                        ])\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Adaptive Probability\"", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "3ab6f109-edb1-46c8-bfc7-aaa0077b86c4", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    self.particles[i] = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmES(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmES", "description": "Novel \"Multi-Swarm Evolutionary Strategy with Crossover\" algorithm", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "135713e0-045c-4290-8f93-10bc1fa50f9b", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.global_best = None\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the global best\n                if self.global_best is None or fitness < func(self.global_best):\n                    self.global_best = particle\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    self.particles[i] = self.particles[i] + np.random.uniform(-1, 1, self.dim)\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the global best particle\n        return self.global_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Mutation\" algorithm", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "fab83ee4-0425-474b-b07e-e15b4348f769", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.probability = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    self.particles[i] = self.particles[i] + np.random.uniform(-1, 1, self.dim)\n                if r2 < self.mutation_probability:\n                    # Probabilistic Mutation\n                    if np.random.rand() < self.probability:\n                        self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Probabilistic Mutation\"", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "53f95418-9165-4921-b43c-f8ca5c869fbb", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.velocity = np.zeros((self.swarm_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    self.particles[i] = self.particles[i] + np.random.uniform(-1, 1, self.dim)\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n\n                # Update velocity\n                self.velocity[i] = self.velocity[i] + 0.5 * (self.particles[i] - self.best_particles[i])\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Update the swarm velocity\n        for i in range(self.swarm_size):\n            self.velocity[i] = self.velocity[i] * 0.9 + 0.1 * np.random.normal(0, 1, self.dim)\n\n        # Update the particles\n        for i in range(self.swarm_size):\n            self.particles[i] = self.particles[i] + self.velocity[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Mutation\"", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "d5813c82-675e-4790-a3c4-833ac6e9a3f3", "solution": "import numpy as np\nimport random\nimport operator\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.adaptive_crossover_probability = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    if np.random.uniform(0, 1) < self.adaptive_crossover_probability:\n                        self.particles[i] = np.array([\n                            particle[0] + np.random.uniform(-1, 1),\n                            particle[1] + np.random.uniform(-1, 1)\n                        ])\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Adaptive Probability\"", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "e14c114b-3db9-4aba-af1c-acbf120c9386", "solution": "import numpy as np\nimport random\nimport operator\n\nclass MultiSwarmES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.step_size = 0.1\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle using evolution strategy\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    new_particle = self.particles[i] + np.random.uniform(-self.step_size, self.step_size, self.dim)\n                else:\n                    new_particle = self.particles[i]\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    new_particle = new_particle + np.random.uniform(-self.step_size, self.step_size, self.dim)\n                self.particles[i] = new_particle\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmES(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmES", "description": "Novel \"Multi-Swarm Evolution Strategy with Crossover and Mutation\"", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "30c076d0-179d-4f23-ba9e-7b3ae7d303d5", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.stochastic_search_probability = 0.2\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                    if np.random.uniform(0, 1) < self.stochastic_search_probability:\n                        # Stochastic search\n                        new_particle = self.stochastic_search(new_particle)\n                    self.particles[i] = new_particle\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n    def stochastic_search(self, particle):\n        # Perform a stochastic search around the particle\n        for _ in range(10):\n            new_particle = particle + np.random.uniform(-0.1, 0.1, self.dim)\n            if np.random.uniform(0, 1) < self.stochastic_search_probability:\n                # Replace the particle with the new one\n                particle = new_particle\n        return particle\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Stochastic Search\" algorithm", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "2f156998-12cc-4748-a0e9-4dd8b21d1d07", "solution": "import numpy as np\nimport random\nimport operator\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.learning_rate = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    self.particles[i] = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Update the learning rate\n        self.learning_rate = 0.5 + np.random.uniform(-0.1, 0.1)\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Adaptive Learning Rate\" algorithm", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "44ef7c2f-299d-4e8c-8073-7ec3859d0f0a", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.1\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                    if r2 < self.adaptive_probability:\n                        self.particles[i] = new_particle\n                    else:\n                        self.particles[i] = particle\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Adaptive Probability\"", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "29aaaeb0-b7dc-4362-85f9-4a4c8155d470", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmCPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.crossover_rate = 0.5\n        self.mutation_rate = 0.1\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    new_particle = particle.copy()\n                    for j in range(self.dim):\n                        if random.random() < self.crossover_rate:\n                            new_particle[j] = particle[j] + np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmCPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmCPSO", "description": "Novel \"Multi-Swarm Crossover Particle Swarm Optimization\" algorithm", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "437f27f0-5207-4887-9216-4cfda6f63b50", "solution": "import numpy as np\nimport random\nimport operator\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.mutation_step = 0.1\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                    self.particles[i] = new_particle\n                    # Apply mutation with probability 0.5\n                    if random.random() < 0.5:\n                        self.particles[i] = self.particles[i] + np.random.uniform(-self.mutation_step, self.mutation_step, self.dim)\n\n                # Apply mutation with probability 0.5\n                if random.random() < 0.5:\n                    self.particles[i] = self.particles[i] + np.random.uniform(-self.mutation_step, self.mutation_step, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Mutation\" algorithm", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "93578319-dab3-43e9-b6fe-4aff033980cb", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.adaptive_mutation_rate = 0.01\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    self.particles[i] = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                if r2 < self.mutation_probability + self.adaptive_mutation_rate:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Adaptive Mutation\" algorithm", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "e1d98103-0626-483e-b472-661c59b06508", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.1\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    self.particles[i] = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n                # Update adaptive probability\n                if self.crossover_probability < self.adaptive_probability:\n                    self.crossover_probability += 0.01\n                if self.mutation_probability < self.adaptive_probability:\n                    self.mutation_probability += 0.01\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Adaptive Probability\" algorithm", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "6ad78148-82d6-4351-a11f-2ecb1f8e048e", "solution": "import numpy as np\nimport random\nimport operator\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.adaptive_crossover = 0.5\n        self.adaptive_mutation = 0.1\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover with adaptive probability\n                    if np.random.uniform(0, 1) < self.adaptive_crossover:\n                        self.particles[i] = np.array([\n                            particle[0] + np.random.uniform(-1, 1),\n                            particle[1] + np.random.uniform(-1, 1)\n                        ])\n                if r2 < self.mutation_probability:\n                    # Mutation with adaptive probability\n                    if np.random.uniform(0, 1) < self.adaptive_mutation:\n                        self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Adaptive Probabilities\"", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "06b2b9e7-8bb4-4436-8c26-e46c82836ab8", "solution": "import numpy as np\nimport random\nimport operator\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.1\n        self.adaptive_crossover_probability = 0.01\n        self.adaptive_mutation_probability = 0.01\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    self.particles[i] = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Adaptive probability update\n            if len(self.particles) > self.swarm_size:\n                for j in range(self.swarm_size):\n                    r1 = np.random.uniform(0, 1)\n                    r2 = np.random.uniform(0, 1)\n                    if r1 < self.adaptive_crossover_probability:\n                        self.particles[j] = self.particles[j] + np.random.uniform(-0.1, 0.1, self.dim)\n                    if r2 < self.adaptive_mutation_probability:\n                        self.particles[j] = self.particles[j] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Adaptive Probability\"", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "a5052c39-f278-4ee4-a723-65ee4b7e8c2b", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.probability_threshold = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    self.particles[i] = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                if r2 < self.mutation_probability:\n                    # Probabilistic mutation\n                    if np.random.rand() < self.probability_threshold:\n                        self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Probabilistic Mutation\" algorithm", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "e16e7b0c-5171-488f-84d9-1e9e353acf8d", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.adaptive_mutation = 0.01\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    self.particles[i] = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                if r2 < self.mutation_probability + self.adaptive_mutation:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Adaptive Mutation\" algorithm", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "27160a8b-652e-4ff2-95aa-a9595a44886f", "solution": "import numpy as np\nimport random\nimport operator\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.w = 0.8\n        self.c = 0.4\n        self.rho = 0.2\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    child = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                    if r2 < self.mutation_probability:\n                        child = child + np.random.uniform(-0.1, 0.1, self.dim)\n                    self.particles[i] = child\n\n                # Update the particle velocity\n                v = np.zeros(self.dim)\n                r = np.random.uniform(0, 1)\n                if r < self.c:\n                    v = self.rho * v + np.random.uniform(-1, 1, self.dim)\n                v = v * self.w\n                self.particles[i] = self.particles[i] + v\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Mutation\" algorithm", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "735ad496-0dff-4242-8c1d-bf97e5dcbd14", "solution": "import numpy as np\nimport random\nimport operator\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                    if np.random.rand() < self.adaptive_probability:\n                        self.particles[i] = new_particle\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Adaptive Probability\"", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "122262d2-8801-42d5-aff2-eb512697c714", "solution": "import numpy as np\nimport random\nimport operator\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.adaptive_crossover_probability = 0.5\n        self.adaptive_mutation_probability = 0.1\n        self.adaptive_crossover_threshold = 0.7\n        self.adaptive_mutation_threshold = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    if np.random.uniform(0, 1) < self.adaptive_crossover_probability:\n                        self.particles[i] = np.array([\n                            particle[0] + np.random.uniform(-1, 1),\n                            particle[1] + np.random.uniform(-1, 1)\n                        ])\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    if np.random.uniform(0, 1) < self.adaptive_mutation_probability:\n                        self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n                # Adaptive probability update\n                if np.random.uniform(0, 1) < 0.01:\n                    self.crossover_probability = np.random.uniform(0, 1)\n                    self.mutation_probability = np.random.uniform(0, 1)\n                    self.adaptive_crossover_probability = np.random.uniform(0, 1)\n                    self.adaptive_mutation_probability = np.random.uniform(0, 1)\n                    self.adaptive_crossover_threshold = np.random.uniform(0, 1)\n                    self.adaptive_mutation_threshold = np.random.uniform(0, 1)\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Adaptive Probability\"", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "fb7f6479-405a-4ba2-a218-d831fc74b9ef", "solution": "import numpy as np\nimport random\nimport operator\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.array([\n                        particle[0] + np.random.uniform(-1, 1),\n                        particle[1] + np.random.uniform(-1, 1)\n                    ])\n                    if r2 < self.mutation_probability:\n                        # Mutation\n                        new_particle = new_particle + np.random.uniform(-0.1, 0.1, self.dim)\n                    self.particles[i] = new_particle\n                else:\n                    # No crossover or mutation\n                    self.particles[i] = particle\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Probability-based Mutation\"", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "427cd28a-067d-4196-8610-d3cb85bbe52a", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.1\n        self.adaptive_crossover_probability = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < func(self.best_particles[i]):\n                    self.best_particles[i] = particle\n\n                # Update the particle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.crossover_probability:\n                    # Crossover\n                    if np.random.uniform(0, 1) < self.adaptive_crossover_probability:\n                        self.particles[i] = np.array([\n                            particle[0] + np.random.uniform(-1, 1),\n                            particle[1] + np.random.uniform(-1, 1)\n                        ])\n                if r2 < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n                # Adaptive probability update\n                if np.random.uniform(0, 1) < self.adaptive_probability:\n                    self.crossover_probability += np.random.uniform(-0.05, 0.05)\n                    self.mutation_probability += np.random.uniform(-0.05, 0.05)\n                    self.crossover_probability = max(0, min(self.crossover_probability, 1))\n                    self.mutation_probability = max(0, min(self.mutation_probability, 1))\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles[i] = self.particles[i]\n\n        # Return the best particle\n        return min(self.best_particles, key=func)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Adaptive Probability\" algorithm", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {}, "mutation_prompt": null}
{"id": "591b49bc-d66b-407f-bd11-5976d0e1818c", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.5:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmPSO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmPSO", "description": "Novel \"Multi-Swarm Particle Swarm Optimization with Crossover and Mutation\" algorithm", "configspace": "", "generation": 50, "fitness": 0.06879218618304127, "feedback": "The algorithm MultiSwarmPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.06.", "error": "", "parent_id": "81c8aceb-8f1f-497c-8e07-1e020ad3d145", "metadata": {"aucs": [0.1462296137550897, 0.10190597659469258, 0.11846895454250606, 0.12382233247226182, 0.13313131789832988, 0.11587468184853733, 0.0998473575412605, 0.11777026715128491, 0.13296147964569316, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01413748843383289, 0.023841541528631383, 0.02483140318083077, 0.03822850413871859, 0.02857118302455508, 0.027019731530763647, 0.05269549662964235, 0.06519972761879578, 0.03106344665834404, 0.02613549322209041, 0.012145645394745608, 0.003602084306865816, 0.023997065875062562, 0.02368367476541733, 0.003044901247822418, 0.014763392921912755, 0.040136784562746275, 0.01669783619914056, 0.0676602240443368, 0.07292317758963163, 0.05560328530721814, 0.0796299877430654, 0.06261406414796933, 0.08490451418984268, 0.08934032610410869, 0.06708983130313151, 0.07677028851660161, 0.08520237096266281, 0.03011515530283304, 0.040330258651158135, 0.05227016390330408, 0.0059958300344539195, 0.05603837181151872, 0.00539243741295381, 0.09853046168667023, 0.01147367869377558, 0.10027683525177622, 0.10646301586290463, 0.07513587916610598, 0.09854328039372684, 0.07429694338820214, 0.11401107428253765, 0.05724713871889575, 0.0926682792306952, 0.1875990540053507, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000583838653532065, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005624273259972723, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019714462079520656, 0.07247513168443676, 0.014548885064371797, 0.013837831415437485, 0.01917366136082599, 0.011408005388367393, 0.04684791670117594, 0.005779396822442329, 0.03626876037533766, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12119750625658521, 0.1807100689160912, 0.16661802922139213, 0.15520183762771156, 0.15235399746106137, 0.1357565564601959, 0.18521036933853774, 0.13349626759430577, 0.12941641955237515, 0.0168834164751559, 0.03207289768305832, 0.02883550793900358, 0.052520483657700234, 0.019267265793438182, 0.035318202665280074, 0.03159070595096258, 0.04000284757201045, 0.03578470609484097, 0.13153458398848594, 0.1529345661128838, 0.11842175776965747, 0.1588459966215623, 0.12364854494344324, 0.1254539738219178, 0.1272518389917071, 0.10758635216884382, 0.12874735094887124, 0.1406582680390357, 0.11780422321947137, 0.1613932299901245, 0.13940593461895767, 0.12858038470070332, 0.14507048283100954, 0.16813176644293948, 0.1925592599479673, 0.14587573764494888, 0.08596167048600456, 0.05467713487135584, 0.09702184227616073, 0.08602836861581942, 0.10704554396566524, 0.09639072899636159, 0.08527428321026886, 0.12834032227655812, 0.09768969768799018, 0.16619483217949071, 0.13490019430809297, 0.14094000161270526, 0.15910055595161188, 0.12685266147141716, 0.14209782566110862, 0.1645043504234347, 0.14611528623721515, 0.14247160176536, 0.00595841895242788, 0.05598684912936491, 0.12455439980711458, 0.001811761106794485, 0.01205784140686661, 0.12979682451084262, 0.13866361318827658, 0.024181568739015114, 0.12503151710796423, 0.129124362195834, 0.1257350352163923, 0.11923985397379477, 0.13699090120180446, 0.13561946655913126, 0.11203079610783317, 0.12820970133605747, 0.15284608436649594, 0.1239951891192057, 0.13903047662534296, 0.12972038572298938, 0.09867913936153672, 0.12212442617010166, 0.07371645421634676, 0.13928299721062942, 0.13992346462915428, 0.07474611548374088, 0.10972790455968573, 0.17005589320982495, 0.16850914367022685, 0.17081531171472797, 0.16670116962063197, 0.18320832006424992, 0.17922665090556889, 0.1694399317296833, 0.18172271723259925, 0.18744910201948728, 0.03983392079440384, 0.0382143979790841, 0.03600365425900509, 0.03992787943037179, 0.0410836644830922, 0.044106292830610294, 0.0669412953223194, 0.03993924518145031, 0.04000436282554687]}, "mutation_prompt": null}
{"id": "2f4b5786-1946-4191-8158-55914777c360", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.1\n        self.quantum_bit = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.5:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)\n", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Crossover and Mutation\" algorithm", "configspace": "", "generation": 51, "fitness": 0.07435712122837085, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.06.", "error": "", "parent_id": "591b49bc-d66b-407f-bd11-5976d0e1818c", "metadata": {"aucs": [0.16434790958086687, 0.11581728967079996, 0.148713533093359, 0.11798818710816728, 0.14364759993945497, 0.11331561847836547, 0.1493657047223529, 0.1606448741015778, 0.1346697881141845, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03487077511752801, 0.028131902497924077, 0.02390455405831904, 0.029130663990715733, 0.04226395289963025, 0.017242345822590543, 0.05137125807933007, 0.030904166936362, 0.03726014608831829, 0.022183073852143576, 0.022677643966614425, 0.012185624473479262, 0.03740792719538144, 0.03382694714692058, 0.018069999702758466, 0.017511524054075966, 0.006741521065729783, 0.016230421278512375, 0.07773034350742114, 0.1348196028186408, 0.09245897634727662, 0.08624288818634684, 0.07484611623046622, 0.0902662924408918, 0.09645936919437059, 0.12998723396074097, 0.07758777623612023, 0.10516095975316753, 0.0563517868274408, 0.06102307048863498, 0.03295155215900303, 0.019991003244377636, 0.03142895930023659, 0.14438123806849412, 0.04959671095874618, 0.055806912653533214, 0.10298722966318874, 0.15102386379511368, 0.10209007339674403, 0.1117828222749142, 0.09065196482126592, 0.11266244731244912, 0.06419846849252331, 0.10617319679004378, 0.09090580881339061, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0071517832386931435, 9.999999999998899e-05, 9.999999999998899e-05, 0.011634024671139387, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026466359929944838, 0.03394017027222618, 0.00012062204646245966, 0.03486833725389349, 0.024335262809957237, 0.08221242300400067, 0.006429128188174982, 0.008320585707676575, 0.06910678475299914, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011804499626059117, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1513967556949527, 0.1623629874689957, 0.16450979535314014, 0.18598148894607602, 0.16526945464594844, 0.16616662916255154, 0.16112956940342849, 0.15958483261038092, 0.13365527587889314, 0.03534261170662445, 0.03002869281179288, 0.046532552541933225, 0.033144087161991465, 0.0395633928388015, 0.039331526561730445, 0.028617562344124048, 0.026828870865730825, 0.03705973445155886, 0.12238720343837883, 0.12788918179874453, 0.14863677046155865, 0.1244196321306259, 0.13375076150821275, 0.12650656804486649, 0.10915511983384474, 0.13671074191363985, 0.1127931778910648, 0.14865008988188821, 0.14750559236553384, 0.1613932299901245, 0.16326784646585657, 0.14623468507724213, 0.1424998741415473, 0.14263354140829776, 0.17377774300845283, 0.18600284665642752, 0.07883400425851028, 0.07290239375102314, 0.09896069156515697, 0.11007743192381025, 0.09364665781755388, 0.10015555392948683, 0.0913606373221093, 0.0997711199450243, 0.10377640193082749, 0.14388742795897747, 0.14291488340053615, 0.1547642195435288, 0.1557018296859407, 0.14788140818545858, 0.1447722772607054, 0.15523886966679856, 0.16761578863699522, 0.13509884307042452, 0.13886045096782929, 0.07783873879144887, 0.12389277421002187, 0.11182408703319635, 0.03671393266798462, 0.1439730970691233, 0.12027650914381016, 0.035953697924953176, 0.10804312693886353, 0.10448525324549696, 0.11650562926873276, 0.11078242778030667, 0.1292897169777596, 0.16211070185072274, 0.13843734295029753, 0.10964925746016618, 0.12296777646260637, 0.15590249348277996, 0.1487774568168454, 0.10998962309228122, 0.19189394482929178, 0.13739018715868423, 0.10822820868123928, 0.12660106110385005, 0.1051877076780331, 0.1136307189472795, 0.10615240351714861, 0.16159375358996697, 0.16634806305128091, 0.17981768080215443, 0.18630083813791676, 0.17383872152800484, 0.1711689819455643, 0.18127128783652968, 0.1844418809882622, 0.18459582257450302, 0.04942536979006529, 0.028441045628563866, 0.0485950411633681, 0.03809826631596147, 0.03698534745964954, 0.035480117823952995, 0.05175334211152727, 0.04267161117649032, 0.03601426842698019]}, "mutation_prompt": null}
{"id": "c81449fb-4ee7-40ab-b7fe-501e20acecd7", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.5:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Crossover and Mutation\" algorithm with probability 0.5 for crossover and mutation.", "configspace": "", "generation": 52, "fitness": 0.0841655892906191, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.07.", "error": "", "parent_id": "2f4b5786-1946-4191-8158-55914777c360", "metadata": {"aucs": [0.1478426570330914, 0.16613932478179017, 0.15578253271856624, 0.14005599851408146, 0.19271695527892763, 0.13056572790749976, 0.15662291471314804, 0.17661107647511087, 0.1259343899752675, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07939473001361053, 0.05339363491502658, 0.03344278679893653, 0.037165062054652864, 0.04947577544895154, 0.034134000747590876, 0.04663954098873202, 0.04728042399242327, 0.07962805905598414, 0.018094743437776395, 0.02063188633838764, 0.018761300998174524, 0.02094774296438595, 0.021584905172347457, 0.02471582167296349, 0.025966975695825623, 0.022112874599217847, 0.034106337323060454, 0.11118052894414154, 0.13411786726404584, 0.08956872235968494, 0.18211329018276745, 0.17715604895908943, 0.3535600100598417, 0.09587808787037555, 0.11569832722148954, 0.12573340728827476, 0.07665757029815834, 0.052456150766591936, 0.06047517426356608, 0.051165228048759115, 0.06928679611893618, 0.05466163867171636, 0.07180117690476617, 0.05707962395456012, 0.094335050857705, 0.13337148750745886, 0.09802970624612195, 0.10100139527211938, 0.10241885661349537, 0.1011242373422645, 0.09886092930407198, 0.09952563756775779, 0.12700323595455443, 0.09878284409348848, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008163779290778939, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04595774120840468, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009071970342192426, 9.999999999998899e-05, 0.03794101056483801, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02414119591059971, 0.03608506145303547, 0.03648795333213617, 0.027136486264075943, 0.015416301931373555, 0.036510389074646654, 0.02511880080170703, 0.031061728851302872, 0.11472952922704005, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18149241927425097, 0.1733001855774815, 0.1746088664038571, 0.17426326011885462, 0.17635156650307204, 0.18215643957146743, 0.20771186224138471, 0.1757175421938426, 0.17150245017533283, 0.04017691662008549, 0.03162924405465872, 0.02952531918185064, 0.0441880317580603, 0.027008488871119174, 0.03165503573861661, 0.036086605030611674, 0.03340074133473281, 0.03178964548594654, 0.12124115809622471, 0.12981047507307975, 0.13259730097632694, 0.1266937346355802, 0.12656048085444804, 0.15182176670398584, 0.1344779724846752, 0.15032486577159976, 0.13539493796510016, 0.14984177177148195, 0.17017798487815816, 0.1613932299901245, 0.16589884082875872, 0.15691041767473946, 0.15775697969278457, 0.18013631600149005, 0.19823300214244854, 0.15938342329409694, 0.07710846193821874, 0.1365009135211761, 0.09228425384471428, 0.10670089746626932, 0.09691327656501691, 0.11262778473619806, 0.0845878469903193, 0.10887830303923329, 0.10218473830781027, 0.1422881034090835, 0.13707119879752316, 0.1355707079739057, 0.15584425108140443, 0.17054339359804727, 0.1447981774502668, 0.14279138902571353, 0.13649459621112148, 0.16148731605029953, 0.14719119377936518, 0.12335405813184674, 0.13213624957314463, 0.14765715428891635, 0.09592987950343546, 0.11835748608186036, 0.09641583696381328, 0.12276354526038868, 0.13371607514915818, 0.2326343077782781, 0.15414550866380938, 0.1329487513674954, 0.161208319808387, 0.14570994422452876, 0.13713001241472011, 0.1544724309503397, 0.14178745350587973, 0.15346201857838548, 0.12872341490459516, 0.1303232239569555, 0.10853308094398817, 0.14248560395556653, 0.10781594422793528, 0.1924904272167446, 0.14826308021992352, 0.1151008953434064, 0.1425588653098866, 0.16909487866096096, 0.17340799156906528, 0.1669288467116674, 0.2056822706360103, 0.19187799182971432, 0.17281604061008315, 0.18212197352687365, 0.2178578895514428, 0.17316434427201588, 0.06252668938564698, 0.04545996355987958, 0.043453701106000664, 0.056928652041708494, 0.040402548848658126, 0.0600238750796932, 0.05858784919056215, 0.040078307308441974, 0.050530664002429004]}, "mutation_prompt": null}
{"id": "f14cec85-53eb-4282-8001-1e1997ece3ea", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.5:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Crossover and Mutation\" algorithm with probability 0.5 for crossover and mutation.", "configspace": "", "generation": 53, "fitness": 0.0823711542076186, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.07.", "error": "", "parent_id": "c81449fb-4ee7-40ab-b7fe-501e20acecd7", "metadata": {"aucs": [0.16621484821469312, 0.17029959972809683, 0.17241945426737315, 0.14401700858043187, 0.1424430044947339, 0.13787967373119503, 0.1626307078166045, 0.15815435028877167, 0.1548410952434286, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04358882245435802, 0.029820077689756364, 0.030917034661086418, 0.04378003760338456, 0.04597302764445432, 0.0370341096355471, 0.05154302273970934, 0.03058840599831769, 0.029915593833795717, 0.020340897917323297, 0.030234038195887103, 0.0383824102807786, 0.020434868234900927, 0.012767075458014143, 0.018227179196180998, 0.028845554189878553, 0.027715394909853974, 0.02424473487166634, 0.14407859319788674, 0.10546069932900248, 0.18908075287685888, 0.16222406232133524, 0.09374863972183989, 0.10893744676343864, 0.1322397768966863, 0.12227054085760158, 0.16646375400322633, 0.08061114384998946, 0.057814478711547546, 0.04822631567982372, 0.08010812591190608, 0.02703320430844547, 0.08481537631613723, 0.015636068874195552, 0.08265773558353118, 0.030515145323942172, 0.13175008845400715, 0.14147916377348924, 0.10510377609890242, 0.12249274479263916, 0.13621563545541737, 0.11662864363537084, 0.07732060114366557, 0.1115970973274556, 0.13383968328788742, 9.999999999998899e-05, 0.01230463759279532, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01382253088808938, 0.026286707932303255, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027041932653487644, 0.015894225513396143, 0.04878863280477763, 0.017749344162471203, 0.03421109485706497, 0.06638757887339597, 0.08960836461430777, 0.03411850919858894, 0.02097068551401371, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20031067799863245, 0.1685454754065986, 0.1705368491189907, 0.16659290656101078, 0.18553821343545618, 0.19010137790414583, 0.1797540012876505, 0.18857289352981854, 0.1738615176088153, 0.05627537078643785, 0.023765343968682684, 0.028286002740638416, 0.03787269389677117, 0.03024446333519537, 0.03809687858422528, 0.03561150311234795, 0.03453069559937627, 0.03545973280068282, 0.12800607477913128, 0.12191645468047485, 0.15676126039607174, 0.1365736236106131, 0.150956372769402, 0.11063850935991137, 0.1204478078732889, 0.13069741587106887, 0.14652967228776437, 0.14261355712406276, 0.15388307136865464, 0.1613932299901245, 0.1559235872580097, 0.18911867381510195, 0.15651022092453515, 0.15405273335592518, 0.17377774300845283, 0.15430771628643125, 0.08456453137836417, 0.10542460975376966, 0.1121706008624146, 0.11481959660899232, 0.12561331617076432, 0.1156831163906441, 0.09536402187613857, 0.10133004550018487, 0.0931171094811678, 0.1422781257565181, 0.16189275084436117, 0.14661696852064832, 0.17114015559048634, 0.14147221798858478, 0.17865425378410915, 0.14434244572456734, 0.1621591892634735, 0.15193071147041282, 0.15097940983751545, 0.10374912483636312, 0.04780838814241872, 0.1437063172081382, 0.1224669272756499, 0.15735388356015068, 0.15124678093667732, 0.13742178370667646, 0.10962626092983119, 0.11899261463554689, 0.1130286134924956, 0.12223943158026285, 0.14780554599387308, 0.12442994679996244, 0.1459137969080151, 0.1383639662718249, 0.15618062291845491, 0.1511809094329266, 0.11603297041674887, 0.10922433318369562, 0.16679849083825415, 0.14852280038080212, 0.2105284294286207, 0.11513398281673892, 0.11123420098544645, 0.16104597420354327, 0.13220932992187973, 0.1667179549811597, 0.1705647204836559, 0.18650125326298117, 0.20365691597058078, 0.17144100327899958, 0.17132591210308035, 0.19192037560705744, 0.18866377224332953, 0.18704489882811626, 0.04410347663632708, 0.04797997400352394, 0.03992314583631562, 0.03514922865953374, 0.055679757091852466, 0.04240597453262185, 0.04267779365559654, 0.04360245751033731, 0.059062201136791725]}, "mutation_prompt": null}
{"id": "1fb9d653-0dbf-4c14-b14f-dabbc5ee6947", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.5:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.5:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Crossover and Mutation\" algorithm with probability 0.5 for crossover, mutation, and crossover-mutation hybrid.", "configspace": "", "generation": 54, "fitness": 0.08942881119946204, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.09.", "error": "", "parent_id": "c81449fb-4ee7-40ab-b7fe-501e20acecd7", "metadata": {"aucs": [0.16220950741271167, 0.1409541500362842, 0.1488832122792323, 0.14675779656802856, 0.1453245303031836, 0.11706538507193331, 0.1833604503757733, 0.14268007605578747, 0.15806882518629572, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03301775886683722, 0.02180985099184307, 0.046252896590459724, 0.044047097790434586, 0.03828324509877634, 0.037614190312538986, 0.047803766256813596, 0.042210032971954914, 0.029744415822471115, 0.02073036893750746, 0.025926939993998865, 0.027111529617642738, 0.036112493740886875, 0.027097354573015542, 0.03226228821064836, 0.016226535558683808, 0.021805404540273465, 0.01889544823638767, 0.13544863684699326, 0.7743967362176503, 0.25904895041291043, 0.14315382117772335, 0.13285528144416692, 0.4561225592085866, 0.1610670729728132, 0.16859329706276271, 0.47678605217807135, 0.0769410036422854, 0.06480580374342593, 0.08300651227598588, 0.0863965612081834, 0.04651251270531265, 0.038149341515802404, 0.05001873991158878, 0.06562445217932378, 0.059270486052627525, 0.10707954837596012, 0.11784057858852359, 0.1181032921649443, 0.09288314327008429, 0.1358369043854405, 0.11524823823157226, 0.08230586339772905, 0.10979833805613637, 0.08843339203906775, 9.999999999998899e-05, 0.01321046649848412, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0039187991837449365, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034757218400458645, 0.034241030754691204, 0.021352429117455385, 0.043496671800485776, 0.038924047067623535, 0.02858663142275475, 0.05195645851368136, 0.05753981854563717, 0.12330305708251543, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17086938050124822, 0.1737264846408214, 0.2088011090104387, 0.2000802785468675, 0.15455432035057382, 0.1828378176989932, 0.18503217315318465, 0.2019442944421327, 0.16893755758114237, 0.040804150882122636, 0.02101446430216858, 0.03604384145341977, 0.03907511392469554, 0.03662278184507306, 0.047815868840615394, 0.034340604510551764, 0.03509517853167088, 0.03511765569766012, 0.14132706084419566, 0.1315743349437345, 0.1205733765315179, 0.1318167060634804, 0.12015230326380988, 0.126740111842797, 0.1580279654968264, 0.13723677437556614, 0.12237228634265795, 0.1409626563149422, 0.15664847796920567, 0.1625224945263255, 0.16094293042871521, 0.13864955073291352, 0.1911794582216022, 0.13841732086558167, 0.17377774300845283, 0.16097155581567846, 0.0859160397038724, 0.1348361415613557, 0.11488535842459291, 0.11945272921162575, 0.0941620606414657, 0.14010631668920437, 0.10604154312814085, 0.11096485757231989, 0.09145698218940468, 0.1597399607825386, 0.1265104482186442, 0.15486097987392367, 0.14458703614131774, 0.15372064950006337, 0.14172300118784786, 0.1533405215720024, 0.15083772576996524, 0.14595709192816353, 0.12193314832075752, 0.1327814027380244, 0.1358003371446681, 0.15573033036114325, 0.11315076541745528, 0.13058232336000142, 0.1292845610204888, 0.14002814514668138, 0.12569808846244346, 0.1621098990621449, 0.15689279126248368, 0.14270568830620067, 0.15336261393627448, 0.1612260916879832, 0.12708110313583676, 0.1315737313671227, 0.1645722672886597, 0.1502478959878274, 0.12414153413440909, 0.1790340742757739, 0.15411125394177239, 0.14117952842552295, 0.12277074104076091, 0.1409700648458967, 0.17660336344575422, 0.09653893061825425, 0.14082535575544575, 0.17121462809402088, 0.17084673018251328, 0.17136290196808368, 0.17429765814035514, 0.17451638223820232, 0.16638971941429626, 0.16781376469889897, 0.17196103131308427, 0.193437002252691, 0.056990338698566845, 0.04475828122004255, 0.04536518666891243, 0.04092486079943847, 0.04287263676974529, 0.05407757971501015, 0.040937167831713306, 0.04936904998334213, 0.038377341953656496]}, "mutation_prompt": null}
{"id": "70afa8c2-0102-483b-bb8f-463880a9a567", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.5:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.5:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)\n", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover and Mutation\" algorithm.", "configspace": "", "generation": 55, "fitness": 0.08368086172680021, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.07.", "error": "", "parent_id": "1fb9d653-0dbf-4c14-b14f-dabbc5ee6947", "metadata": {"aucs": [0.16114112298650796, 0.18739460577443212, 0.12319290973074293, 0.13435033054171197, 0.1710302251892113, 0.1534778084877937, 0.15580586949587139, 0.14808038408310054, 0.12702378757007826, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048597983018170865, 0.042488342220556086, 0.04326190157810672, 0.059039657135782186, 0.04024642008844059, 0.03808491404043357, 0.04355366182228004, 0.03188842822470883, 0.03404947680251702, 0.05523337652134974, 0.019901292857631425, 0.025941516431663647, 0.025200038770408772, 0.02374295369951329, 0.017824179991808853, 0.030800620750077168, 0.018308826541604817, 0.012904000735421639, 0.11714954939948752, 0.1302525542353018, 0.2341719308821233, 0.12271257547164771, 0.1302572250227899, 0.11273760296645652, 0.11071969332727116, 0.17076832374850492, 0.1737187739919489, 0.08812411167812517, 0.07744559410410745, 0.055078043658927656, 0.05176270911180014, 0.04672166271304745, 0.0851425858365954, 0.11300486928553533, 0.10847262434353255, 0.09927799002532844, 0.12706107737552663, 0.1418136979150042, 0.1012792082414542, 0.1005505932339602, 0.13401059507306268, 0.09870275230947356, 0.09865506230786358, 0.11128485743355854, 0.09114074949446627, 0.002741465805468968, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001837295557812646, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002174421229607093, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006237642844867164, 0.061023806092711075, 9.999999999998899e-05, 0.03912672343550805, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.041821734686205314, 0.017001446039241475, 0.07483457349255351, 0.024028608277327668, 0.03000079816614576, 0.04061676625414512, 0.09191030564154012, 0.03656245916425527, 0.02039839849729852, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18825491066501676, 0.15948415422552753, 0.20078003981577097, 0.18896776248844238, 0.17762500142146087, 0.20761540970286674, 0.1871945941244607, 0.17465896398951486, 0.17132109156115216, 0.03529125770857933, 0.044978685616707814, 0.03793373719717441, 0.03798481179443591, 0.04045487412172255, 0.0549718342325648, 0.05484923167438649, 0.02773663267336235, 0.0518579666740816, 0.13936624868667746, 0.1482898000640418, 0.12237122362431507, 0.1411554930892598, 0.1468780300440392, 0.15537168451860162, 0.14645596338170386, 0.13641048805258904, 0.14167185303309437, 0.1359178257624446, 0.1574891081031523, 0.1613932299901245, 0.16110189968408362, 0.14288742694956003, 0.15124662879262118, 0.1618195956851377, 0.17377774300845283, 0.16446545963682768, 0.0917640646939204, 0.09549801193648999, 0.09676100550227673, 0.10313700431573558, 0.08370235847690133, 0.12083760729685378, 0.11057352379694696, 0.12608735799194204, 0.09775927491936998, 0.16131101197160347, 0.14998610892922892, 0.14685219389007775, 0.162722216226851, 0.16463053072881884, 0.14212660621904338, 0.14650091009752342, 0.14173448211454398, 0.14137431862813976, 0.13594356348137937, 0.05630425023916652, 0.14703948491777463, 0.14118487048046968, 0.14099566990396672, 0.13325784112411787, 0.12167392536560673, 0.11942886924534102, 0.14558788795597843, 0.12409148900588929, 0.134431936094342, 0.125809923686243, 0.1589716907556218, 0.19298288459137636, 0.13993818631606936, 0.1355232178958371, 0.13698288467484598, 0.16441036497341033, 0.12111695386047217, 0.13307523719731507, 0.1092943585300793, 0.11311458543229769, 0.11074702246405599, 0.15951319138170783, 0.1049161301030126, 0.09867635214251547, 0.11922835296074519, 0.17540827922390967, 0.16978353472597663, 0.1704434411932767, 0.183922569803331, 0.1780302618951164, 0.1768941458932657, 0.1799895843714474, 0.18438098595041474, 0.18460378704931724, 0.04731587340190324, 0.059711956321992, 0.05196766539212605, 0.03977609983406927, 0.05471782658491442, 0.04525854569871679, 0.04738836782534617, 0.04782075622717563, 0.04228096293181682]}, "mutation_prompt": null}
{"id": "a492e6d3-7c3b-4d36-8335-9e072780063d", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.adaptive_crossover_probability = 0.5\n        self.adaptive_mutation_probability = 0.5\n        self.adaptive_crossover_mutation_probability = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.adaptive_crossover_probability:\n                    # Adaptive Crossover\n                    if random.random() < 0.5:\n                        new_particle = np.copy(particle)\n                        for j in range(self.dim):\n                            if random.random() < 0.5:\n                                new_particle[j] += np.random.uniform(-1, 1)\n                        self.particles[i] = new_particle\n                    elif random.random() < 0.5:\n                        new_particle = np.copy(particle)\n                        for j in range(self.dim):\n                            if random.random() < 0.5:\n                                new_particle[j] -= np.random.uniform(1, 1)\n                        self.particles[i] = new_particle\n\n                if random.random() < self.adaptive_mutation_probability:\n                    # Adaptive Mutation\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.adaptive_crossover_mutation_probability:\n                    # Adaptive Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    if random.random() < 0.5:\n                        new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)\n", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Hybridization\"", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"cannot access local variable 'j' where it is not associated with a value\").", "error": "UnboundLocalError(\"cannot access local variable 'j' where it is not associated with a value\")", "parent_id": "1fb9d653-0dbf-4c14-b14f-dabbc5ee6947", "metadata": {}, "mutation_prompt": null}
{"id": "283747dd-ad68-4fe5-9178-8e1c510f7f40", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.5:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.5:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Crossover and Mutation\" algorithm with probability 0.5 for crossover, mutation, and crossover-mutation hybrid.", "configspace": "", "generation": 57, "fitness": 0.08643393121730424, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": "1fb9d653-0dbf-4c14-b14f-dabbc5ee6947", "metadata": {"aucs": [0.16487962839481118, 0.1479458444013333, 0.15482047380948638, 0.1391583880265682, 0.136784457142483, 0.1427897010402277, 0.2022904294493314, 0.23484664322950943, 0.14319057213289166, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04595491319907108, 0.03453867682592304, 0.04150083760119472, 0.031336673698793116, 0.04086428299745293, 0.05860154246679816, 0.05870275726808538, 0.04001837430392696, 0.041516405608164164, 0.01622476927397931, 0.020578140136007228, 0.031481725168901575, 0.056111941766238904, 0.04281736283696991, 0.026275762247643386, 0.05176416323153332, 0.018545806836466894, 0.01695306755519943, 0.1051985246144197, 0.5444079966230626, 0.12628385342755033, 0.15001573570315052, 0.11858744224250872, 0.1224208923848159, 0.10708917334577128, 0.12044289462161961, 0.15263501282461056, 0.08467658650126764, 0.06413057372822573, 0.05529398307712474, 0.056369022068398555, 0.05905232698721852, 0.06030606790016424, 0.04231222286878311, 0.060859371628847136, 0.05725084296781546, 0.10793975357785401, 0.09998775664010007, 0.1512815627274997, 0.09462885246197417, 0.1239929024220211, 0.11184853522467475, 0.08812863622431066, 0.1165897525099201, 0.09149413607082646, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06217402250534687, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022361784440714794, 0.0328600993857503, 0.053824388957069313, 0.03904358617674064, 0.055618482925460566, 0.07627109954027578, 0.09040369681152793, 0.024848034403676666, 0.02966735389533659, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.210194146434188, 0.18662359130959594, 0.22737100230353813, 0.16726593763329112, 0.1785813071344643, 0.15171297188075006, 0.18288916089774898, 0.1818730966501083, 0.1769326981815209, 0.03498376116272772, 0.058551289993945876, 0.0367022539828471, 0.04315591574205624, 0.04573921583540996, 0.03534856993430002, 0.05365691613912882, 0.059613556113492505, 0.06444016303071731, 0.1381090458092007, 0.11997948982193574, 0.1399375040984152, 0.18502351620309287, 0.13680726890236672, 0.12557671762500355, 0.15070803075216077, 0.120205529031996, 0.14025182144436898, 0.14742832980050258, 0.1508251913003773, 0.1693977247857369, 0.17291168487199482, 0.16403668323532639, 0.15204009952234177, 0.14455990403433205, 0.17377774300845283, 0.15103464327305516, 0.10274772301872126, 0.09229388883197953, 0.09530138881909078, 0.09953171564785812, 0.09807018813279755, 0.09525848943603854, 0.09734193559543514, 0.0997711199450243, 0.08753066820366062, 0.15231894403807344, 0.13309282762577535, 0.15224936277377987, 0.17470701490058038, 0.17303518586586164, 0.141271382368078, 0.15215122453985097, 0.1593886761491804, 0.15215484754351216, 0.1475188390907406, 0.14416945780158907, 0.094630046066015, 0.14198954278645892, 0.12970029044841613, 0.15925957412063474, 0.15137083675563767, 0.0986585943089312, 0.1298594260848922, 0.14140790029141714, 0.14676466664093002, 0.15530492309251676, 0.1467892605432327, 0.16682359580903994, 0.1456304102021726, 0.2202222762898205, 0.13604553779263295, 0.16336897306936227, 0.1243338139219613, 0.1191991145005008, 0.15873505768680185, 0.1364201032799649, 0.16424730786740926, 0.15780441620028363, 0.12792513708513908, 0.12144695124274874, 0.14641583505936429, 0.17703155219003497, 0.17629228096707994, 0.17209512634208568, 0.18338432758177636, 0.1719670551873803, 0.18098109215120672, 0.17872800307133496, 0.19224357096563027, 0.18047180803167362, 0.054115386179839464, 0.051544157045898986, 0.0430298436653036, 0.04362778188999272, 0.03707708815170896, 0.046960290615146505, 0.050756110638731866, 0.05977165020408248, 0.051056763638976044]}, "mutation_prompt": null}
{"id": "5581cb2f-42b3-4b7d-95ab-300a5218aac0", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.adaptive_crossover = 0.5\n        self.adaptive_mutation = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < self.adaptive_crossover:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < self.adaptive_crossover:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover and Mutation\" algorithm", "configspace": "", "generation": 58, "fitness": 0.08649134385281514, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.08.", "error": "", "parent_id": "1fb9d653-0dbf-4c14-b14f-dabbc5ee6947", "metadata": {"aucs": [0.18345609332766, 0.14752612515839136, 0.1461209794301922, 0.13169812489607935, 0.15604613923514044, 0.1370907238456428, 0.16712762886074783, 0.14958487400723175, 0.15670466306157538, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03444381635531313, 0.03770847436525915, 0.042274274185445604, 0.04217710617260584, 0.054710989208462846, 0.03405896259437535, 0.03712267130893854, 0.04177023737524854, 0.029187678621921065, 0.029225322225840733, 0.012508773932115802, 0.03499843728783747, 0.030642185128200383, 0.028372461950154526, 0.02312653790686836, 0.034452990476691925, 0.02354659298865769, 0.018892967023593554, 0.6847871288965167, 0.11501532582807517, 0.1903849545238684, 0.1264202574547607, 0.11374559231160586, 0.12476677684016413, 0.13224230112705393, 0.13488382980238367, 0.19270027846647075, 0.06274794416174423, 0.04468733729022878, 0.06592567911949887, 0.09573895255016052, 0.0387443306060512, 0.05550168815294565, 0.06255593100965873, 0.03485314580181931, 0.05272338821824474, 0.11693023991087248, 0.10783755199066913, 0.1173016045129831, 0.12613948424195764, 0.10912039763463599, 0.09729208058156114, 0.07123648388702153, 0.11560408914212772, 0.17229279566757671, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004031846299145769, 0.0095038518016074, 0.017629799788289935, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011298322478927592, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03349093508626888, 0.035273647480828396, 0.04259265693734049, 0.017785272027388777, 0.0791898753705933, 0.02332202346608614, 0.031487372676252234, 0.009611508240567113, 0.1483231597571938, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.23568174941522513, 0.2027891759345256, 0.18080596062998067, 0.17552687976406522, 0.1628077480949507, 0.1627296435554637, 0.18958674203629167, 0.2116514323630928, 0.167018454635391, 0.032049019820880265, 0.035901700900617506, 0.033909312252326296, 0.04254537799686531, 0.03104401112290689, 0.04857382850897063, 0.03544766340800454, 0.03420968895959564, 0.03269960888405532, 0.11350960588720449, 0.1510787000605175, 0.14434359561461096, 0.13421211277783718, 0.13112822831993487, 0.13899820656634, 0.14640692910388753, 0.1089624554438482, 0.10256615830976845, 0.1677310368678443, 0.15524259214557168, 0.1613932299901245, 0.18624070115195757, 0.14349256254779064, 0.15646768543891543, 0.1470380447903772, 0.17377774300845283, 0.15143924310956414, 0.11624257746093025, 0.09643007546571847, 0.08907669406395613, 0.09968681815748315, 0.08590416489091546, 0.11879102031776256, 0.12330933557254631, 0.11260692926968352, 0.09620907918025334, 0.15248776743295167, 0.1354999776097482, 0.13565990134314376, 0.17632889521121375, 0.19805764454837438, 0.14642687296720847, 0.14581162969860506, 0.2046944612030157, 0.15190251612412398, 0.15711254339434655, 0.13607742270220313, 0.14655348975883098, 0.10124236174700896, 0.10733768091162055, 0.11054745718293912, 0.11397510372012509, 0.13532331397794317, 0.14825885649092396, 0.14282352022511735, 0.11656845089340873, 0.11491892653594427, 0.13653426961387904, 0.19552009636657786, 0.15236912866837593, 0.1545305633089321, 0.149603127328104, 0.15822780293975625, 0.11282416012617325, 0.15058052294518043, 0.1461752112230219, 0.14231663902252278, 0.11734815782667452, 0.1480210739071488, 0.13282918596074034, 0.20078283614958214, 0.15449929283106667, 0.19138095007636846, 0.17426148827524324, 0.17186211567246723, 0.18508074741636804, 0.1814476446012524, 0.1753463898292208, 0.18471683963212338, 0.16874306077493262, 0.18176324579186942, 0.05937371794419399, 0.037513685013223386, 0.074113472747661, 0.049218871492090144, 0.04156553613868785, 0.05441514174161899, 0.05633008782335058, 0.03803354422653826, 0.06463367524598629]}, "mutation_prompt": null}
{"id": "a375f3cc-569b-449f-8d8d-60290e0ecded", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.crossover_adaptive = 0.5\n        self.mutation_adaptive = 0.5\n        self.hybridization_adaptive = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < self.crossover_adaptive:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < self.crossover_adaptive:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Hybridization\" algorithm", "configspace": "", "generation": 59, "fitness": 0.08546642823616662, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": "1fb9d653-0dbf-4c14-b14f-dabbc5ee6947", "metadata": {"aucs": [0.15958186630820204, 0.12193530608362302, 0.16527133966154472, 0.1370820005845157, 0.17664843756263326, 0.18443430206857014, 0.15980455919076597, 0.13177738981314524, 0.1346098344447748, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029818742059116277, 0.05980666654301148, 0.03982112615920086, 0.0688865255060257, 0.026269569673464832, 0.04116968484483363, 0.058891964203527825, 0.05432105229782824, 0.04676512949962652, 0.04296699388520486, 0.007003171269897246, 0.029649882009505912, 0.03502552818585447, 0.020388938447736815, 0.029971622559263, 0.032262904849517104, 0.06206355827127541, 0.028678297514570072, 0.10660787055946241, 0.11752890923314285, 0.10045758335442001, 0.13827563936628307, 0.18592691142134876, 0.3008159178282487, 0.1572496037139003, 0.17087495700559263, 0.2577457435566285, 0.10534419018653607, 0.03494407048809156, 0.06016860276100089, 0.061908360059066414, 0.08566539619948221, 0.05851825723065052, 0.0679260724499402, 0.0563955569737411, 0.0657880961629782, 0.1437291243165162, 0.13850576785239732, 0.12160498430187383, 0.11371526018877742, 0.10080829392936252, 0.14585268326396494, 0.08944966915059815, 0.09206952547416292, 0.12641876366322102, 9.999999999998899e-05, 0.003402835665644144, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00539717523786909, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002333197154058886, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03120001433710473, 0.018844543024133964, 0.07027474129102662, 0.043506559234474995, 0.05565193378705535, 0.023099061683697464, 0.022980398021948845, 0.014300695385816131, 0.06085975824698431, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00013814263382005976, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17689904020862646, 0.1729357705789767, 0.17463954129121417, 0.16138250135828514, 0.19933690187133557, 0.18682823379857294, 0.18276987599767713, 0.19567560613986823, 0.17035398478335317, 0.025560578532666245, 0.026305767236550648, 0.030410310550928243, 0.034196534993399474, 0.0591623612623664, 0.03510487183002842, 0.042605903041018967, 0.029658036855875758, 0.052858267886405685, 0.18515951307293166, 0.15509285351267754, 0.14643078830029355, 0.11065771050058049, 0.16335088868378755, 0.11917733083434301, 0.11286758904533656, 0.16878606612680613, 0.14095350832288822, 0.14445414004915746, 0.17451929656396825, 0.1613932299901245, 0.15622814265015694, 0.14270300845536554, 0.1855880032636753, 0.14438479136263482, 0.17377774300845283, 0.1862830062258498, 0.09102983171161538, 0.08965030833676679, 0.13057433635651938, 0.09868370018027994, 0.10722327652844887, 0.10568530950530275, 0.09897052156559549, 0.10695428689602826, 0.09927274936860864, 0.1539396724760601, 0.15184971233694833, 0.1562223220600898, 0.16921852166661777, 0.14258424093245736, 0.16742767860429264, 0.14963688018288468, 0.1368557134409828, 0.13216315896931485, 0.1622161635023256, 0.11355956355376018, 0.14564542048646856, 0.1540379844199269, 0.1273028347875017, 0.13465162796334373, 0.14287304590340633, 0.13274996034782016, 0.12858007593323506, 0.1646318162926702, 0.12061501663256058, 0.16769069704692174, 0.15385567388528487, 0.15927256854536187, 0.147955595381969, 0.13885002092310583, 0.16475738784646987, 0.1348878025589062, 0.12369725253121833, 0.11759382075807967, 0.11073295661246507, 0.1113166505904375, 0.12592337898920447, 0.12353304186965175, 0.10317125683490336, 0.21859667399718985, 0.12372146467944167, 0.16340823532441606, 0.18442735022728707, 0.17590082586057065, 0.18677564221704257, 0.17170348856240358, 0.1645809361446633, 0.17591335209003334, 0.21129045447265216, 0.18549181155378514, 0.05742321907360404, 0.04820533072038102, 0.039748024377755375, 0.04600969038519509, 0.042495048914902744, 0.0484559889919155, 0.061048822623742116, 0.0403685514115919, 0.04245679398916946]}, "mutation_prompt": null}
{"id": "0a2d4034-262f-4666-9547-cea9db402453", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.adaptive_crossover_probability = 0.5\n        self.adaptive_mutation_probability = 0.5\n        self.adaptive_crossover_mutation_probability = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < self.adaptive_crossover_probability:\n                            if random.random() < 0.5:\n                                new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < self.adaptive_crossover_mutation_probability:\n                            if random.random() < 0.5:\n                                new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)\n", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Hybrid\" algorithm", "configspace": "", "generation": 60, "fitness": 0.08426233834277869, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.07.", "error": "", "parent_id": "1fb9d653-0dbf-4c14-b14f-dabbc5ee6947", "metadata": {"aucs": [0.18519565802251947, 0.14482652176691702, 0.14603690777236356, 0.14648625276922833, 0.16543217292918622, 0.12780062791946856, 0.13746556483684058, 0.15834956888760987, 0.11748491831505359, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04869795245065256, 0.03756619786887172, 0.03461507460502211, 0.05952314338174425, 0.05427654251837721, 0.03662683450071236, 0.041079972477146676, 0.027857327138033572, 0.038972228314764434, 0.0363384879391897, 0.04319495729880496, 0.044072676285234036, 0.026287793490922362, 0.02620189021762076, 0.022968534724093104, 0.03874325985427007, 0.024516010890965334, 0.03402491191883239, 0.13392888658818958, 0.13998993379569713, 0.10864734695704359, 0.11519845907164927, 0.2711400271882195, 0.18360783802844638, 0.13279465972740745, 0.11157100414702892, 0.10624040041432725, 0.06664389499480328, 0.054075058039288915, 0.08348217822007098, 0.06434833808001017, 0.06663310835751635, 0.10172588820732964, 0.053098328781661985, 0.10325417229570744, 0.05168020501758597, 0.12599687607537347, 0.09664969459940442, 0.11029970624092345, 0.13088802606956818, 0.16775626542410715, 0.10915360472249891, 0.07758491925034028, 0.14753300124511248, 0.11873709649483866, 0.01267396825946876, 9.999999999998899e-05, 0.011670968861305697, 9.999999999998899e-05, 0.005294715230409697, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009103889654851427, 9.999999999998899e-05, 9.999999999998899e-05, 0.006734206756188188, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.038592215882871095, 0.014184206810960331, 0.04430687450315196, 0.04496432273322548, 0.04922758911552305, 0.03198091671941672, 0.03359386955516386, 0.03392973132324606, 0.09695491761852992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.19288150967929207, 0.18742690355709057, 0.20154762642817403, 0.17288235821903197, 0.16174202037576701, 0.23294948846390795, 0.18957910119516774, 0.18774435476199236, 0.17168635412662403, 0.03477381898721965, 0.036529090775053175, 0.029635411861770655, 0.04000157453620323, 0.04771911092918568, 0.04582149143402914, 0.040603182506106505, 0.03225983545806543, 0.07144516152557079, 0.12587328798870767, 0.1442602713143184, 0.12285104521508161, 0.13806482080255011, 0.14909617047445067, 0.12286149983132422, 0.1563638434251161, 0.1537224977107624, 0.15929491316785482, 0.1627502208158712, 0.17178342850759598, 0.17072277760531251, 0.15304381915056164, 0.14762451755265416, 0.1852784050304106, 0.15400206925618531, 0.17391175488559474, 0.15465034944564837, 0.09203363267238307, 0.11147632743174185, 0.09329286623921473, 0.09843753046694159, 0.08368844086634653, 0.09439255132125746, 0.08442085625167073, 0.10032113492502426, 0.10766923499250047, 0.17237845307802546, 0.14479645342251057, 0.1348549952673156, 0.13736602544532284, 0.1654051783611059, 0.15497573608047766, 0.1494191701420754, 0.13305784138019194, 0.1365920591130867, 0.1408665869031287, 0.05263614098570013, 0.12452519897727088, 0.15489195520049692, 0.10292067999674748, 0.12215399609665512, 0.09652844937603366, 0.10237053274831975, 0.129835985625397, 0.1462701294640858, 0.1336373286064505, 0.1433950218047617, 0.13946263306215168, 0.1500300719201807, 0.15547240991296152, 0.1527387048392448, 0.1456641415403377, 0.1506995199504496, 0.16599709538434815, 0.1517247084190647, 0.13405322741183812, 0.1252147310223023, 0.14946083367279206, 0.1595304033966619, 0.17900611855998672, 0.11096383526678033, 0.14655689560797414, 0.17116248930619438, 0.17322212188727737, 0.17148017270494387, 0.16819377863569973, 0.17304848757390356, 0.1679602040171052, 0.19621085746428013, 0.17867695117662918, 0.18335360805367829, 0.05751488305896868, 0.043159782004261404, 0.06398404190965301, 0.03770884530618224, 0.049450239013824615, 0.04170009554290954, 0.0730804202519576, 0.04853378245956286, 0.042241111310687085]}, "mutation_prompt": null}
{"id": "6404940e-03ec-496c-9d89-c4f5d8537204", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Adaptive crossover\n                    if random.random() < 0.5:\n                        new_particle = np.copy(particle)\n                        for j in range(self.dim):\n                            if random.random() < 0.5:\n                                new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.5:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover and Mutation\" algorithm", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"cannot access local variable 'new_particle' where it is not associated with a value\").", "error": "UnboundLocalError(\"cannot access local variable 'new_particle' where it is not associated with a value\")", "parent_id": "1fb9d653-0dbf-4c14-b14f-dabbc5ee6947", "metadata": {}, "mutation_prompt": null}
{"id": "584cdcee-398c-45ec-9dd1-d81e3d44f23d", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.5:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.5:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Crossover and Mutation\" algorithm with probability 0.5 for crossover, mutation, and crossover-mutation hybrid.", "configspace": "", "generation": 62, "fitness": 0.08396484261270674, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.07.", "error": "", "parent_id": "1fb9d653-0dbf-4c14-b14f-dabbc5ee6947", "metadata": {"aucs": [0.17481234314995509, 0.1728141180856757, 0.15906918434739603, 0.15159720559454415, 0.1363737249060596, 0.1766011929042437, 0.1390922837865748, 0.13972784756249623, 0.13209598454144433, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03421088990074317, 0.029262234526996833, 0.07068045236697851, 0.02805270956431527, 0.0355513692264251, 0.03846357469210271, 0.04427315644507146, 0.032406763422241025, 0.03360179532036378, 0.028797873511319794, 0.02187941126901427, 0.027211455079088065, 0.026830759922955583, 0.02933439334549881, 0.023470620004172216, 0.026676257714158602, 0.028218224447790652, 0.0469271906883969, 0.11010478579192495, 0.3314265456448572, 0.10849804527615092, 0.3857652821370081, 0.1263730272815643, 0.16058777770676336, 0.12692836439160493, 0.13116603552386275, 0.12327696107514619, 0.06274794416174423, 0.054852958228076565, 0.060979179503734326, 0.05937120152288555, 0.05878877110004488, 0.05060118753436382, 0.02898653003564744, 0.035934984808098536, 0.05296864832427384, 0.1396871295752128, 0.08438339391655458, 0.1267687285134178, 0.12017677798159443, 0.08803739817404044, 0.15546272108884474, 0.11540310438897083, 0.1052295512266248, 0.12665982318338687, 9.999999999998899e-05, 0.016432836780331805, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014416287372216452, 9.999999999998899e-05, 0.006648155633802499, 0.0015340498566515093, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05613955840264262, 0.03493024099886788, 0.062297195609788636, 0.04029097854157482, 0.04482038320435766, 0.01184330349175522, 0.013420460685941715, 0.04263210148218055, 0.04956142121370577, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005304284147575666, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005383673684118406, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20167331000274558, 0.1627325507032319, 0.17427134289910295, 0.15638665090106296, 0.16791286786565995, 0.19028608329427732, 0.20206628776010205, 0.19689880163228113, 0.16365846368233794, 0.03778853918453662, 0.03931647459655163, 0.041418320282311294, 0.04367801327227805, 0.03009384950126681, 0.03384808599532496, 0.041035724311379806, 0.039203531431240335, 0.03152198192911104, 0.13779030217373545, 0.11556378318526517, 0.12633175055139545, 0.1188570644085366, 0.1140193428496532, 0.13122834123151494, 0.15150257867762518, 0.14212865885030845, 0.1127282573800168, 0.15361736007703808, 0.1465805188062519, 0.16614819585115204, 0.1563321815649611, 0.1481668566841341, 0.15670739269560707, 0.15589377347200972, 0.17377774300845283, 0.18090198643532207, 0.10108434939422017, 0.11058978228606153, 0.09497786422978638, 0.08857035135430746, 0.0826366366178729, 0.09556851135096045, 0.09188018717246194, 0.0997711199450243, 0.11003991991476492, 0.1909503137903601, 0.1332192515313766, 0.14926319779756125, 0.1459936469152593, 0.13472296494087754, 0.16036965448763407, 0.13843855101284408, 0.1448876951996113, 0.14296249123943394, 0.13768450347747552, 0.1335228586655478, 0.1381043478570535, 0.14941041003192546, 0.14027217865219865, 0.10230963536375237, 0.16187113131032382, 0.13432731742090886, 0.12629861107687834, 0.1544987105458937, 0.16690617025827337, 0.15532747347326126, 0.11541156671189168, 0.16574113770881582, 0.12170749654262059, 0.13115685009950517, 0.1510026202335082, 0.1281340459706577, 0.1611661025176767, 0.154762367193385, 0.109310812842499, 0.18192239900793883, 0.11026226536966299, 0.1485788052459731, 0.11715820053854042, 0.14956751240834543, 0.12872838734908187, 0.18795406137527038, 0.17283789412004902, 0.21547685241122783, 0.1778576089396935, 0.17069810885534098, 0.17926807314527393, 0.19485885554080884, 0.16611359614684318, 0.18548871861559135, 0.047538558404116915, 0.04249816149157726, 0.041164297812663064, 0.056674019970264444, 0.04422628947511276, 0.05979251650704298, 0.049115099500208426, 0.05281694931468339, 0.047054127939865076]}, "mutation_prompt": null}
{"id": "a4dd6a3d-dab4-4efe-b9e6-75a618b9f4f0", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.5:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.5:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Crossover and Mutation\" algorithm with probability 0.5 for crossover, mutation, and crossover-mutation hybrid.", "configspace": "", "generation": 63, "fitness": 0.08682938252497145, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.08.", "error": "", "parent_id": "1fb9d653-0dbf-4c14-b14f-dabbc5ee6947", "metadata": {"aucs": [0.17757826424357082, 0.1371667302234597, 0.15126227342539955, 0.19170880681125768, 0.16782343235368813, 0.11798694567367096, 0.15256125969283618, 0.15824084353656676, 0.12698682666166317, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.041752956965174004, 0.041726710685915935, 0.04486472830868915, 0.04620095367474264, 0.03500825365203053, 0.03575878224653295, 0.049997149682055486, 0.039425047377580236, 0.032110970193455435, 0.024406454926224286, 0.03824790210284523, 0.02706943741617307, 0.0280753495834537, 0.01814066573587969, 0.03460692120321496, 0.024620797621150436, 0.03542166193141749, 0.03248939233265824, 0.11995032354972957, 0.10001972033867879, 0.13784875333875968, 0.1308321386617205, 0.2808652370173862, 0.1280039192516681, 0.20362442816912507, 0.5137403152935521, 0.22696965501208344, 0.07471812538799472, 0.04929086291028417, 0.06547891547540041, 0.07342251109709574, 0.05061169706940438, 0.03535761057356701, 0.05344885200413152, 0.07784520991654376, 0.08062480172135789, 0.10027683525177622, 0.15552643718431047, 0.1353690332539088, 0.11721412544314957, 0.08783365203444171, 0.10078205469844581, 0.08483601316585776, 0.09213001875786775, 0.12151495541143598, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009278711494190461, 9.999999999998899e-05, 0.0006747544785937754, 9.999999999998899e-05, 9.999999999998899e-05, 0.00632559611075123, 9.999999999998899e-05, 0.007694950390585431, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01808298433273925, 0.0799392835990691, 0.01222467099597413, 0.02592500665745434, 0.026013814989400807, 0.014215409596184503, 0.04645088413941523, 0.022657952214985788, 0.09845313987148696, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17950828858238022, 0.16808857735799287, 0.17940872624414117, 0.18435411024773607, 0.1907987468470561, 0.17048174871468202, 0.1968240633063355, 0.17790627672851023, 0.18721038516771626, 0.03307788508242371, 0.038974937083175454, 0.058977805605304856, 0.05863349370826931, 0.035905663725059433, 0.038342090666258044, 0.038922134573858735, 0.04452389763714382, 0.0312511457650273, 0.11306565273073788, 0.1467276436531716, 0.12722097427414303, 0.12104429027358876, 0.1359546369650536, 0.11867912417966797, 0.13030956407808825, 0.13034509588892218, 0.1308209570436788, 0.17772836909803214, 0.16615196836011092, 0.1613932299901245, 0.16348364525376125, 0.1415735646716958, 0.1553880456439578, 0.18992970290290834, 0.18269228816219607, 0.1632170843752616, 0.09304055595652605, 0.0955470921287106, 0.11098210194381186, 0.11407787187632035, 0.09897541166605084, 0.09172526497299549, 0.1073038950734625, 0.0997711199450243, 0.10149217740311323, 0.15208826683177246, 0.13976397627304016, 0.15873579940865346, 0.17414586177929126, 0.15038285970161702, 0.14977230826434973, 0.22411247126739542, 0.16301806855451673, 0.15471086565016445, 0.15657480357906328, 0.09189906731574704, 0.11012001719282594, 0.13927776551160442, 0.1270813569260436, 0.14096950303343236, 0.14671831526409496, 0.14727444876684037, 0.13249267179936164, 0.2099905664031697, 0.12894066014582772, 0.15949395307963932, 0.15572279764825636, 0.15127429904077794, 0.170333572553522, 0.15058405794894603, 0.11976117315869328, 0.12159226333684858, 0.12615012261126013, 0.15281609869541812, 0.1062000426079529, 0.1662155977253189, 0.1423592056065126, 0.14342468652847706, 0.1442704796311609, 0.2031721121034481, 0.10868011634660657, 0.19863430416049055, 0.18909795359890536, 0.17763529836133019, 0.17675556239679413, 0.19262490196252258, 0.17346092819957992, 0.17455974736977353, 0.17245448360484184, 0.1844647851697787, 0.04370327721568623, 0.04490481894724563, 0.049094182305154166, 0.04774173927220615, 0.03864757473603875, 0.04735142431320094, 0.052247607648754246, 0.057227018114969, 0.05027660104891096]}, "mutation_prompt": null}
{"id": "236afed0-b534-4de6-8658-918254d985db", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.5:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.5:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Crossover and Mutation\" algorithm with probability 0.5 for crossover, mutation, and crossover-mutation hybrid.", "configspace": "", "generation": 64, "fitness": 0.08828666441810372, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.08.", "error": "", "parent_id": "1fb9d653-0dbf-4c14-b14f-dabbc5ee6947", "metadata": {"aucs": [0.15788503324837655, 0.16961082618097412, 0.15985991744199124, 0.14614629612347796, 0.17969802598509854, 0.13479411135779829, 0.17943906106005902, 0.18669439409404298, 0.14377694026297394, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03201347254217013, 0.03523666630496847, 0.03730663335771589, 0.03711099216285385, 0.06926048887102021, 0.03082751753563151, 0.05451638259332903, 0.0425070342063254, 0.04051366524855149, 0.019264625299871274, 0.014291602284380311, 0.03092683541159491, 0.02634017049220272, 0.027275024441280604, 0.032783237747949556, 0.023184075260487824, 0.028415756374361445, 0.0247481879383602, 0.10918998429403781, 0.26535936266363946, 0.6531390990410877, 0.1016060192753988, 0.13262653416505943, 0.29252227500795047, 0.4734738123064792, 0.13807072960020395, 0.12251903811831766, 0.06274794416174423, 0.09661031498217021, 0.07519301886246998, 0.05731581154789833, 0.034659681858050906, 0.044388100654843, 0.038114962405071506, 0.07652912676416923, 0.024825534844803432, 0.10676013368508463, 0.11692140971210052, 0.08911485674465114, 0.1325353778232451, 0.12374167564092553, 0.09334480897023423, 0.10981928522241236, 0.08496533687057528, 0.09968089633128241, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01431431675665773, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01197182587159551, 9.999999999998899e-05, 9.999999999998899e-05, 0.007652160472200964, 0.011461445696947847, 9.999999999998899e-05, 0.021960498421270347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01999084441989485, 0.03783660015496537, 0.06926737770857994, 0.12182146867632004, 0.026746512152319712, 0.019594887956637108, 0.07395385953378153, 0.028283357186415392, 0.03347278855022018, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17239239293227693, 0.17754727271424053, 0.17519671178724672, 0.16496364651041462, 0.16007505939289624, 0.18641836339983142, 0.20128516120837847, 0.15280844624076528, 0.2077368913788753, 0.03369880763955657, 0.02771341138385197, 0.02705682304757351, 0.04863234642880976, 0.045027192598638965, 0.042782121007982954, 0.04272363900462184, 0.039352010477282984, 0.031490099953259465, 0.12545392475210992, 0.13387076825112199, 0.1376226763522851, 0.12243080389985683, 0.12351382972667102, 0.1626072954277341, 0.14094518659241317, 0.1354143020839247, 0.12414105374437856, 0.14235261661515564, 0.15544109851600585, 0.18143490062552659, 0.16664284107952987, 0.1858325872927824, 0.15192179265250838, 0.1727177205267486, 0.17377774300845283, 0.15539275971871136, 0.09560812299214116, 0.1058401943599161, 0.09768437754814896, 0.11393635778525313, 0.0956732657356213, 0.08957380594049502, 0.11672054173372504, 0.11288547263203108, 0.0986160395315816, 0.14736747725124533, 0.14648451588952482, 0.14876600898129855, 0.13938936147845582, 0.15272660727166154, 0.16804817107190206, 0.147031294790277, 0.15689612284147902, 0.15084000516211127, 0.13586401980678364, 0.10350826121714651, 0.14433091738618054, 0.13433498120509846, 0.13033125758672326, 0.14615883584572698, 0.15715239577801332, 0.13574798650948983, 0.13825399239848413, 0.12590724854189705, 0.14524318068624964, 0.1389514436691801, 0.14748679879838777, 0.15063792242110485, 0.1607041001455407, 0.15624924689051856, 0.14056913467528354, 0.13756012375890259, 0.1341480607420248, 0.1078160503800365, 0.11571265064568592, 0.14484504149439237, 0.12697137276317605, 0.21082044994489224, 0.14194267035483044, 0.11049131739258133, 0.14199517520840288, 0.1630430984769391, 0.20440355183652503, 0.17376094589253122, 0.2090637271392659, 0.1808768514197321, 0.1826317638706314, 0.18577436754458976, 0.16887590964392274, 0.1844226272976105, 0.05699022060400005, 0.0411361874053231, 0.046963035526594865, 0.04723081554535924, 0.04078374328892165, 0.044433410884539115, 0.04958484751163539, 0.04229231064387262, 0.04798537362282673]}, "mutation_prompt": null}
{"id": "266df45b-1709-46ed-ae99-665056c30554", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.5:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.5:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIM(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIM", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Crossover, Mutation, and Quantum Bit Flip\" algorithm.", "configspace": "", "generation": 65, "fitness": 0.08588462053235098, "feedback": "The algorithm MultiSwarmQIM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": "1fb9d653-0dbf-4c14-b14f-dabbc5ee6947", "metadata": {"aucs": [0.18535772637969583, 0.1683070157122154, 0.17618069868881847, 0.11969357181324192, 0.2144441438189717, 0.1623268049907749, 0.13581775154829212, 0.1147052492830235, 0.1630593278303729, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029522904819484608, 0.03699051403759002, 0.038094720090360856, 0.050208582972087634, 0.04074097288556222, 0.033149933424145295, 0.03346080084180103, 0.07182456542201654, 0.036620209058758846, 0.025337925228551494, 0.022240810357236684, 0.02947539825713208, 0.03516603680108943, 0.04038609402692239, 0.028239508873231678, 0.029122801665741993, 0.026475232891037148, 0.0274031694575948, 0.20866865488394837, 0.10866411629411266, 0.12462862796088592, 0.12514045923638073, 0.1081820848970323, 0.10627444801822095, 0.11477568306929042, 0.4993645118512259, 0.18189401404582417, 0.12124011375496135, 0.07085082783219909, 0.0747785206043654, 0.08599531797960558, 0.06363357315051266, 0.0793178083792494, 0.05014415784098314, 0.05206801607821476, 0.02169419019378549, 0.1574056709444216, 0.09269216200004815, 0.0968225968326456, 0.09763306979615949, 0.09307311050021949, 0.12235882107993401, 0.14541731934223612, 0.08543317032860342, 0.09328573778026039, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015168242147970412, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06794700474935911, 9.999999999998899e-05, 0.021945211115393937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06063702758268974, 0.04776177408798399, 0.056520036798131, 0.08530978360453789, 0.031517275287246016, 0.020585510230030413, 0.028880430700532034, 0.013783595744914945, 0.0661715498835509, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01048846859624386, 9.999999999998899e-05, 9.999999999998899e-05, 0.1718261017930165, 0.1751379213484453, 0.20025950394079295, 0.17955358956626732, 0.1843850442011561, 0.18143712588452765, 0.18606071137311664, 0.19281768616052308, 0.1780258105801168, 0.04371179085375165, 0.026019539891761867, 0.035290238165878174, 0.03912863643815212, 0.037611578761947206, 0.03068553690359599, 0.0437146456504135, 0.03957091215684827, 0.05510416680587238, 0.1284700242634692, 0.12478835586182435, 0.15210273194826607, 0.12303772826478121, 0.11149776452944027, 0.12878531101213353, 0.14178215425023066, 0.11604566584614984, 0.14657022005091436, 0.15755850540769456, 0.16147511470147113, 0.1613932299901245, 0.1661338188075362, 0.15253204836692602, 0.1590543696865312, 0.15360428661722159, 0.17377774300845283, 0.1472662472684233, 0.09619582454126352, 0.09567424603068464, 0.11031137938890656, 0.09235310091381943, 0.09390699909915334, 0.097379788633297, 0.09288060939653064, 0.1123094961996961, 0.09845951250208951, 0.15277033840296972, 0.17481082582549023, 0.1512517212586223, 0.14942363268467818, 0.15276524361357513, 0.13815718735089666, 0.16755002527198137, 0.15283625355873587, 0.1647859699418075, 0.13685250909072455, 0.12641409516584723, 0.12762525470974473, 0.1397458566632347, 0.12834198178349876, 0.11557783495851914, 0.16185527444818382, 0.13056059004934106, 0.1367336821767432, 0.12144197053263739, 0.22870848434067015, 0.1478972493417383, 0.20762944396796534, 0.13564794016404136, 0.14587327852541054, 0.15223543702266817, 0.12607338040091742, 0.1428298402446453, 0.1388030095508337, 0.14040917511908624, 0.15712772806303965, 0.16010811410063974, 0.1122318828518688, 0.13932353011020082, 0.15377420126987984, 0.11824061143166731, 0.10051560596063103, 0.17772679289591742, 0.18478935791367546, 0.1880493436756847, 0.16448195165021606, 0.16504177407186493, 0.17343468949273377, 0.16802951137663769, 0.20027397398490254, 0.18009724029441132, 0.05303914150341238, 0.05090786973983108, 0.0485484696051639, 0.05163100941487697, 0.046303180501401364, 0.05509622754705923, 0.051657674436278334, 0.04936418457128944, 0.03613591684961537]}, "mutation_prompt": null}
{"id": "6d1ea624-574e-43ff-9aa8-302b7cf83a95", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n        self.adaptive_probability = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < self.adaptive_probability:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < self.adaptive_probability:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)\n", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Probability for Crossover, Mutation, and Crossover-Mutation Hybrid\"", "configspace": "", "generation": 66, "fitness": 0.08912203641180444, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.09.", "error": "", "parent_id": "1fb9d653-0dbf-4c14-b14f-dabbc5ee6947", "metadata": {"aucs": [0.15023237851023163, 0.15387605166578522, 0.16303624353377166, 0.13024513351607803, 0.18843099792410933, 0.18193942231972504, 0.16460314382132635, 0.13814932648709632, 0.1796435786707189, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0343861918053211, 0.036379515760923686, 0.03660861514317881, 0.0361373454309476, 0.02807845906915607, 0.029423257909495404, 0.03875197306192113, 0.04626898770576027, 0.0399338964328978, 0.027718582443525652, 0.01723363354049834, 0.03324827078083015, 0.03198664370109017, 0.022722431635586515, 0.016293799974476886, 0.038347296752094695, 0.019524907244770295, 0.019468185496317347, 0.7049203720039343, 0.12943611803127208, 0.2876085055483425, 0.11973971303994235, 0.1349414777199205, 0.20899755695809785, 0.7599234903240483, 0.09661066718730238, 0.10801671430470838, 0.06274794416174423, 0.06200329074538635, 0.04375211096249354, 0.06795396172179025, 0.03481949329891065, 0.0483910808366208, 0.06283009449207366, 0.03681120938497984, 0.0639729481060698, 0.10027683525177622, 0.11524236401503607, 0.13189268306343382, 0.108154216531961, 0.12710946129858003, 0.11548078095946401, 0.05989262670533735, 0.1295378836132448, 0.14800490087504203, 0.005668869565946255, 9.999999999998899e-05, 0.005410976691862968, 0.015445023299565763, 0.013387299811034592, 9.999999999998899e-05, 9.999999999998899e-05, 0.01579332533291511, 0.003048467330965865, 0.008359992852654208, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06747560350113835, 0.047069941942429416, 0.01149153340390241, 0.017894466527173192, 0.004345435179855639, 0.010633204880828084, 0.008058911187148965, 0.024455455270152693, 0.05225071935910963, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1827429698533407, 0.16654677134733442, 0.17639496073150018, 0.1802531508991344, 0.1865685216980697, 0.20249698579684505, 0.16306124750639084, 0.20543081686659348, 0.16009278658124804, 0.02443782009117712, 0.03236047237040107, 0.03244956572460689, 0.03367795019543174, 0.033164170979853025, 0.061219353007796795, 0.03793330444999632, 0.031177378785666177, 0.035622742429423315, 0.13812505733975577, 0.12346870706276547, 0.1324768686425959, 0.12398497652755869, 0.12689821413808677, 0.155295069218219, 0.12057711300214102, 0.12535138796904755, 0.14884560955587278, 0.15531131743674764, 0.15873562010635667, 0.1613932299901245, 0.15448582412465817, 0.1364665446268466, 0.15022554035817826, 0.1494820922333956, 0.1998533230174272, 0.1782828918592293, 0.08854914052133211, 0.08286443622347539, 0.09832224297456982, 0.10650966658749605, 0.09827638177715048, 0.11191091463594216, 0.09092236312672486, 0.10629429769545673, 0.11711869843824985, 0.18182655249684876, 0.16947893770539046, 0.14235066182418055, 0.16909752898481634, 0.1520253015204226, 0.14982677298378289, 0.1482658619253211, 0.14282149969499258, 0.14646465211278825, 0.09677856939460927, 0.12949514166380172, 0.15653364515260348, 0.128709800079726, 0.14452111973907156, 0.14302822934034776, 0.13604682501960852, 0.11045804671304738, 0.13929517073480824, 0.15259762371500507, 0.14536048528579382, 0.12955267610644827, 0.13193620586886845, 0.14051379861959123, 0.14431143863840912, 0.13749605133771925, 0.1449925049295644, 0.1453040760399137, 0.19350933357230027, 0.14846635921884244, 0.2720112790316792, 0.16065813715634436, 0.14277308541195233, 0.12711868721654118, 0.1327405325926284, 0.10936084792375533, 0.12151880348352662, 0.18826574593856205, 0.17022043828794742, 0.1790847279662685, 0.18709272187093096, 0.18174783236717018, 0.17154616667238676, 0.17733276707050394, 0.1792447529576675, 0.17831128223940562, 0.10239934210593149, 0.04010065677693442, 0.052378676367808796, 0.051268423601682156, 0.038773002582610405, 0.04940724180524503, 0.06222875748838741, 0.047621267968321224, 0.05320532152689739]}, "mutation_prompt": null}
{"id": "da40be30-cfbe-4d2d-88c8-74cb955ec36f", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.5:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.5:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Crossover, Mutation, and Crossover-Mutation Hybrid Probabilities\"", "configspace": "", "generation": 67, "fitness": 0.09227112317160142, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.09.", "error": "", "parent_id": "1fb9d653-0dbf-4c14-b14f-dabbc5ee6947", "metadata": {"aucs": [0.16775904713204293, 0.16485243217434542, 0.1705793074349281, 0.16060643237262762, 0.18462122810653447, 0.15837838510432556, 0.1568631123493267, 0.16341180462593963, 0.1875814957597468, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00756730545563733, 9.999999999998899e-05, 0.040156654742154796, 0.03166650481506206, 0.0383780625486102, 0.05595635912962138, 0.05147571080456981, 0.033611503411695276, 0.037431830671895816, 0.03564048441491141, 0.037930226451918125, 0.023019331037642532, 0.025872842968586496, 0.03255428275264716, 0.0435020606101334, 0.03246501649953948, 0.017738153598857775, 0.038327469506158396, 0.04551272842385934, 0.02221476968305869, 0.5427736321435916, 0.5352474323278131, 0.4341008833926775, 0.15268967742248574, 0.1290021160686432, 0.13728288730010918, 0.43752075052493145, 0.14991254916016283, 0.4521732351983775, 0.0735175674512184, 0.07402978394244875, 0.06353106364876238, 0.08808132017771952, 0.07444411964529296, 0.03480992956893092, 0.06291554315359449, 0.08499844966165493, 0.05525566922853975, 0.1104432442305997, 0.10198780759208914, 0.09235301504423865, 0.07832654476702339, 0.10145059383094035, 0.13575613383600083, 0.08506168052529683, 0.11854770671629755, 0.10089567228442031, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00819098053774503, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007597872112663384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029666378030696827, 0.06592598227988933, 0.05070974056466693, 0.039725127337669086, 0.012855334983150946, 0.07383172829923912, 0.024580491140462568, 0.03123562404962954, 0.009302974364028382, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18027744275776736, 0.17719005022686574, 0.18857350061333, 0.17569260123804886, 0.17727666031132816, 0.2124631363581625, 0.21313247654512302, 0.18444887316269087, 0.16806865572187157, 0.043469639278874594, 0.0271004224906799, 0.03791142024684924, 0.054665034033028914, 0.04794918509053914, 0.031945606601728516, 0.03585865726715387, 0.04228756479670315, 0.033136172098818806, 0.13125103725699538, 0.1385477394244362, 0.12943526841274233, 0.1221334887721881, 0.1442656273507955, 0.12459446578547761, 0.14474500350903563, 0.11355577798993799, 0.1549195736229403, 0.15438702224635492, 0.17670885308841677, 0.1613932299901245, 0.14677279574528257, 0.15904904253677887, 0.16856627829216453, 0.16666487229463478, 0.17377774300845283, 0.1523724847250325, 0.11013926804722995, 0.09952938614807405, 0.11415844309764567, 0.09590334771159492, 0.0937574731957358, 0.10722024206341962, 0.09931136623934345, 0.10082302865126713, 0.10487916214813853, 0.14759556446756927, 0.13843982093025808, 0.14722623235487975, 0.1415625463359329, 0.13446816505347547, 0.14794831482839144, 0.16185529703461887, 0.1428988920968688, 0.15725163282386934, 0.1265367112736101, 0.11479310834039202, 0.1270348668124307, 0.13570247660453538, 0.0025749497995346537, 0.13416015533016812, 0.14449881178671098, 0.12746975263435012, 0.15668124167779174, 0.1283195378011064, 0.23750271088551655, 0.12893902122069634, 0.171330381455835, 0.16873518576223778, 0.18054831386936676, 0.18905067062077052, 0.1482476269672196, 0.23710404462160206, 0.11248563394285083, 0.16446902116481166, 0.12688059681706598, 0.2042611372672276, 0.1168547391245478, 0.15978834974945622, 0.1206633595343497, 0.12104092558523116, 0.11285582000076988, 0.18967016386453894, 0.18449881056357775, 0.181955199943029, 0.1861408196223031, 0.17566021936165688, 0.17984646795925852, 0.17422344972444304, 0.1729773077839014, 0.18191098947715678, 0.03985007951657027, 0.04773816981733303, 0.04164676558920166, 0.05016832312446129, 0.050549751243080365, 0.04939666078412597, 0.05227840098340253, 0.045453318181519764, 0.057007185626417045]}, "mutation_prompt": null}
{"id": "4f42c9ca-f239-441e-9bd8-3ebfc89279f9", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.6\n        self.mutation_probability = 0.6\n        self.crossover_mutation_probability = 0.4\n        self.quantum_bit = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Crossover, Mutation, and Crossover-Mutation Hybrid Probabilities\" with refined crossover, mutation, and crossover-mutation probabilities.", "configspace": "", "generation": 68, "fitness": 0.09250006385782289, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.10.", "error": "", "parent_id": "da40be30-cfbe-4d2d-88c8-74cb955ec36f", "metadata": {"aucs": [0.17221101419595886, 0.14034798595259723, 0.16858057809586335, 0.13937918165042373, 0.14735591453778363, 0.15513814065005305, 0.14798207016206322, 0.15079100479088536, 0.15587680736081133, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030395332175691125, 0.029827156011882794, 0.02689439182416986, 0.040531597340898395, 0.040006895650427365, 0.038921538158101954, 0.03676639162409534, 0.037140461322955565, 0.03472482583912062, 0.025860140276144583, 0.018134437345148413, 0.01550239008729859, 0.030336129812733592, 0.028684127200621745, 0.022459482168213474, 0.036687545465400984, 0.030779802552369673, 0.045463882370366804, 0.24098980873006626, 0.4374609275121657, 0.48876203898595094, 0.7121387576995494, 0.2144100507661586, 0.16755543959271202, 0.13225988173115932, 0.4735943609925418, 0.5551755891290415, 0.06322671485591513, 0.06090350939477318, 0.09870606672006688, 0.05053527821365511, 0.054108956704014055, 0.046250853907567446, 0.025798562867424546, 0.03610519927970968, 0.08296181450657802, 0.13299904873485635, 0.09233002028431325, 0.1130622001329632, 0.13614323461528455, 0.106641797876047, 0.12450346972383608, 0.09669680990546914, 0.0781183648249818, 0.09146502380256372, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006274646015363761, 9.999999999998899e-05, 0.010549636586045907, 9.999999999998899e-05, 9.999999999998899e-05, 0.0024442440088224826, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005572830257171146, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08742956429451987, 0.018613141781352205, 0.037421703554896935, 0.05174240451325618, 0.004005017766376628, 0.031022405283809507, 0.025875545560770097, 0.08735054342743387, 0.024900675612593348, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20104304348419277, 0.18288104986200415, 0.2072624265293893, 0.16565013821489594, 0.1605476382766945, 0.17905443837170076, 0.18036088058142263, 0.19764875753719358, 0.1900331528710858, 0.026906694974591527, 0.04385276721742726, 0.05808120047437404, 0.043245890510925866, 0.06129800997542767, 0.06798639659995065, 0.031558641398716114, 0.049484026427980665, 0.03224063333326199, 0.1448521910993803, 0.1296757097171667, 0.13327558299542874, 0.10706531655504892, 0.1304782529077384, 0.13253214781001876, 0.1121598421280956, 0.13203510122047846, 0.13087064115487268, 0.14032525326879008, 0.17065769002268172, 0.1613932299901245, 0.17149906629148282, 0.14889722986281473, 0.1703927385741345, 0.16181568399555035, 0.17377774300845283, 0.13658214412115977, 0.09477468092555774, 0.11758196465715576, 0.095251487257901, 0.1187018114330951, 0.09793057591281162, 0.11499330005236497, 0.08721427271727367, 0.0997711199450243, 0.10126779611829184, 0.15396183610103287, 0.1478679937885916, 0.15824960149159195, 0.18375169011614967, 0.141469933141525, 0.1355289364057196, 0.1570989862394141, 0.13380352060772127, 0.1586751599991223, 0.1371267448205188, 0.12452827751672213, 0.14072412063747075, 0.1564053156811146, 0.11143929851307544, 0.1372795710784871, 0.1396388940907256, 0.09129373569147337, 0.13695000371719757, 0.17023926413671797, 0.13847298462149715, 0.1445876645382116, 0.18925154021863588, 0.1277010211157925, 0.17761958428461844, 0.1293438908758442, 0.12052254253238748, 0.15652212905118723, 0.11729152851467917, 0.14676903447818768, 0.15214476606289695, 0.12945944964387945, 0.12705598752452585, 0.11978580152333707, 0.1122561993395993, 0.1547697082197136, 0.11861935842959315, 0.16302812791638122, 0.1816007156892009, 0.17032527660332597, 0.17287817432190655, 0.17343904572412105, 0.18097642170260342, 0.17344388886785322, 0.18499500943052782, 0.21022916607435005, 0.054220215422032925, 0.03478242410678445, 0.05750975174565831, 0.039266532026856815, 0.03425093938292756, 0.04715502987802955, 0.05764102977118468, 0.04161355077064077, 0.07165869394841085]}, "mutation_prompt": null}
{"id": "a60e00fb-e119-4c3c-9cc3-5abcec187f8f", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n        self.adaptive_crossover_probability = 0.5\n        self.adaptive_mutation_probability = 0.5\n        self.adaptive_crossover_mutation_probability = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < self.adaptive_crossover_probability:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < self.adaptive_crossover_mutation_probability:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Probabilities\" ", "configspace": "", "generation": 69, "fitness": 0.08818663045711998, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.08.", "error": "", "parent_id": "4f42c9ca-f239-441e-9bd8-3ebfc89279f9", "metadata": {"aucs": [0.15786170061740845, 0.150281439429091, 0.14863794493506888, 0.12310201815429123, 0.1573890333899688, 0.13057984081482232, 0.19402302036321994, 0.14516786434080498, 0.1449512250586804, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.042603074561603727, 0.051999945406644654, 0.041065877943457285, 0.0293428930394517, 0.03115975965593587, 0.0377039394852422, 0.03875672530666885, 0.053294618536156135, 0.034560749440298744, 0.03631668714737046, 0.02356198607929505, 0.03821036318590598, 0.040236671593137374, 0.030614857326073053, 0.021206539206645503, 0.02333584977905445, 0.027631066066814647, 0.030482896670388282, 0.1302890192506898, 0.11766922070441, 0.5601007238586484, 0.1870734246358574, 0.10866030256055292, 0.13842491248073152, 0.13289041379856992, 0.5499115985733868, 0.3913533315836055, 0.07641785157090797, 0.12251530363910201, 0.07129426580130527, 0.04870907093785104, 0.09373485237570278, 0.05889964749764676, 0.0623992711578798, 0.024966067722927088, 0.022465857209975182, 0.10027683525177622, 0.10216787183002563, 0.12071207033854459, 0.15922510173105053, 0.11782414303756084, 0.11535372176662861, 0.13111345336190605, 0.10872537749892386, 0.10495100297141502, 9.999999999998899e-05, 0.0024013736812972253, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04799971634013456, 0.040631556899690446, 0.05022610062761956, 0.020225363353256087, 0.05112621585975052, 0.07276726054279092, 0.07152738189372299, 0.01407532078054552, 0.03320633954750052, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000565465324740777, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.19824333187155818, 0.18632080831231146, 0.20668579729745418, 0.17093433942986225, 0.17300408263434874, 0.1828513590071621, 0.18132463175368163, 0.17278514911506682, 0.16346836075482074, 0.03788820022053063, 0.03752025906478573, 0.029653692495308137, 0.041687801470166375, 0.03830023397466942, 0.031837927824261536, 0.029089706980777064, 0.03989360063263936, 0.037154956745803824, 0.1663730183050498, 0.12856923043806223, 0.12269902342416494, 0.13891249245513937, 0.12574730767511788, 0.1476832270153704, 0.14731253390472776, 0.11660605379719635, 0.12948648375732397, 0.1480591675834101, 0.16517830485715346, 0.1613932299901245, 0.15889379081964783, 0.14994151944286527, 0.15384093854310266, 0.15192967391499934, 0.17377774300845283, 0.1441095394221662, 0.0943939548463546, 0.09228274387353363, 0.09830089961823885, 0.1264617781956494, 0.0907416783602677, 0.10971732225150754, 0.11080819610855874, 0.10596036306100631, 0.10495140049470286, 0.1750474082048442, 0.13442032233373358, 0.14399782961304752, 0.17440358915946985, 0.15276988218909482, 0.18434347581299504, 0.14667406950230377, 0.13173531182940335, 0.14209267715115315, 0.1531400357185123, 0.1289685043787796, 0.14258927603241722, 0.14866489065197908, 0.1331182640260895, 0.13702028661423848, 0.14352129892391063, 0.08171894798236934, 0.1369970523080679, 0.15514850850964446, 0.1224885957333609, 0.13562408307848295, 0.1924957627065056, 0.16041475953733209, 0.13595908874165819, 0.1508921804672696, 0.1324899608182485, 0.16702131039698176, 0.158236103147685, 0.13728635842077141, 0.10847127722636729, 0.1076092675759186, 0.15120943272299248, 0.13592103338541417, 0.0991543410744593, 0.11772116251220488, 0.1558212740804411, 0.1926807316921274, 0.17434809714609856, 0.17764969999689073, 0.16986046536565302, 0.18533572713656987, 0.17695045699969492, 0.17327434779358697, 0.18602633044780115, 0.18312576700615302, 0.04422419993395166, 0.03844013502851107, 0.052037677517154934, 0.049569199154102406, 0.054631618823832495, 0.04902611362467435, 0.046180358055721404, 0.05426717750349619, 0.050565202662516406]}, "mutation_prompt": null}
{"id": "010d7fcf-7652-4b37-bd92-3e0e17ecb217", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Crossover, Mutation, and Crossover-Mutation Hybrid Probabilities\" with refined crossover, mutation, and crossover-mutation probabilities.", "configspace": "", "generation": 70, "fitness": 0.09158477433582322, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.09.", "error": "", "parent_id": "4f42c9ca-f239-441e-9bd8-3ebfc89279f9", "metadata": {"aucs": [0.15974091258908574, 0.13050532115338265, 0.1702130269295471, 0.133818754187902, 0.11944297245602464, 0.15282019186665274, 0.25120847553301395, 0.1472203411864701, 0.21688544962586442, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03209935078368331, 0.027399410008389302, 0.05846411643622229, 0.03409058141508936, 0.028093208492994792, 0.05731252912333784, 0.04144781110418294, 0.044827999237035177, 0.04397327493522263, 0.029510705178854568, 0.024255336612463152, 0.03222486652596157, 0.020897819040408883, 0.026489447966402957, 0.02127603735201078, 0.03994340924979156, 0.022489644458784652, 0.02349530581314352, 0.38578894282549836, 0.30561975289957977, 0.17635484181640082, 0.6563820240263969, 0.6869955682681868, 0.23589058333745738, 0.43206782782280573, 0.30455982503349677, 0.12152464447161804, 0.06274794416174423, 0.07112270312349411, 0.06987248413346514, 0.05423082593690487, 0.058210420757683234, 0.09009280544209919, 0.03126180105881937, 0.05802478539780864, 0.1206587886764866, 0.14446117538024428, 0.08224659834595494, 0.10678497594308722, 0.09536318475914451, 0.11135453467161094, 0.1153907901215091, 0.12464255187892215, 0.08469473701663277, 0.08747944696663257, 0.0019653139149697907, 0.009306020719232588, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03358069520638418, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03785262785481358, 0.031059850269584466, 0.05214878866297801, 0.04500387129891259, 0.008357457436169224, 0.04638560779333489, 0.009437208686447374, 0.031698897973380546, 0.03346558995065663, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.19632732025026267, 0.16920902665629545, 0.1679274599690298, 0.18345531645246993, 0.15941646282761524, 0.1674570269797172, 0.17582751726737245, 0.16471769746823006, 0.183341881366893, 0.025634504765967736, 0.030962395548860155, 0.038930085584564456, 0.03430963977264323, 0.03350398784332209, 0.04889184232671939, 0.03437143338406201, 0.036226146208454324, 0.0416879799586215, 0.12430604337616591, 0.14402273555662903, 0.12015947784206216, 0.1067279506429395, 0.1360166948003989, 0.13378330535033311, 0.12341481403575294, 0.13064063085279054, 0.12736087515961425, 0.14803687050169534, 0.16539432555928635, 0.16519776264551278, 0.13944649464261838, 0.14416557405584085, 0.1566429563998183, 0.1464340986250554, 0.17377774300845283, 0.1603587292647295, 0.10668571739301858, 0.09234473949961575, 0.10960039443017555, 0.10528179251977998, 0.10674615335581317, 0.09674851329676804, 0.0887813600502193, 0.10795730736498643, 0.10594991788267494, 0.1368311690144668, 0.1508623415819471, 0.1357313683203205, 0.18604165062876687, 0.13696853145227328, 0.15944641430018947, 0.17178079938189494, 0.16109030453921003, 0.1404886613094899, 0.09989879312363104, 0.14399164884779825, 0.14853292662787898, 0.15388556197587, 0.13737739551537087, 0.12503660333010336, 0.13881542488554166, 0.12399512734395524, 0.12386839344011746, 0.16280833625278623, 0.11687079171018522, 0.11585173370407154, 0.15997258445632356, 0.17517959619733925, 0.1649216170395732, 0.12201725479379566, 0.14049020700339165, 0.11376075714054645, 0.14127978408647124, 0.1704661470731602, 0.10791271405341563, 0.14003572438677425, 0.1877204604681174, 0.10877665930808866, 0.09255458173309539, 0.11380666910704473, 0.17443831458610748, 0.1648725162044189, 0.1816230896870631, 0.18504168308493685, 0.17755593493353228, 0.1800121310121322, 0.168337232712785, 0.17503927130088248, 0.17920368927997754, 0.16543923434565022, 0.03486293712027233, 0.04400459986647853, 0.049902117067955776, 0.05677705845672554, 0.04292382039194431, 0.060178690348455355, 0.05232559579929019, 0.05572366379122362, 0.05746744636866097]}, "mutation_prompt": null}
{"id": "223d5ad6-a986-4d94-929b-89924982ace7", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)\n", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Probabilities\" ", "configspace": "", "generation": 71, "fitness": 0.08729198017531131, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.08.", "error": "", "parent_id": "4f42c9ca-f239-441e-9bd8-3ebfc89279f9", "metadata": {"aucs": [0.18810681115420413, 0.14123285022510756, 0.14573990279302307, 0.13662869915564502, 0.159948564229494, 0.14412434763809145, 0.17884174167468103, 0.12874373928726035, 0.14226902624993765, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04308121081790528, 0.03411328057324059, 0.05507201616948476, 0.03902015182148366, 0.026400038667269143, 0.05869098356772284, 0.06793043889900785, 0.046283345651451424, 0.03613248796306556, 0.031019734048908343, 0.01444287889657736, 0.016592318444387244, 0.01960340630598334, 0.0397765244607966, 0.03387820997957347, 0.016696582993408038, 0.013531212808203463, 0.026642892546909436, 0.52943280516458, 0.13306467850037784, 0.2721333341056784, 0.5050887693402988, 0.17681448249087883, 0.1906040126662799, 0.14989987646797287, 0.29792847680723367, 0.2892734668435164, 0.06756112516752799, 0.05411217776959565, 0.045234353491511725, 0.1101148189448421, 0.04895127522981324, 0.07514200655435466, 0.08948358348998886, 0.0684040219984221, 0.027184437997466726, 0.11831961479800024, 0.09425734862275781, 0.09493631633678123, 0.0857517810172802, 0.07853853740705219, 0.12668728062007018, 0.08860655709539422, 0.07343402236140051, 0.11755467514216111, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017804656844625066, 9.999999999998899e-05, 0.01089739938958667, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.049950724170371386, 0.01740324531907045, 0.060041766570536836, 0.002926666600807537, 0.02592840885209169, 0.03810834258367157, 0.024141537046376116, 0.007213260249319675, 0.03606928942004983, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005775745664372889, 0.008476806719713736, 9.999999999998899e-05, 0.19362238405809562, 0.17895153795144303, 0.17690903096287092, 0.17719308847095816, 0.22310218359083656, 0.1701196259874287, 0.17552492757736615, 0.16818392144381777, 0.1815279296299832, 0.029892695350296372, 0.05533941666259634, 0.052954389218325404, 0.04072228342916551, 0.028074911766273525, 0.03355619225686335, 0.02410253681783192, 0.026742744985700506, 0.040824429737054246, 0.15690084174888874, 0.13115742054311819, 0.11842175776965747, 0.14069016389806843, 0.13325053317111502, 0.1379369077906254, 0.15135900293991267, 0.11575575138903427, 0.13267023060630345, 0.16085964425562693, 0.1830220020536879, 0.17136939359529602, 0.15489858115137645, 0.17549195912749205, 0.15534359965424505, 0.15451260521342725, 0.17377774300845283, 0.1566383649503701, 0.10293808658222847, 0.09185248485061692, 0.08661849274624533, 0.11527895897611673, 0.11198350077146912, 0.09335100660680296, 0.10508739890408492, 0.10880846332540572, 0.08473640092994561, 0.142592318636382, 0.1336527928106458, 0.1780009987806518, 0.21686772750349892, 0.14304498803108978, 0.12717803589766663, 0.1530883637054985, 0.14343683980007937, 0.1444058448707095, 0.14370205835925987, 0.014611551410511847, 0.13859727142812994, 0.13675088555814996, 0.12746410198043723, 0.13132070680933627, 0.14262436229559095, 0.1368752114763332, 0.131070913446534, 0.12440024778486203, 0.11604572926887158, 0.1336800399207062, 0.11918950169307341, 0.17265644137753366, 0.19086461995438886, 0.12730366831995776, 0.15433586302583113, 0.2092553128828082, 0.11811536635520203, 0.10533159980575069, 0.1291143106094581, 0.1411990443031178, 0.10057332604688851, 0.12650390482412055, 0.14352830159717722, 0.1651422483774332, 0.12001378211572133, 0.18205537501281366, 0.17836939087480186, 0.19614733486991343, 0.17758327620903125, 0.1693167676866134, 0.16445789977606362, 0.17371948363144274, 0.18149635240738438, 0.15906125096576762, 0.04167565391417061, 0.054673123664234824, 0.04772660011133245, 0.04692304624768329, 0.04455832746638133, 0.03611547368728496, 0.041276084252701906, 0.040207931797042296, 0.05231545488799694]}, "mutation_prompt": null}
{"id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)\n", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Probabilities\"", "configspace": "", "generation": 72, "fitness": 0.09861838143161945, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.11.", "error": "", "parent_id": "4f42c9ca-f239-441e-9bd8-3ebfc89279f9", "metadata": {"aucs": [0.16981598707754342, 0.12928024953081607, 0.14679476176536754, 0.1170378792102802, 0.25659848154827436, 0.1371945428832736, 0.15875412549568646, 0.14523989951593452, 0.14903419256444672, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03526880842587976, 0.024653891413677576, 0.0364138001579859, 0.033463828296312226, 0.021232928366186066, 0.046590038413575896, 0.0336767216167535, 0.03210907195196544, 0.040681660888690185, 0.03072638345755563, 0.018289248479793074, 0.028459576789077068, 0.037943543530116974, 0.024250252058320432, 0.03514402160097452, 0.026393599231067988, 0.024700862745440255, 0.02079632051307012, 0.19655655724506682, 0.44778268501892227, 0.3042758690574646, 0.6663662062758817, 0.3115417887571541, 0.6387440959136925, 0.6010385360676914, 0.7335738627721683, 0.5336581434716421, 0.07287479996813617, 0.05300408996107475, 0.0607111929033628, 0.0805736528549611, 0.059176784360045365, 0.09498995439053393, 0.05586097197693196, 0.04397938417479241, 0.03991614784093067, 0.10027683525177622, 0.11781731750699487, 0.16536486295246233, 0.157383185649296, 0.0939409421301487, 0.12238509373929662, 0.08491783980094347, 0.10900488967639921, 0.08881070706416994, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008083978261075542, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00023984064037363417, 9.999999999998899e-05, 9.999999999998899e-05, 0.013832182481826605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0018850422245130227, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023996216499527323, 0.033653965035653544, 0.02944272991289565, 0.0009924651532344786, 0.039189628003092336, 0.04241174011738569, 0.01844517409640467, 0.002321752759290807, 0.04974987794191932, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0037294480659797458, 9.999999999998899e-05, 0.18869084151338678, 0.254330184033136, 0.1771331184273104, 0.1984467012141583, 0.16104230446124823, 0.2088571575813527, 0.18076178258663655, 0.20523217372042724, 0.19305982485025852, 0.03453936515304867, 0.06855636892343409, 0.0289941802711563, 0.033578229318709574, 0.05241741971169245, 0.04739411489129075, 0.036953178178502966, 0.030705575344204372, 0.05356286483963446, 0.14191153673732226, 0.11342517433055987, 0.14210748581024601, 0.11925830850992847, 0.11642986470216998, 0.13987084147180395, 0.11146024755292416, 0.12807763244562032, 0.20039742523230375, 0.14824125291184131, 0.17672609216256663, 0.1613932299901245, 0.1649491245914667, 0.14865134183966022, 0.14907832917700248, 0.14802822311876185, 0.17377774300845283, 0.16358349280770257, 0.09387101052697577, 0.1068426136369448, 0.09688008531836623, 0.096154748811486, 0.11768577706300676, 0.10381765434646728, 0.09956904248045906, 0.0997711199450243, 0.09366058835439706, 0.16638788879576005, 0.13719698722509022, 0.15364719914244795, 0.12942198762003632, 0.13970695193734628, 0.13946514338774452, 0.18950978868238877, 0.14752369006283517, 0.15176142362274403, 0.14970604915918395, 0.13056318064270966, 0.12421731639801925, 0.1368144048676071, 0.14138210921268468, 0.14791646807397119, 0.15357645816608623, 0.13458156008730415, 0.14589258886462375, 0.1607119860916384, 0.14882904741098568, 0.127695698513133, 0.16771373293487346, 0.15966178119537122, 0.17222338374905943, 0.14640923331392497, 0.12174379778148536, 0.15294029525223773, 0.1521333214306686, 0.12180962753716085, 0.14733397937453485, 0.16862736300059156, 0.1676537672614843, 0.12626102545962237, 0.15930197214018427, 0.1426489721653057, 0.11920043004565284, 0.16467252185748293, 0.1983672948155667, 0.19635702277714107, 0.17052817210644788, 0.16905870808333512, 0.18486009713556473, 0.16404424549491892, 0.16814005850724678, 0.18089800768760067, 0.03955835517875317, 0.060565620362245665, 0.0583765431469343, 0.048456085847739305, 0.05568474592858241, 0.038787151101384865, 0.04118688248513025, 0.05715602575677625, 0.04488175294409957]}, "mutation_prompt": null}
{"id": "cf7ed11c-e7ce-4a69-8edc-cdb2fbf0fc97", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.4  # Reduced crossover probability\n        self.mutation_probability = 0.3  # Reduced mutation probability\n        self.crossover_mutation_probability = 0.2  # Reduced crossover-mutation probability\n        self.quantum_bit = 0.3  # Reduced quantum bit probability\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)\n", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Probabilities\"", "configspace": "", "generation": 73, "fitness": 0.08375444340542988, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.07.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.14244144702657902, 0.13735512423665108, 0.18044874329332616, 0.11623276804955096, 0.13109645325886066, 0.13886950485260063, 0.14691856902571943, 0.13645941589841093, 0.16910907245146167, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04846361652989217, 0.03295296661232039, 0.039381560192989884, 0.03292504807237362, 0.03319981168432262, 0.024199245725008423, 0.030412946091294857, 0.03502212430511353, 0.023505294890440176, 0.01823169568450267, 0.014236921111382639, 0.01609713802199708, 0.0245770646996063, 0.0411400089030407, 0.023650898750056104, 0.02836637569361078, 0.02252787050462235, 0.017657485031076225, 0.12237456077315234, 0.1260207599818841, 0.5034748676354326, 0.12794584159142652, 0.1194906580039804, 0.10817214347512161, 0.22693011291055343, 0.15430966644437616, 0.11720441060112041, 0.06274794416174423, 0.07558211023595462, 0.0842129146645828, 0.054306721048228423, 0.08599988868202868, 0.07127137688605745, 0.0870811709826943, 0.06021037351880332, 0.08564030522082067, 0.11217397810499219, 0.08224659834595494, 0.09299631724566748, 0.11943903780116982, 0.09661142272448864, 0.09511136956014177, 0.10301829177283817, 0.06925469996253764, 0.10211001991377433, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024027849237361454, 0.01256823773591309, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015665895531273732, 0.06386118674600771, 0.05896241883294917, 0.0067222756434188735, 0.034805164436210956, 0.05852777435645873, 0.025460508032040696, 0.06813319274217589, 0.04998907348376491, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.15785999016874197, 0.16128788225598478, 0.19382452726266497, 0.17623849135916703, 0.15716886625168847, 0.17039117602631138, 0.2523898427187671, 0.1887139201196233, 0.1854138743997099, 0.059338577978144125, 0.03497142511151485, 0.031226537393710174, 0.05103183132937761, 0.030979377305264455, 0.05664501092207497, 0.03459065795115346, 0.03537281628160671, 0.047302830347157765, 0.1393586204880417, 0.13673235492790414, 0.14876281537254943, 0.12336436722694233, 0.10852972522114013, 0.12619282008917598, 0.1154472255168163, 0.11808731661438054, 0.10989187355132402, 0.15324075335106535, 0.15968465343122373, 0.1613932299901245, 0.18334639687109133, 0.1551513942452417, 0.16580086351027878, 0.15049102564647032, 0.17377774300845283, 0.15424035285847382, 0.08852364365972065, 0.09979730277634247, 0.1014595726697437, 0.1027909608737615, 0.09336488111317343, 0.09366873924149788, 0.10658678359192053, 0.10216491939945516, 0.1254198475374515, 0.18148870777580495, 0.14133634334805323, 0.16327206747896528, 0.15236814244410124, 0.154869023826671, 0.15201523275146445, 0.16115102561319194, 0.1624648782463457, 0.16993912049941973, 0.14411520806019051, 0.05552458314238906, 0.13387031474429456, 0.14737063828629238, 0.14365483002926793, 0.0756981391426007, 0.1505750834139804, 0.11685817399166076, 0.13431734328945677, 0.1509422408726867, 0.1559773750616461, 0.12555904317552558, 0.20488304340064534, 0.13494401091604158, 0.22629744474483326, 0.12163468919595166, 0.12905754157401061, 0.15015398056228912, 0.12759712331942918, 0.133623440203808, 0.12326058842549625, 0.20089904577977213, 0.10925955485553207, 0.13772763411111588, 0.11401668671748577, 0.18076319744241987, 0.12213265687415764, 0.1776274767708932, 0.17453100068814076, 0.18363123506618084, 0.1648676748853184, 0.16656575257352302, 0.19233001497925684, 0.17628086558140765, 0.16340193593084096, 0.20184361392985306, 0.0495356074700265, 0.03885024691955408, 0.04343412740909591, 0.055072341731492225, 0.03425093938292756, 0.05795177560745379, 0.04468459793279922, 0.03991352472141729, 0.03921076308533844]}, "mutation_prompt": null}
{"id": "01241ee7-c2f2-4b4b-823a-5874c088904e", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.5:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.5:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Probabilities\" modified to use probabilities of 0.5", "configspace": "", "generation": 74, "fitness": 0.08561074934185642, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.18421488321274904, 0.17278254003856397, 0.19591316696123018, 0.15047913776555288, 0.17673319549363586, 0.15689158800945735, 0.17279748812424134, 0.15634704946915212, 0.1374399503549083, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03567641335892513, 0.03612091238262838, 0.0458436986687073, 0.04371903384773945, 0.04231793228223668, 0.05485313727340313, 0.022674599282279773, 0.04038222638245459, 0.039994419616165566, 0.02557720957082943, 0.05108875342683972, 0.014526827004177179, 0.02196796544494861, 0.03200500287629893, 0.049279635055309856, 0.021913901480344222, 0.017481206889823464, 0.031749286846338154, 0.1407972940140848, 0.16269458110660817, 0.15464799102062166, 0.12967754722484548, 0.18826783110532874, 0.1783005197199654, 0.11057430220219444, 0.17029663926209726, 0.11932260141170858, 0.06274794416174423, 0.06108808744259864, 0.06345799985399903, 0.048996835796125904, 0.04648663498733563, 0.05473082392497075, 0.11796805677545996, 0.06726230795467947, 0.08685334612308926, 0.125243310581998, 0.11316069220497282, 0.1074223809737721, 0.09063660034789778, 0.10697902903353207, 0.0961919109199918, 0.14047105295152318, 0.11679589319794703, 0.09249375087625233, 9.999999999998899e-05, 0.0016024071199830514, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01510379202575951, 0.0017712612481176615, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04141448312304763, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04432345992268305, 0.03858645426292229, 0.04835151957530781, 0.09141248452800499, 0.02120780751678286, 0.034675802790175125, 0.04420652015409432, 0.047972246256015705, 0.036217724769188164, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18081194009179813, 0.18388159153212313, 0.1901880295886773, 0.19898404914431056, 0.1705647124262003, 0.17900167254084987, 0.22149996617513856, 0.1724919667642565, 0.17666734344735013, 0.03277045038248416, 0.04137437341801431, 0.029169369075056073, 0.03572041571752127, 0.027522888628858877, 0.038944303174241246, 0.0324339650281088, 0.03696011684957334, 0.03291631237661219, 0.12553014274740326, 0.13494785250170693, 0.1268500895306417, 0.12297605412440948, 0.11863297170278275, 0.13937010858204435, 0.13602314653409775, 0.1418539280898129, 0.11995924131295232, 0.17906997331099994, 0.16630799413897746, 0.1613932299901245, 0.1541527843766396, 0.15006634175198252, 0.17008791667582268, 0.14256620114270369, 0.17377774300845283, 0.15049463919993145, 0.0939194015853223, 0.10438272124711112, 0.08694234933234202, 0.11177886461532094, 0.09711801288976862, 0.1036875680330237, 0.1286743425831126, 0.0997711199450243, 0.12465736249460047, 0.18091275309490373, 0.13922865004034424, 0.1525274547738552, 0.14739455790329703, 0.15176952438900648, 0.14101558020815264, 0.1488697347583242, 0.17048024275928075, 0.12747701417386925, 0.13133005281615384, 0.14930243541082977, 0.14795221086871846, 0.14108381876833864, 0.0988769224507976, 0.15094079845834296, 0.1497697755882551, 0.12991852538865, 0.13360075619334588, 0.16379386311746857, 0.14260454354637786, 0.128507904832886, 0.16977942393634549, 0.16539514629572072, 0.1497991114924918, 0.14937410426003261, 0.12958090036885717, 0.13793985856279456, 0.13959617469196983, 0.12272593179321134, 0.1634198834247862, 0.16522362129057178, 0.14846569060257986, 0.15604509966852165, 0.1505123633330917, 0.18807244523554123, 0.1600317568981693, 0.18482486351651783, 0.173640805451302, 0.1778221430310336, 0.1804950760772257, 0.17173453023187635, 0.1867229761027187, 0.18739774267059928, 0.1665012162189733, 0.17132975776732817, 0.045250099266387456, 0.04332451946671878, 0.06261163224199096, 0.045313870119127575, 0.05642495117729285, 0.05671055955128046, 0.04501005071462005, 0.048306988691061314, 0.06210278675439118]}, "mutation_prompt": null}
{"id": "018088ed-e506-411c-8af7-6d8e42b1c636", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.4\n        self.mutation_probability = 0.4\n        self.crossover_mutation_probability = 0.6\n        self.quantum_bit = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Probabilities\"", "configspace": "", "generation": 75, "fitness": 0.09023559211797437, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.09.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.1811050784634759, 0.10750105279240829, 0.14715109692167339, 0.13613347348762272, 0.14817898165362509, 0.11305612656366726, 0.17290393652398106, 0.1317358546954207, 0.1413603633844246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06193257422262266, 0.03926788882679355, 0.033277765197264886, 0.03567309601429136, 0.028808222829758923, 0.035472758364271995, 0.043849916823937574, 0.039422059264670906, 0.03269987736087754, 0.013090971194122725, 0.03421959944754094, 0.028283733171022174, 0.028648114536389047, 0.023310753812510465, 0.03591349509295283, 0.026565975085068527, 0.06563963753967894, 0.013049683874266305, 0.4191102296306478, 0.6830082798119133, 0.38194649757087995, 0.13669006309884735, 0.11748068531326028, 0.24259020094690897, 0.12318588211148396, 0.23294624569253586, 0.5986548270720937, 0.06274794416174423, 0.05782654446190738, 0.05908680905293817, 0.06067243081485918, 0.04763067107701302, 0.05390877731584787, 0.05840220972740384, 0.059956410515601966, 0.08066118941340428, 0.11018266847123481, 0.08224659834595494, 0.15356892590837545, 0.1020116222178401, 0.1380657276105951, 0.10594013357680565, 0.2056614235964308, 0.10612151389389224, 0.08622656490596237, 0.024268336197871054, 9.999999999998899e-05, 9.999999999998899e-05, 0.034967932838850135, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00045149886025031005, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008892504708395643, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.025562682041474938, 0.029874352623799116, 0.05491400272592528, 0.01726871581834477, 0.013886131411856684, 0.01426084043119702, 0.09505494327842567, 0.028871661464213827, 0.016238517034187328, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005048451984275282, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17269346987832046, 0.15958300919415236, 0.1876198010501109, 0.17614026096618196, 0.17985335021205395, 0.1690854059681589, 0.1718248034969715, 0.169130705130903, 0.1809009803929016, 0.03712319754688764, 0.028446531608423364, 0.04757426987419855, 0.03318761023960504, 0.036836116041990996, 0.04417745523615091, 0.06657062216556187, 0.034901627242974076, 0.03502510416766946, 0.12760252023452645, 0.1309595150445484, 0.13500943291161016, 0.12489293723686146, 0.11077181829204419, 0.13145155728601898, 0.14868800047724384, 0.12196937994454327, 0.11285901042476143, 0.14706626313732996, 0.15666498693894648, 0.16421146512480134, 0.18653713323839616, 0.1602220900249064, 0.15862331329135304, 0.15112934742235795, 0.17377774300845283, 0.16015346275863995, 0.0864506098307809, 0.10543982033872057, 0.09829660019226627, 0.10652829395213081, 0.09481404661322645, 0.0989876135253408, 0.0954334028046665, 0.0997711199450243, 0.10088520045896876, 0.14876969282765806, 0.1502510913699845, 0.1599816979137455, 0.15943178446448014, 0.1376497239493676, 0.14833062494925198, 0.13903300330519164, 0.137582887484741, 0.15256384966412373, 0.12604220534574828, 0.13682547670521394, 0.11286262188792062, 0.14630242255323977, 0.11154014607421436, 0.13681278566569277, 0.1364259533723965, 0.11206840568212406, 0.12274697837209114, 0.13095736921256884, 0.15809736906331506, 0.14805211187464518, 0.15256447119896988, 0.15604265038987908, 0.1217544139356973, 0.16193207237052798, 0.14530440496335417, 0.17147722068621296, 0.21737146277051678, 0.11952559223096393, 0.13039560430336117, 0.14960385076878335, 0.16156889686608011, 0.1712496767091921, 0.12953448624844754, 0.10699643376286294, 0.2139017875441216, 0.16967198147448603, 0.1618422857141133, 0.18240521034898416, 0.17073252271312267, 0.16206652510837105, 0.17459754316745635, 0.1965458395834231, 0.1792027391465939, 0.17716416511714084, 0.046120526004022944, 0.05047138307649257, 0.04708464225910791, 0.06944252503572446, 0.04566675028875089, 0.04754962768320181, 0.03785486504677826, 0.04965117908549743, 0.046695227176882015]}, "mutation_prompt": null}
{"id": "69d7170b-599a-489d-9392-111f52efbd68", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.4\n        self.mutation_probability = 0.6\n        self.crossover_mutation_probability = 0.4\n        self.quantum_bit = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Probabilities\"", "configspace": "", "generation": 76, "fitness": 0.09169027588930868, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.10.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.15759101770044692, 0.1352894486419446, 0.15502666025844736, 0.14327334159297256, 0.15942747602696095, 0.12686264559408722, 0.12752654401459518, 0.14626612583279053, 0.19141580781234502, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04930407287528704, 0.05669558574161471, 0.056444133298210186, 0.03021499129404892, 0.05098026794443722, 0.04580833697768849, 0.059972829976915776, 0.037978682050575086, 0.023769314705572087, 0.033867883463626236, 0.028379701184442108, 0.02888401961937237, 0.021334866159404386, 0.028934564418528708, 0.021927946592266934, 0.03604486801086226, 0.02971922766565782, 0.03573152955329495, 0.17306759157082396, 0.4652704138010564, 0.14567497490757797, 0.5363244485547922, 0.7209952278318621, 0.1412391826555881, 0.33829136992959064, 0.16925863602417446, 0.5206906738079665, 0.06274794416174423, 0.0435776078332788, 0.0627612495219626, 0.0658770437955225, 0.06204803506957701, 0.0550825438510637, 0.057188213069292226, 0.06813898996403045, 0.05555126135429744, 0.10051983298466616, 0.14732203159664548, 0.08933294236803646, 0.08139224533233902, 0.11078751169839074, 0.09153884956028524, 0.08603090463647056, 0.11872668207789028, 0.1376006778158455, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0038556193878954703, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02416944189218795, 9.999999999998899e-05, 9.999999999998899e-05, 0.021152052244826525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04580358383716088, 0.05700061268514167, 0.020689899636279763, 0.03211828333088673, 0.039208722566595466, 0.03292398439109678, 0.02818131602474805, 0.08286449816963071, 0.06338068461757829, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.221472640324069, 0.1646861460393304, 0.17950639448499295, 0.1951744132790778, 0.21223514430542068, 0.15908698419378653, 0.18418133242461965, 0.19961630817208809, 0.20515202542758393, 0.03283089453433563, 0.02793594644460884, 0.02198412468535549, 0.03419688413129174, 0.052348135602743984, 0.03518676246397512, 0.03539238949300538, 0.06021346407028905, 0.04212853050350718, 0.14665690717297963, 0.12546793057522432, 0.14807513145089923, 0.11184651558788883, 0.157305944618083, 0.14010760822215562, 0.13010558055550114, 0.12803943738475498, 0.13860259684085063, 0.18157256407229028, 0.20022583638899427, 0.1613932299901245, 0.16783914397460598, 0.15688467904402748, 0.16371258240393272, 0.1676381843928002, 0.17377774300845283, 0.1620299514266813, 0.10016743538605422, 0.0935769896372487, 0.09301943510222732, 0.09981899069928823, 0.09542067858676273, 0.09617089928327527, 0.0837317855149382, 0.0997711199450243, 0.08773922053239658, 0.1369007390256367, 0.15410882209664556, 0.15399060995262992, 0.13526201187878906, 0.14264342560891907, 0.14111889003099476, 0.17376826422073988, 0.14570918830107493, 0.18063748870723761, 0.12823504191787416, 0.07842023048564728, 0.13506248319362235, 0.1558293016027139, 0.15519775967465443, 0.14272133414579125, 0.1386495872789103, 9.999999999998899e-05, 0.13653552297034843, 0.12450266352879646, 0.11800862212649421, 0.15502749189842557, 0.1591814330613439, 0.1313832991966628, 0.11982468250589351, 0.16110059462555948, 0.1451620034365031, 0.1582724991470026, 0.12912906737179897, 0.12314841955128031, 0.14899107167810666, 0.17070440330683356, 0.13064223954036913, 0.1723615445981974, 0.14214680222781373, 0.12969102582138636, 0.12599641083661572, 0.1647057474597885, 0.17123104265422628, 0.16185906793635607, 0.17778593651470054, 0.16727587688252366, 0.19144683274908447, 0.16379371706646273, 0.160859412893678, 0.17586374937886196, 0.03614582810384859, 0.04244269018989666, 0.06832500677346576, 0.04612039238084231, 0.05526998717243736, 0.04467909819823779, 0.06141537931626606, 0.03819676374641312, 0.0413337711795384]}, "mutation_prompt": null}
{"id": "8b695d7e-a4e5-486a-b56e-589ba5a4efc9", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.4\n        self.mutation_probability = 0.4\n        self.crossover_mutation_probability = 0.6\n        self.quantum_bit = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Probabilities\"", "configspace": "", "generation": 77, "fitness": 0.08989823998810288, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.09.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.14288442015008185, 0.14646900165146293, 0.16670672365323003, 0.14958655591168735, 0.13680349098403644, 0.1522891067019183, 0.16238648952286694, 0.1880579821372026, 0.1315306044893092, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0432703843866602, 0.036976143341872714, 0.049391597323603875, 0.03784747625262552, 0.03165616177516373, 0.030302757823427395, 0.06930462155884942, 0.032742469722175316, 0.03029793375134071, 0.03597134788997314, 0.027466249681184496, 0.03153972965773133, 0.022157863232579067, 0.024676786930484362, 0.01547646986365303, 0.05839376332368518, 0.03465432652559175, 0.025497198748909766, 0.21548545445827216, 0.13684413181043964, 0.2208287986229357, 0.3315267634002522, 0.49712200458321976, 0.46396618401934187, 0.1400059918234472, 0.3623691500622881, 0.49446878963464114, 0.06341138209635044, 0.04901769459367866, 0.06770199110618891, 0.05280272185206358, 0.0682112371850806, 0.07220192267869374, 0.051022584786639014, 0.06401422533656842, 0.03403271987717649, 0.1053347650661357, 0.10116498168610177, 0.14414321406619002, 0.1352601975984138, 0.08336931746358456, 0.1040996564264387, 0.09282342204367211, 0.11539374262187341, 0.1137878520510267, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0816442241519788, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.036150840898395264, 0.058502624977082474, 0.045003619245272075, 0.02055285177277766, 0.056094286128597015, 0.056106254115477316, 0.03851153258525597, 0.008461972478693514, 0.05736365863311299, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17668793164034013, 0.16253900556888512, 0.1590102245109961, 0.16942270893357003, 0.21220503656680145, 0.17570743585430915, 0.17998660781866316, 0.1867486353833142, 0.17882752561093618, 0.0267892617729798, 0.0267225690018964, 0.03472213141269931, 0.04729714034744115, 0.044079735242870455, 0.030343697793101643, 0.04253901854494946, 0.03790004821196469, 0.04551418239438321, 0.13804330490782413, 0.12388623496872042, 0.1433282149768874, 0.11993086282766507, 0.15458724933647938, 0.12682265578621477, 0.11936901315759785, 0.13411630540523434, 0.13215126230735819, 0.1544679228458854, 0.1447529139102509, 0.1613932299901245, 0.18192701342730055, 0.14130689583357015, 0.15843870426005402, 0.13969301112575871, 0.17377774300845283, 0.15118434564798422, 0.09290419352866941, 0.08597567951284035, 0.08539678043117105, 0.1002876995913734, 0.10346289820697163, 0.1103202683114487, 0.11291731450979137, 0.0997711199450243, 0.10103049994177127, 0.15534766093941654, 0.13080927044160384, 0.1419327183754303, 0.1493857445718204, 0.1377706142162326, 0.1406170274000622, 0.13425218138786388, 0.1482063460638101, 0.16397044242964198, 0.1240956108106468, 0.10446136928960492, 0.12342319018006742, 0.14945814655352074, 0.1100767421416129, 0.1496894168736166, 0.14936107958669564, 0.11208984772012409, 0.11832479044165922, 0.16040563807866526, 0.13123784630915802, 0.12038176392709743, 0.24787914868773364, 0.15107667804130254, 0.17685249097380706, 0.15963138205901373, 0.12065775863847661, 0.12977928139824635, 0.14545959208635817, 0.1773022022437366, 0.20025022972371476, 0.1284408208850102, 0.1050492754541048, 0.19385525500988854, 0.11587436583210797, 0.10817022061739356, 0.11729531982884056, 0.18153706751039156, 0.18183467772570816, 0.17524572415104245, 0.17410916523661035, 0.17691993577879528, 0.16853758997145274, 0.16563930928302018, 0.17143777699454843, 0.18103931108492866, 0.04176580690105114, 0.04570265503477544, 0.04830777251420604, 0.047553824191224, 0.04355793490274662, 0.054520703598544995, 0.058828013567946424, 0.04318719234655777, 0.03869725417739722]}, "mutation_prompt": null}
{"id": "d20939e1-d553-40d1-a245-c3c21b7fc892", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.4  # Increased from 0.5\n        self.mutation_probability = 0.6  # Increased from 0.5\n        self.crossover_mutation_probability = 0.4  # Increased from 0.5\n        self.quantum_bit = 0.6  # Increased from 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Probabilities\"", "configspace": "", "generation": 78, "fitness": 0.0914909248135013, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.09.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.17030523728358438, 0.17024245839465124, 0.14878840005675487, 0.15031809303782884, 0.1557008203802619, 0.15476501231576034, 0.19645721783625725, 0.15067429400026955, 0.1356604594386246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034122335728333786, 0.02887578741152952, 0.03573994913031453, 0.0648714392712414, 0.05616879377601214, 0.03313699262828318, 0.034754173216895445, 0.029118985378156825, 0.03268312822428854, 0.024199879213609554, 0.03296554869715673, 0.009829845659144354, 0.019963724146817907, 0.044605035904898394, 0.02053228897811077, 0.026935180053010987, 0.024881440455714388, 0.019964812569542523, 0.18912147735415996, 0.1454590710586381, 0.30889118710685126, 0.1258488157337826, 0.16202759510333054, 0.3833523899359763, 0.35193926087894967, 0.47099551724178423, 0.8637238259251103, 0.07858707614695393, 0.08408295311387848, 0.06675606684340851, 0.0399682148090833, 0.04199217887006923, 0.0481463062571682, 0.041333387043174796, 0.057544538408086154, 0.09916041133153963, 0.12697943936276646, 0.10645177229558545, 0.10225481696235106, 0.09076008864626695, 0.09919761863620913, 0.09982038595148135, 0.09875790725477473, 0.09333269514656217, 0.08031201727807002, 9.999999999998899e-05, 9.999999999998899e-05, 0.037020182516457445, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.040748752535191834, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007741404837696475, 9.999999999998899e-05, 0.0012182614376151646, 9.999999999998899e-05, 0.04557922653187163, 0.08902945529025363, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03322545716179226, 0.014762470042418263, 0.023710442849844138, 0.02069900320933815, 0.05093077963458581, 0.015714161872849797, 0.1190463582828597, 0.044598692742772617, 0.0288458786873802, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1984302158759781, 0.16339726323793768, 0.17944196258558898, 0.16403384689636713, 0.16153505110877997, 0.16413358121791966, 0.20410267565156837, 0.1786792044636346, 0.21830284875198236, 0.025917837697960966, 0.036922857049071944, 0.027970169009895796, 0.03266886175302153, 0.03232040632189692, 0.0484670506771403, 0.022551449748573926, 0.03824031598227717, 0.043686563541171064, 0.1375482142675568, 0.14373275075509573, 0.1340854657626025, 0.1219105104066932, 0.12141726539622177, 0.11032510736030876, 0.10988429059924476, 0.11465687780215339, 0.11992208428884421, 0.17494917228786666, 0.14758694416642792, 0.16736801299691761, 0.1671934077150139, 0.1547810025669658, 0.16158659580811907, 0.1592427372194205, 0.17377774300845283, 0.16032940756932423, 0.10963058773696088, 0.09382892205594107, 0.10573121226288162, 0.1271671858811786, 0.09871791720009082, 0.10896699358801021, 0.10176805259556754, 0.0997711199450243, 0.09311748277836829, 0.14509354979728284, 0.13509410717599168, 0.1448932878274869, 0.15275895092549452, 0.16403121364614104, 0.16041977070847024, 0.18918053709214067, 0.12639303404786328, 0.13947167881471612, 0.13711629153808413, 0.07795990897762162, 0.14053388292530056, 0.15439975301154296, 0.14376088649028096, 0.14540359823317228, 0.1344830514028612, 0.1496479876481258, 0.15761777130378252, 0.1313701215321076, 0.13205543667958408, 0.14667301513691122, 0.16121030577483653, 0.13850771446241938, 0.15604256399742822, 0.11338236441672178, 0.15066762991960858, 0.13670931159742994, 0.12981854517250246, 0.22895402265617815, 0.14413697052956864, 0.1680573876054403, 0.10510474267726111, 0.21494766650746078, 0.1118012947547764, 0.1282976448282085, 0.20005364276345683, 0.16732954212417228, 0.17246501813678783, 0.17470244291405812, 0.1716538273190107, 0.16980545241648926, 0.17589276375707685, 0.17251716465677835, 0.18461579695122066, 0.17106669705024868, 0.05067400112747089, 0.03556638213707297, 0.04536399974166816, 0.04297663110383032, 0.04367017824726627, 0.0479222920321406, 0.04331879925183879, 0.04695064650484271, 0.04897038055803715]}, "mutation_prompt": null}
{"id": "53dc2585-91c5-4c7b-bd40-db6549a565bd", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Probabilities and Hybrid Crossover-Mutation\"", "configspace": "", "generation": 79, "fitness": 0.0856962986396549, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.08.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.19757111554639473, 0.16001909353760746, 0.14657418407756828, 0.13456500900024915, 0.13873377735859216, 0.20932950341299006, 0.15110465081307645, 0.12733484303726528, 0.146344647296893, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043472988361452414, 0.037067455431750385, 0.047722822502787365, 0.01950135291980226, 0.033279005642344206, 0.03395420166396057, 0.03967598437784714, 0.02620239993204232, 0.033997551703693674, 0.04485147430317671, 0.022622052020888073, 0.03967961915541507, 0.02068461612305239, 0.014144729028894298, 0.014914933206392145, 0.023009111925913928, 0.026839660837116974, 0.01603974286253884, 0.4833980316493459, 0.1282506980887156, 0.33384506472791187, 0.44195055583320375, 0.2758118709545744, 0.18232351783582745, 0.20606379683147857, 0.11252416420352218, 0.13064450355322477, 0.06760686073068323, 0.03632886432164373, 0.07716503742440128, 0.047821077034000736, 0.07595499283602036, 0.03902764723618024, 0.07889995129461913, 0.07632180043658121, 0.06009615644342903, 0.10027683525177622, 0.12227387661685185, 0.09292689394203213, 0.1083563611719015, 0.08343171036137464, 0.1083469024271424, 0.0635552832760502, 0.09764717590737015, 0.12756679283990124, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005520506446425544, 9.999999999998899e-05, 0.016143408192191067, 9.999999999998899e-05, 0.002454192068726657, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009551749770588702, 0.006976142943211028, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07864691489568953, 0.027083378250331358, 0.02482128870876854, 0.021065976752183246, 0.010434139779080365, 0.031752364543976674, 0.01018901979874498, 0.00959985244283923, 0.03772336539869414, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1905723250623993, 0.17697984562596303, 0.180958053299356, 0.17734556417972747, 0.20361123464703268, 0.19313313674158172, 0.17641626802081445, 0.20042323423833075, 0.16596041263309558, 0.02397027644043681, 0.0548059252382771, 0.028389680676361606, 0.03552903484197556, 0.04871122756792279, 0.032172818720352714, 0.032762476530950546, 0.026037949583211373, 0.028692945543082216, 0.15059733719709345, 0.14531520769840567, 0.17178020712042996, 0.13722096446801701, 0.11839082896538422, 0.1146483752180204, 0.12161508833410994, 0.11549894949578898, 0.1211528293657107, 0.17864675570973465, 0.16720275445894417, 0.1613932299901245, 0.1536325743495891, 0.1342923058857397, 0.1603430246289903, 0.13679645596944445, 0.17377774300845283, 0.19785458810034928, 0.0863655244647552, 0.09391950622424394, 0.0928243375304093, 0.10015796809834687, 0.09133714913235413, 0.11341556928133412, 0.0982849676388956, 0.0997711199450243, 0.07696780764683298, 0.18423060260044155, 0.14281434805996507, 0.1465285296459159, 0.146578031906626, 0.13550318848103338, 0.17866455840529638, 0.16717297961922728, 0.14716057485492906, 0.13702057761335706, 0.12291185266291127, 0.10573329013652222, 0.14598559086895535, 0.1459029506432935, 0.12602024031889436, 0.1420060391992256, 0.13423790897717058, 0.11868932858914483, 0.12020786216058965, 0.13650632866642987, 0.12400933547333859, 0.12688620634956171, 0.11023340042738494, 0.1244169296980161, 0.17748699450159422, 0.14386814164342154, 0.16785488022914252, 0.13081070127048866, 0.15822548524252145, 0.16217706367612283, 0.14436402930279268, 0.1434758250559518, 0.1387281452510415, 0.14121140261269416, 0.07949972843685715, 0.10605175330213501, 0.11663419205672076, 0.18169237798957494, 0.16330204470866105, 0.18034121976063033, 0.16398990145005243, 0.18017715461895645, 0.17635027162461792, 0.1804932090285969, 0.1933041082404432, 0.17627003523605522, 0.048302590047141325, 0.05166489602429669, 0.0657522662601503, 0.04234981230047763, 0.048108884425212106, 0.044436775521419225, 0.05452110393803944, 0.0411277692226788, 0.044216259010426584]}, "mutation_prompt": null}
{"id": "ec232b5f-c07c-4541-89b1-fcec5dcbaf3b", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.4\n        self.mutation_probability = 0.4\n        self.crossover_mutation_probability = 0.6\n        self.quantum_bit = 0.4\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Probabilities\"", "configspace": "", "generation": 80, "fitness": 0.08627901425713862, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.08.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.1497918501605815, 0.14396996129021022, 0.1364512402608219, 0.15333870923546689, 0.14241230765300938, 0.13039001440369502, 0.1305288950964345, 0.20349651302208827, 0.1775822484626255, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030247018215837085, 0.0388893185545377, 0.030428505698596564, 0.03499252088694016, 0.03863801099969355, 0.04175199308417599, 0.04124434938676691, 0.03930411839778225, 0.041607604248963814, 0.03174468290313548, 0.01646737596488934, 0.02666879524986221, 0.02933934578394859, 0.029220489067453115, 0.04884292271425916, 0.020454572744692645, 0.0266637794593928, 0.01627699142758232, 0.2521599923221114, 0.22585196476563574, 0.12105680289577325, 0.24557416226187168, 0.21611745904220303, 0.3628788891704411, 0.1431830029613992, 0.1336819909093514, 0.5752251185806663, 0.07346676018189968, 0.061721789325981824, 0.05105348974486712, 0.12934300762348505, 0.05903667284753833, 0.07659822373580771, 0.10632134332283583, 0.05114032261528989, 0.04465826127495187, 0.11343708397162355, 0.1029827443655511, 0.10422927493032785, 0.10580095430477288, 0.11915803880728015, 0.09094544936048188, 0.11453552961807234, 0.08698781231157993, 0.09452515676975759, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0025211886349985058, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005764112650080588, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05253628767285101, 0.044493662673386614, 0.06498232279904348, 0.03440978674021622, 0.04374482631576415, 0.020470893792818745, 0.049306078963917255, 0.022537028566898543, 0.04991695909686478, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16819107723354243, 0.19946538573541506, 0.18611458424715277, 0.17918389919453837, 0.18149957750982681, 0.1569465305750105, 0.1985625881703369, 0.1808074409612338, 0.16229644979910574, 0.02434406701661751, 0.022992116916497274, 0.027770930783039494, 0.03785459047904116, 0.0380604638731733, 0.03873588231581071, 0.043207986261927345, 0.03765184513579012, 0.04132024818424618, 0.13892845182106028, 0.12908486533407104, 0.1244624002150273, 0.13144890903871187, 0.114347715316241, 0.17806639920123712, 0.11204254696098037, 0.10800137935879117, 0.12952822184420365, 0.15627293075058135, 0.188504872877855, 0.1613932299901245, 0.17139552064455277, 0.1557297738237603, 0.1563317449967473, 0.17915350066007196, 0.17377774300845283, 0.1499169688207176, 0.11650162882772441, 0.10924165819542164, 0.0874658698111882, 0.11757473485066572, 0.090798535558679, 0.116231821072315, 0.0837317855149382, 0.10060561845575144, 0.1507113904686328, 0.14741251420547874, 0.13217972404736011, 0.1427079001494711, 0.14338228585270996, 0.15086022257794918, 0.14818631472583854, 0.14397678590147012, 0.1262115319665692, 0.15989736442101476, 0.1440544809082991, 0.12063246870097466, 0.1370286103586834, 0.1362469788997741, 0.11347883520325508, 0.12191036819097878, 0.15518501486330205, 0.13940057461295952, 0.1235057216925527, 0.13855625879500366, 0.12611945553298864, 0.14046790831832856, 0.11741717200846435, 0.16693965292662782, 0.12366602497462231, 0.129165891925771, 0.14354221142104673, 0.14927855922956246, 0.11726923392387001, 0.10456802499446893, 0.1620303919833821, 0.11889509789901453, 0.111659384264027, 0.11744347361227825, 0.17894659989763062, 0.11908318474321367, 0.11196255876509809, 0.177004633153649, 0.1573773007058149, 0.1710937642737379, 0.16365547400731162, 0.16940679307023543, 0.20672159064370776, 0.18058964370705655, 0.16181256515691733, 0.1744553239862533, 0.06602039047039265, 0.050544557568887094, 0.04233904179583281, 0.04689250222461305, 0.0465944953437869, 0.055622385310018396, 0.0511902957818644, 0.04160254328477819, 0.045520534450396166]}, "mutation_prompt": null}
{"id": "fed2cb80-ee5a-4701-ba2a-a3b5343d87bf", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Probabilities\" using 0.5 probability", "configspace": "", "generation": 81, "fitness": 0.08846607288141828, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.09.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.17744700488968868, 0.16367485893128453, 0.18518429795713098, 0.15112042830357564, 0.19013600690223542, 0.16256615671531893, 0.13666074971917808, 0.1708973330300183, 0.1582431176020873, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027281973620511546, 0.03185984145902909, 0.025821156522911726, 0.037615403251693325, 0.03673301354434155, 0.06254435967052363, 0.032344920082477246, 0.061180513480710186, 0.030510588967963437, 0.019308556124576715, 0.019267461207889358, 0.03356043700449951, 0.03429696727098186, 0.03065425557317014, 0.030996071249461576, 0.032427153514338, 0.010192664048394917, 0.029795133200629098, 0.21040437286259073, 0.15207340522054436, 0.800396584087977, 0.4756302441355901, 0.19124253769664035, 0.26600483579598344, 0.23662351411678684, 0.1853157722988924, 0.11254038597106009, 0.06274794416174423, 0.057662133330953824, 0.06045994574453106, 0.05949605639181177, 0.04288762098203225, 0.06395227338515708, 0.03997959865933953, 0.05594376693644465, 0.03710304820097021, 0.10740189861248639, 0.08224659834595494, 0.10592793002902257, 0.07597755905062442, 0.1337659590332947, 0.14838370270110468, 0.09795366710683961, 0.07938916355978509, 0.09036121763794469, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013562867849715388, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09549898136798451, 9.999999999998899e-05, 9.999999999998899e-05, 0.003126819695156935, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024066543634855275, 0.017924370251085953, 0.006069483317212465, 0.009319773196313719, 0.013133426601216525, 0.029489020748504124, 0.04263773139781857, 0.07801551906882964, 0.0434817097315543, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00482144842122656, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1683846003515559, 0.18510776256871353, 0.187333332910259, 0.17856727946556694, 0.16593890079884588, 0.17250554565111065, 0.17505338098740764, 0.20120637408312358, 0.18121144382520693, 0.04135571277360173, 0.0359831700048866, 0.03582924343121974, 0.04493763136952689, 0.031546171980551874, 0.04175472137522662, 0.034654986730769055, 0.05626538842206774, 0.029701577313371308, 0.1349179686592925, 0.12771757005911133, 0.15403907245889237, 0.13995910250830546, 0.13699218550354997, 0.12069586406653632, 0.12806896515606692, 0.10834737418521323, 0.13547648566370485, 0.15856722831906778, 0.169883441129289, 0.1613932299901245, 0.15354157710815597, 0.14355684696139037, 0.1502645307407684, 0.15779182467276842, 0.17377774300845283, 0.15339649166839375, 0.119459332191995, 0.10837298948490859, 0.09100339852617656, 0.11131393370751774, 0.08976111744174575, 0.13178004529211762, 0.1039251136581042, 0.12224400214042652, 0.0988012185017253, 0.1539263281131673, 0.14304837955338168, 0.1466999082566497, 0.14488104668665014, 0.1456715833808988, 0.13262759171348915, 0.14446240601196692, 0.1546538798807403, 0.13391655672184355, 0.13746274594955832, 0.1370478783327761, 0.11662398709398147, 0.1364283313125415, 0.12708817160551222, 0.16015091509719293, 0.1407113414032437, 0.14182121868705744, 0.11683483030968933, 0.11451728766578739, 0.13807096178320022, 0.12145480796622454, 0.11783603201348891, 0.19705557613740587, 0.1633714092445473, 0.12004331575321081, 0.13158624880529501, 0.11338571980909806, 0.126292233846809, 0.19031154157442942, 0.1860120552168012, 0.1842234572580579, 0.18790114955826576, 0.09100464266047781, 0.10879112422578074, 0.10341500615705446, 0.10628351242930001, 0.17857275091786573, 0.1913901285589582, 0.17514636726599708, 0.1768443333059413, 0.16887402580246036, 0.17156571839140577, 0.169112341298003, 0.18519596713811481, 0.18333240935358774, 0.04984885209674739, 0.04280427130267839, 0.04306863617383627, 0.04655947505440672, 0.05970398562272017, 0.04339302890505492, 0.05040351322864478, 0.04715822312263385, 0.05735880060270393]}, "mutation_prompt": null}
{"id": "8c2a4b73-9857-4d04-b988-c83f94494999", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.4\n        self.mutation_probability = 0.3\n        self.crossover_mutation_probability = 0.2\n        self.quantum_bit = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Probabilities\"", "configspace": "", "generation": 82, "fitness": 0.08415690281992799, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.07.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.16217216223183173, 0.17847314567283434, 0.14099551295932766, 0.11955987343273522, 0.11717866595824367, 0.15334205078394936, 0.20143083306136556, 0.14419731513824208, 0.14536890376301492, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04116268571621018, 0.04041347301166409, 0.042392568277271114, 0.054198997441383456, 0.04002942894560546, 0.032209023554556016, 0.03883937088920719, 0.02528772739267604, 0.03042838144686899, 0.04187502091226181, 0.027830499561863453, 0.019720703743067336, 0.020106793551871505, 0.028042960271429718, 0.02062546754805772, 0.02170188689107433, 0.02336548072979472, 0.025944001937417083, 0.1016721240769437, 0.13060236374981105, 0.241267038866952, 0.13940738232880723, 0.11688944759342212, 0.29121646430700554, 0.11603057788998372, 0.12711136370438325, 0.4807791159898598, 0.08578556973749418, 0.041098006816486454, 0.03735171834607953, 0.05511503392123196, 0.09486789410042751, 0.06102653706678651, 0.06328092926678708, 0.04661842768432378, 0.06435435393901501, 0.12090377643069283, 0.11315710164926407, 0.08281961445998709, 0.14030701409809865, 0.10046182746721699, 0.08855941746550178, 0.07553102313170579, 0.08046416385952504, 0.11457061635759669, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030629701628973605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008557523567349623, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004567007151477953, 0.0425224383455185, 0.015937956922742136, 0.07522022065811307, 0.03658119939325388, 0.05552895230281951, 0.03324532361869348, 0.012427856734358977, 0.02603258751387616, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1698325585320697, 0.18677782392210907, 0.1845937622100513, 0.16155132447797438, 0.16034443197323778, 0.18609709980188593, 0.1915641033956651, 0.172980096031354, 0.21228050006169374, 0.03080875522183546, 0.02341808016773661, 0.03167900068662388, 0.03266886175302153, 0.02502757951517376, 0.04180602736829986, 0.029267082016560364, 0.04768270551995679, 0.06689601157853398, 0.12647891262450262, 0.1272970618208621, 0.14613287676637887, 0.16286373257262698, 0.12114996874204953, 0.12221853398406513, 0.1203693792123599, 0.11368370156698382, 0.13056240601875546, 0.14160771755157298, 0.15067155606205962, 0.16399153836941605, 0.15198588263755386, 0.1380577134747929, 0.17286498010606577, 0.15574111481028485, 0.17377774300845283, 0.14789287411976038, 0.10645917984330722, 0.08860013880867534, 0.0990549283958646, 0.11672858742504433, 0.10799552292808234, 0.13935521843633558, 0.10644595791035227, 0.1008598101255559, 0.09546843405916494, 0.15418358670977628, 0.13063387406105742, 0.14913815650533724, 0.14277081635157884, 0.15844732201933198, 0.1605808980554757, 0.14330993794058355, 0.12839095912596132, 0.1571917589185574, 0.1446679541056185, 0.12925029887121509, 0.14098559843677627, 0.09092419021690568, 0.12051248920489266, 0.09968319210220067, 0.14945840473135452, 0.14765159533089078, 0.12064987478645539, 0.1241400628501611, 0.237486448949076, 0.1448701103575618, 0.15958121735678654, 0.1388256975929114, 0.1503746553190649, 0.11854047568272363, 0.1292470700821381, 0.14663593650484996, 0.16544701267044548, 0.20407691846939502, 0.16396869639789635, 0.09341123553748698, 0.12920329576106981, 0.10543088005278356, 0.10159811967402022, 0.1350291028335281, 0.18194724564721543, 0.17664980758268245, 0.18646426079419653, 0.19523066650741971, 0.1778819721081787, 0.17933211099281265, 0.21011091752455036, 0.18962965485686611, 0.16797280395812808, 0.1837548967171737, 0.06508722133815448, 0.04569195188582531, 0.056388870858391615, 0.04225760356766439, 0.050321530409785376, 0.04126697774334609, 0.050137664995956066, 0.04704891255705845, 0.04393598412268662]}, "mutation_prompt": null}
{"id": "8e0644b8-adb8-4f74-a969-74ace3fa8a29", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.4\n        self.mutation_probability = 0.4\n        self.crossover_mutation_probability = 0.6\n        self.quantum_bit = 0.4\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Probabilities\"", "configspace": "", "generation": 83, "fitness": 0.0885215924237375, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.08.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.15875585406096526, 0.16122734957247298, 0.15317889880717972, 0.18491692407345395, 0.17496051518670097, 0.13928655720869343, 0.18113523004730203, 0.13685621137860526, 0.14195434430070653, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05255062411879041, 0.0454698132010426, 0.04676091119325121, 0.033790587482689594, 0.030081578624926775, 0.034311790841626166, 0.03673410522377196, 0.03254470960237299, 0.03134323598336508, 0.03400596817126056, 0.050177471258150974, 0.02346067270964869, 0.023961663522013676, 0.021997205487188864, 0.02632791761679565, 0.035252713076853404, 0.016658661668740193, 0.021476113306457267, 0.39929880970914355, 0.3216399817324044, 0.45021277259638526, 0.15346939332307996, 0.25246847342613565, 0.3697570447100287, 0.1615881389036462, 0.5068978978945988, 0.12311629000908797, 0.06792354448403182, 0.08531946795417189, 0.0785795927640589, 0.05898273532922327, 0.08761617189785942, 0.04056699248870432, 0.0650320747284111, 0.04726800381804841, 0.04785663938998186, 0.11469660388651459, 0.1051146096988137, 0.11850357877933404, 0.08124194838132881, 0.08963437678074881, 0.08070856571802543, 0.12881876344066934, 0.0889514413478204, 0.10213260050208062, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.021119564255673184, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014716688482648177, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03435871905873589, 0.05320363281981533, 0.04529695410569201, 0.013110426001983089, 0.01631983218086186, 0.07852654669588577, 0.01898762367619744, 0.03416360619560088, 0.015823470937705864, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18476080098726122, 0.16267325968803392, 0.17200108248269608, 0.15469742512134832, 0.15831183718045283, 0.17883468724613227, 0.18709847766829435, 0.16669675029226705, 0.23312497247086517, 0.029141252780930826, 0.020382420706856696, 0.02611799316239216, 0.03266886175302153, 0.033968219874486394, 0.02636619179377997, 0.06795032620963937, 0.025976647072038728, 0.035386446504441116, 0.1118745003044258, 0.1208020043985425, 0.14019334516064397, 0.1136562596191234, 0.12797612294833616, 0.10798713552628325, 0.13694182618047346, 0.1458433448608072, 0.1328116764370708, 0.14883206871793442, 0.14138430313751849, 0.18493988650856208, 0.1537342981147911, 0.1578274668026215, 0.16379558090074553, 0.1589576693075, 0.17377774300845283, 0.15174223871004866, 0.09660081202448911, 0.08372876952634234, 0.10241900881159904, 0.1098949961057133, 0.08203846853681518, 0.10800506062807325, 0.10494554993978522, 0.0997711199450243, 0.1194536206523098, 0.16362291260221484, 0.14469187597218935, 0.15269944944245017, 0.15550337443192186, 0.14183766241160922, 0.13831907412781108, 0.18287363687945335, 0.16867513167138637, 0.16142728550655228, 0.14335280946704188, 0.14266726726139844, 0.14539502628835776, 0.13066955077984166, 0.1639742732338344, 0.1412762131908306, 0.03302660379212463, 0.14454229559754894, 0.16842455899054898, 0.10664569900069054, 0.15159358469083595, 0.130951060075583, 0.15040104296804313, 0.16953411821378972, 0.11745636098957768, 0.1152196662905024, 0.18332106945687265, 0.15604517456749223, 0.16807866836708563, 0.1573484500840483, 0.16545864614217154, 0.1209261657324785, 0.1070129935331815, 0.13730366713213338, 0.1363867012143466, 0.09586610090687953, 0.11105315158236351, 0.17802302199911102, 0.1760651558665851, 0.17648817369883196, 0.1768638712155307, 0.16570133634864193, 0.16509979319014434, 0.16778160805106823, 0.19328858987106634, 0.19039662133879187, 0.051935234553203036, 0.03723671703653275, 0.04834276191546072, 0.06363982705007021, 0.04197354701680267, 0.04463050880522501, 0.06873953131583344, 0.04956137856458387, 0.03782122745549188]}, "mutation_prompt": null}
{"id": "132f468d-0392-45e8-af3e-5ccb1cfbd7d3", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Probabilities and Hybrid Crossover-Mutation\"", "configspace": "", "generation": 84, "fitness": 0.09364508682193272, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.10.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.14653334842098653, 0.15956261692057505, 0.13951660243115316, 0.1951779886631242, 0.1326011755994002, 0.1432331299965346, 0.1606876338107941, 0.16754495197173125, 0.11039698092743, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03945164162852721, 0.025377849472626668, 0.04588984355314951, 0.024966250958708636, 0.02238398631179994, 0.03791902554795468, 0.03645955569225445, 0.032421045807765614, 0.03441066090466394, 0.02795532967833192, 0.02487628342080206, 0.027532905187728662, 0.020356054728392747, 0.0348162611098356, 0.020164054017624222, 0.038748179685305306, 0.019392876981794704, 0.019069738544992276, 0.5848062127221674, 0.5808271275562935, 0.41531991654393163, 0.3309177874889693, 0.23586605417385786, 0.61210591128916, 0.16607408095549836, 0.5536584781017557, 0.2396285834421047, 0.06274794416174423, 0.060330995001535825, 0.05271512132865752, 0.04290256775732393, 0.0809574645738359, 0.03964062155675585, 0.036753898705860766, 0.06757570118915224, 0.07810910782590141, 0.11844091609074403, 0.08959394300652435, 0.09110623643887616, 0.09892583617636741, 0.12478024722961911, 0.07729794446713967, 0.09867081824294999, 0.1256770994082903, 0.10373881245882732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001950572438483178, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015576720168887004, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030557937725786855, 0.05760568752640005, 0.008661411798166374, 0.029125303453804707, 0.051197696718476626, 0.029623951861995734, 0.02969980524941329, 0.011776340730174306, 0.01923907436049399, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.19050484219039565, 0.19989781482526325, 0.21252788849182047, 0.17875352619546958, 0.1838384792609531, 0.16478326413588218, 0.24668264852270239, 0.21022707580884548, 0.17507885768594955, 0.024679357622810816, 0.02422497123291012, 0.03461952392926815, 0.03266886175302153, 0.036324855980790605, 0.029430022288311153, 0.04633317276865778, 0.02814195974223732, 0.034350100050637766, 0.15611499222682046, 0.12618640531837877, 0.12614297002953467, 0.12128602759371132, 0.1375809340787506, 0.12806638943070758, 0.10679107560824852, 0.14297293242964693, 0.13789181927500993, 0.16477660896771562, 0.16941698657332727, 0.1613932299901245, 0.15840853580610514, 0.1546724741422436, 0.17471573400669027, 0.18728470709289546, 0.17377774300845283, 0.15626298284903584, 0.08094876372380622, 0.10621748442782142, 0.09293794026853952, 0.11158426859034476, 0.09381890487896505, 0.10908637339268734, 0.10592359564811138, 0.10189194699070847, 0.10506105825939505, 0.14023487849453375, 0.13412092529399777, 0.16808551720434084, 0.150968504148695, 0.15426851382186724, 0.15980412655556575, 0.15441522531235952, 0.16909729154351993, 0.12722826662083586, 0.14874494288122764, 0.10756106751929495, 0.13038742730438824, 0.14189489101029595, 0.1210773089171544, 0.12798831901416574, 0.14239176259929687, 0.14879865111534196, 0.1399989396366189, 0.12906222273417478, 0.16580708375966602, 0.11626759854827706, 0.17479803703093189, 0.14209560605625704, 0.13322476992406262, 0.14831965510912015, 0.14155984876694527, 0.16001355348126067, 0.15780444920324976, 0.1800098967578071, 0.1670311069016368, 0.16580251380844369, 0.13844605090977058, 0.14542628478686526, 0.15875125137515356, 0.15037362118896758, 0.14771043687943308, 0.1794140318634211, 0.16728280270279428, 0.1648642529826282, 0.16819289974267126, 0.18258449014819012, 0.16819494444373573, 0.16954085439114408, 0.17314869554816958, 0.16289055674983943, 0.04371510627488584, 0.03884081961448105, 0.04277462144104904, 0.039426490407034165, 0.0389959816261537, 0.050514557221623346, 0.05213022483121388, 0.05863645855898181, 0.04551040978030885]}, "mutation_prompt": null}
{"id": "0eb782a6-fb88-4f9d-966b-34ebb3a74d26", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.4\n        self.mutation_probability = 0.4\n        self.crossover_mutation_probability = 0.2\n        self.quantum_bit = 0.3\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Probabilities\"", "configspace": "", "generation": 85, "fitness": 0.08428747352820257, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.07.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.17635147299755594, 0.1769359742433857, 0.1525718270666765, 0.13727368793533046, 0.128284562700827, 0.13251551782420024, 0.15289969991458396, 0.1418589478290636, 0.16895271828482927, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02566964764556834, 0.03512859104649124, 0.034844561953492836, 0.035579273747331164, 0.042494644689589633, 0.0322390906329707, 0.030244366034346548, 0.04904272725256964, 0.04034748651824793, 0.03112557031648211, 0.018064644408125385, 0.030671453784836045, 0.04310688708218735, 0.032964903664190026, 0.01736828114779909, 0.03073932893857656, 0.03271939742553365, 0.020806879053923533, 0.10999567352697437, 0.2359516101819289, 0.1010589839818633, 0.13002614011964064, 0.14917819782183883, 0.10567632094675206, 0.3074183205629588, 0.2731385461599466, 0.0967425919929894, 0.06736317823884042, 0.08111312178952124, 0.08112004840858444, 0.05965845809302517, 0.02893678703801328, 0.04596948587267835, 0.07714178821143247, 0.06106361944320382, 0.11641113864809993, 0.10744271430267949, 0.11268737774020388, 0.09012489595521622, 0.13655166185758194, 0.10247541630715218, 0.07649331905326962, 0.1084254606565237, 0.12660996912124756, 0.10186625227365254, 9.999999999998899e-05, 0.0031712928538987217, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004849811397230952, 0.01974713396307981, 9.999999999998899e-05, 0.013690123460810666, 9.999999999998899e-05, 9.999999999998899e-05, 0.005802345541092158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04548407652059272, 0.051929448781820375, 0.04281509489885116, 0.06733407570720251, 0.005683045997959768, 0.022501557195474975, 0.04186580463714218, 0.0754079776336819, 0.0410963312973226, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18888154700360826, 0.18091027780337487, 0.1829104490066925, 0.1690381576967015, 0.1607455283277055, 0.18957834340941027, 0.1876942172724706, 0.19524019875079046, 0.18700573231154327, 0.03356997240761139, 0.030215195516388293, 0.03411400075288462, 0.03266886175302153, 0.03823416717506134, 0.05241836257649668, 0.055322508375743706, 0.033998040734548374, 0.046133733720375325, 0.1170490269781933, 0.20494638787919617, 0.14343764447794838, 0.12091055793937722, 0.13270263227548074, 0.12920347727586978, 0.1413683237826655, 0.12427173578427086, 0.11604846222625675, 0.14131125203151718, 0.20296567580967295, 0.1613932299901245, 0.14930693734743306, 0.15540184999665796, 0.16818971890544, 0.15449492597144565, 0.17377774300845283, 0.15345117188424884, 0.0948272727854863, 0.09972525188524961, 0.09298084680479246, 0.09003982549006373, 0.08845530317498118, 0.11635486063610789, 0.10622985480817992, 0.10162116525005782, 0.10178810959025031, 0.14346657270573038, 0.13577822053036348, 0.14055968967857047, 0.13456468920385978, 0.15408542531969127, 0.14357006515260295, 0.12864597424107416, 0.16968676528758353, 0.14357061135987792, 0.13602445538636598, 0.1133609557041193, 0.11194837657794576, 0.1530780691158543, 0.12958458919355653, 0.15804230414081522, 0.11850995693389121, 0.09077954035986002, 0.11779845975747572, 0.11528542899458405, 0.1563587548570038, 0.14526304374754395, 0.2382569718420251, 0.13051462953715565, 0.16557217219191356, 0.13332257941669268, 0.15355066903264125, 0.14922363506811254, 0.14254459447827106, 0.11410237748759278, 0.13562230978041423, 0.15554526164030724, 0.12829121354001272, 0.21236149436387508, 0.13259251367237446, 0.10754559986856715, 0.15948142432277468, 0.17597573031535252, 0.17880611006879177, 0.18448568371597351, 0.1715500635962366, 0.18217504963690645, 0.18443431638072505, 0.18035410169227706, 0.19951162584091653, 0.171180824176563, 0.04624465615604456, 0.038855298905315805, 0.03814107047267257, 0.04913787491806232, 0.06455250142619551, 0.037569138528629864, 0.048556255958912, 0.04128048897689607, 0.046140215919638794]}, "mutation_prompt": null}
{"id": "4271240b-be69-4435-aea5-2c90e745616a", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.4  # 0.4\n        self.mutation_probability = 0.3  # 0.3\n        self.crossover_mutation_probability = 0.4  # 0.4\n        self.quantum_bit = 0.4  # 0.4\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Probabilities\"", "configspace": "", "generation": 86, "fitness": 0.08845309325884097, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.09.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.17255121108160598, 0.12661787444409056, 0.1512562907236874, 0.13303420227913354, 0.14208432755942957, 0.14408215536551994, 0.2004792097620549, 0.15114430507004784, 0.13735858688636926, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03788324276596289, 0.04394741306543415, 0.03561119738573837, 0.035584254198976706, 0.028482724718155272, 0.038423918940312274, 0.033338257555827644, 0.04224139664736615, 0.03316415242267323, 0.04443748228636801, 0.041269018762476684, 0.03979795886393089, 0.022714447075156907, 0.01534462610433207, 0.016210830921110753, 0.014763392921912755, 0.03256951733787683, 0.014058919937530168, 0.2490176841450482, 0.41629719395405396, 0.48484958997159266, 0.2902994744428926, 0.6773344050225873, 0.20545032318568424, 0.11953349946957148, 0.20653634374479513, 0.1440870543108833, 0.06274794416174423, 0.061106777605630436, 0.07718002349192898, 0.05823441802511442, 0.08145359362142057, 0.12135837367222901, 0.04442481864894621, 0.03210940043753874, 0.06809032569425566, 0.11165995495835235, 0.18988342004463643, 0.09039133563932178, 0.10932247068939616, 0.11724191082883739, 0.06654677239609685, 0.14065926117880245, 0.09995905445127085, 0.08888802180924049, 9.999999999998899e-05, 0.012139905765532366, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02133558726518081, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05224108222525392, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.025274230883562288, 0.023737879175800503, 0.08895231615719768, 0.049865603504556044, 0.03909799065003239, 0.012257343110256391, 0.01144568204492935, 0.03924726830777403, 0.019639828886029886, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.19185007214808525, 0.19775039106395087, 0.18740468059890025, 0.22051170113806862, 0.16699642928199487, 0.18726450003754336, 0.16565228828433098, 0.17413321076926858, 0.1627348443288562, 0.028664644363137426, 0.02882000510040672, 0.03610559968144389, 0.044158973575671334, 0.03179652286095136, 0.03309776005051901, 0.03299535123284025, 0.032408002536462255, 0.043061398940377194, 0.12160671270764267, 0.11043539591341456, 0.12082574265903423, 0.13424698778219424, 0.12337370380400536, 0.1237072194580664, 0.1187501165209125, 0.13103924039885695, 0.15116724627152633, 0.14562251751408162, 0.17180820798396435, 0.1613932299901245, 0.15264091220657916, 0.1382499488720601, 0.16426818375668495, 0.17287239770450014, 0.17377774300845283, 0.169483592992406, 0.08915926962519738, 0.1311185196461614, 0.11285302904662675, 0.09558078772646328, 0.09910300573428743, 0.1080119509606855, 0.09449498280218527, 0.10174615702936773, 0.14545237847571757, 0.1497467165602513, 0.14145860135308508, 0.14220117232639606, 0.1413840337093072, 0.14894271884967658, 0.14163922492116932, 0.14274586742630613, 0.1258278995346953, 0.17331350628017606, 0.14131514385579635, 0.12622244736779542, 0.13384324931699043, 0.15048164359822858, 0.11914560052109902, 0.005147621687621173, 0.11831931756747327, 0.14770947067614526, 0.12780673333845693, 0.1626628032445948, 0.11533287658764146, 0.14753018144673047, 0.11889841062527629, 0.12298133200692696, 0.1545943141620173, 0.14984685737498693, 0.13254808940914387, 0.15728999802130017, 0.18017279493027505, 0.14638742947175976, 0.10875887335058976, 0.12393637065615459, 0.09710116716462702, 0.1599167785810529, 0.1266279839050427, 0.12346416595375143, 0.13994241761482495, 0.1741411329184428, 0.1778475866781235, 0.21978877894299387, 0.16647623571027104, 0.18956439960741767, 0.1629204259830631, 0.16241287068682664, 0.16525833045255944, 0.1763286159929638, 0.0467221110096403, 0.04574458230002476, 0.053068029665106375, 0.0400305544889743, 0.035612077369862494, 0.047692454907115045, 0.04537595000425132, 0.039383732360931734, 0.040611826188649114]}, "mutation_prompt": null}
{"id": "ced62b18-518c-4198-a6cc-17b4272d2f40", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.4\n        self.mutation_probability = 0.4\n        self.crossover_mutation_probability = 0.6\n        self.quantum_bit = 0.4\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Probabilities\"", "configspace": "", "generation": 87, "fitness": 0.09226451366850837, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.10.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.16404304861619146, 0.1864045380699948, 0.14558795370221, 0.15485089557116172, 0.13579838300377345, 0.12467245940517335, 0.12204313482931717, 0.16148252059991386, 0.14628745879669314, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04013986523342716, 0.02338732950815503, 0.04457686907651093, 0.03637872697872413, 0.02126073320548616, 0.03293870071717975, 0.03930444432655167, 0.04162496820196737, 0.03945220993261067, 0.025811856262185406, 0.03389392731086005, 0.011749904093296015, 0.030185463951575175, 0.025918794089808017, 0.023970488844483606, 0.04836401102124732, 0.02369672132970313, 0.0490858645243607, 0.5209554102833821, 0.5599851972891924, 0.8788943012764221, 0.18082529359323019, 0.22110240990484398, 0.6305060393495481, 0.1341499793993125, 0.13071351147162968, 0.23602626961476603, 0.0629942427631971, 0.07210667326661147, 0.08278179456109325, 0.03392844032280484, 0.08710154291324523, 0.12318130736903987, 0.05390159700202635, 0.04022529650412543, 0.05188837193112872, 0.11555656224121558, 0.10389909549654153, 0.12254869491184384, 0.14470932431469574, 0.1103846668096059, 0.10280389621843422, 0.10425092286084947, 0.08941698256316466, 0.08068436066476858, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02693004741771332, 9.999999999998899e-05, 0.022993844771294625, 0.001029343465500987, 0.011654298068242142, 0.007225096728380231, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015431639274551379, 0.07823820991090724, 0.02444820087134414, 0.03602217937323693, 0.05182811719396874, 0.04822560682115695, 0.0513874253763843, 0.00955371975044128, 0.03873986746699232, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1858843655704452, 0.17036656096507008, 0.16809650778310947, 0.19880558741180998, 0.17052881163349576, 0.17805785374960048, 0.2055346126090729, 0.16485211104106479, 0.17466400859136433, 0.04958980764913645, 0.015126895828883602, 0.02198412468535549, 0.036708956270644744, 0.03796804543752841, 0.04923384064526559, 0.04539651671726319, 0.027324288738563518, 0.03896855520512532, 0.11403887686794756, 0.10703859743453581, 0.11842175776965747, 0.1341842270011412, 0.11977443989611314, 0.11688592977249623, 0.11668573121282011, 0.11896520267968314, 0.15318963795458218, 0.15552167647513815, 0.14760842332428614, 0.1613932299901245, 0.14376485337810774, 0.13756187958769406, 0.14650830317482855, 0.14458890714361805, 0.17377774300845283, 0.1624655343349437, 0.08418368878383242, 0.10514789625358312, 0.10377050436776603, 0.10113075334953425, 0.10839657003203718, 0.10016683150659833, 0.11265483627108819, 0.10834686711150465, 0.11386738759289472, 0.1407268857163716, 0.13446560604918634, 0.1372372568775685, 0.14365751948979721, 0.15045477177509092, 0.14508605709485967, 0.1287945654852738, 0.18617364245768409, 0.1356755210661389, 0.1282554586129403, 0.1247156934332414, 0.1421695206439284, 0.1391313263729329, 0.13492353323034023, 0.15855299683424673, 0.1416390354771816, 0.11378269042104183, 0.13755533490355087, 0.13656274639451715, 0.13399859370731015, 0.14300017076882088, 0.20676864379171844, 0.1286282491786651, 0.12043368030770285, 0.11275440367856082, 0.14636477362959321, 0.17689263877745032, 0.14905689556418056, 0.20623167213033056, 0.10349857800913054, 0.10605879761554848, 0.1378153574078873, 0.21580782154010048, 0.16960901199873346, 0.13226728526563059, 0.1077850448651605, 0.17781450737290938, 0.18477485672876637, 0.1825432883304624, 0.1593532928206256, 0.19344517338224776, 0.16071286237344506, 0.16956510884053133, 0.16918352923200508, 0.16916704615687517, 0.04571573592670741, 0.04972953878675146, 0.04168841469545281, 0.044683484345815705, 0.0375044631396817, 0.04883063480336203, 0.037092962624603376, 0.06686602807570619, 0.04775945479223831]}, "mutation_prompt": null}
{"id": "c92c2e8a-376f-4470-8af1-fc842db6111f", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.3\n        self.mutation_probability = 0.3\n        self.crossover_mutation_probability = 0.3\n        self.quantum_bit = 0.3\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Probabilities\"", "configspace": "", "generation": 88, "fitness": 0.0835974695402515, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.07.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.15031310946760534, 0.14440272623199468, 0.13380271833631563, 0.14981071153371828, 0.1482359685898771, 0.12557608011331156, 0.14586734374098087, 0.13062661383406016, 0.11644654122954323, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030416989869255895, 0.031986672166734564, 0.03230620217729907, 0.04273545536108447, 0.041412831941000317, 0.03070749585185606, 0.03825018758894416, 0.04749111915325244, 0.023183248640686327, 0.02438373141751493, 0.02904620327773244, 0.018247822236918898, 0.02177382109672965, 0.022417562203577268, 0.026608683471328054, 0.022903880620235628, 0.044809647801704156, 0.021948164523624136, 0.12935370272140168, 0.1385735744979154, 0.37089516993740146, 0.24540387640401273, 0.17605689689219506, 0.453396328953819, 0.10445601679179894, 0.13132441933522354, 0.24152412867855255, 0.06274794416174423, 0.06764728406147225, 0.06043214760852611, 0.1335592787978056, 0.047601831470776235, 0.04750556392662619, 0.0702000149875921, 0.1066931392916256, 0.04043231871043684, 0.10869258877064836, 0.09886744218188503, 0.0847491858312478, 0.1004111907995271, 0.10639874376676528, 0.11728444162413998, 0.0768220105014239, 0.10918556674406832, 0.18159910572643323, 0.01911043937059531, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07444792203694195, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006120408378109676, 9.999999999998899e-05, 9.999999999998899e-05, 0.0226455042379321, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009470575038214024, 0.013953621971636077, 0.019587999319077842, 0.08614505000253525, 0.021704509944154737, 0.027707002893007315, 0.029876198896814254, 0.08869088522409274, 0.02218422822095467, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.19511712674890214, 0.16055045847623428, 0.19244188529823236, 0.17005554353277252, 0.1656574042218919, 0.15176731293325285, 0.19348629394223638, 0.15867868466278556, 0.18196718413191504, 0.04605918922760266, 0.0270995045045358, 0.03381607637110662, 0.04143059434758689, 0.028482033115822425, 0.03585303947952412, 0.035010255627834, 0.02579656302604383, 0.06477226091277444, 0.12114884757522848, 0.13125762721336798, 0.12659972258595498, 0.10622739454442875, 0.13011026437038387, 0.11386084003431773, 0.1264912032706943, 0.13182674980620923, 0.12788848364244187, 0.1458357565129994, 0.13245952268094274, 0.16633967588680465, 0.15568188488207502, 0.14457322060081823, 0.17924217163554257, 0.14538997821349897, 0.17377774300845283, 0.15821250473830717, 0.09189494818474597, 0.10863140253294146, 0.08908436858753888, 0.11791623246910166, 0.11897986308097219, 0.10947277132041433, 0.10247271126431712, 0.10525645928111627, 0.10494200686026978, 0.14549740949424306, 0.1434790136024927, 0.13619175374980919, 0.16147693693121856, 0.15580286389405174, 0.15315168080298958, 0.14185568984683705, 0.13520305148596068, 0.14564214153367172, 0.13681775597602586, 0.13093952146670784, 0.035220336103569894, 0.10733906953367145, 0.1079611418433487, 0.1470542311244637, 0.1413729023555088, 0.031529435849156684, 0.13402164495183244, 0.22123126424198214, 0.1927067961026414, 0.11718955209817827, 0.15097818922566275, 0.12887606413526465, 0.1512270115048472, 0.1149013754736492, 0.21185293369488256, 0.1591585310716822, 0.11873444571898562, 0.1100243197000007, 0.11923935245885298, 0.16770210087494508, 0.10904480147042084, 0.151262728070379, 0.10673730778330881, 0.11054179616438176, 0.13054642968226216, 0.17094813619328075, 0.1624942434510147, 0.16843927363123568, 0.1830634553337097, 0.1665647892863661, 0.17113034532610494, 0.17832288290688625, 0.1738107286221806, 0.18633819738195523, 0.04318448300760214, 0.04013139100981955, 0.04927077695156645, 0.043500658422761296, 0.041580240431234095, 0.05183835459021213, 0.049755081224603814, 0.0431935413965161, 0.043189704978432]}, "mutation_prompt": null}
{"id": "50a87620-9af6-46a5-91a6-10c27b8326d3", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.3\n        self.mutation_probability = 0.3\n        self.crossover_mutation_probability = 0.2\n        self.quantum_bit = 0.3\n        self.exploration_probability = 0.1\n        self.exploration_bound = 0.1\n        self.exploration_decay = 0.95\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n        self.exploration_level = 1.0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n            # Update exploration level\n            self.exploration_level *= self.exploration_decay\n            if random.random() < self.exploration_probability:\n                # Increase exploration\n                for j in range(self.dim):\n                    self.particles[i][j] += np.random.uniform(-self.exploration_bound, self.exploration_bound)\n                    # Apply quantum bit flip\n                    if random.random() < self.quantum_bit:\n                        self.particles[i][j] *= -1\n\n            # Apply exploration bound\n            for j in range(self.dim):\n                if self.particles[i][j] > 5.0:\n                    self.particles[i][j] = 5.0\n                elif self.particles[i][j] < -5.0:\n                    self.particles[i][j] = -5.0\n\n            # Apply exploration decay\n            if self.exploration_level < 0.1:\n                self.exploration_probability = 0.0\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Probabilities and Dynamic Exploration-Exploitation Trade-off\"", "configspace": "", "generation": 89, "fitness": 0.08007128187857732, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.07.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.15328889815651126, 0.1635772842419938, 0.14409807058396762, 0.13599939536316874, 0.15216177345596338, 0.18240879022784762, 0.15214039481596997, 0.14557957224076312, 0.1038357364842557, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048814750149341335, 0.0345672577469639, 0.03657737678898243, 0.03636687888979595, 0.03704218669855586, 0.04384097604974535, 0.044055485058332344, 0.03206277248328637, 0.022416913781416414, 0.020398323831271825, 0.020064559322141795, 0.040815063429536336, 0.042816701440797966, 0.021164211793458176, 0.021298069003913067, 0.026615313048945266, 0.023923902983638112, 0.048767431632565805, 0.1014852937819829, 0.10044615014813807, 0.12207661303003747, 0.19382018337624718, 0.11258509468573796, 0.10468047850115747, 0.11153375045456781, 0.20330068397474055, 0.12888805896984745, 0.06274794416174423, 0.07008734348742596, 0.061446144073680764, 0.05547558801515384, 0.06020818433075581, 0.08505794652675336, 0.10280607662037888, 0.08347828022140036, 0.035962389541547624, 0.1531739386834572, 0.12695412760996483, 0.10947196337445242, 0.10034394860088791, 0.07498449498425741, 0.0820132388770497, 0.07976876737927252, 0.08821631305296362, 0.06954526637769143, 9.999999999998899e-05, 9.999999999998899e-05, 0.0019599371944374333, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019708009535426618, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003288136957738441, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01834530673175283, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0820943990735239, 0.05553262652815938, 0.03607964985260537, 0.0824677489500778, 0.012285287803829648, 0.02256853922548141, 0.017419492208766152, 0.035959379237129885, 0.044766462217554204, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.22493427503217223, 0.1794167113952717, 0.20593411511697046, 0.15448200561207992, 0.18208104291994986, 0.1757784662198193, 0.19576955414015362, 0.16242094865901835, 0.17525662019477584, 0.028139812395913344, 0.04334579014947726, 0.03954428924542075, 0.04691230754456244, 0.04036044694711782, 0.04022469692334052, 0.04446183174832097, 0.043179729948661816, 0.03379227384630923, 0.13119113619869438, 0.14220173671925984, 0.13957807842403214, 0.12501487662283617, 0.13060824824146489, 0.11668583911073105, 0.1317213720233663, 0.125066619448293, 0.11045471997394474, 0.14120925874203638, 0.15583570643809275, 0.1613932299901245, 0.17812990339696522, 0.15327251604210634, 0.15058508631406953, 0.16893993851283773, 0.17377774300845283, 0.14879850316949883, 0.0922267602685155, 0.07481416057801493, 0.10639621506487784, 0.09597154936610097, 0.09308803401152221, 0.1127625713232906, 0.09969880268259346, 0.0997711199450243, 0.09885250049034844, 0.14452749777206553, 0.1472177740605708, 0.1371223596517961, 0.14111996248518954, 0.15353703548947473, 0.14408791583703384, 0.14351690054591415, 0.13061880614805776, 0.1505264901407538, 0.11623212891589174, 0.11934628064874575, 0.12465441218386708, 0.13138305819946983, 0.1329708351475285, 0.15831832656153566, 0.13736675088481698, 0.005882852055157817, 0.05218773872132154, 0.15886085672882966, 0.12095113566514959, 0.15183931022923536, 0.14265252398936756, 0.12412302653534157, 0.15923513519902477, 0.12398728282042104, 0.19735512217232798, 0.14544552257423016, 0.1290714194624929, 0.10707465199753696, 0.11606123661948464, 0.2121803712636191, 0.1441522009237508, 0.14613733438820276, 0.11786612668503316, 0.12715940771711354, 0.10823206443262356, 0.15913435748809568, 0.16771286227237303, 0.16258490603433218, 0.17757699772617885, 0.18330290606836952, 0.1858704218943047, 0.1578109111026197, 0.16769982088902702, 0.16489810184379572, 0.06012954392712477, 0.053589694280295364, 0.047395991969423235, 0.050687562090262483, 0.04153378903772009, 0.043677421737153055, 0.05504205672460227, 0.045594295461182766, 0.041340918165524765]}, "mutation_prompt": null}
{"id": "ac739d10-591c-4fe2-98ea-1262c20d8203", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.4  # Increased crossover probability\n        self.mutation_probability = 0.3  # Decreased mutation probability\n        self.crossover_mutation_probability = 0.3  # Decreased crossover-mutation probability\n        self.quantum_bit = 0.3  # Decreased quantum bit probability\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Probabilities\" with modified probabilities", "configspace": "", "generation": 90, "fitness": 0.08414868935691476, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.08.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.17584743388079038, 0.11288564182776628, 0.16777288844585492, 0.11113132015075189, 0.1428070058949399, 0.12912097606784356, 0.16226951726843541, 0.13563718402000957, 0.12369877177897781, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026464770485947864, 0.03256192881961173, 0.03522537330021003, 0.03162206768758946, 0.04662750767857482, 0.05568392952627199, 0.0592539869683425, 0.047376906450886214, 0.01893348632206837, 0.02964076118335013, 0.02396459989932387, 0.03432927798111718, 0.030223839610161618, 0.017838133765234354, 0.026408623841983503, 0.03849616653885879, 0.020392362211341775, 0.02332993672526462, 0.12708460464961568, 0.5290760090316547, 0.08881261002126173, 0.14558366739314166, 0.1794080573002047, 0.27476515241534305, 0.34944485585399576, 0.21167014413951923, 0.10202791815618095, 0.0873835693060997, 0.026440885381264323, 0.06194086031677526, 0.0676959210680056, 0.04295233740666515, 0.07285676176198141, 0.047608851996015944, 0.014787883701022464, 0.059096327991394526, 0.10027683525177622, 0.136302643394123, 0.08875880536377756, 0.11959082634451224, 0.0968067349130044, 0.13786663928437792, 0.07596275599039704, 0.08555163191733806, 0.10325697195584926, 9.999999999998899e-05, 0.04446191360580176, 0.05692453084863225, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0016455610865364623, 9.999999999998899e-05, 9.999999999998899e-05, 0.0009544139385023742, 0.002029357362192008, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.018182733484050417, 0.0777051293150347, 0.033842015196170916, 0.0297079132471465, 0.03502984332734793, 0.0078005257878894785, 0.0073461246926977974, 0.05529031581811994, 0.04394789491647588, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18210949279090416, 0.15953425927846387, 0.16820054259186423, 0.21510201118194094, 0.14960182120007826, 0.14282509681686262, 0.19039829600933977, 0.18010338695996575, 0.17465029909394703, 0.052457785889922004, 0.01966072198670299, 0.033916160396687545, 0.05452584405898675, 0.036203730778154974, 0.04792115578469858, 0.04684765466877139, 0.03297166799237761, 0.037406464466110956, 0.12522578360979952, 0.10778000951927569, 0.13764273311001585, 0.11041072442868738, 0.12030283490004279, 0.11594253174110802, 0.11287795269614365, 0.11053510877920181, 0.10852077012738137, 0.14238683963574295, 0.16843686001588698, 0.16155051900410422, 0.15071790374502048, 0.1527251498430704, 0.16181053267658208, 0.15418302531653483, 0.17377774300845283, 0.16763322618935794, 0.07865096969699426, 0.08210774626960315, 0.08911853294993377, 0.09869738246239124, 0.10731871743604993, 0.1039475260111703, 0.09375145240368643, 0.0997711199450243, 0.10067487610713255, 0.18378952467858978, 0.13500049890327304, 0.1727224929185035, 0.14719067665344698, 0.1334058245700811, 0.13489652098719562, 0.14518937805015997, 0.14570219562421483, 0.16868192717022812, 0.14445594237903026, 0.13159544312267313, 0.14421508670449878, 0.141913745664194, 0.10444074283718696, 0.11817918681128481, 0.1380179324715598, 0.10969194048548869, 0.14827049044592133, 0.14598002151466494, 0.16306719751637533, 0.14103153905662058, 0.14248796198839841, 0.14045820950244248, 0.13089111598111025, 0.15032262889465586, 0.1534989962028701, 0.20037432793144772, 0.1286853351473619, 0.16586774043613695, 0.15941721160981537, 0.16199476576311356, 0.09588353990913279, 0.11124235766400559, 0.1664117317560434, 0.09247972804602744, 0.14802020322732656, 0.1597689886613649, 0.19014447947057578, 0.17943414900513233, 0.17166384004939905, 0.16206796013871627, 0.20995607633276414, 0.17163801880859952, 0.1868482997606139, 0.18063022290686803, 0.045012155941014154, 0.04978788431891157, 0.06642305210359067, 0.061579528803616945, 0.040330796567292215, 0.03577242538649694, 0.04805939373766943, 0.05023532285355037, 0.048032246784755595]}, "mutation_prompt": null}
{"id": "90d7656a-8918-421b-ac90-d7c1e06d2c69", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.adaptive_probability = 0.5\n        self.adaptive_mutation = 0.5\n        self.adaptive_crossover_mutation = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.adaptive_crossover_mutation:\n                    # Adaptive Crossover-Mutation Hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.adaptive_mutation:\n                    # Adaptive Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.adaptive_probability:\n                    # Adaptive Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Probabilities and Crossover-Mutation Hybrid\"", "configspace": "", "generation": 91, "fitness": 0.08866943838799787, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.09.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.15272531138257273, 0.15906325819604628, 0.19624822037510348, 0.17382556223952672, 0.1543659165244935, 0.13819344188334126, 0.1527347199698259, 0.15622902161095553, 0.12063313764587746, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03658861986525186, 0.03648915626836946, 0.03170803527832944, 0.03713116720070575, 0.033117164371150865, 0.03111312538708766, 0.02597346123464994, 0.04249254177377404, 0.045057308740544255, 0.03234376042418585, 0.018338760818782607, 0.020867065965379683, 0.01959972157639278, 0.047700858563065274, 0.03589730840060035, 0.02118832500399126, 0.022678499973811994, 0.04829452844022453, 0.4322824775671098, 0.5088099471525815, 0.229075411092855, 0.18175190587314172, 0.32753294129371247, 0.6177384669086989, 0.16586950098372877, 0.16192227310577523, 0.13383019879733526, 0.07766869117164932, 0.08983155679274457, 0.05481029280330263, 0.05549237513055738, 0.09223230671761506, 0.04262759479566136, 0.0653203758533889, 0.07206499932597454, 0.05328036624575305, 0.1100971895731937, 0.12481410827132788, 0.0942448215472852, 0.11446422105768872, 0.07285119553694963, 0.12236867358658277, 0.09438830812015842, 0.12354415063437996, 0.11295895814621215, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015448716118319106, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03802222972594371, 0.044399343244752476, 0.017534547202545547, 0.07114349291143884, 0.03138106738673452, 0.006146129920960419, 0.06013666517484706, 0.024348371229579446, 0.04382326950301918, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2157847692675584, 0.17548421936220004, 0.17477926425678847, 0.1444887357960215, 0.15850990466308434, 0.15285030908702224, 0.21523697742450953, 0.17914471949662525, 0.21528535737000154, 0.02183563680209155, 0.04095489211343262, 0.05324750543086898, 0.04302460102875538, 0.03702633850230719, 0.026626282314957228, 0.028517515202390653, 0.03013575218463649, 0.037106698774304836, 0.12902174021298274, 0.12130807151980494, 0.12482594094102928, 0.11565479365854425, 0.12524916302297073, 0.12857483255807567, 0.12236183848583582, 0.13613616826056274, 0.12384516388231914, 0.16492659897701956, 0.14504547389273992, 0.1613932299901245, 0.14550977014459243, 0.15546306313012703, 0.16582039814816285, 0.14868551287036624, 0.17377774300845283, 0.15911806775894888, 0.09067543457285687, 0.08154111940673303, 0.08594850120404884, 0.10035090200195151, 0.08387413714747105, 0.10368607415570674, 0.09227000127685658, 0.10039263040850588, 0.10239966041706106, 0.15300064343685826, 0.14981502334128038, 0.14193917603087358, 0.14425045521703672, 0.15390923296322123, 0.13491254190988966, 0.14852028044128052, 0.12697391471778663, 0.14597772696955713, 0.1463257695457525, 0.1443929494142281, 0.14238143281428073, 0.13960588492843307, 0.11514818653960468, 0.14347673013132067, 0.05212535953220465, 0.04351721594859681, 0.14192735444040117, 0.22417059632761716, 0.11563489548648753, 0.11456654677644706, 0.15031311387827284, 0.1207914665021157, 0.12593485683375982, 0.17228753596062707, 0.15756847931102835, 0.15938020612338843, 0.1412940105434427, 0.2269955424021427, 0.11631597117052206, 0.14345301473367889, 0.13090065949430008, 0.17469410163633425, 0.1672894414004339, 0.20377084712125126, 0.097935134677413, 0.18272638655839435, 0.18841960852548467, 0.1743977757022973, 0.19259786350874997, 0.17996159367155284, 0.17719565947259908, 0.16777670414947365, 0.18021308895420318, 0.1715841536714131, 0.04773968579178234, 0.03744699753869574, 0.04625383076911094, 0.06844732137864595, 0.039133322955899885, 0.04091719725632925, 0.04700243535116555, 0.04218170480259065, 0.03905641329833165]}, "mutation_prompt": null}
{"id": "35081905-7030-4a77-a0f8-549d80fcd24e", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.4\n        self.mutation_probability = 0.4\n        self.crossover_mutation_probability = 0.3\n        self.quantum_bit = 0.4\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Probabilities\"", "configspace": "", "generation": 92, "fitness": 0.08453956766092305, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.07.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.17162034789348057, 0.17566090408434243, 0.1716639117545432, 0.11542202662190104, 0.13180974243683063, 0.17303727149068893, 0.18046395007310423, 0.14107079712763948, 0.18760794343622733, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028969752340452737, 0.045165693448815714, 0.043252996892952256, 0.03551931444137457, 0.04436224090910257, 0.020026000040199277, 0.05312669831752903, 0.03042278319897307, 0.04290037971972216, 0.02912298970958671, 0.0361000608277684, 0.051253039591522054, 0.025332713645585314, 0.02180220839629543, 0.024692306767291172, 0.023709965364837493, 0.03270700183685005, 0.017152856317257603, 0.1068583988411188, 0.12031969189848457, 0.3070058982831815, 0.10694741619927084, 0.16070226437948, 0.23387215051311305, 0.12306262658502132, 0.1331227143983984, 0.15449467854630516, 0.08334398962927114, 0.08968155048934945, 0.05212868137442861, 0.07973560657168399, 0.053455730498631615, 0.03548366563159433, 0.10886895468400892, 0.033011091524905556, 0.057881739732867366, 0.13418122498711438, 0.08566452076977915, 0.11543581015463678, 0.08483055782267535, 0.1290054738787505, 0.10382389559998939, 0.06912562070023198, 0.1245450961474025, 0.10337669381476022, 0.06074007187920938, 0.0005506406360674676, 0.023521615131585016, 9.999999999998899e-05, 9.999999999998899e-05, 0.0077422221064563645, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0031165353403768137, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014016017975780004, 0.020593221235741255, 0.07450635830032659, 0.02401577259095178, 0.026089405225191098, 0.07378707824818242, 0.056918181043588034, 0.02028379333891428, 0.04741172050934461, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010946828566671729, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.21091539996893383, 0.18277129123609215, 0.18483996599304264, 0.17485218334397545, 0.16578648119794848, 0.1770205954816806, 0.18111900950982673, 0.22272201825405868, 0.2047980582505453, 0.036254362671715556, 0.03355174901825053, 0.04544383646158423, 0.041913776433588956, 0.041148228877772586, 0.03832796299377694, 0.046090842750170835, 0.02569035675541076, 0.040498246541800786, 0.15156136771316542, 0.1446520144392942, 0.1247967816492892, 0.11895978939273222, 0.1092467183295941, 0.11949678021666754, 0.15512166377335468, 0.13950080637391293, 0.12054080025169989, 0.1507981816674806, 0.13723879363056313, 0.1613932299901245, 0.15053654398347716, 0.15172091249617892, 0.16713315404278584, 0.14378694705583694, 0.17377774300845283, 0.17067407953175984, 0.11066263581229774, 0.08077243982559335, 0.11106591591637138, 0.10283676535891229, 0.11033550671712622, 0.11353107940581486, 0.08748268439532547, 0.0997711199450243, 0.09204144549482696, 0.1420034743692048, 0.13975503286375224, 0.14553625147125726, 0.18027309356083443, 0.1318734913255708, 0.1525618362908452, 0.13609686834711576, 0.14272250401772513, 0.13479761119625322, 0.14834436499008175, 0.13399067033298706, 0.13304558331317962, 0.14770264786995013, 0.12222843105895209, 0.13009503134662614, 0.11776007728421045, 0.15043320738594446, 0.12693156685442208, 0.1720416217577151, 0.14604198262937407, 0.15035424927491825, 0.14115300608382753, 0.15321260153263083, 0.16826082468915082, 0.11283481386347927, 0.1493263181399347, 0.21103371325649745, 0.15631146771016813, 0.15034617310982523, 0.14924528349622201, 0.16189481980121312, 0.10379509724357627, 0.1423511727336001, 0.10936656790652066, 0.16218220301937714, 0.1311470519778528, 0.18934682468716935, 0.17118618477753222, 0.1597675009078785, 0.16712851970038678, 0.17731981417689202, 0.16420434811697782, 0.16948542103759223, 0.19953335546305262, 0.19576837926027746, 0.04707125856775729, 0.04438319320614059, 0.04576398495931755, 0.05686139713522842, 0.03577686785557721, 0.04329081085512776, 0.04708227487120131, 0.04873249507160671, 0.044631903377315596]}, "mutation_prompt": null}
{"id": "16c7b8e4-f983-4899-97a9-63195b084c9e", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.4\n        self.mutation_probability = 0.4\n        self.crossover_mutation_probability = 0.3\n        self.quantum_bit = 0.4\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Probabilities\" with reduced probability values for improved performance.", "configspace": "", "generation": 93, "fitness": 0.08562909711372935, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.09.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.2138699442912423, 0.1332642069713854, 0.16743158694297833, 0.11371776769274888, 0.1652040589558601, 0.1482891110832656, 0.1568820554696364, 0.1548928822125767, 0.1314313994608285, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027400187903325768, 0.03798653129854068, 0.031488497081815336, 0.03081553648969859, 0.04209234559010533, 0.05330450932782349, 0.027195404756302777, 0.052207472513733255, 0.039173303727294884, 0.02541151733668956, 0.04054336787434221, 0.03260320388512861, 0.02149851418479598, 0.03004318370834136, 0.009549521491762802, 0.022134189160651463, 0.025008418284503953, 0.03870689060250332, 0.11398569742469078, 0.4812064404756137, 0.09915314546040022, 0.5609339948281491, 0.11876328379012069, 0.09289100516475124, 0.12734038974971518, 0.5913567249370886, 0.1517244927682263, 0.06309725827627022, 0.03847737197423029, 0.044173323670275155, 0.04297987600621256, 0.048034373147253784, 0.06065038830947289, 0.05129149720670789, 0.030579061177460454, 0.031015418484114154, 0.10027683525177622, 0.21036883743017643, 0.11469798747070525, 0.13578834713392285, 0.10090732374549372, 0.10005024185745881, 0.13572009493446313, 0.1208816498701899, 0.07658988572650793, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001910805477403521, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003588308689250863, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02266242415273667, 0.026921046650344782, 0.05922095506792957, 0.06311656803972743, 0.04049662253264885, 0.02781771404299671, 0.06907287727249911, 9.999999999998899e-05, 0.04836685118763928, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1870203417752173, 0.2083213663925394, 0.18189182586007235, 0.16396837791264773, 0.20878501778116743, 0.15313407399416523, 0.17289573190009355, 0.1593045128786552, 0.17287758745992177, 0.028817275356368688, 0.03466539434805749, 0.027193739093494318, 0.046815155135930264, 0.02998466967058433, 0.03283582595086321, 0.0690646200226982, 0.03656113626779989, 0.03923925646627102, 0.1332436934387915, 0.1438284024645885, 0.1343813859675591, 0.1242909949266845, 0.10852972522114013, 0.13823317659846557, 0.13079059516468827, 0.13677263407369122, 0.11175366546875287, 0.15264268031093453, 0.16528994770188388, 0.1613932299901245, 0.14805037809090027, 0.14505543520189879, 0.1540249895993404, 0.1496369327900018, 0.17377774300845283, 0.15791837831321687, 0.10476303709129697, 0.1142559058239514, 0.09679150480304921, 0.08355518315743682, 0.07805985999297005, 0.09264255204992278, 0.0914244628135753, 0.11441481677084575, 0.09344521661273542, 0.1529754809290833, 0.15055606290961332, 0.15613099486362791, 0.17491712345111177, 0.14727443514169458, 0.15863995756217375, 0.14491424645981532, 0.1318208056625384, 0.15236648320379664, 0.10614367920605017, 0.13307215986296272, 0.14250497166467468, 0.14321478858407188, 0.12334591915220083, 0.09241851043684945, 0.15010903046359148, 0.12687601877222077, 0.14001519535634854, 0.10048900562349539, 0.16206299031813653, 0.12399797467919726, 0.12724265335007312, 0.14952627653965045, 0.15180393460782549, 0.15127615579552423, 0.1470773590813491, 0.15756475620876076, 0.13726431161507424, 0.13875985395306056, 0.12167631412214064, 0.10603228942051734, 0.15109320415866567, 0.10850878887714277, 0.13344604939183968, 0.10631166736966369, 0.11211385147745401, 0.17942876136782437, 0.17779613103135927, 0.17245311779129258, 0.1803624197555953, 0.1784307358795224, 0.17374608891362298, 0.1923366374409664, 0.1807579820227122, 0.16374721089926514, 0.05060485826082406, 0.036886987871146415, 0.04771077093108411, 0.04203437922312969, 0.034393474380947864, 0.041748233664244294, 0.0525303142535718, 0.05893395832397075, 0.042542450886509875]}, "mutation_prompt": null}
{"id": "d6cb6c69-b8c5-4451-858a-d4c8a8b58432", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability * 0.8:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability * 0.9:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit * 0.8:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability * 0.7:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit * 0.7:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Probabilities and Hybrid Crossover-Mutation\"", "configspace": "", "generation": 94, "fitness": 0.08319337403742921, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.08.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.1755196566955648, 0.22055302637605234, 0.17181492226290773, 0.11999541120394319, 0.15548343673282794, 0.14139191294825726, 0.18463772200787998, 0.179533143994431, 0.15401670740686402, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06635878424948183, 0.020831310506332357, 0.045744830771131784, 0.028984869874216335, 0.03469141154407329, 0.028171758540946223, 0.03742327589505823, 0.04417523773271992, 0.03170229711942196, 0.020870716091286323, 0.02001421835788275, 0.049249710709286965, 0.03937988188439012, 0.024173529014204886, 0.026646752845947086, 0.037467204889376826, 0.019251929047934713, 0.013032441233601144, 0.23399917959761973, 0.15097796015943354, 0.2013632375206602, 0.13829417456380233, 0.13083414655190595, 0.11535502198520353, 0.12713368453194673, 0.668276413717453, 0.18508030834095512, 0.07925810439889935, 0.04683604079703185, 0.07274482564073148, 0.03839235296239296, 0.04427160623905746, 0.0541587681665866, 0.06131806559143682, 0.03404849421602152, 0.04695680151129378, 0.11907686279944119, 0.10700757241420089, 0.11360713239230169, 0.15985421801377053, 0.09484748890208305, 0.11575900580517118, 0.06428612828491076, 0.07048211941326132, 0.09019637922389101, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007186078722040801, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006668645959524655, 0.04236844599510836, 0.07099007799767965, 0.060324272595995154, 0.007449282318529593, 0.04643965635969616, 0.016296644420591866, 0.025447103322101206, 0.014587093370995174, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18896220560579335, 0.21702150663605813, 0.16350628898469732, 0.17151745626372417, 0.15664609503812665, 0.16052832645965665, 0.1788154916867819, 0.18014766122640735, 0.19592928733349801, 0.019331004123340656, 0.02485803046372581, 0.05395446528305403, 0.03266886175302153, 0.03688567657501629, 0.03266071598535669, 0.05094823462392595, 0.03167140430826898, 0.06519756652738617, 0.13643728238670993, 0.11638764877261187, 0.13949123580041545, 0.18158620654021063, 0.11277228368859327, 0.10840243057947996, 0.13680389858897346, 0.1238864155082674, 0.12800888592036463, 0.15959928227663, 0.14914356878817814, 0.1729563762549856, 0.1586412913837394, 0.13569915557936696, 0.13502878857530398, 0.1476175071541025, 0.17377774300845283, 0.16419137233244496, 0.11132660171145436, 0.0940746069806373, 0.10000473159488898, 0.09987051912350631, 0.09249852331865294, 0.1242588112622941, 0.09334433103513606, 0.0997711199450243, 0.08366651079377174, 0.1486681416362382, 0.13929815430961678, 0.14723946971701918, 0.15932679783995551, 0.14588556347224257, 0.1723194851613985, 0.16894558368044166, 0.1263469530575032, 0.14092266219762783, 0.1322157039571864, 0.15803721691339578, 0.13827736896153642, 0.13988531259728898, 0.018586637610242707, 0.1381075606413399, 0.1491853145677715, 0.10067488037975347, 0.13441848753938446, 0.14116835031046282, 0.11586836953787372, 0.11218578048601446, 0.15394453350804338, 0.12627851268718482, 0.16054813154163072, 0.12032112357192837, 0.11687669930432643, 0.15422517210554743, 0.13570981117017233, 0.12015411669842002, 0.13219234893804055, 0.17719739824304725, 0.07639313401664782, 0.10493064498910065, 0.10384265103248524, 0.11343148011732396, 0.13582628142512965, 0.18457901397461995, 0.19741213269582225, 0.16948946348415506, 0.1900456351797304, 0.168307018185736, 0.1780844262561726, 0.1806160751021929, 0.1822392200135532, 0.16842705802746805, 0.04104823443202188, 0.035702197000000546, 0.04200029967073349, 0.04759032835983912, 0.04446633249356746, 0.04366866584271245, 0.04459059600234594, 0.04174368883219792, 0.05123567008673402]}, "mutation_prompt": null}
{"id": "1413c4e9-98c4-47e6-ae3f-9c33a63b1069", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.4\n        self.mutation_probability = 0.4\n        self.crossover_mutation_probability = 0.6\n        self.quantum_bit = 0.4\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Probabilities\"", "configspace": "", "generation": 95, "fitness": 0.09286093754286266, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.10.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.1412959374024495, 0.14385743505228143, 0.18199418031813097, 0.1271325966447474, 0.14372535007153897, 0.1266866067621535, 0.1498897831736904, 0.12393281766643172, 0.13602117362791466, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031768772550973656, 0.028787696563636334, 0.056135971121588635, 0.040189502081631856, 0.03568484154271245, 0.03530536362558523, 0.03975627875942278, 0.06833094912577364, 0.029851278555535155, 0.02389151416348445, 0.018479375842587742, 0.030526759251480517, 0.027625949753451673, 0.019975994381767337, 0.021125232836789798, 0.049630065716768645, 0.012206596047709906, 0.03165378475628278, 0.3875842026213082, 0.15379103771783176, 0.5925614391914455, 0.7097990155925769, 0.11828345558381792, 0.4370533285710311, 0.16812280575421246, 0.5722673525910698, 0.5528541924866381, 0.09971094794252766, 0.05866426199329311, 0.06218372704886965, 0.09437422651310301, 0.04876111966158514, 0.07108925256211185, 0.03655112660555937, 0.08603295994720905, 0.062163183466930616, 0.10027683525177622, 0.11719340399259692, 0.10813391697786423, 0.0862770726475739, 0.11594785978946343, 0.07262864660342838, 0.096523978126693, 0.09756029471717143, 0.12150457017154237, 9.999999999998899e-05, 0.009741782569459012, 9.999999999998899e-05, 9.999999999998899e-05, 0.038553977431484254, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011968697743024448, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0785025078966306, 0.0385676429675923, 0.002604335618941356, 0.034771625108412585, 0.04053658888458833, 0.09841839031095367, 0.027640054455164265, 0.014477294900278825, 0.0276885942194689, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1816807338802836, 0.17428921734063385, 0.15233621472495473, 0.1917952176633957, 0.1505520133660817, 0.17235550229572705, 0.18217560042879755, 0.19603583248706702, 0.21008365192343847, 0.023976983852656453, 0.024200908322373316, 0.03882019795952385, 0.033798418386432605, 0.037371714232261155, 0.03303803731900312, 0.0457833669028862, 0.08797513746836172, 0.04110899382750577, 0.11992590072465759, 0.12361531329986775, 0.11842175776965747, 0.12054463649178648, 0.14555624566383485, 0.11624310567721985, 0.1319758015247029, 0.11277526031578433, 0.12584357320716277, 0.15259211860813449, 0.14440058988693927, 0.16304946447662638, 0.16516101181303566, 0.15273750292981336, 0.15402216502928856, 0.14568195981017484, 0.17377774300845283, 0.13702838352563063, 0.09150068827765556, 0.0861827762293026, 0.11526002792743151, 0.10087286340866608, 0.09471318315150568, 0.11256056880805976, 0.10408693948320491, 0.10875344045466173, 0.12891097055647238, 0.16740986226622134, 0.13853899801777447, 0.13803176467741518, 0.1403833640445007, 0.15649893973976814, 0.1489405899556725, 0.15918350410566817, 0.15106919526321216, 0.12867194035380125, 0.1412450474638446, 0.14492966100930338, 0.1290973228460902, 0.1448854910615508, 0.13868239959505224, 0.1414721143368748, 0.13682538911912157, 0.1314755110471949, 0.13333265412597117, 0.19807637723144955, 0.1259833120966759, 0.12886646440580973, 0.21517092696306162, 0.14398200010224316, 0.16069173667939085, 0.13539176137053333, 0.10534794045635465, 0.12093158051146147, 0.1350021008421587, 0.11488385916661448, 0.15069969541069972, 0.14849966212909327, 0.10216881617407303, 0.12888214377106522, 0.1234847699585977, 0.1111470313857249, 0.15106156085912847, 0.17649509447917677, 0.1918661885891515, 0.18761490584073148, 0.1744528303422792, 0.1846949009048341, 0.17663979431917343, 0.17879898202872568, 0.1744920322678858, 0.16900401369293505, 0.05281579550517035, 0.04625568763289489, 0.056839534781935264, 0.05027543438979343, 0.044010365431967124, 0.050175958452299496, 0.04045553029364202, 0.04293918262126939, 0.044463369037152756]}, "mutation_prompt": null}
{"id": "7683545d-62e0-46f6-b1df-dfc6c3048a14", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.4\n        self.mutation_probability = 0.3\n        self.crossover_mutation_probability = 0.2\n        self.quantum_bit = 0.4\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Probabilities\"", "configspace": "", "generation": 96, "fitness": 0.08414455560890416, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.08.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.15977281358599427, 0.13814187594412564, 0.1480273521631743, 0.1486104524657228, 0.15761945122616694, 0.1497371996316379, 0.1449776462150565, 0.17727751464923913, 0.1777879242585887, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03481510033473767, 0.027754794002932237, 0.03988316260216673, 0.0315339928344327, 0.04325029168384387, 0.0354582410618719, 0.03163950928275594, 0.04168541088605493, 0.031146123524255942, 0.015542389744503504, 0.0379920709851429, 0.04037633678127772, 0.023869057872679345, 0.015528979889572803, 0.014969576046175104, 0.026188973398280857, 0.026636162173712674, 0.016152271498071746, 0.1415460044848854, 0.7305264845547805, 0.0894351356391686, 0.11163788908397965, 0.28158046874085585, 0.3724835140925151, 0.1099396875092642, 0.12285581679785373, 0.14734853566021267, 0.06274794416174423, 0.06505664974453651, 0.05092101086465428, 0.0695921087811967, 0.07433623554810542, 0.04376793150496394, 0.0524870959823458, 0.052055888575467724, 0.03805489378957028, 0.1659499350614011, 0.15295141941666712, 0.08288377305054218, 0.15983875844357298, 0.1012789829455022, 0.0957008074725536, 0.1094101152213065, 0.06791645575835059, 0.10065962010557328, 0.00310111487439102, 9.999999999998899e-05, 9.999999999998899e-05, 0.011592579315070961, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012218005082813566, 9.999999999998899e-05, 0.03304717945735447, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03767454269548565, 0.00718343076273964, 0.007979609403614085, 0.03484472787244064, 0.040804269544510996, 0.07831200437481689, 0.009916613494926563, 0.016418842579918214, 0.02909834368721753, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16538723654327547, 0.1704876128299322, 0.18240584259876524, 0.14807779210929073, 0.16791861110193151, 0.18427425897560445, 0.19087152935959595, 0.1593737059043242, 0.17450692994774852, 0.025087675871801385, 0.0239840077982586, 0.034085865965765016, 0.04431348422659542, 0.04519426605929544, 0.045998688243338415, 0.02962490523798811, 0.043459231688129374, 0.05820596687136326, 0.1136842332046768, 0.13097808365995933, 0.11842175776965747, 0.13323797863725484, 0.12463032250127304, 0.13122669580525204, 0.12264446951934238, 0.1297553012840026, 0.13579038022135415, 0.15131730780626806, 0.1434052387887057, 0.1613932299901245, 0.1422908114701621, 0.1625178910199112, 0.1569474963331977, 0.1648959161448572, 0.17377774300845283, 0.15246500770797689, 0.09707865507776237, 0.09027518600455187, 0.08398582550377798, 0.0983285112715292, 0.10020228784286977, 0.09810955838887003, 0.09650008627123263, 0.1350501947329158, 0.09999611385627982, 0.1384404901637316, 0.14595512530197907, 0.1714640656255375, 0.14705196154294609, 0.13302727713518558, 0.15044179269229752, 0.15005088489451301, 0.13756484726747953, 0.14627801430927412, 0.15175234785806024, 0.03583825139132546, 0.1218272800521778, 0.06330005394270066, 0.14252009834892376, 0.13178875946252921, 0.14071079353231397, 0.12311334261757023, 0.07997208161663016, 0.14926936920495903, 0.2552146915897414, 0.12093900767347476, 0.1353963859311229, 0.16566524563978924, 0.1491465017956054, 0.14731838809287034, 0.14972600104734424, 0.1212794355463529, 0.11040265245322212, 0.17976168151250183, 0.08708836637182615, 0.11475141325380012, 0.10509159089074505, 0.16395650208384016, 0.16793886012653625, 0.12252739934198376, 0.11745297636798024, 0.18716584110638168, 0.16765280803492733, 0.206816753090017, 0.17316206380560384, 0.16937577410911542, 0.17289430901409364, 0.16486677507259062, 0.18510712871462243, 0.16781970444980687, 0.04176197002806881, 0.035962385749218284, 0.054907472237136656, 0.09106608484197609, 0.04117097602063646, 0.04140360219034045, 0.06399617126500923, 0.03803354422653826, 0.05033991942860716]}, "mutation_prompt": null}
{"id": "20e3f60a-5cef-45ea-9dab-5b96bac281b1", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.5\n        self.mutation_probability = 0.5\n        self.crossover_mutation_probability = 0.5\n        self.quantum_bit = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)\n\n# Refine the strategy\noptimizer.crossover_probability = 0.5\noptimizer.mutation_probability = 0.5\noptimizer.crossover_mutation_probability = 0.5\noptimizer.quantum_bit = 0.5\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Probabilities\" using probability 0.5", "configspace": "", "generation": 97, "fitness": 0.08897282465611273, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.08.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.18791596672340583, 0.1547729227977639, 0.1438929813964578, 0.13064309284434183, 0.1440060189738489, 0.13829115375144252, 0.13273139757079988, 0.14743324828799376, 0.14288227578712032, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.046022945396278936, 0.03422928215860588, 0.0370760964140594, 0.04516931946715175, 0.035038777046061065, 0.035596385712654, 0.042678746130034195, 0.04664538316231115, 0.024724055890461005, 0.028545283483144113, 0.041086998237699124, 0.025795204705021946, 0.03044678817094104, 0.02903223790560283, 0.012224899964303537, 0.033343791108861986, 0.03410683011778837, 0.020780251559238017, 0.150643027430154, 0.48044162612789765, 0.14661036939279037, 0.22815462799721764, 0.11390018057756002, 0.3934148826207905, 0.5467512669182155, 0.32723109182009325, 0.2674592223040958, 0.0753781461360239, 0.06150601018867907, 0.10207544840899141, 0.054799046611462066, 0.03811649769471137, 0.06467527304551646, 0.08211179125112555, 0.05543698840584088, 0.041502778303901366, 0.13621363557484167, 0.10246890593157354, 0.10938172202475949, 0.097467203828699, 0.09319059175666877, 0.08591097004617299, 0.14201984539345025, 0.14111003065644012, 0.12704495723610398, 9.999999999998899e-05, 0.0114779101380591, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004069095773715836, 0.001654348050506127, 0.036413417692740535, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.018474195171168994, 0.047422555835568536, 0.01442397256200545, 0.02115688376691427, 0.04486631631011895, 0.007786882958699781, 0.0006707122980371683, 0.03254308624252156, 0.040913844591930815, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18749428013814218, 0.17821415910560678, 0.19009120053700557, 0.17576806933143874, 0.15680275736582483, 0.20462941428641424, 0.21363191874783816, 0.1941994410511242, 0.162302144415711, 0.02768028364108155, 0.024906125609467034, 0.03589971791723179, 0.03295616098048981, 0.02625486283399603, 0.05417178404125078, 0.0434305747837016, 0.03670463413731073, 0.051802026243333965, 0.13623629558666583, 0.12275710360106984, 0.11842175776965747, 0.14648561121617953, 0.1185010646704413, 0.12079593452225612, 0.1059611963124002, 0.13098612376532182, 0.1271983740737196, 0.1504908284687333, 0.1395972297704371, 0.1613932299901245, 0.14399051030669507, 0.14815261563101745, 0.17384394909485312, 0.15061394803525163, 0.17377774300845283, 0.15466307779692323, 0.09059435874512856, 0.1216918385530622, 0.08398582550377798, 0.10413025243636553, 0.09867145434027969, 0.11306565953356262, 0.08624593981807083, 0.0997711199450243, 0.11175358042411876, 0.1562853125477326, 0.12597235927647765, 0.15197617964869603, 0.14049496184709276, 0.13562224300908587, 0.18386012053995682, 0.14623643130791242, 0.13668458099677228, 0.1770852524596721, 0.13617374031791718, 0.134442547377839, 0.14715880839963325, 0.13464131290819037, 0.13099738867601995, 0.16143671026739814, 0.14416975872372662, 0.1323248442248327, 0.13407301643476333, 0.19452158505023331, 0.1567164670622755, 0.1335152660111255, 0.14641373626194987, 0.13391804036830546, 0.1166368235652977, 0.16120894293835697, 0.15833488454503708, 0.16125423808897543, 0.12644066940008847, 0.11487939595313479, 0.15101762567281352, 0.22056497276461373, 0.10455380357304889, 0.1572964450709773, 0.0941808507064179, 0.17807013826312745, 0.15745633519625024, 0.16094996408682605, 0.1818993922741663, 0.21515713253120206, 0.1673921739727532, 0.16476288436101116, 0.17967462593839023, 0.18647156066439552, 0.18404981287501454, 0.1819846086910063, 0.04777623636621009, 0.048566662782237424, 0.043909286723459284, 0.045160793322920334, 0.04254233955304554, 0.043068496867325834, 0.048486899498711655, 0.04460581269792674, 0.04733778113228326]}, "mutation_prompt": null}
{"id": "fee4209a-d679-4ee4-b0b7-a7c246a7eafa", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.3\n        self.mutation_probability = 0.3\n        self.crossover_mutation_probability = 0.2\n        self.quantum_bit = 0.3\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Probabilities and Enhanced Mutation\"", "configspace": "", "generation": 98, "fitness": 0.07817672316172224, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.07.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.1689188536757722, 0.15763934241063504, 0.1367535209181464, 0.18275338771370986, 0.15555605358112445, 0.14810304793664564, 0.1844529772416239, 0.13769506591597636, 0.1328052362760438, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029623241936334144, 0.05585789525447271, 0.02642850340863112, 0.03449074364965432, 0.05423552752485661, 0.02755403051479066, 0.04600650880895263, 0.02536523043469785, 0.04085742193839448, 0.023475688265816474, 0.007088950978897501, 0.019241501659026272, 0.02665324618595355, 0.022075884382279587, 0.012503887823990367, 0.0339655429709379, 0.043109104135537035, 0.017358039762863653, 0.10007587585902189, 0.10189929222130756, 0.08858311820165343, 0.22957670678427022, 0.09832662717444896, 0.0925686459907682, 0.09679537573088781, 0.10125392163292213, 0.10634927127053628, 0.06956470770114465, 0.0685503163668858, 0.08685531827253767, 0.03336821779216992, 0.05335536482471903, 0.06451729567428044, 0.02856218939872035, 0.02874228289266534, 0.051312533615354594, 0.11248902914638714, 0.09356569974226225, 0.11078074670736826, 0.08511711816640277, 0.08839546973492107, 0.0784663077348241, 0.10226222853281308, 0.13314799263420796, 0.09883385837208714, 0.0057821089980075735, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005772587980263366, 0.0027285671024041003, 9.999999999998899e-05, 9.999999999998899e-05, 0.010719757140186248, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011558665738537255, 0.024003225935831374, 0.026578808989969227, 0.04124739609980965, 0.00039176650990724315, 0.06755133986279815, 0.032387837874104486, 0.015841366083229502, 0.022155195299189856, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16141760862615173, 0.19998294634265457, 0.17686703078809873, 0.1711820664371586, 0.1729569001687985, 0.17019498406189337, 0.1744423306276629, 0.18411682352197867, 0.19164278342639274, 0.03702698470368082, 0.026080744147790602, 0.032865265405481514, 0.0426352007131634, 0.04231934164798512, 0.040275714008089936, 0.039280923367500664, 0.04038380055855795, 0.04155030078282851, 0.15335010616864597, 0.1108169207325862, 0.15321678799989857, 0.11640912947439797, 0.12453856358513316, 0.12306767806367314, 0.13703501021815734, 0.1243878306928542, 0.11501911661104935, 0.14035699577556204, 0.15179702095232694, 0.1613932299901245, 0.1396365070058848, 0.14308094272054894, 0.16259066855922233, 0.15265351291830653, 0.17377774300845283, 0.14815918316351107, 0.08502710155725723, 0.0826717572416299, 0.08467066698923553, 0.10703706127418244, 0.08846676163437528, 0.10559807308868496, 0.0907134616222044, 0.11379160382802944, 0.09114732959646354, 0.14224177489574008, 0.1422341426174487, 0.17233257468634222, 0.1582794735799513, 0.1546248001110132, 0.14125144265648104, 0.1464575022594916, 0.15041735698043102, 0.1384336511771468, 0.1474148461506205, 0.12249668059114649, 0.1651483037507585, 0.14466201629386155, 0.12431614223795517, 0.11557452553927428, 0.13653756327565403, 0.018861093441614463, 0.1443644423857373, 0.1580436636733331, 0.13722090019648858, 0.11713496658103884, 0.15991772028078155, 0.12294177032005804, 0.153483971154181, 0.13072032426759028, 0.15209192405472227, 0.13092278966987525, 0.16351349215121758, 0.14595031884357612, 0.15240707061134984, 0.12264565765784663, 0.1386057801596613, 0.13315481530876838, 0.113630804417165, 0.1170804578236948, 0.11923670907442208, 0.1780337464176206, 0.19058725185134362, 0.1771878185820689, 0.17837094170007373, 0.16941615280936584, 0.16642190721821737, 0.186242966520897, 0.2028188186012193, 0.17196156544176666, 0.03430415261419517, 0.04296140286167105, 0.04130865674495676, 0.03574933486022913, 0.04042161314219428, 0.04868336131483342, 0.04416909622211351, 0.04726117515705486, 0.044685687091906456]}, "mutation_prompt": null}
{"id": "02411c84-f9dd-4e11-97e4-9b40f14e6682", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmQIO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.particles = []\n        self.best_particles = []\n        self.crossover_probability = 0.4\n        self.mutation_probability = 0.4\n        self.crossover_mutation_probability = 0.6\n        self.quantum_bit = 0.5\n        self.pbest = np.full((self.swarm_size, self.dim), -np.inf)\n        self.gbest = np.full(self.dim, -np.inf)\n        self.count = 0\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            for _ in range(self.swarm_size):\n                particle = np.random.uniform(-5.0, 5.0, self.dim)\n                self.particles.append(particle)\n\n            for i in range(self.swarm_size):\n                particle = self.particles[i]\n                # Evaluate the function\n                fitness = func(particle)\n\n                # Update the best particle\n                if fitness < self.pbest[i, 0]:\n                    self.pbest[i, :] = particle\n                    self.gbest = np.copy(particle)\n\n                # Update the particle\n                if random.random() < self.crossover_probability:\n                    # Crossover\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.7:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n\n                if random.random() < self.mutation_probability:\n                    # Mutation\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                if random.random() < self.crossover_mutation_probability:\n                    # Crossover-mutation hybrid\n                    new_particle = np.copy(particle)\n                    for j in range(self.dim):\n                        if random.random() < 0.8:\n                            new_particle[j] += np.random.uniform(-1, 1)\n                    self.particles[i] = new_particle\n                    self.particles[i] += np.random.uniform(-0.05, 0.05, self.dim)\n                    # Apply quantum bit flip\n                    for j in range(self.dim):\n                        if random.random() < self.quantum_bit:\n                            self.particles[i][j] *= -1\n\n                # Update the best particles\n                for j in range(self.dim):\n                    if self.pbest[i, j] > self.gbest[j]:\n                        self.pbest[i, j] = self.gbest[j]\n\n            # Update the best particles\n            for i in range(self.swarm_size):\n                self.best_particles.append(self.pbest[i, :])\n\n        # Return the best particle\n        return self.best_particles[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\noptimizer = MultiSwarmQIO(budget, dim)\nbest_solution = optimizer(func)\nprint(\"Best solution:\", best_solution)", "name": "MultiSwarmQIO", "description": "Novel \"Multi-Swarm Quantum Inspired Optimization with Adaptive Crossover, Mutation, and Crossover-Mutation Probabilities\"", "configspace": "", "generation": 99, "fitness": 0.09649459707296038, "feedback": "The algorithm MultiSwarmQIO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.11.", "error": "", "parent_id": "46b5ba1b-ded6-43dc-9b36-8382ba3828ba", "metadata": {"aucs": [0.16907029216580372, 0.15296638285816022, 0.17066791727528674, 0.14095096023571418, 0.14791598749545953, 0.1606300474635025, 0.15698034769220226, 0.12668606234728197, 0.15882829879878568, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04560350634657806, 0.030969124692022287, 0.03644765326103383, 0.040145460149274004, 0.026374330230461207, 0.040290914064843864, 0.0343044213465713, 0.04233688451284434, 0.0347032914123262, 0.027097312822439212, 0.024565659766658254, 0.04634320481024645, 0.04464444979887361, 0.022267196795315414, 0.04166491069845901, 0.03285479223664456, 0.029833350488027044, 0.014630712333114193, 0.2683487484009206, 0.2802439850242411, 0.8024434927445541, 0.3632933527183434, 0.5142116293621566, 0.3538193294761769, 0.7495875836234123, 0.5631740998504924, 0.42429827213226035, 0.06656691485277355, 0.05971502411562324, 0.08123435905532461, 0.06152203709896509, 0.051596384507406556, 0.08553773243188312, 0.025988442229726738, 0.07215987467901508, 0.05791749539444535, 0.10636830117534157, 0.11860570701039053, 0.1167320524117289, 0.09287243338754192, 0.10926373157972469, 0.09506450250439791, 0.11653635209003299, 0.09443031599083973, 0.1002170928786601, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0018575006582832732, 9.999999999998899e-05, 0.006495898389173416, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000540861412324789, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006603513200816424, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0342088697857682, 0.036654868686149755, 0.041507928515595816, 0.031544526446528276, 0.003377181416271191, 0.030144084310590236, 0.05039604323280966, 0.01739994081678764, 0.07460422945668121, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17613978776674355, 0.20615162407366705, 0.16756349716658858, 0.18056576962823967, 0.16747151523286008, 0.18541459394022264, 0.17371702225937047, 0.16993668807556916, 0.19956001640825594, 0.03151536359260987, 0.018645660522332963, 0.044456623966575015, 0.050437563556717024, 0.027151734146129147, 0.03774778672384893, 0.02750709095539039, 0.05343987598849076, 0.03013016314657746, 0.10791977303553735, 0.11155267435449823, 0.14252513628142627, 0.11477120026418619, 0.12766994176381463, 0.11679637956206479, 0.13754081632518989, 0.10097924398559133, 0.1381833540479238, 0.15701026031802034, 0.15003297679624006, 0.1613932299901245, 0.1632444558630658, 0.18111633816370576, 0.15013864207835237, 0.16099093873628334, 0.17930739067017187, 0.15072426055857036, 0.09150355652807995, 0.0910004092110781, 0.08435092291488877, 0.09259237987082813, 0.12211088996037922, 0.09905404795493467, 0.10944686235879986, 0.10918708906729158, 0.10589568242953551, 0.1518970620964175, 0.13628643049396594, 0.1418633358963436, 0.1629841887475748, 0.15886356623975373, 0.1597236243622301, 0.15875979939411045, 0.1692651397973457, 0.13426193431911015, 0.13399445837790336, 0.13962739420056514, 0.13163369406973047, 0.1773365524132401, 0.11401943687695382, 0.14676275497528168, 0.14273893562023243, 0.1230164681636916, 0.14851655289366283, 0.15181172417812738, 0.11661188983377146, 0.12408229226349343, 0.1799660463996381, 0.1207914665021157, 0.1574018662541954, 0.1330028971123577, 0.16134872303977432, 0.1939475130373366, 0.11343898780621697, 0.12843739160392875, 0.15991224941014903, 0.2002404077845754, 0.11087207228091378, 0.11150972323228847, 0.1493607968064814, 0.1134715478482845, 0.10113345231961468, 0.18441484136552266, 0.19982020596228378, 0.17087886034514232, 0.17840502824929116, 0.20675874952734585, 0.174213489085296, 0.16253013149125128, 0.18230167949899245, 0.18422041107817166, 0.0499666780464868, 0.0411907801296153, 0.04526260159868145, 0.05678616921066881, 0.06370227629187919, 0.05706488325897885, 0.04311849862341133, 0.042796478761344736, 0.06405943319084217]}, "mutation_prompt": null}
