{"id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 56, in evaluateBBOB\nAttributeError: 'ExperimentLogger' object has no attribute 'population_size'\n.", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 56, in evaluateBBOB\nAttributeError: 'ExperimentLogger' object has no attribute 'population_size'\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "25912508-7dfc-4233-97cd-e90415d19a7a", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.adaptation_threshold = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Adaptation\n                for i in range(self.num_particles):\n                    if random.random() < self.adaptation_threshold:\n                        # Select a random particle\n                        j = random.randint(0, self.num_particles - 1)\n\n                        # Update pbest and gbest\n                        if values[i] < self.pbest[j, 0]:\n                            self.pbest[j, :] = particles[i, :]\n                        if values[i] < self.gbest[0]:\n                            self.gbest[:] = particles[i, :]\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "c05e7d4f-3bf5-45a1-957c-7ba9c387b004", "solution": "import numpy as np\nimport random\nimport operator\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.hybridization_rate = 0.2\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                    # Hybridization\n                    if random.random() < self.hybridization_rate:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Select a random operator\n                        op = random.choice([operator.add, operator.sub, operator.mul, operator.truediv])\n\n                        # Apply the operator\n                        child = op(particles[i, :], particles[j, :])\n\n                        # Ensure the child is within the bounds\n                        child = np.clip(child, self.lower_bound, self.upper_bound)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Hybridization\" algorithm", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "a17f2309-293d-4529-a45a-17975ab27da9", "solution": "import numpy as np\nimport random\nfrom deap import base, creator, tools, algorithms\n\nclass MultiObjectiveParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim, 2))\n        self.gbest = np.zeros(self.dim)\n        self.individuals = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitnesses = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            self.individuals = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n            self.fitnesses = np.zeros(self.population_size)\n            self.pbest = np.zeros((self.population_size, self.dim, 2))\n            self.gbest = np.zeros(self.dim)\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                for i in range(self.population_size):\n                    values = func(self.individuals[i, :])\n                    self.fitnesses[i] = values[0]\n                    self.pbest[i, :, 0] = self.individuals[i, :]\n                    self.pbest[i, :, 1] = values[1]\n\n                # Update pbest and gbest\n                for i in range(self.population_size):\n                    if self.fitnesses[i] < self.pbest[i, 0, 0]:\n                        self.pbest[i, :, 0] = self.individuals[i, :]\n                        self.pbest[i, :, 1] = self.fitnesses[i]\n                    if self.fitnesses[i] < self.gbest[0]:\n                        self.gbest[:] = self.individuals[i, :]\n\n                # Crossover and mutation\n                for i in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.population_size - 1)\n                        k = random.randint(0, self.population_size - 1)\n\n                        # Crossover\n                        child = (self.individuals[i, :] + self.individuals[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        self.individuals[i, :] = child\n\n            # Return the best solution\n            return self.gbest\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2, x[0]**2 + x[1]**2\n\noptimizer = MultiObjectiveParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "MultiObjectiveParticleSwarmOptimization", "description": "Novel \"Multi-Objective Particle Swarm Optimization with Crossover and Mutation\"", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "ae358113-642f-4101-890f-77e30c28c83a", "solution": "import numpy as np\nimport random\n\nclass AdaptiveCrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.hybrid_probability = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Hybrid evolution\n                        if random.random() < self.hybrid_probability:\n                            # Select a random particle\n                            hybrid_particle = particles[random.randint(0, self.num_particles - 1), :]\n                            # Add a small random perturbation to the child\n                            child += np.random.uniform(-0.1, 0.1, self.dim)\n                            # Replace the child with the hybrid particle\n                            particles[i, :] = hybrid_particle\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = AdaptiveCrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "AdaptiveCrossoverParticleSwarmOptimization", "description": "Novel \"Adaptive Crossover-Particle Swarm Optimization with Hybrid Evolution\"", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "cea2e622-7076-429b-87dc-c420263ec01b", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.pbest_history = []\n        self.gbest_history = []\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Update pbest and gbest history\n                self.pbest_history.append(self.pbest)\n                self.gbest_history.append(self.gbest)\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "c70fb8ff-9425-4f8e-8071-a4aa4d5ef934", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.evolution_rate = 0.5\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n            self.pbest = np.copy(self.population)\n            self.gbest = np.copy(self.population[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(self.population)\n\n                # Update pbest and gbest\n                for i in range(self.population_size):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = self.population[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = self.population[i, :]\n\n                # Crossover and mutation\n                for i in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.population_size - 1)\n                        k = random.randint(0, self.population_size - 1)\n\n                        # Crossover\n                        child = (self.population[i, :] + self.population[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        self.population[i, :] = child\n\n                # Evolution\n                for i in range(self.population_size):\n                    if random.random() < self.evolution_rate:\n                        # Replace particle with a new random solution\n                        self.population[i, :] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Evolution\" algorithm", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "3aaaa436-26f6-4b9c-aa6e-177a8aab0b81", "solution": "import numpy as np\nimport random\n\nclass AdaptiveCrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.differential_evolution_probability = 0.5\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Differential evolution\n                for i in range(self.num_particles):\n                    if random.random() < self.differential_evolution_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Calculate difference vector\n                        diff = particles[j, :] - particles[i, :]\n\n                        # Calculate trial vector\n                        trial = particles[i, :] + diff * np.random.uniform(0.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = trial\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = AdaptiveCrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "AdaptiveCrossoverParticleSwarmOptimization", "description": "Novel \"Adaptive Crossover-Particle Swarm Optimization with Differential Evolution\"", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "be697cf1-d601-4d77-a247-1eb8abb9f944", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.refine_probability = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle with refined version\n                        if random.random() < self.refine_probability:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm with probabilistic refinement.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "25fa7bab-ec23-4767-8fc9-74e5eb87f731", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.5\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "fca9f03e-770e-4f69-9eea-22e9e20cf9c5", "solution": "import numpy as np\nimport random\nimport copy\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.stochastic_search_rate = 0.5\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle with a stochastic search\n                        if random.random() < self.stochastic_search_rate:\n                            new_individual = self.evaluate_fitness(particles[i, :])\n                            particles[i, :] = new_individual\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n    def evaluate_fitness(self, individual):\n        # Evaluate the fitness of the individual\n        # This function should be implemented based on the specific problem\n        # For example, for the BBOB test suite, you can use the following function\n        def func(x):\n            return x[0]**2 + x[1]**2\n\n        return func(individual)\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Stochastic Search\"", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "34ee4ed3-9427-430a-aee2-4f2b6d3c4986", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "490997ee-8597-409a-aeec-8b52f0ce0754", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n            self.pbest = np.copy(self.population)\n            self.gbest = np.copy(self.population[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(self.population)\n\n                # Update pbest and gbest\n                for i in range(self.population_size):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = self.population[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = self.population[i, :]\n\n                # Crossover and mutation\n                for i in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.population_size - 1)\n                        k = random.randint(0, self.population_size - 1)\n\n                        # Crossover\n                        child = (self.population[i, :] + self.population[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        self.population[i, :] = child\n\n            # Update the best solution\n            self.gbest = np.copy(self.population[np.argmin(np.min(self.population, axis=0))])\n\n        # Return the best solution\n        return self.gbest\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "ad6a18d7-65bf-45a4-8539-1ae5e0317449", "solution": "import numpy as np\nimport random\nimport math\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.pbest_update_rate = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Update pbest\n                for i in range(self.population_size):\n                    if random.random() < self.pbest_update_rate:\n                        self.pbest[i, :] = particles[i, :]\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "6b1f423d-53bd-4d43-94b5-cccc8f084d7f", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.mutation_probability = 0.2\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.crossover_mask = np.ones((self.population_size, self.num_particles), dtype=bool)\n        self.mutation_mask = np.ones((self.population_size, self.num_particles), dtype=bool)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.population_size):\n                    for j in range(self.num_particles):\n                        if self.crossover_mask[i, j]:\n                            # Select two particles\n                            k = random.randint(0, self.num_particles - 1)\n                            l = random.randint(0, self.num_particles - 1)\n\n                            # Crossover\n                            child = (particles[i, :] + particles[k, :]) / 2\n                            if random.random() < self.adaptation_rate:\n                                child += np.random.uniform(-1.0, 1.0, self.dim)\n                            if random.random() < self.mutation_probability:\n                                child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                            # Replace particle\n                            particles[i, :] = child\n\n                            # Update crossover mask\n                            self.crossover_mask[i, j] = False\n                            self.crossover_mask[i, k] = False\n\n                        if self.mutation_mask[i, j]:\n                            # Mutation\n                            child = particles[i, :]\n                            if random.random() < self.adaptation_rate:\n                                child += np.random.uniform(-1.0, 1.0, self.dim)\n                            if random.random() < self.mutation_probability:\n                                child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                            # Replace particle\n                            particles[i, :] = child\n\n                            # Update mutation mask\n                            self.mutation_mask[i, j] = False\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Mutation Probability\"", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "969e51b6-d923-4bb8-b775-afbc1347417b", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "27b0a861-ebcb-491d-b04c-8350e02ec79d", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.5\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if self.pbest[i, 0] > self.gbest[0]:\n                        self.gbest[:] = self.pbest[i, :]\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "4a08f187-b571-40b0-85c7-5f90b0423339", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryDecompositionParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.decomposition_size = 10\n        self.decomposition_rate = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Decompose particles\n                decomposed_particles = []\n                for i in range(self.num_particles):\n                    if random.random() < self.decomposition_rate:\n                        decomposition = np.random.uniform(self.lower_bound, self.upper_bound, (self.decomposition_size, self.dim))\n                        decomposed_particles.append(decomposition)\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + decomposed_particles[j][0, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n        # Return the best solution\n        return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = EvolutionaryDecompositionParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "EvolutionaryDecompositionParticleSwarmOptimization", "description": "Novel \"Evolutionary Decomposition of Particle Swarm Optimization\" algorithm", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "cf113880-ce9d-46b0-9122-b875e0fed8af", "solution": "import numpy as np\nimport random\nimport operator\n\nclass MultiObjectiveEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.mutate_probability = 0.2\n        self.mutation_range = 1.0\n        self.fitness_values = np.zeros((self.num_particles, self.dim))\n        self.pbest = np.zeros((self.num_particles, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.fitness_values = np.zeros((self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update fitness values\n                for i in range(self.num_particles):\n                    for j in range(self.dim):\n                        self.fitness_values[i, j] = values[i, j]\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    for j in range(self.dim):\n                        if self.fitness_values[i, j] < self.pbest[i, j]:\n                            self.pbest[i, :] = particles[i, :]\n                        if self.fitness_values[i, j] < self.gbest[0]:\n                            self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.mutate_probability:\n                            child += np.random.uniform(-self.mutation_range, self.mutation_range, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = MultiObjectiveEvolutionaryAlgorithm(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "MultiObjectiveEvolutionaryAlgorithm", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Adaptive Crossover\" algorithm", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "34c747d0-2ed6-47ad-bfbf-bbe088e1c72d", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.hybridization_rate = 0.5\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.hybridized_particles = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Hybridize particles\n            for i in range(self.num_particles):\n                if random.random() < self.hybridization_rate:\n                    self.hybridized_particles[i, :] = (self.pbest[i, :] + self.gbest) / 2\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (self.hybridized_particles[i, :] + self.hybridized_particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Hybridization\" algorithm", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "e572a3b8-63f3-45c6-b030-ff17284b35fa", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.pbest_history = []\n        self.gbest_history = []\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Store pbest and gbest history\n                self.pbest_history.append(self.pbest.copy())\n                self.gbest_history.append(self.gbest.copy())\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "55a72379-88a8-4fbb-8c5a-ce494161f275", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.5\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.pbest_history = []\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Store pbest history\n                self.pbest_history.append(self.pbest)\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "da96c22f-fb10-4fca-a277-c01524bf6286", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryTreeBasedOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_iterations = self.budget\n        self.tree_size = 20\n        self.branching_probability = 0.5\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.tree = np.zeros((self.population_size, self.tree_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize tree\n            for i in range(self.population_size):\n                self.tree[i, 0, :] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.pbest[i, :] = self.tree[i, 0, :]\n                self.gbest[:] = self.tree[i, 0, :]\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate tree\n                values = func(self.tree)\n\n                # Update pbest and gbest\n                for i in range(self.population_size):\n                    if values[i, 0] < self.pbest[i, 0]:\n                        self.pbest[i, :] = self.tree[i, 0, :]\n                    if values[i, 0] < self.gbest[0]:\n                        self.gbest[:] = self.tree[i, 0, :]\n\n                # Branching and mutation\n                for i in range(self.population_size):\n                    if random.random() < self.branching_probability:\n                        # Select parent\n                        parent = random.randint(0, self.population_size - 1)\n\n                        # Select child\n                        child = np.random.choice([0, 1])\n\n                        # Create new branch\n                        self.tree[i, child, :] = (self.tree[parent, 0, :] + self.tree[i, 0, :]) / 2\n                        if random.random() < self.mutation_rate:\n                            self.tree[i, child, :] += np.random.uniform(-1.0, 1.0, self.dim)\n\n                    # Mutation\n                    if random.random() < self.mutation_rate:\n                        self.tree[i, 0, :] += np.random.uniform(-1.0, 1.0, self.dim)\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = EvolutionaryTreeBasedOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "EvolutionaryTreeBasedOptimization", "description": "Novel \"Evolutionary Tree-Based Optimization with Adaptive Branching\" algorithm", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "c4dabc3d-c74c-4122-908d-bb3aced24850", "solution": "import numpy as np\nimport random\nimport math\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.differential_evolution_probability = 0.5\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.pbest_history = np.zeros((self.population_size, self.dim))\n        self.pbest_history_count = 0\n        self.pbest_history_best = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Differential evolution\n                for i in range(self.num_particles):\n                    if random.random() < self.differential_evolution_probability:\n                        # Select three particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n                        l = random.randint(0, self.num_particles - 1)\n\n                        # Calculate differential evolution\n                        diff = particles[k, :] - particles[j, :]\n                        child = particles[i, :] + self.differential_evolution_probability * diff\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Update pbest history\n            if self.pbest_history_count < self.population_size:\n                self.pbest_history[self.pbest_history_count, :] = self.pbest[self.pbest_history_count, :]\n                self.pbest_history_count += 1\n                if np.any(self.pbest[self.pbest_history_count - 1, :] < self.pbest_history[self.pbest_history_count - 1, :]):\n                    self.pbest_history_best[:] = self.pbest[self.pbest_history_count - 1, :]\n                    self.pbest_history_best_count += 1\n\n            # Check for convergence\n            if self.pbest_history_best_count > 10:\n                self.pbest_history_best_count = 0\n\n        # Return the best solution\n        return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Differential Evolution\"", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "637dae87-87c8-4a9d-8b18-523550de56e8", "solution": "import numpy as np\nimport random\n\nclass HybridCrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.hybridization_rate = 0.5\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.previous_pbest = np.zeros((self.population_size, self.dim))\n        self.previous_gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Hybridize with previous best\n                        if random.random() < self.hybridization_rate:\n                            child = (self.previous_pbest[i, :] + self.previous_gbest) / 2\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Update previous best\n                self.previous_pbest = np.copy(self.pbest)\n                self.previous_gbest = np.copy(self.gbest)\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = HybridCrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "HybridCrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Hybridization\"", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "af879c4d-5f95-446f-b04f-16003c1232a5", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle with probability 0.5\n                        if random.random() < 0.5:\n                            particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "aa847e21-2f41-4cd1-a7cd-74f05db7b999", "solution": "import numpy as np\nimport random\n\nclass DifferentialAdaptiveParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.5\n        self.adaptation_rate = 0.1\n        self.differential_rate = 0.2\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.differential_matrix = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Differential update\n                for i in range(self.num_particles):\n                    if random.random() < self.differential_rate:\n                        j = random.randint(0, self.num_particles - 1)\n                        self.differential_matrix[i, :] = particles[j, :] - particles[i, :]\n\n                # Crossover\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + self.differential_matrix[j, :] + self.pbest[j, :]) / 3\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = DifferentialAdaptiveParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "DifferentialAdaptiveParticleSwarmOptimization", "description": "Novel \"Differential-Adaptive-Particle Swarm Optimization with Crossover\" algorithm", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "1258a4e9-2867-4422-bc74-99f4dd7e7c04", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Update gbest\n            self.gbest = np.min(self.pbest, axis=0)\n\n        # Return the best solution\n        return self.gbest\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "61fbec4e-1c1e-454d-99f9-e1d50ed0e39e", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Adaptation\n                for i in range(self.num_particles):\n                    if random.random() < 0.5:\n                        self.pbest[i, :] = particles[i, :]\n                        self.gbest[:] = particles[i, :]\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "52e06aaa-a39b-4642-9995-c480ee897cd1", "solution": "import numpy as np\nimport random\n\nclass AdaptiveCrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.es_probability = 0.5\n        self.es_mutation_rate = 0.1\n        self.es_bounds = (self.lower_bound, self.upper_bound)\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.es_history = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(*self.es_bounds)\n                            if random.random() < self.es_probability:\n                                child += np.random.uniform(-self.es_bounds[1], self.es_bounds[1], self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Evolutionary strategy\n                if random.random() < self.es_probability:\n                    # Select a particle\n                    i = random.randint(0, self.num_particles - 1)\n\n                    # Evaluate the particle\n                    values = func(particles[i, :])\n\n                    # Update the ES history\n                    self.es_history[i, :] = particles[i, :]\n\n                    # Calculate the ES update\n                    es_update = np.mean(self.es_history, axis=0) - np.mean(particles[i, :])\n\n                    # Update the particle\n                    particles[i, :] += es_update * self.es_mutation_rate\n\n                    # Update the pbest and gbest\n                    if values < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = AdaptiveCrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "AdaptiveCrossoverParticleSwarmOptimization", "description": "Novel \"Adaptive Crossover-Particle Swarm Optimization with Evolutionary Strategies\"", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "393d16a7-f69e-47cb-acc0-17859cc8c308", "solution": "import numpy as np\n\nclass DifferentialEvolutionWithAdaptiveLearningRate:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.difficulty = 0.5\n        self.fitness_history = []\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.x0 = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            self.x0 = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n            self.fitness_history = []\n            self.pbest = np.copy(self.x0)\n            self.gbest = np.copy(self.x0[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(self.x0)\n\n                # Update pbest and gbest\n                for i in range(self.population_size):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = self.x0[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = self.x0[i, :]\n\n                # Differential evolution\n                for i in range(self.population_size):\n                    j1, j2 = np.random.choice(self.population_size, 2, replace=False)\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        x1, x2 = self.x0[j1, :], self.x0[j2, :]\n                        child = (x1 + x2) / 2 + np.random.uniform(-self.difficulty, self.difficulty, self.dim)\n                        child = child.clip(self.lower_bound, self.upper_bound)\n                        self.x0[i, :] = child\n\n                # Adaptive learning rate\n                if len(self.fitness_history) > 1:\n                    self.difficulty = self.adaptation_rate * (1 - len(self.fitness_history) / (self.num_iterations + 1))\n                self.fitness_history.append(values)\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = DifferentialEvolutionWithAdaptiveLearningRate(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "DifferentialEvolutionWithAdaptiveLearningRate", "description": "Novel \"Differential Evolution with Adaptive Learning Rate\" algorithm", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "57961a52-552b-443d-b0ba-1b0dbdd9bf51", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.adaptation_rate = 0.1\n        self.adaptive_probability = 0.5\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Adaptive crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.adaptive_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle with 50% probability\n                        if random.random() < 0.5:\n                            particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = EvolutionaryAlgorithm(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "EvolutionaryAlgorithm", "description": "Novel \"Evolutionary Algorithm with Adaptive Probability\" ", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "3212866a-f50b-4b12-9eae-c77ec31b8748", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.adaptation_rate_threshold = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle with a probability of 0.5\n                        if random.random() < 0.5:\n                            particles[i, :] = child\n\n            # Update adaptation rate\n            self.adaptation_rate = max(0, self.adaptation_rate * (1 - self.adaptation_rate_threshold))\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "ac0a0dc1-7fe6-4ac8-be59-28fe3e7a69a9", "solution": "import numpy as np\nimport random\n\nclass AdaptiveCrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.individual_changes = 0\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Change individual lines with 0.5 probability\n                if self.individual_changes < self.num_iterations:\n                    for i in range(self.num_particles):\n                        if random.random() < 0.5:\n                            # Select two particles\n                            j = random.randint(0, self.num_particles - 1)\n                            k = random.randint(0, self.num_particles - 1)\n\n                            # Crossover\n                            child = (particles[i, :] + particles[j, :]) / 2\n                            if random.random() < self.adaptation_rate:\n                                child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                            # Mutation\n                            if random.random() < self.adaptation_rate:\n                                child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                            # Replace particle\n                            particles[i, :] = child\n                    self.individual_changes += 1\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = AdaptiveCrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "AdaptiveCrossoverParticleSwarmOptimization", "description": "Novel \"Adaptive Crossover-Particle Swarm Optimization\" algorithm with 0.5 probability of changing individual lines.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "a90cecc0-47af-4ddd-90c1-4b4405039d36", "solution": "import numpy as np\nimport random\n\nclass AdaptiveEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.mutation_probability = 0.1\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(self.population)\n            self.gbest = np.copy(self.population[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(self.population)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = self.population[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = self.population[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (self.population[i, :] + self.population[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.mutation_probability:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        self.population[i, :] = child\n\n                # Adaptation\n                for i in range(self.num_particles):\n                    if random.random() < self.adaptation_rate:\n                        # Select a random particle\n                        j = random.randint(0, self.num_particles - 1)\n\n                        # Adapt the particle\n                        self.population[i, :] = (self.population[i, :] + self.population[j, :]) / 2\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = AdaptiveEvolutionaryAlgorithm(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "AdaptiveEvolutionaryAlgorithm", "description": "Novel \"Adaptive Evolutionary Algorithm with Crossover and Mutation\" algorithm", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "413e43a4-f9bc-4ed4-8a6b-23e345156ddb", "solution": "import numpy as np\nimport random\n\nclass AdaptiveCrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.crossover_probabilities = np.ones(self.population_size)\n        self.adaptation_rates = np.ones(self.population_size)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probabilities[i]:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rates[i]:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rates[i]:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Update crossover probabilities and adaptation rates\n                for i in range(self.num_particles):\n                    if self.pbest[i, 0] == self.gbest[0]:\n                        self.crossover_probabilities[i] += self.adaptation_rate\n                        self.adaptation_rates[i] += self.adaptation_rate\n                    else:\n                        self.crossover_probabilities[i] -= self.adaptation_rate\n                        self.adaptation_rates[i] -= self.adaptation_rate\n                    self.crossover_probabilities[i] = max(0.0, min(1.0, self.crossover_probabilities[i]))\n                    self.adaptation_rates[i] = max(0.0, min(1.0, self.adaptation_rates[i]))\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = AdaptiveCrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "AdaptiveCrossoverParticleSwarmOptimization", "description": "Novel \"Adaptive Crossover-Particle Swarm Optimization\" algorithm", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "dfb72f2c-b7ee-4167-a8f4-410894ac4981", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "0a99a953-be5d-4b00-b6fd-6110270088f1", "solution": "import numpy as np\nimport random\n\nclass AdaptiveCrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.probability_threshold = 0.5\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.adaptation_counter = 0\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                        # Adapt probability\n                        self.adaptation_counter += 1\n                        if self.adaptation_counter >= self.num_iterations // 2:\n                            self.crossover_probability = max(0.0, self.crossover_probability - (self.adaptation_rate / 2) * (self.adaptation_counter / self.num_iterations))\n                            self.adaptation_counter = 0\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = AdaptiveCrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "AdaptiveCrossoverParticleSwarmOptimization", "description": "Novel \"Adaptive Crossover-Particle Swarm Optimization with Probability-Based Adaptation\"", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "75fd4775-16e1-41d1-b155-ae7afd6d53c0", "solution": "import numpy as np\nimport random\n\nclass HyperEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.mutation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.mutation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Update hyper-parameters\n            for i in range(self.population_size):\n                if random.random() < 0.5:\n                    self.crossover_probability += 0.01\n                if random.random() < 0.5:\n                    self.mutation_rate += 0.01\n                if random.random() < 0.5:\n                    self.population_size += 10\n                if random.random() < 0.5:\n                    self.dim += 1\n\n            # Ensure bounds\n            self.lower_bound = max(self.lower_bound, np.min(particles, axis=0))\n            self.upper_bound = min(self.upper_bound, np.max(particles, axis=0))\n\n        # Return the best solution\n        return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = HyperEvolutionaryAlgorithm(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "HyperEvolutionaryAlgorithm", "description": "Novel \"Hyper-Evolutionary Algorithm with Crossover and Mutation\"", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "a60106ca-68ae-46e7-9971-2f2e9231c901", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.diversity_rate = 0.5\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.diversity = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n            self.diversity = np.copy(particles)\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle with new particle\n                        new_particle = child\n                        if random.random() < self.diversity_rate:\n                            # Introduce diversity by replacing particle with a new particle\n                            # from the same dimension\n                            index = random.randint(0, self.dim - 1)\n                            new_particle[index] = self.pbest[i, index]\n                        particles[i, :] = new_particle\n\n        # Return the best solution\n        return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Diversity\" algorithm", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "a08ced06-cc84-47f5-ac7a-4748ae0dc830", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.hybridization_rate = 0.2\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Hybridization\n                for i in range(self.num_particles):\n                    if random.random() < self.hybridization_rate:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[j, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Hybridization\" algorithm", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "126cca21-a67f-45a2-bcfd-65efa5ed1985", "solution": "import numpy as np\nimport random\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.adaptive_crossover = False\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Adaptive crossover\n                        if self.adaptive_crossover:\n                            if random.random() < 0.5:\n                                child += np.random.uniform(-1.0, 1.0, self.dim)\n                            else:\n                                child -= np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Adaptive crossover toggle\n            if self.adaptive_crossover:\n                if random.random() < 0.5:\n                    self.adaptive_crossover = False\n                else:\n                    self.adaptive_crossover = True\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = HybridEvolutionaryAlgorithm(budget=100, dim=2)\noptimizer.adaptive_crossover = True\nresult = optimizer(func)\nprint(result)", "name": "HybridEvolutionaryAlgorithm", "description": "Novel \"Hybrid Evolutionary Algorithm with Adaptive Crossover\" algorithm", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "2da93e7f-daa4-4922-b180-878505937efb", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Replace best individual with the global best\n            self.gbest = np.copy(self.pbest[np.argmin(self.pbest, axis=0)])\n\n        # Return the global best solution\n        return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "b4d82af9-5617-4f8f-ae6f-d72310fc5781", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.random_crossover_probability = 0.5\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.random_crossover = False\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            if self.random_crossover:\n                self.random_crossover = False\n                self.crossover_probability = 0.5\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Random crossover\n                        if random.random() < self.random_crossover_probability:\n                            child = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Random crossover\n                if random.random() < self.random_crossover_probability:\n                    self.random_crossover = True\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Random Crossover\" algorithm", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "c038f9aa-f6ee-485b-abcd-201b50ccbb3c", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.hybridization_rate = 0.5\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle with hybridized version\n                        if random.random() < self.hybridization_rate:\n                            hybridized_child = (particles[i, :] + self.gbest) / 2\n                            particles[i, :] = hybridized_child\n\n                # Replace particle with new particle if it is better\n                if random.random() < self.hybridization_rate:\n                    new_particle = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    if np.sum(new_particle**2) < np.sum(self.pbest[i, :])**2:\n                        self.pbest[i, :] = new_particle\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Hybridization\" algorithm", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "8ebfc4ab-1596-4c4e-963e-c9522cc1cba1", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.adaptive_crossover_probability = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.adaptive_crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Update adaptive crossover probability\n            self.adaptive_crossover_probability = np.mean([func(particles[i, :]) for i in range(self.num_particles)])\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm with adaptive probability.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "f987a406-5f3e-40c2-98d9-8a2a7a1ea692", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Update gbest with the best individual from the new population\n            self.gbest = np.max(self.pbest, axis=0)\n\n            # Update pbest with the best individual from the new population\n            self.pbest = np.max(self.pbest, axis=0)\n\n            # If the number of iterations is reached, return the best individual\n            if self.num_iterations == self.budget:\n                return self.gbest\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "3d847cc0-f74b-41fb-a071-22c55614a032", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.probability = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n                        if random.random() < self.probability:\n                            child *= 1 + np.random.uniform(-0.2, 0.2, self.dim)\n                        if random.random() < self.probability:\n                            child += np.random.uniform(-0.2, 0.2, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "35b00bbb-2910-43d2-80a9-429dc26212e7", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Adapt the crossover probability\n            self.crossover_probability = np.random.uniform(0.5, 0.9)\n\n            # Adapt the adaptation rate\n            self.adaptation_rate = np.random.uniform(0.01, 0.1)\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "f46c0e52-7f4c-4dc6-805d-87d79da4b44e", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.mutation_probability = 0.5\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.pbest_history = []\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.mutation_probability:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle with probabilistic crossover and mutation\n                        if random.random() < 0.5:\n                            particles[i, :] = child\n                        else:\n                            particles[i, :] = particles[i, :]\n\n            # Store pbest history\n            self.pbest_history.append(self.pbest[0])\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Probabilistic Mutation\"", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "26a0361b-7438-4316-86f5-eff4bb8dee43", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.hybridization_rate = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Hybridize with gbest\n                        if random.random() < self.hybridization_rate:\n                            child += self.gbest\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Hybridization\" algorithm", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "1e1c4618-2f7b-465f-b63d-8bf479597602", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass EvolutionaryGradientBoosting:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.gradient_step_size = 0.1\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize population\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate population\n                values = func(self.population)\n\n                # Update population\n                for i in range(self.num_particles):\n                    # Crossover\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (self.population[i, :] + self.population[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        self.population[i, :] = child\n\n                # Gradient-based optimization\n                for i in range(self.num_particles):\n                    # Evaluate function\n                    values = func(self.population[i, :])\n\n                    # Update particle\n                    self.population[i, :] -= self.gradient_step_size * np.array(func(self.population[i, :]).grad)\n\n                    # Ensure bounds\n                    self.population[i, :] = np.clip(self.population[i, :], self.lower_bound, self.upper_bound)\n\n        # Return the best solution\n        return self.population[np.argmin(np.array([func(x) for x in self.population]))]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = EvolutionaryGradientBoosting(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "EvolutionaryGradientBoosting", "description": "Novel \"Evolutionary-Gradient-Boosting\" algorithm combining evolutionary strategies and gradient-based optimization.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "31aeb91d-b345-49c6-8dc2-32422f19518a", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.5\n        self.adaptation_rate = 0.1\n        self.adaptive_probability = 0.5\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                    # Adaptive crossover probability\n                    if random.random() < self.adaptive_probability:\n                        self.crossover_probability += 0.01\n                        if self.crossover_probability > 1.0:\n                            self.crossover_probability = 1.0\n\n                    # Adaptive adaptation rate\n                    if random.random() < self.adaptive_probability:\n                        self.adaptation_rate += 0.01\n                        if self.adaptation_rate > 1.0:\n                            self.adaptation_rate = 1.0\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Adaptive Probability\" algorithm", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "22a175e1-4859-4cf3-841a-d317120b6d8c", "solution": "import numpy as np\n\nclass DifferentialEvolutionWithAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.5\n        self.adaptation_rate = 0.1\n        self.f = None\n\n    def __call__(self, func):\n        self.f = func\n        for _ in range(self.num_iterations):\n            # Initialize population\n            population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate population\n                values = self.f(population)\n\n                # Update population\n                new_population = population.copy()\n                for i in range(self.population_size):\n                    j = np.random.randint(0, self.population_size - 1)\n                    k = np.random.randint(0, self.population_size - 1)\n\n                    # Differential evolution\n                    differential = population[j, :] - population[k, :]\n                    mutated = population[i, :] + differential * np.random.uniform(-1.0, 1.0, self.dim)\n\n                    # Adaptive crossover\n                    if random.random() < self.crossover_probability:\n                        child = (mutated + population[i, :]) / 2\n                    else:\n                        child = mutated\n\n                    # Replace individual\n                    new_population[i, :] = child\n\n                # Replace population\n                population = new_population\n\n                # Check for termination\n                if np.all(values <= np.min(values)):\n                    break\n\n        # Return the best solution\n        return np.min(values)\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = DifferentialEvolutionWithAdaptiveCrossover(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "DifferentialEvolutionWithAdaptiveCrossover", "description": "Novel \"Differential Evolution with Adaptive Crossover\" algorithm", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "1a55636d-37ac-42c8-866b-f41d5132af45", "solution": "import numpy as np\nimport random\nfrom scipy import optimize\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.differential_evolution_probability = 0.5\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.differential_evolution_pbest = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n            self.differential_evolution_pbest = np.copy(particles)\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Differential evolution\n                for i in range(self.num_particles):\n                    if random.random() < self.differential_evolution_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Calculate differential evolution\n                        diff = particles[j, :] - particles[i, :]\n                        target = particles[k, :] + diff * np.random.uniform(0.0, 1.0, self.dim)\n                        if np.any(target < self.lower_bound) or np.any(target > self.upper_bound):\n                            target = self.lower_bound + (target - self.lower_bound) / (self.upper_bound - self.lower_bound) * (self.upper_bound - self.lower_bound)\n                        if np.any(target < self.lower_bound) or np.any(target > self.upper_bound):\n                            target = self.upper_bound - (target - self.upper_bound) / (self.upper_bound - self.lower_bound) * (self.upper_bound - self.lower_bound)\n\n                        # Replace particle\n                        particles[i, :] = target\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Differential Evolution\"", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "1a65421f-e7fd-4a6a-950b-fed7b793b889", "solution": "import numpy as np\nimport random\n\nclass DifferentialEvolutionWithAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.5\n        self.adaptation_rate = 0.1\n        self.difficulty = 0.5\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Differential evolution\n                for i in range(self.num_particles):\n                    # Select three random particles\n                    j = random.randint(0, self.num_particles - 1)\n                    k = random.randint(0, self.num_particles - 1)\n                    l = random.randint(0, self.num_particles - 1)\n\n                    # Calculate differences\n                    diff1 = particles[j, :] - particles[i, :]\n                    diff2 = particles[k, :] - particles[i, :]\n                    diff3 = particles[l, :] - particles[i, :]\n                    diff = (diff1 + diff2 + diff3) / 3\n\n                    # Calculate new particle\n                    new_particle = particles[i, :] + self.difficulty * diff\n                    if random.random() < self.crossover_probability:\n                        # Select two random particles\n                        m = random.randint(0, self.num_particles - 1)\n                        n = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (new_particle + particles[m, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n        # Return the best solution\n        return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = DifferentialEvolutionWithAdaptiveCrossover(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "DifferentialEvolutionWithAdaptiveCrossover", "description": "Novel \"Differential Evolution with Adaptive Crossover\" algorithm", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "8e26ece0-3901-45d4-96f0-1f133445d5cd", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.stagnation_avoidance_rate = 0.2\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.pbest_history = np.zeros((self.population_size, self.num_iterations))\n        self.gbest_history = np.zeros((self.dim, self.num_iterations))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n            self.pbest_history = np.copy(particles)\n            self.gbest_history = np.copy(particles[0])\n\n            # Main loop\n            for iteration in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest_history[i, iteration] = particles[i, :]\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest_history[:, iteration] = particles[i, :]\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                        # Stagnation avoidance\n                        if iteration > 0 and np.all(self.pbest_history[i, iteration - 1] == self.pbest[i, iteration] and\n                                               np.all(self.gbest_history[:, iteration - 1] == self.gbest[:, iteration])):\n                            if random.random() < self.stagnation_avoidance_rate:\n                                particles[i, :] += np.random.uniform(-1.0, 1.0, self.dim)\n\n                # Check for stagnation\n                for i in range(self.num_particles):\n                    if np.all(self.pbest_history[i, iteration] == self.pbest[i, iteration] and\n                               np.all(self.gbest_history[:, iteration] == self.gbest[:, iteration])):\n                        if random.random() < self.stagnation_avoidance_rate:\n                            particles[i, :] += np.random.uniform(-1.0, 1.0, self.dim)\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Stagnation Avoidance\" algorithm", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "c58185dc-4cfa-41f9-871b-740281fd680d", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.5\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.pbest_history = []\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Store pbest history\n                self.pbest_history.append(self.pbest.copy())\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "b44c2048-4ef9-4cc3-8797-1c5ba69fa535", "solution": "import numpy as np\nimport random\nimport copy\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.pbest_copy = np.zeros((self.population_size, self.dim))\n        self.gbest_copy = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest_copy = copy.copy(self.pbest)\n            self.gbest_copy = copy.copy(self.gbest)\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                    # Update pbest and gbest copy\n                    if values[i] < self.pbest_copy[i, 0]:\n                        self.pbest_copy[i, :] = particles[i, :]\n                    if values[i] < self.gbest_copy[0]:\n                        self.gbest_copy[:] = particles[i, :]\n\n            # Update pbest and gbest\n            self.pbest = np.copy(self.pbest_copy)\n            self.gbest = np.copy(self.gbest_copy)\n\n            # Update pbest and gbest with 50% probability\n            if random.random() < 0.5:\n                self.pbest = np.copy(self.pbest_copy)\n                self.gbest = np.copy(self.gbest_copy)\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "9f54777f-c734-4e14-8a80-a23b1292c950", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.adaptation_threshold = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle with adapted version\n                        if random.random() < self.adaptation_threshold:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "bc4013b4-632f-46de-85f9-15cafa1b3f6b", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.pbest_history = np.zeros((self.population_size, self.num_iterations, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest_history[i, _, :] = self.pbest[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Update pbest_history\n            self.pbest_history[:, -1, :] = self.pbest\n\n    def get_pbest_history(self):\n        return self.pbest_history\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)\n\n# Evaluate the BBOB test suite\nfrom bbob import bbb\n\nfor func_name in bbb.get_bbb_functions():\n    func = bbb.get_function(func_name)\n    result = optimizer(func)\n    print(f\"Function: {func_name}, Result: {result}\")", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "3ebc98d4-3c3e-403c-8a4d-52bdf0457512", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.5\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.pbest_history = []\n        self.gbest_history = []\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Store pbest and gbest history\n                self.pbest_history.append(self.pbest)\n                self.gbest_history.append(self.gbest)\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "b54ed7bb-6aeb-496b-8559-d00b740351a9", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.5\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "27524540-e86b-4dec-ae65-580d933a6f2a", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Adapt particles\n            for i in range(self.num_particles):\n                if random.random() < 0.5:\n                    # Select a random particle\n                    j = random.randint(0, self.num_particles - 1)\n\n                    # Adapt the selected particle\n                    particles[i, :] += np.random.uniform(-1.0, 1.0, self.dim)\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "70f89268-0030-478f-8271-916c3710c016", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.5\n        self.adaptation_rate = 0.5\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.crossover_mask = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n                        self.crossover_mask[i, :] = 1\n\n                # Update crossover mask\n                self.crossover_mask *= 0.5\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm with 0.5 probability crossover and mutation.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "d2c4bdd2-21e6-45c2-9229-8cf7ead7bc1a", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.adaptation_threshold = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                    # Adaptation\n                    if random.random() < self.adaptation_threshold:\n                        # Select a random particle\n                        idx = random.randint(0, self.num_particles - 1)\n                        # Replace the particle with the current gbest\n                        particles[idx, :] = self.gbest[:]\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "2d2b0561-029d-4c2e-972d-578c6323706d", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.5\n        self.adaptation_rate = 0.5\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm using 50% probability for crossover and mutation.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "644422dc-393b-4896-9e25-dd153a647953", "solution": "import numpy as np\nimport random\nimport operator\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.de = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-self.de, self.de, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Differential evolution\n                for i in range(self.num_particles):\n                    # Select three particles\n                    j = random.randint(0, self.num_particles - 1)\n                    k = random.randint(0, self.num_particles - 1)\n                    l = random.randint(0, self.num_particles - 1)\n\n                    # Calculate the target\n                    target = self.pbest[j, :] + self.de * (self.pbest[k, :] - self.pbest[l, :])\n\n                    # Update the particle\n                    particles[i, :] = self.pbest[i, :] + self.de * (target - self.pbest[i, :])\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Differential Evolution\"", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "4ffef3b6-bd1e-46d3-af02-e0cee402c848", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.mutation_probability = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Probabilistic mutation\n                        if random.random() < self.mutation_probability:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n        # Return the best solution\n        return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Probabilistic Mutation\" algorithm", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "d6e840ed-eb20-4459-9a57-8da7841bd1c6", "solution": "import numpy as np\nimport random\n\nclass MultiObjectiveEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.5\n        self.adaptation_rate = 0.1\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.mutation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                    # Check if the particle is better than the gbest\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = MultiObjectiveEvolutionaryAlgorithm(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "MultiObjectiveEvolutionaryAlgorithm", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Adaptive Crossover and Mutation\"", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "f5745f12-2cb0-4740-ad9d-cd0b63bb5646", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.adaptation_threshold = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                        # Adaptation\n                        if np.any(particles[i, :] < self.lower_bound) or np.any(particles[i, :] > self.upper_bound):\n                            particles[i, :] = self.lower_bound + (particles[i, :] - self.lower_bound) * self.adaptation_threshold\n                        elif np.any(particles[i, :] < self.lower_bound) or np.any(particles[i, :] > self.upper_bound):\n                            particles[i, :] = self.upper_bound - (particles[i, :] - self.upper_bound) * self.adaptation_threshold\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "bb993d54-586f-4728-8898-46604228b8bc", "solution": "import numpy as np\nimport random\nimport copy\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.pbest_history = np.zeros((self.num_iterations, self.population_size, self.dim))\n        self.gbest_history = np.zeros((self.num_iterations, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest_history[_] = copy.deepcopy(particles)\n            self.gbest_history[_] = copy.deepcopy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                        self.pbest_history[_, i, :] = copy.deepcopy(particles[i, :])\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n                        self.gbest_history[_, 0] = copy.deepcopy(particles[i, :])\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "32daa5db-8b41-4026-8d1a-bd273594fcf1", "solution": "import numpy as np\nimport random\n\nclass MultiObjectiveEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.5\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim, 2))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i, 0] < self.pbest[i, 0, 0] or values[i, 1] < self.pbest[i, 0, 1]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i, 0] < self.gbest[0, 0] or values[i, 1] < self.gbest[0, 1]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = MultiObjectiveEvolutionaryAlgorithm(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "MultiObjectiveEvolutionaryAlgorithm", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Adaptive Crossover\" algorithm", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "47e9babb-af2a-408b-9a3f-33266067051f", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.5\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.pbest_history = np.zeros((self.population_size, self.dim, self.num_iterations))\n        self.gbest_history = np.zeros((self.dim, self.num_iterations))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n            self.pbest_history = np.copy(particles)\n            self.gbest_history = np.copy(particles[0])\n\n            # Main loop\n            for iteration in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, iteration]:\n                        self.pbest[i, iteration] = values[i]\n                        self.pbest_history[i, iteration, :] = particles[i, :]\n                    if values[i] < self.gbest[iteration]:\n                        self.gbest[iteration] = values[i]\n                        self.gbest_history[iteration, :] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Update gbest\n            for i in range(self.num_particles):\n                if self.pbest[i, iteration] > self.gbest[iteration]:\n                    self.gbest[iteration] = self.pbest[i, iteration]\n\n        # Return the best solution\n        return self.gbest[-1]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "dad43112-6796-459d-ba48-11897fc7dbae", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.5\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.pbest_history = np.zeros((self.population_size, self.budget, self.dim))\n        self.gbest_history = np.zeros((self.dim, self.budget))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest_history[:, :, :] = np.copy(particles)\n            self.gbest_history[:, :] = np.copy(particles[0])\n\n            # Main loop\n            for iteration in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, iteration]:\n                        self.pbest[i, iteration] = values[i]\n                        self.pbest_history[i, iteration, :] = particles[i, :]\n                    if values[i] < self.gbest[iteration]:\n                        self.gbest[iteration] = values[i]\n                        self.gbest_history[iteration, :] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n        # Return the best solution\n        return self.gbest_history[-1, :]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "70c62260-5795-4de5-8921-44cf56272433", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.crossover_probabilities = np.zeros((self.population_size, self.num_iterations))\n        self.mutation_probabilities = np.zeros((self.population_size, self.num_iterations))\n\n    def __call__(self, func):\n        for iteration in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probabilities[i, iteration]:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.mutation_probabilities[i, iteration]:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.mutation_probabilities[i, iteration]:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Update crossover and mutation probabilities\n            for i in range(self.num_particles):\n                if values[i] < self.pbest[i, 0]:\n                    self.crossover_probabilities[i, iteration + 1] = 0.5\n                    self.mutation_probabilities[i, iteration + 1] = 0.5\n                else:\n                    self.crossover_probabilities[i, iteration + 1] = self.crossover_probability\n                    self.mutation_probabilities[i, iteration + 1] = self.adaptation_rate\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm with adaptive crossover and mutation probabilities.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "6a061afc-1d87-4fa8-9c39-d877a2c1d215", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.es_probability = 0.5\n        self.es_size = 10\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.es_population = []\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Evolutionary Strategy\n                if random.random() < self.es_probability:\n                    new_individuals = []\n                    for _ in range(self.es_size):\n                        individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                        new_individuals.append(individual)\n                    self.es_population = new_individuals\n                    self.es_population = np.array(self.es_population)\n                    values = func(self.es_population)\n                    for i in range(self.es_size):\n                        if values[i] < self.pbest[i, 0]:\n                            self.pbest[i, :] = self.es_population[i, :]\n                    if values[0] < self.gbest[0]:\n                        self.gbest[:] = self.es_population[0, :]\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Evolutionary Strategies\"", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "48566ebc-cd01-476e-973b-a6ebb932b421", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.mutation_probability = 0.5\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.pbest_history = []\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.mutation_probability:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle with child\n                        particles[i, :] = child\n\n                        # Store pbest history\n                        self.pbest_history.append(self.pbest[i, :])\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Probabilistic Mutation\"", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "3911106f-7e48-4265-877b-c97ee2884340", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle with 50% probability\n                        if random.random() < 0.5:\n                            particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "3e81f910-eaa0-4267-b610-05282764c97d", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.evolution_rate = 0.5\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(self.population)\n            self.gbest = np.copy(self.population[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(self.population)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = self.population[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = self.population[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (self.population[i, :] + self.population[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        self.population[i, :] = child\n\n                # Evolution\n                if random.random() < self.evolution_rate:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Evolution\" algorithm", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "7a6db39b-b8b7-4f5d-a59b-a9f9637c84ac", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.differential_evolution_rate = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Differential evolution\n                for i in range(self.num_particles):\n                    if random.random() < self.differential_evolution_rate:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Calculate differential evolution parameters\n                        r1 = random.random()\n                        r2 = random.random()\n                        r3 = random.random()\n                        r4 = random.random()\n\n                        # Calculate new particle\n                        new_particle = self.pbest[i, :] + r1 * (self.pbest[j, :] - self.pbest[i, :]) + r2 * (self.pbest[k, :] - self.pbest[i, :]) + r3 * (self.gbest - self.pbest[i, :]) + r4 * (self.gbest - self.pbest[j, :])\n\n                        # Replace particle\n                        particles[i, :] = new_particle\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Differential Evolution\" algorithm", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "cd6315ac-671c-4c97-ba5a-753273910ce7", "solution": "import numpy as np\nimport random\nimport tensorflow as tf\n\nclass HyperNetworkOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.neural_network = tf.keras.models.Sequential([\n            tf.keras.layers.Dense(64, activation='relu', input_shape=(self.dim,)),\n            tf.keras.layers.Dense(64, activation='relu'),\n            tf.keras.layers.Dense(self.dim)\n        ])\n        self.neural_network.compile(optimizer='adam', loss='mean_squared_error')\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Train neural network\n            for _ in range(100):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Get input for neural network\n                inputs = np.array([particles[i, :] for i in range(self.num_particles)])\n\n                # Train neural network\n                self.neural_network.fit(inputs, values, epochs=1, verbose=0)\n\n            # Get output from neural network\n            outputs = self.neural_network.predict(particles)\n\n            # Update particles using neural network output\n            for i in range(self.num_particles):\n                # Get new particle\n                new_particle = particles[i, :] + outputs[i, :]\n                new_particle = np.clip(new_particle, self.lower_bound, self.upper_bound)\n\n                # Crossover and mutation\n                if random.random() < self.crossover_probability:\n                    # Select two particles\n                    j = random.randint(0, self.num_particles - 1)\n                    k = random.randint(0, self.num_particles - 1)\n\n                    # Crossover\n                    child = (particles[i, :] + particles[j, :]) / 2\n                    if random.random() < self.adaptation_rate:\n                        child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                    # Mutation\n                    if random.random() < self.adaptation_rate:\n                        child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                    # Replace particle\n                    particles[i, :] = child\n\n                # Replace particle\n                particles[i, :] = new_particle\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = HyperNetworkOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "HyperNetworkOptimization", "description": "Novel \"HyperNetwork Optimization\" algorithm that utilizes a neural network to adaptively adjust the optimization process.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "59d54e52-572a-48dc-a596-1c5ed8ae7d7b", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.differential_evolution_probability = 0.2\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.pbest_history = np.zeros((self.population_size, self.num_iterations, self.dim))\n        self.gbest_history = np.zeros((self.dim, self.num_iterations))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest_history[:, 0, :] = particles\n            self.gbest_history[:, 0] = particles[0]\n\n            # Main loop\n            for i in range(self.num_iterations - 1):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for j in range(self.num_particles):\n                    if values[j] < self.pbest[j, 0]:\n                        self.pbest_history[j, i + 1, :] = particles[j, :]\n                        self.pbest[j, :] = particles[j, :]\n                    if values[j] < self.gbest[0]:\n                        self.gbest_history[:, i + 1] = particles[j, :]\n                        self.gbest[:] = particles[j, :]\n\n                # Crossover and mutation\n                for j in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        k = random.randint(0, self.num_particles - 1)\n                        l = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[j, :] + particles[k, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[j, :] = child\n\n                # Differential evolution\n                if random.random() < self.differential_evolution_probability:\n                    # Select three particles\n                    m = random.randint(0, self.num_particles - 1)\n                    n = random.randint(0, self.num_particles - 1)\n                    o = random.randint(0, self.num_particles - 1)\n\n                    # Calculate differential evolution parameters\n                    r1 = random.random()\n                    r2 = random.random()\n\n                    # Calculate new particle\n                    new_particle = particles[m, :] + r1 * (particles[n, :] - particles[m, :])\n                    new_particle = new_particle + r2 * (particles[o, :] - particles[m, :])\n\n                    # Replace particle\n                    particles[m, :] = new_particle\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Differential Evolution\" algorithm", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "40460b3b-8182-4936-828e-83eae045e25a", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.5\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.pbest_count = np.zeros((self.population_size, self.dim))\n        self.pbest_sum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest_count[i, :] = self.pbest_count[i, :] + 1\n                        self.pbest_sum[i, :] = self.pbest_sum[i, :] + particles[i, :]\n                        self.pbest[i, :] = particles[i, :]\n\n                # Update pbest and gbest using count and sum\n                for i in range(self.num_particles):\n                    if self.pbest_count[i, 0] > 0:\n                        self.pbest[i, :] = self.pbest_sum[i, :] / self.pbest_count[i, :]\n\n                # Update gbest\n                if self.pbest[0, 0] < self.gbest[0]:\n                    self.gbest[:] = self.pbest[0, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "aab83893-0f5b-44c2-b559-8d33a588ad2b", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.stochastic_selection_rate = 0.5\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Stochastic selection\n                selected_particles = []\n                for _ in range(self.num_particles):\n                    if random.random() < self.stochastic_selection_rate:\n                        selected_particles.append(particles[i, :])\n                    else:\n                        selected_particles.append(self.pbest[i, :])\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (selected_particles[i, :] + selected_particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Stochastic Selection\"", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "ac624fe4-9aa6-40d3-996c-de6cea67f5e5", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.exploration_rate = 0.5\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.exploration = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n                            self.exploration[i, :] += np.random.uniform(-1.0, 1.0, self.dim)\n                            if np.random.rand() < self.exploration_rate:\n                                child += self.exploration[i, :]\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Add exploration to pbest\n            for i in range(self.num_particles):\n                if self.exploration[i, 0] > 0:\n                    self.pbest[i, :] += self.exploration[i, :] / self.exploration[i, 0]\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Exploration\" algorithm", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "a7e05cc7-cb45-48a0-9a3f-c5c5bf2fbee5", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.pbest_history = []\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                    # 50% chance to change individual line\n                    if random.random() < 0.5:\n                        # Select a random particle\n                        idx = random.randint(0, self.num_particles - 1)\n                        # Change one of the lines\n                        line = random.randint(0, self.dim - 1)\n                        # Generate a new random value\n                        new_value = np.random.uniform(self.lower_bound, self.upper_bound)\n                        particles[idx, line] = new_value\n\n            # Store pbest history\n            self.pbest_history.append(self.pbest.copy())\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm with 50% probability of individual line changes.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "2bc4c8ab-1533-451f-b261-0b4d10554963", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.5\n        self.mutation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.mutation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.mutation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Adaptive mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.mutation_rate:\n                        # Select a random dimension\n                        dim = random.randint(0, self.dim - 1)\n                        # Generate a random mutation\n                        mutation = np.random.uniform(-1.0, 1.0, self.dim)\n                        # Apply mutation to the particle\n                        particles[i, dim] += mutation\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = EvolutionaryAlgorithm(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "EvolutionaryAlgorithm", "description": "Novel \"Evolutionary Algorithm with Adaptive Crossover and Mutation\" ", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "f82a6e6b-7a98-44dd-9f3f-98530ab0c433", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.5\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.adaptive_crossover = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Adaptive crossover\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Update adaptive crossover\n                        self.adaptive_crossover[i, :] = child\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Replace best particle\n                self.pbest = np.copy(particles)\n                self.gbest = np.copy(particles[0])\n\n            # Update adaptive crossover\n            for i in range(self.num_particles):\n                if random.random() < self.adaptation_rate:\n                    self.adaptive_crossover[i, :] += np.random.uniform(-1.0, 1.0, self.dim)\n\n            # Replace adaptive crossover\n            self.adaptive_crossover = np.clip(self.adaptive_crossover, self.lower_bound, self.upper_bound)\n\n            # Select best adaptive crossover particle\n            best_adaptive_crossover = np.min(self.adaptive_crossover, axis=0)\n            self.adaptive_crossover = np.where(np.all(self.adaptive_crossover == best_adaptive_crossover, axis=1)[:, np.newaxis], self.adaptive_crossover, np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim)))\n\n            # Replace particles with adaptive crossover\n            particles = self.adaptive_crossover\n\n        # Return the best solution\n        return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = EvolutionaryParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "EvolutionaryParticleSwarmOptimization", "description": "Novel \"Evolutionary-Particle Swarm Optimization with Adaptive Crossover\" algorithm", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "48923860-311e-4962-8c05-57c136555c7e", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.pbest_history = []\n        self.gbest_history = []\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n                        self.gbest_history.append(self.gbest.copy())\n                        self.pbest_history.append(self.pbest.copy())\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Update pbest and gbest history\n            self.pbest = np.min(self.pbest_history, axis=0)\n            self.gbest = np.min(self.gbest_history, axis=0)\n\n        # Return the best solution\n        return self.gbest\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "f8103fcb-205d-48b0-a57d-15d7777c8db3", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Adapt the crossover probability and adaptation rate\n                self.crossover_probability *= 0.5\n                self.adaptation_rate *= 0.5\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "b162eece-305f-4b82-9704-bc6bf11865ec", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.selection_probability = 0.5\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.fittest_particles = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Select fittest particles\n                self.fittest_particles = np.copy(particles)\n                self.fittest_particles = self.fittest_particles[self.fittest_particles[:, 0] == np.sort(self.fittest_particles[:, 0])[:int(self.num_particles * self.selection_probability)], :]\n                if len(self.fittest_particles) < self.num_particles:\n                    self.fittest_particles = np.random.choice(self.fittest_particles, self.num_particles, replace=True)\n\n            # Replace particles with fittest particles\n            particles = self.fittest_particles\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Evolutionary Selection\"", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "494c5693-90ca-4531-815e-b7d99084a654", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.mutation_rate = 0.2\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.random_mutations = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n            self.random_mutations = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n                            if random.random() < self.mutation_rate:\n                                child += self.random_mutations[i, :]\n                        else:\n                            child += self.random_mutations[i, :]\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Random Mutation\" algorithm", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "a5c8d93b-213b-4467-a613-6f73f7c9b43f", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.5\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n        self.pbest_count = np.zeros(self.population_size)\n        self.gbest_count = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Initialize pbest and gbest counts\n            self.pbest_count = np.zeros(self.population_size)\n            self.gbest_count = np.zeros(self.dim)\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest counts\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest_count[i] += 1\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest_count[:] = self.pbest_count[:]\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Update pbest and gbest\n            for i in range(self.num_particles):\n                if self.pbest_count[i] > self.pbest_count[self.gbest_count.argmax()]:\n                    self.pbest[self.gbest_count.argmax(), :] = particles[i, :]\n                    self.pbest_count[self.gbest_count.argmax()] += 1\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "5f343978-f8ea-412b-8f79-86da75837cb8", "solution": "import numpy as np\nimport random\nimport copy\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.stochastic_search_rate = 0.2\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Stochastic search\n                if random.random() < self.stochastic_search_rate:\n                    # Select a random particle\n                    i = random.randint(0, self.num_particles - 1)\n                    # Generate a new solution by adding noise to the best solution\n                    new_solution = self.gbest + np.random.uniform(-1.0, 1.0, self.dim)\n                    # Replace the particle with the new solution\n                    particles[i, :] = new_solution\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Stochastic Search\" algorithm", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "2ecc66fa-1ea5-42c7-96b8-dfa657eda821", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle with 50% probability\n                        if random.random() < 0.5:\n                            particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "fde16d89-cc98-499d-8a34-7033aec455ea", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.exploration_rate = 0.2\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.exploration_rate:\n                            child += np.random.uniform(-2.0, 2.0, self.dim)\n                            if random.random() < self.exploration_rate:\n                                child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Add exploration to the mutation process\n            for i in range(self.num_particles):\n                if random.random() < self.exploration_rate:\n                    particles[i, :] += np.random.uniform(-2.0, 2.0, self.dim)\n                    if random.random() < self.exploration_rate:\n                        particles[i, :] += np.random.uniform(-1.0, 1.0, self.dim)\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Exploration\" algorithm", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "aaeb2773-bd1d-485c-8ebb-884b7f38f669", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.exploration_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.exploration_rate:\n                            child += np.random.uniform(-self.upper_bound, self.upper_bound, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n                # Adaptation\n                for i in range(self.num_particles):\n                    if random.random() < self.adaptation_rate:\n                        # Select a random particle\n                        j = random.randint(0, self.num_particles - 1)\n\n                        # Update pbest\n                        if values[i] < self.pbest[j, 0]:\n                            self.pbest[j, :] = particles[i, :]\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation and Exploration\" algorithm", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "9c234552-835e-4d2c-a688-82509001215b", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Update pbest and gbest\n            for i in range(self.num_particles):\n                if np.all(self.pbest[i, :] < self.pbest[i, :]):\n                    self.pbest[i, :] = particles[i, :]\n                if np.all(self.pbest[i, :] < self.gbest):\n                    self.gbest[:] = particles[i, :]\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
{"id": "c986b794-70c9-4f9c-beae-6ac01442b2e1", "solution": "import numpy as np\nimport random\n\nclass CrossoverParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 100\n        self.num_particles = self.population_size\n        self.num_iterations = self.budget\n        self.crossover_probability = 0.8\n        self.adaptation_rate = 0.1\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.gbest = np.zeros(self.dim)\n\n    def __call__(self, func):\n        for _ in range(self.num_iterations):\n            # Initialize particles\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            self.pbest = np.copy(particles)\n            self.gbest = np.copy(particles[0])\n\n            # Main loop\n            for _ in range(self.num_iterations):\n                # Evaluate particles\n                values = func(particles)\n\n                # Update pbest and gbest\n                for i in range(self.num_particles):\n                    if values[i] < self.pbest[i, 0]:\n                        self.pbest[i, :] = particles[i, :]\n                    if values[i] < self.gbest[0]:\n                        self.gbest[:] = particles[i, :]\n\n                # Crossover and mutation\n                for i in range(self.num_particles):\n                    if random.random() < self.crossover_probability * 0.5:\n                        # Select two particles\n                        j = random.randint(0, self.num_particles - 1)\n                        k = random.randint(0, self.num_particles - 1)\n\n                        # Crossover\n                        child = (particles[i, :] + particles[j, :]) / 2\n                        if random.random() < self.adaptation_rate * 0.5:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Mutation\n                        if random.random() < self.adaptation_rate * 0.5:\n                            child += np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Replace particle\n                        particles[i, :] = child\n\n            # Return the best solution\n            return self.gbest[0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = CrossoverParticleSwarmOptimization(budget=100, dim=2)\nresult = optimizer(func)\nprint(result)", "name": "CrossoverParticleSwarmOptimization", "description": "Novel \"Crossover-Particle Swarm Optimization with Adaptation\" algorithm with 50% probability crossover and mutation.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\").", "error": "AttributeError(\"'ExperimentLogger' object has no attribute 'population_size'\")", "parent_id": "a88285c9-efd9-47de-af77-30d53e30b3b5", "metadata": {}, "mutation_prompt": null}
