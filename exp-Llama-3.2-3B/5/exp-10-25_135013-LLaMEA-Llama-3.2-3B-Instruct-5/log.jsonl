{"id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < 0.2:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" (CDEA) for black box optimization problems.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 75, in evaluateBBOB\n  File \"<string>\", line 84, in evaluate_func\nTypeError: 'Individual' object is not callable\n.", "error": "TypeError(\"'Individual' object is not callable\")Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 75, in evaluateBBOB\n  File \"<string>\", line 84, in evaluate_func\nTypeError: 'Individual' object is not callable\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "3c62dcf7-2d6b-436e-99f5-417dde64c7e1", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover with probability 0.05\n            if random.random() < 0.05:\n                child = (parent1 + parent2) / 2\n            else:\n                child = parent1\n\n            # Mutation with probability 0.05\n            if random.random() < 0.05:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n                child = np.clip(child, -5.0, 5.0)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability-based mutation and crossover.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "c35bb652-d70e-49de-83b1-09566e619db5", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mut_prob = 0.05\n        self.cro_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n            if random.random() < self.cro_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Mutation\n            if random.random() < self.mut_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation and crossover.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "b19c70e2-edc7-4641-b093-4f1a5d6ab52e", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            mutation_prob = 0.05\n            if random.random() < mutation_prob:\n                mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                child += mutation\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with mutation probability adjustment", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "a57ed71a-e78d-403f-8e58-f7c2756fc818", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < 0.05:\n                mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                child += mutation\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability-based mutation", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "23d126be-bf8d-47dc-8d46-26031af142ee", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n            if random.random() < 0.05:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Mutation\n            if random.random() < 0.05:\n                mutation_type = random.choice(['uniform', 'gaussian'])\n                if mutation_type == 'uniform':\n                    child += np.random.uniform(-1.0, 1.0, size=self.dim)\n                elif mutation_type == 'gaussian':\n                    child += np.random.normal(0, 1, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" (CDEA) with probability-based mutation and crossover refinement.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "c73b9872-ad3d-45ad-ba2f-ac9d84fe9071", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.probability = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.probability:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability 0.05 to change individual lines for black box optimization problems.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "299b238d-3af6-40e2-815e-4fe4f064934d", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            if random.random() < 0.5:\n                child = (parent1 + parent2) / 2\n            else:\n                child = parent1\n\n            # Mutation\n            if random.random() < 0.1:\n                if random.random() < 0.05:\n                    child += np.random.uniform(-1.0, 1.0, size=self.dim)\n                else:\n                    child -= np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability-based mutation and crossover.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "fd84c50e-8beb-427a-94c1-e79634f67f10", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < 0.2:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n            # Change individual lines with 0.05 probability\n            if random.random() < 0.05:\n                idx = np.random.choice(self.budget, size=1, replace=False)\n                population[idx] = np.random.uniform(-5.0, 5.0, size=self.dim)\n                fitness[idx] = func(population[idx])\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" (CDEA) with 0.05 probability to change the individual lines.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "24a61025-c2d8-4a83-ad38-bbf92387a651", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.05\n        self.crossover_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                child = (parent1 + parent2) / 2\n            else:\n                child = parent1\n\n            # Mutation\n            if random.random() < self.mutation_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability-based mutation and crossover.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "98b09c10-34e7-4ca4-9c14-d3177167b6e5", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.2\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.mutation_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n                self.mutation_prob = min(self.mutation_prob * 0.95, 0.5)  # adapt mutation probability\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with adaptive mutation probability.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "409d3903-7b92-4997-b82e-22722b046a10", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation with probability 0.05\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation with probability 0.05\n            if random.random() < 0.05:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability 0.05 mutation and crossover.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "b77475ca-0a52-4bb2-8e11-3e185bd383ef", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mut_prob = 0.2\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.mut_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n            # Adjust mutation probability\n            self.mut_prob = max(0.05, min(0.5, self.mut_prob + random.random() * 0.05))\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" (CDEA) with mutation probability adjustment.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "5e13e449-93ac-4b1b-80e1-541aa0581300", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.05\n        self.crossover_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.mutation_prob:\n                if random.random() < self.crossover_prob:\n                    child += np.random.uniform(-1.0, 1.0, size=self.dim)\n                else:\n                    child += np.random.uniform(-0.5, 0.5, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with adaptive mutation and crossover.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "db8b4896-1ac3-42f1-9c0f-148a1136f94c", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            if random.random() < 0.05:\n                child = parent1\n            else:\n                child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < 0.05:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability-based crossover and mutation", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "67831d00-8b6d-47e6-bdb7-4f0c44cab989", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2 + np.random.uniform(-0.1, 0.1, size=self.dim)\n\n            # Mutation\n            if random.random() < 0.05:\n                mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                child += mutation\n\n            # Ensure bounds are not exceeded\n            child = np.clip(child, -5.0, 5.0)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability-based mutation and crossover.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "5489e4bd-cf73-4b75-9bc3-8f669a4967b9", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.change_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.change_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability 0.05 to change the individual lines for black box optimization problems.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "379256ff-c365-4a62-ab13-5aab61092ee7", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.mutation_prob:\n                # Randomly select a dimension to mutate\n                idx_mutate = np.random.choice(self.dim)\n                child[idx_mutate] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with adaptive mutation probability", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "0be76695-a324-453b-87cf-7e96ac6f7188", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.crossover_prob = 0.7\n        self.mutation_prob = 0.2\n        self.selection_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                child = (parent1 + parent2) / 2\n            else:\n                child = parent1\n\n            # Mutation\n            if random.random() < self.mutation_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with adaptive mutation and crossover probabilities.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "9645b1d2-e134-4493-8852-80e8531f980d", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.mutation_prob:\n                mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                child += mutation\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with adaptive mutation probability", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "ad8e96cf-1b6a-452f-9c46-d5109a46d682", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.p_change = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.p_change:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n                idx_child = np.argmin(fitness + func(child))\n                if func(child) < self.f_best:\n                    self.f_best = func(child)\n                    self.x_best = child\n            else:\n                idx_child = np.argmin(fitness)\n                if fitness[idx_child] < self.f_best:\n                    self.f_best = fitness[idx_child]\n                    self.x_best = population[idx_child]\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with 0.05 probability to change the individual lines.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "b882fe82-413a-4041-a413-e8f1652937c5", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Probabilistic mutation\n            if random.random() < 0.05:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation and crossover.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "8ae8fa6c-f1d5-42b6-9ed4-da15684c23f0", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_probability = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.mutation_probability:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with 5% probability mutation.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "e884a25d-c5d9-4405-b65f-c4df267cd836", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.2\n        self.crossover_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                child = (parent1 + parent2) / 2\n            else:\n                child = parent1\n\n            # Mutation\n            if random.random() < self.mutation_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" (CDEA) with mutation and crossover probability adjustment.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "b67fbf27-9584-4ec1-aa0a-758540f25f2f", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation with 0.05 probability\n            if random.random() < 0.05:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" (CDEA) with 0.05 probability of mutation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "02f31472-3d29-4dca-a85b-88fc209ad099", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and probabilistic mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Probabilistic mutation\n            if random.random() < 0.05:\n                mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                child += mutation\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "406d83ec-5772-4e2a-bc71-6b6c47cac66e", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and probabilistic mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Probabilistic mutation\n            if random.random() < 0.05:\n                mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                child += mutation\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "3808ac9d-a381-443d-be65-71f79ad85290", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            if random.random() < 0.5:\n                child = (parent1 + parent2) / 2\n            else:\n                child = parent1\n\n            # Mutation\n            if random.random() < 0.05:\n                mutation_factor = np.random.uniform(-1.0, 1.0)\n                child += mutation_factor * np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability-based mutation and crossover.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "357e3518-d8ac-411a-aa31-4b745d170882", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.05\n        self.crossover_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                child = (parent1 + parent2) / 2\n            else:\n                child = parent1\n\n            # Mutation\n            if random.random() < self.mutation_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation and crossover.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "474deef1-42f7-41ed-976b-7b8422d09f56", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n            if random.random() < 0.05:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Mutation\n            if random.random() < 0.05:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation and crossover.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "99786ea0-9c04-4df3-8661-4a1ce9ce801d", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.mutation_prob:\n                # Randomly select a dimension to mutate\n                idx_mutate = np.random.choice(self.dim)\n                child[idx_mutate] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with adaptive mutation probability", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "d685b37b-4dcf-418d-bcd5-e24e5bf61392", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.05\n        self.crossover_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection\n        selected = population[np.argsort(fitness)]\n\n        # Perform crossover and mutation\n        for i in range(self.budget - 1):\n            # Selection\n            parent1, parent2 = selected[i], selected[i + 1]\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                child = (parent1 + parent2) / 2\n            else:\n                child = parent1\n\n            # Mutation\n            if random.random() < self.mutation_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability-based mutation and crossover.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "30f135e3-844f-4cda-9414-66cea4d01db5", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Probabilistic mutation\n            if random.random() < 0.05:\n                mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                child += mutation\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "64c0c78d-9a31-4dc3-8f4d-6208bb180811", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.selection_prob = 0.05\n        self.mutation_prob = 0.2\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            selection_mask = np.random.rand(self.budget) < self.selection_prob\n            idx = np.where(selection_mask)[0]\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.mutation_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with adaptive mutation and selection probability", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "cce0cbcf-b98d-421c-af41-872b2f9b20e8", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.p_mutate = 0.05\n        self.p_crossover = 0.5\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            if random.random() < self.p_crossover:\n                child = (parent1 + parent2) / 2\n            else:\n                child = parent1\n\n            # Mutation\n            if random.random() < self.p_mutate:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation and crossover.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "821d75c7-0e30-4294-86b9-0746a7a291aa", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.selection_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            if random.random() < self.selection_prob:\n                idx = np.random.choice(self.budget, size=2, replace=False)\n                parent1, parent2 = population[idx]\n\n                # Crossover\n                child = (parent1 + parent2) / 2\n\n                # Mutation\n                if random.random() < 0.2:\n                    child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n                # Evaluate the child\n                fitness_child = func(child)\n\n                # Update the best solution\n                idx_child = np.argmin(fitness + fitness_child)\n                if fitness_child[idx_child] < self.f_best:\n                    self.f_best = fitness_child[idx_child]\n                    self.x_best = child\n\n                # Store the history\n                self.f_history.append(self.f_best)\n                self.x_history.append(self.x_best)\n            else:\n                # Random selection\n                idx = np.random.choice(self.budget, size=1, replace=False)\n                individual = population[idx]\n                fitness_individual = func(individual)\n\n                # Update the best solution\n                if fitness_individual < self.f_best:\n                    self.f_best = fitness_individual\n                    self.x_best = individual\n\n                # Store the history\n                self.f_history.append(self.f_best)\n                self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with adaptive mutation and selection probability.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "98c0800d-959e-4b5e-a873-c294226d4911", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_rate = 0.05\n        self.crossover_rate = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n            if random.random() < self.crossover_rate:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Mutation\n            if random.random() < self.mutation_rate:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with 0.05 probability of mutation and crossover modification.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "5f5dbff3-7267-492e-88a3-cf2d8562ddc2", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.2\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.mutation_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n            else:\n                child += np.random.uniform(-0.1, 0.1, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" (CDEA) with mutation probability adjustment.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "a2e2a777-78cb-45d1-98c0-0f8055acb1b8", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mut_prob = 0.2\n        self.cro_prob = 0.5\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            if random.random() < self.cro_prob:\n                child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.mut_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with mutation and crossover probabilities", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "91f63005-282c-42f2-8265-c2a96fc9842e", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, probabilistic crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Probabilistic crossover\n            if random.random() < 0.2:\n                child = parent1\n            else:\n                child = (parent1 + parent2) / 2\n\n            # Probabilistic mutation\n            if random.random() < 0.05:\n                mutation_factor = np.random.uniform(-1.0, 1.0, size=self.dim)\n                child += mutation_factor\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation and crossover.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "7ee625ec-572e-43bd-bcf5-8367ddf34ed3", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.2\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.mutation_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n                self.mutation_prob = max(0.05, min(0.5, self.mutation_prob + 0.05 * random.random()))\n            else:\n                self.mutation_prob = max(0.05, min(0.5, self.mutation_prob - 0.05 * random.random()))\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with adaptive mutation probability", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "1bc8bbfc-5acc-4aef-8e5f-0e7756fa3c0a", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_rate = 0.2\n        self.crossover_rate = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            if random.random() < self.crossover_rate:\n                child = (parent1 + parent2) / 2\n            else:\n                child = parent1\n\n            # Mutation\n            if random.random() < self.mutation_rate:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability-based mutation and crossover refinement.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "cfc1d9be-c130-45eb-817d-8b0fbc5441aa", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < 0.2:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n            else:\n                child += np.random.uniform(-0.05, 0.05, size=self.dim)  # adaptive mutation\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with adaptive mutation and crossover rates", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "fddcaa50-f418-494e-ba03-a5896abc06fa", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation with probability 0.05\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < 0.05:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability 0.05 to change individual lines.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "e87b4a04-6689-4f50-9902-13bb8079a07b", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            mutation_prob = 0.2 * np.random.uniform(0, 1)\n            if random.random() < mutation_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with adaptive mutation and crossover probabilities.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "2956339a-5205-4885-809b-3d65711ab9f3", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mut_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.mut_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" (CDEA) with adaptive mutation probability for black box optimization problems.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "f8c5e8d2-0b7e-4475-87e9-e50a1f6a8269", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < 0.05:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n            else:\n                child += np.random.uniform(-0.1, 0.1, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" (CDEA) with adaptive mutation and crossover.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "5b093af2-b084-4eb1-9304-8ae4ff894b7e", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.05\n        self.crossover_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection\n        selected = np.random.choice(self.budget, size=2, replace=False)\n        parent1, parent2 = population[selected]\n\n        # Perform crossover with probability\n        if random.random() < self.crossover_prob:\n            child = (parent1 + parent2) / 2\n        else:\n            child = parent1\n\n        # Perform mutation with probability\n        if random.random() < self.mutation_prob:\n            child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n        # Evaluate the child\n        fitness_child = func(child)\n\n        # Update the best solution\n        idx_child = np.argmin(fitness + fitness_child)\n        if fitness_child[idx_child] < self.f_best:\n            self.f_best = fitness_child[idx_child]\n            self.x_best = child\n\n        # Store the history\n        self.f_history.append(self.f_best)\n        self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability-based mutation and crossover refinement.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "9cb82dbb-8650-40e1-b455-90d28fa0a63c", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.05\n        self.crossover_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover with probability 0.05\n            if random.random() < self.crossover_prob:\n                child = (parent1 + parent2) / 2\n            else:\n                child = parent1\n\n            # Mutation with probability 0.05\n            if random.random() < self.mutation_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" (CDEA) with probabilistic mutation and crossover.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "a653033c-b735-483d-a062-b2b2090f9cfa", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.05\n        self.crossover_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n            if random.random() < self.crossover_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Mutation\n            if random.random() < self.mutation_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation and crossover.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "b7e39cf8-03fc-491b-93fd-82d32922a77a", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.change_probability = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.change_probability:\n                # Randomly change individual lines with 0.05 probability\n                for i in range(self.dim):\n                    if random.random() < self.change_probability:\n                        child[i] += np.random.uniform(-1.0, 1.0)\n                        population[idx[0]][i] += np.random.uniform(-1.0, 1.0)\n                        population[idx[1]][i] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with 0.05 probability to change individual lines for black box optimization problems.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "b5239464-6131-43af-836d-16e4c8af67ce", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.mutation_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" (CDEA) with mutation probability 0.05", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "901339e4-e075-44d9-b124-17c63cc072f5", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.05\n        self.selection_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            if random.random() < self.selection_prob:\n                idx = np.random.choice(self.budget, size=2, replace=False)\n                parent1, parent2 = population[idx]\n            else:\n                idx = [np.random.choice(self.budget) for _ in range(2)]\n                parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.mutation_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability-based mutation and selection.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "e470f4dc-4cce-40dc-91bf-809f6949a140", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mut_prob = 0.2\n        self.cro_prob = 0.8\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            if random.random() < self.cro_prob:\n                child = (parent1 + parent2) / 2\n            else:\n                child = parent1\n\n            # Mutation\n            if random.random() < self.mut_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" (CDEA) with adaptive mutation and crossover probabilities", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "0e0c78e1-d8cc-40e1-a7c6-1bf5e499fd62", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.05\n        self.crossover_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                child = (parent1 + parent2) / 2\n            else:\n                child = parent1\n\n            # Mutation\n            if random.random() < self.mutation_prob:\n                mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                child += mutation\n\n            # Ensure bounds\n            child = np.clip(child, -5.0, 5.0)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation and crossover.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "acabb097-ee2d-482a-92f3-7d51b15c7fa6", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            if random.random() < 0.05:\n                child = parent1\n            else:\n                child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < 0.05:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability-based mutation and crossover.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "65b207a8-af7d-4e30-864b-95efee400a92", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            mutate = random.random() < 0.05\n            if mutate:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation and crossover.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "f58a22d7-a343-4d9e-8ac0-8b2b41bbf148", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.change_probability = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.change_probability:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n                # Change individual lines with 0.05 probability\n                for i in range(self.dim):\n                    if random.random() < self.change_probability:\n                        child[i] = np.random.uniform(-5.0, 5.0)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with 0.05 probability to change individual lines for black box optimization problems.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "d5c8bb62-12fe-4268-88e1-37cd5e1a99d4", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover with probability 0.05\n            if random.random() < 0.05:\n                child = (parent1 + parent2) / 2\n            else:\n                child = parent1\n\n            # Mutation with probability 0.05\n            if random.random() < 0.05:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability-based mutation and crossover.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "ed800b11-fc75-41c4-82e4-389e68a3fa4f", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < 0.2:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n            elif random.random() < 0.05:\n                child += np.random.uniform(-np.abs(child), np.abs(child), size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with adaptive mutation probability", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "6eee356f-ab45-4175-ab56-2e7ffabfb64c", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Probability-based mutation\n            if random.random() < 0.05:\n                mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                child += mutation\n            else:\n                child += np.random.uniform(-0.1, 0.1, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability-based mutation", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "aedf982b-765c-43db-9b59-5e77d9c7ea1b", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_rate = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.mutation_rate:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with 5% mutation rate.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "e6d51d5d-3c8b-4ab2-94f8-ce407cb95e51", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < 0.05:\n                # Change individual lines with 0.05 probability\n                for i in range(self.dim):\n                    if random.random() < 0.05:\n                        child[i] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with 0.05 probability to change individual lines.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "b83945fc-88b5-48b7-9d58-c0bab2991b53", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation with 5% probability\n            if random.random() < 0.05:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with 5% mutation probability", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "fae26f17-24c0-4fdf-9e96-9ad5ec3b9099", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            if random.random() < 0.1:  # 10% chance of crossover\n                child = (parent1 + parent2) / 2\n            else:\n                child = parent1\n\n            # Mutation\n            if random.random() < 0.05:  # 5% chance of mutation\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability-based mutation and crossover.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "df236143-09b2-4441-9671-ccfe3308ff57", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.05\n        self.crossover_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                child = (parent1 + parent2) / 2\n            else:\n                child = parent1\n\n            # Mutation\n            if random.random() < self.mutation_prob:\n                mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                child += mutation\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation and crossover.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "2d8aae5c-3e38-4d98-b2f4-4045891c6e72", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Probabilistic mutation\n            mutate = random.random() < 0.05\n            if mutate:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "4e4cd349-32cb-4fc8-9daf-561f6ffbe981", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.2\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation with adaptive probability\n            if random.random() < self.mutation_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n                self.mutation_prob = min(self.mutation_prob * 0.95, 0.5)  # decay mutation probability\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" (CDEA) with adaptive mutation probability.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "05c8cca8-a8c6-445d-86ce-bd74bf9a3ef7", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.mutation_prob:\n                # Randomly select a dimension to mutate\n                dim_to_mutate = np.random.choice(self.dim)\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n                child[dim_to_mutate] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability-based mutation.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "af650f33-e8be-4da3-97ff-8c2b1dbd110e", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutate_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.mutate_prob:\n                # Change individual lines with probability 0.05\n                if random.random() < 0.05:\n                    child += np.random.uniform(-1.0, 1.0, size=self.dim)\n                elif random.random() < 0.05:\n                    child -= np.random.uniform(1.0, 5.0, size=self.dim)\n                elif random.random() < 0.05:\n                    child *= 1.1\n                else:\n                    child /= 1.1\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability-based mutation.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "4978aeb9-96fe-40ac-bd57-1b2a23cfed67", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_rate = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.mutation_rate:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability 0.05 mutation rate", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "fe56fd0a-3076-4d95-b780-b992153cb719", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.probability = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.probability:\n                mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                child += mutation\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability 0.05 to change individual lines.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "40a88db6-325b-4f36-be20-61755aa26743", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.mutation_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with adaptive mutation probability", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "00e4f600-772c-40de-9e43-59190b058e22", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            if random.random() < 0.1:\n                child = parent1\n            else:\n                child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < 0.05:\n                mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                child += mutation\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation and crossover.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "74dc0350-e706-407e-addb-2fd0a27f6778", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < 0.05:\n                # Probabilistic mutation\n                mutation_prob = np.random.uniform(0.0, 1.0)\n                if mutation_prob < 0.2:\n                    child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation and crossover.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "762f0abe-37c4-4ded-a957-1aede22402f2", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < 0.05:\n                mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                child += mutation\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation and crossover.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "81785444-1ace-4165-96f1-33ef47ee5b67", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation with probability 0.05\n            if random.random() < 0.05:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n                if np.any(np.abs(child) > 5.0):\n                    child = np.clip(child, -5.0, 5.0)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation and crossover.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "93554a2b-6b7b-4689-a073-29b7ca964f8e", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < 0.2:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution with probability 0.05\n            if random.random() < 0.05:\n                idx_child = np.argmin(fitness + fitness_child)\n                if fitness_child[idx_child] < self.f_best:\n                    self.f_best = fitness_child[idx_child]\n                    self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability 0.05 to refine its strategy.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "0d156d5f-29b3-4d7d-b4ed-5f8bf9a3ae85", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            if random.random() < 0.5:\n                child = (parent1 + parent2) / 2\n            else:\n                child = np.random.choice([parent1, parent2], p=[0.5, 0.5])\n\n            # Mutation\n            if random.random() < 0.05:\n                mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                child += mutation\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation and crossover.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "82fe5e14-5171-45f1-a19f-704732a3a90c", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2 + np.random.uniform(-1.0, 1.0, size=self.dim)  # Introduce probabilistic mutation\n\n            # Mutation\n            if random.random() < 0.2:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation and crossover.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "c7d0b5b5-04ae-4b5a-9c78-e5a1d01e6ae6", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation with probability\n            if random.random() < self.mutation_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" (CDEA) with probabilistic mutation.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "4e0cf4c4-4134-4e6e-adca-56639356e820", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mut_prob = 0.2\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.mut_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n                self.mut_prob = np.random.uniform(0.01, 0.1)  # Adjust mutation probability\n            else:\n                self.mut_prob = np.random.uniform(0.01, 0.1)  # Reset mutation probability\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" (CDEA) with mutation probability adjustment.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "2ef8068f-4ca5-48f5-b3e0-10814d8274f9", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.05\n        self.crossover_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection\n        selected_population = population[np.argsort(fitness)]\n\n        # Perform crossover\n        new_population = []\n        for i in range(self.budget):\n            if random.random() < self.crossover_prob:\n                parent1 = selected_population[i]\n                parent2 = selected_population[(i+1) % self.budget]\n                child = (parent1 + parent2) / 2\n                new_population.append(child)\n            else:\n                new_population.append(selected_population[i])\n\n        # Perform mutation\n        for i in range(self.budget):\n            if random.random() < self.mutation_prob:\n                child = new_population[i]\n                if random.random() < 0.5:\n                    child += np.random.uniform(-1.0, 1.0, size=self.dim)\n                new_population[i] = child\n\n        # Evaluate the new population\n        fitness_new = [func(x) for x in new_population]\n\n        # Update the best solution\n        idx_new = np.argmin(fitness_new)\n        if fitness_new[idx_new] < self.f_best:\n            self.f_best = fitness_new[idx_new]\n            self.x_best = new_population[idx_new]\n\n        # Store the history\n        self.f_history.append(self.f_best)\n        self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation and crossover.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "49224e4d-527d-4950-8184-94a53d393443", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            if random.random() < 0.5:\n                child = (parent1 + parent2) / 2\n            else:\n                child = parent1 + parent2\n\n            # Mutation\n            if random.random() < 0.05:\n                mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                child += mutation\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" (CDEA) with probability-based mutation and crossover.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "5a372267-c851-49a6-b8d1-6ef70036c393", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < 0.05:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability-based mutation and crossover.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "5e231df9-268b-4483-9259-c5c0ff953a03", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mut_prob = 0.05\n        self.cro_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection\n        selected = np.random.choice(self.budget, size=2, replace=False)\n        parent1, parent2 = population[selected]\n\n        # Crossover with probability\n        if random.random() < self.cro_prob:\n            child = (parent1 + parent2) / 2\n        else:\n            child = parent1\n\n        # Mutation with probability\n        if random.random() < self.mut_prob:\n            child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n        # Evaluate the child\n        fitness_child = func(child)\n\n        # Update the best solution\n        idx_child = np.argmin(fitness + fitness_child)\n        if fitness_child[idx_child] < self.f_best:\n            self.f_best = fitness_child[idx_child]\n            self.x_best = child\n\n        # Store the history\n        self.f_history.append(self.f_best)\n        self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with adaptive mutation and crossover probability.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "c9918db3-0da3-452d-a68d-f412028c9860", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.mutation_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n            elif random.random() < self.mutation_prob:\n                child *= np.random.uniform(0.9, 1.1, size=self.dim)\n            elif random.random() < self.mutation_prob:\n                child += np.random.normal(0, 0.1, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "2b645bec-1947-4341-90e0-e0b798b4dab0", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.2\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.mutation_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Adjust mutation probability based on fitness\n            if fitness[idx_child] < self.f_best:\n                self.mutation_prob *= 0.99\n            elif fitness[idx_child] > self.f_best:\n                self.mutation_prob *= 1.01\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n            # Adjust mutation probability\n            self.mutation_prob = np.clip(self.mutation_prob, 0.01, 0.3)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" (CDEA) with mutation probability adjustment.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "47336e72-25c3-4778-ac80-158865ec31fb", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < 0.05:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n            elif random.random() < 0.05:\n                child *= np.random.uniform(0.9, 1.1, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability 0.05 mutation and crossover.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "b5828f45-048f-4d36-876f-2fc63a6088d7", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mut_prob = 0.05\n        self.cro_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            if random.random() < self.cro_prob:\n                child = (parent1 + parent2) / 2\n            else:\n                child = parent1\n\n            # Mutation\n            if random.random() < self.mut_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with mutation and crossover probabilities", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "b7b80a38-ae4f-4d38-812a-2db38a829840", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation with probability\n            if random.random() < self.mutation_prob:\n                mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                child += mutation\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "a57db16d-635b-47b5-9d04-77d3fd04b853", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.2\n        self.crossover_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection\n        selected = population[np.random.choice(self.budget, size=self.budget, replace=False)]\n\n        # Perform crossover and mutation\n        for i in range(self.budget):\n            if random.random() < self.crossover_prob:\n                parent1, parent2 = selected[i], selected[np.random.choice(self.budget, size=1, replace=False)]\n                child = (parent1 + parent2) / 2\n                if random.random() < self.mutation_prob:\n                    child += np.random.uniform(-1.0, 1.0, size=self.dim)\n                selected[i] = child\n\n        # Evaluate the selected population\n        fitness = [func(x) for x in selected]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = selected[idx_best]\n\n        # Store the history\n        self.f_history.append(self.f_best)\n        self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with mutation and crossover probability adjustment.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "a47da3e1-49ec-4122-a1e9-ed3a9e9bcd66", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.change_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.change_prob:\n                # Change the individual's line with a 0.05 probability\n                if random.random() < 0.5:\n                    # Change the first line\n                    child[:, 0] += np.random.uniform(-1.0, 1.0, size=self.dim)\n                else:\n                    # Change the second line\n                    child[:, 1] += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with 0.05 probability of changing the individual's line.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "ee72874e-e2be-4a15-8f69-acffd2189936", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover with probability 0.05\n            if random.random() < 0.05:\n                child = parent1\n            else:\n                child = (parent1 + parent2) / 2\n\n            # Mutation with probability 0.05\n            if random.random() < 0.05:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability-based mutation and crossover refinement.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "db3a37d6-15e3-4a9a-a6d2-ecceefd3414f", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n            if random.random() < 0.05:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Mutation\n            if random.random() < 0.05:\n                idx = np.random.choice(self.dim)\n                child[idx] += np.random.uniform(-1.0, 1.0)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability-based mutation and crossover.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "a4345e7c-c5a6-4d63-a970-e36a341959d8", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutate_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.mutate_prob:\n                mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                child += mutation\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probability-based mutation.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "1ec90c2a-b1fa-452c-9f94-37c2c4aa08f8", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Probabilistic mutation\n            if random.random() < 0.05:\n                mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                child += mutation\n                if random.random() < 0.05:\n                    child *= 1.1  # amplify mutation\n            else:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "c7e8e244-2bd9-4dbb-bee4-2539e4942cdc", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_rate = 0.2\n        self.crossover_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                child = (parent1 + parent2) / 2\n            else:\n                child = parent1\n\n            # Mutation\n            if random.random() < self.mutation_rate:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with adaptive mutation rate and crossover probability.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "97f6ea12-ea67-4cd3-be97-7534eaf11071", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            child = (parent1 + parent2) / 2\n\n            # Mutation\n            if random.random() < self.mutation_prob:\n                mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                child += mutation\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
{"id": "a5e21b53-09d1-4f8d-be7a-ae1de6a3d77f", "solution": "import numpy as np\nimport random\n\nclass CDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_history = []\n        self.x_history = []\n        self.mutation_prob = 0.05\n        self.crossover_prob = 0.05\n\n    def __call__(self, func):\n        if self.f_best is None:\n            self.f_best = func(0)\n            self.x_best = 0\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n        # Initialize the population with random points\n        population = np.random.uniform(-5.0, 5.0, size=(self.budget, self.dim))\n\n        # Evaluate the population\n        fitness = [func(x) for x in population]\n\n        # Update the best solution\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < self.f_best:\n            self.f_best = fitness[idx_best]\n            self.x_best = population[idx_best]\n\n        # Perform selection, crossover, and mutation\n        for _ in range(self.budget - 1):\n            # Selection\n            idx = np.random.choice(self.budget, size=2, replace=False)\n            parent1, parent2 = population[idx]\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                child = (parent1 + parent2) / 2\n            else:\n                child = parent1\n\n            # Mutation\n            if random.random() < self.mutation_prob:\n                child += np.random.uniform(-1.0, 1.0, size=self.dim)\n\n            # Evaluate the child\n            fitness_child = func(child)\n\n            # Update the best solution\n            idx_child = np.argmin(fitness + fitness_child)\n            if fitness_child[idx_child] < self.f_best:\n                self.f_best = fitness_child[idx_child]\n                self.x_best = child\n\n            # Store the history\n            self.f_history.append(self.f_best)\n            self.x_history.append(self.x_best)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ncdea = CDEA(budget=100, dim=5)\ncdea(0)(func)", "name": "CDEA", "description": "Novel \"Crowd-Driven Evolutionary Algorithm\" with probabilistic mutation and crossover", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "4f4cadd7-3324-48d3-9f25-357ff9eb7a22", "metadata": {}, "mutation_prompt": null}
