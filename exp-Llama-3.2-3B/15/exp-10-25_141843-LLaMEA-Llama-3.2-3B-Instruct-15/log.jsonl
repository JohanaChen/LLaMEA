{"id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 48, in <module>\n  File \"<string>\", line 15, in __init__\nNameError: name 'func' is not defined\n.", "error": "NameError(\"name 'func' is not defined\")Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 48, in <module>\n  File \"<string>\", line 15, in __init__\nNameError: name 'func' is not defined\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "7243372d-1c22-4ca1-9ba8-66c54f583897", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n        self.refine_probability = 0.15  # probability of refining the current solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Refine the current solution with probability 0.15\n            if np.random.rand() < self.refine_probability:\n                # Refine the current solution by changing one dimension randomly\n                idx = np.random.randint(0, self.dim)\n                new_x[:, idx] += np.random.uniform(-self.upper_bound, self.upper_bound)\n                new_x[:, idx] = np.clip(new_x[:, idx], self.lower_bound, self.upper_bound)\n                f_new = [func(xi) for xi in new_x]\n                if np.min(f_new) < self.best_f:\n                    self.best_x = new_x[np.argmin(f_new)]\n                    self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "ca373717-5350-4cf1-885e-ed7303bb5424", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                # Refine the strategy by changing individual lines with probability 0.15\n                if np.random.rand() < 0.15:\n                    for k in range(self.h):\n                        for l in range(self.d):\n                            # Randomly select a direction\n                            dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                            new_x[k] += dx * np.random.uniform(0, 1)\n                            new_x[k] = np.clip(new_x[k], self.lower_bound, self.upper_bound)\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability adjustment.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "4085d280-5406-4c68-9852-c5ce3c11eee8", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # adaptive probability\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria with adaptive probability\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                # Refine the strategy by changing individual lines with probability 0.15\n                if np.random.rand() < 0.15:\n                    # Randomly select an individual\n                    i = np.random.randint(0, self.h)\n                    # Randomly change a line\n                    j = np.random.randint(0, self.dim)\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i, j] += dx * np.random.uniform(0, 1)\n                    new_x[i, j] = np.clip(new_x[i, j], self.lower_bound, self.upper_bound)\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability for exploring better solutions.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "776e7a99-5e8f-4162-a1dd-e85948f13ac1", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n        self.refine_probability = 0.15\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                # Refine the solution with probability 0.15\n                if np.random.rand() < self.refine_probability:\n                    # Randomly select a line of the solution to refine\n                    i = np.random.randint(0, self.h)\n                    # Randomly select a point in the line to refine\n                    j = np.random.randint(0, self.dim)\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    # Refine the point\n                    new_x[i, j] += dx * np.random.uniform(0, 1)\n                    new_x[i, j] = np.clip(new_x[i, j], self.lower_bound, self.upper_bound)\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "b9c88714-5ec5-4760-8564-13d59c9a1127", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                # Refine the individual with a probability of 0.15\n                if np.random.rand() < 0.15:\n                    for k in range(self.dim):\n                        new_x[i, k] += np.random.uniform(-0.1, 0.1)\n                        new_x[i, k] = np.clip(new_x[i, k], self.lower_bound, self.upper_bound)\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off with a probability of 0.15 to refine the individual.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "86a5f944-fe4e-4e1d-952b-08005b88e7d6", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # initial probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria with adaptive probability\n            if np.random.rand() < self.p * (1 - (self.budget - _) / self.budget):\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "594c3054-bbde-4c05-ab3b-69e767f7f7bd", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # initial probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.p_refine = 0.15  # probability for refining the strategy\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Refine the strategy\n            if np.random.rand() < self.p_refine:\n                # Refine the probability of accepting worse solutions\n                self.p = np.random.uniform(0.1, 0.9)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability refinement", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "6d3f0ce9-ac56-4934-a5af-345adaeca9c3", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                # Refine the solution by changing individual lines with probability 0.15\n                refine = np.random.rand(self.h) < 0.15\n                new_x[refine] = new_x[refine] + np.random.uniform(-self.upper_bound, self.upper_bound, size=len(refine))\n                new_x[refine] = np.clip(new_x[refine], self.lower_bound, self.upper_bound)\n                f_new = [func(xi) for xi in new_x]\n                if np.min(f_new) < self.best_f:\n                    self.best_x = new_x[np.argmin(f_new)]\n                    self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search with Adaptive Probability\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off and probability of accepting worse solutions.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "d6d6981a-8130-4570-82af-d89a9009e750", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "599f0e9c-70c3-473c-b2eb-398d65b53401", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "beea0d23-9806-4dec-bee5-82c778cc1e70", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions, adjusted from 0.5\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Refine the strategy with adaptive probability adjustment\n            refine_prob = 0.2\n            if np.random.rand() < refine_prob:\n                # Randomly select a solution to refine\n                refine_idx = np.random.choice(self.h, 1, replace=False)\n                # Generate a new solution by changing one dimension\n                new_x[refine_idx] += np.random.uniform(-0.1, 0.1)\n                new_x[refine_idx] = np.clip(new_x[refine_idx], self.lower_bound, self.upper_bound)\n                # Calculate the objective function value of the refined solution\n                f_refined = func(new_x[refine_idx])\n                # Update the best solution if the refined solution is better\n                if f_refined < self.best_f:\n                    self.best_x = new_x[refine_idx]\n                    self.best_f = f_refined\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability adjustment for exploration-exploitation trade-off", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "64f61b31-d0ee-4fee-bda8-7ab664396ac7", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # initial probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Refine the current solution with adaptive probabilistic refinement\n            if np.random.rand() < self.p:\n                refinement_probability = 0.15\n                for k in range(self.h):\n                    if np.random.rand() < refinement_probability:\n                        # Randomly select a line to refine\n                        line_to_refine = np.random.randint(0, self.dim)\n                        # Generate a new point by perturbing the line\n                        dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                        new_x[k] += dx * np.random.uniform(0, 1)\n                        new_x[k] = np.clip(new_x[k], self.lower_bound, self.upper_bound)\n                        # Calculate the new objective function value\n                        f_new[k] = func(new_x[k])\n                        # Update the best solution if the new value is better\n                        if f_new[k] < self.best_f:\n                            self.best_x = new_x[k]\n                            self.best_f = f_new[k]\n\n            # Acceptance criteria\n            if np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search with Adaptive Probabilistic Refinement\" algorithm", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "3fcbc70c-a521-4519-8613-c863321ce8b8", "solution": "import numpy as np\nimport random\nimport copy\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Refine the strategy\n            if np.random.rand() < 0.15:\n                # Randomly select two individuals\n                idx1, idx2 = np.random.choice(self.h, size=2, replace=False)\n                # Calculate the average of the two individuals\n                new_x[idx1] = (self.x[idx1] + self.x[idx2]) / 2\n                # Update the objective function values\n                f_new = [func(new_x)]\n                # Update the best solution\n                if np.min(f_new) < self.best_f:\n                    self.best_x = new_x[np.argmin(f_new)]\n                    self.best_f = np.min(f_new)\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "a7dc6eff-6b72-465f-8a53-52620cb2a450", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Refine the strategy\n            if np.random.rand() < 0.15:\n                # Randomly select a solution\n                idx = np.random.randint(0, self.h)\n                # Generate a new solution by changing one dimension\n                new_idx = np.random.randint(0, self.dim)\n                new_x[idx, new_idx] += np.random.uniform(-0.1, 0.1)\n                new_x[idx, new_idx] = np.clip(new_x[idx, new_idx], self.lower_bound, self.upper_bound)\n                # Calculate the new objective function value\n                f_new = [func(xi) for xi in new_x]\n                # Update the best solution if necessary\n                if np.min(f_new) < self.best_f:\n                    self.best_x = new_x[np.argmin(f_new)]\n                    self.best_f = np.min(f_new)\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with probability adjustment for adaptive exploration-exploitation trade-off.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "7ba765f9-26d6-489d-a129-693055c0a0a7", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # adaptive probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria with adaptive probability\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f or np.random.rand() < self.p:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search with Adaptive Probability\" algorithm combining the strengths of Harmony Search and Multi-Directional Search with adaptive probability adjustment.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "b5625735-d6ea-4682-b386-a225961a627b", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # adaptive probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                # Refine the strategy with adaptive probability\n                refine_prob = self.p + np.random.uniform(-0.05, 0.05)\n                refine_prob = np.clip(refine_prob, 0, 1)\n                if np.random.rand() < refine_prob:\n                    # Change individual lines of the selected solution\n                    for k in range(self.dim):\n                        dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                        new_x[i, k] += dx * np.random.uniform(0, 1)\n                        new_x[i, k] = np.clip(new_x[i, k], self.lower_bound, self.upper_bound)\n                    # Update the best solution\n                    if np.min(f_new) < self.best_f:\n                        self.best_x = new_x[np.argmin(f_new)]\n                        self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability of accepting worse solutions.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "3700752d-dfd3-4067-9ddb-b3d1081ee508", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.random.rand() < 0.15 or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search with Adaptive Probability\" algorithm combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off and refine the strategy with a probability of 0.15.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "1be82d7d-d519-49ae-80b4-86d3c3019a0e", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # adaptive probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Adaptive probability adjustment\n            if np.random.rand() < self.p:\n                self.p = max(0.05, self.p - 0.05)  # decrease probability by 0.05\n            elif np.random.rand() < 0.8:\n                self.p = min(0.5, self.p + 0.05)  # increase probability by 0.05\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability adjustment", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "e2d4ee8c-7767-4183-857e-c31d74bc1ab7", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability of accepting worse solutions", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "2c7f49c1-0766-4cdc-9dd6-9ed5cc10e2bd", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Refine the strategy with 0.15 probability\n            if np.random.rand() < 0.15:\n                # Select a random individual\n                i = np.random.randint(0, self.h)\n                # Change one line of the individual\n                j = np.random.randint(0, self.dim)\n                new_x[i, j] += np.random.uniform(-self.upper_bound, self.upper_bound) * np.random.uniform(0, 1)\n                new_x[i, j] = np.clip(new_x[i, j], self.lower_bound, self.upper_bound)\n\n                # Calculate the objective function values\n                f_new = [func(xi) for xi in new_x]\n                # Update the best solution\n                if np.min(f_new) < self.best_f:\n                    self.best_x = new_x[np.argmin(f_new)]\n                    self.best_f = np.min(f_new)\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "fd0bbc72-e05d-4813-9f28-7c53f65af3af", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # initial probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Adaptive probability adjustment\n            prob = self.p * (1 - _ / self.budget)  # decrease probability as budget decreases\n            if np.random.rand() < prob or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability adjustment.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "7f689239-6d23-406e-8784-e4e1c96c026d", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                # Refine the strategy by changing the individual lines with probability 0.15\n                if np.random.rand() < 0.15:\n                    idx = np.random.randint(0, self.h)\n                    new_x[idx] += np.random.uniform(-self.upper_bound, self.upper_bound) * np.random.uniform(0, 1)\n                    new_x[idx] = np.clip(new_x[idx], self.lower_bound, self.upper_bound)\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "05075d24-71e3-45c0-b605-bf52b289806a", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # initial probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n        self.p_adjustment = 0.15  # probability adjustment for refining the strategy\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n                # Refine the strategy by adjusting the probability\n                if np.random.rand() < self.p_adjustment:\n                    self.p *= 0.9  # decrease the probability\n                    if self.p < 0.1:\n                        self.p = 0.1  # minimum probability\n                    else:\n                        self.p = np.random.uniform(0.1, 0.5)  # randomize the probability\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability adjustment for exploration-exploitation trade-off.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "2f570af2-2411-4247-b9ae-fb57a755a81f", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions, adjusted to 0.15\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Refine the strategy with adaptive probability adjustment\n            refine_probability = 0.15\n            if np.random.rand() < refine_probability:\n                for i in range(self.h):\n                    for j in range(self.d):\n                        # Randomly select a direction\n                        dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                        new_x[i] += dx * np.random.uniform(0, 1)\n                        new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n                        # Calculate the objective function values\n                        f_new = [func(xi) for xi in new_x]\n\n                        # Update the best solution\n                        if np.min(f_new) < self.best_f:\n                            self.best_x = new_x[np.argmin(f_new)]\n                            self.best_f = np.min(f_new)\n\n                        # Acceptance criteria\n                        if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                            self.x = new_x\n                            self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability adjustment", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "e08395cc-10d9-4947-b7c8-e4d52b3e5592", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                # Refine the strategy with adaptive probability\n                refined_x = np.copy(self.x)\n                refined_f = np.copy(self.best_f)\n                for _ in range(int(self.budget * 0.15)):\n                    # Randomly select an individual\n                    idx = np.random.randint(0, self.h)\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    # Refine the individual\n                    refined_x[idx] += dx * np.random.uniform(0, 1)\n                    refined_x[idx] = np.clip(refined_x[idx], self.lower_bound, self.upper_bound)\n                    # Calculate the objective function value\n                    refined_f[idx] = func(refined_x[idx])\n                    # Update the best solution\n                    if refined_f[idx] < refined_f:\n                        self.best_x = refined_x\n                        self.best_f = refined_f\n                self.x = refined_x\n                self.best_f = refined_f\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search with Adaptive Probability\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off with a probability of 0.15.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "14ca8108-397a-415c-8c21-b9359c7844f0", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Adaptive probabilistic refinement\n            if np.random.rand() < 0.15:\n                # Refine the solution by changing one line\n                index = np.random.randint(0, self.dim)\n                new_x[i, index] += np.random.uniform(-0.1, 0.1)\n                new_x[i, index] = np.clip(new_x[i, index], self.lower_bound, self.upper_bound)\n                f_new = [func(xi) for xi in new_x]\n                if np.min(f_new) < self.best_f:\n                    self.best_x = new_x[np.argmin(f_new)]\n                    self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search with Adaptive Probabilistic Refinement\" algorithm", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "d777b605-4803-4315-88a4-47748b690ac5", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria with probability 0.15\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n                # Refine the strategy with probability 0.15\n                if np.random.rand() < 0.15:\n                    for k in range(self.h):\n                        for l in range(self.d):\n                            # Randomly select a direction\n                            dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                            new_x[k] += dx * np.random.uniform(0, 1)\n                            new_x[k] = np.clip(new_x[k], self.lower_bound, self.upper_bound)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off with probability 0.15.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "5ebd3ff3-abd1-46bd-ada8-ebc932d4b5e4", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # initial probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n        self.p_refine = 0.15  # probability of refining the strategy\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Refine the strategy\n            if np.random.rand() < self.p_refine:\n                # Randomly select an individual to refine\n                idx = np.random.randint(0, self.h)\n                # Generate a new harmony\n                new_x[idx] += np.random.uniform(-self.upper_bound, self.upper_bound)\n                new_x[idx] = np.clip(new_x[idx], self.lower_bound, self.upper_bound)\n                # Calculate the objective function value\n                f_new = func(new_x[idx])\n                # Update the best solution\n                if f_new < self.best_f:\n                    self.best_x = new_x[idx]\n                    self.best_f = f_new\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "2d2d7cd9-28db-4664-8744-3f02097fef9c", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # initial probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n        self.refine_prob = 0.15  # probability of refining the current solution\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Refine the current solution with probability refine_prob\n            if np.random.rand() < self.refine_prob:\n                # Refine the current solution by perturbing it\n                refined_x = np.copy(self.x)\n                for i in range(self.h):\n                    for j in range(self.d):\n                        # Randomly select a direction\n                        dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                        refined_x[i] += dx * np.random.uniform(0, 1)\n                        refined_x[i] = np.clip(refined_x[i], self.lower_bound, self.upper_bound)\n\n                # Calculate the objective function values\n                f_refined = [func(xi) for xi in refined_x]\n\n                # Update the best solution\n                if np.min(f_refined) < self.best_f:\n                    self.best_x = refined_x[np.argmin(f_refined)]\n                    self.best_f = np.min(f_refined)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search with Adaptive Probabilistic Refinement\" algorithm", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "73be25a5-d29e-47d6-a55a-f38f6be17319", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # initial probability of accepting worse solutions\n        self.p_threshold = 0.15  # threshold for adjusting probability\n        self.p_adjustment = 0.1  # adjustment step for probability\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Adjust probability based on success rate\n            success_rate = np.sum(f_new < self.best_f) / self.h\n            if success_rate > self.p:\n                self.p = min(1, self.p + self.p_adjustment)\n            elif success_rate < self.p:\n                self.p = max(0, self.p - self.p_adjustment)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability adjustment", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "89922e9c-b59e-42d6-b42a-4fd3acd5cda4", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # adaptive probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability of accepting worse solutions.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "48051d9e-c397-45f3-936d-1f1afb735d34", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Refine the strategy by changing individual lines\n            if np.random.rand() < self.p:\n                idx = np.random.choice(self.h)\n                new_x[idx] = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n                new_x[idx] = np.clip(new_x[idx], self.lower_bound, self.upper_bound)\n                f_new = [func(xi) for xi in new_x]\n                if np.min(f_new) < self.best_f:\n                    self.best_x = new_x[np.argmin(f_new)]\n                    self.best_f = np.min(f_new)\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "9cda6dd5-a15e-4e10-8f32-235660bc70f1", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                # Refine the strategy by changing individual lines with probability 0.15\n                refine = np.random.rand(self.h, self.d) < 0.15\n                new_x[refine] += np.random.uniform(-self.upper_bound, self.upper_bound, size=(refine.sum(), self.dim)) * np.random.uniform(0, 1, size=(refine.sum(), 1))\n                new_x[refine] = np.clip(new_x[refine], self.lower_bound, self.upper_bound)\n\n                f_new[refine] = func(new_x[refine])\n                if np.min(f_new[refine]) < np.min(f_new):\n                    self.x = new_x\n                    self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability to adjust exploration-exploitation trade-off.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "c85cd7d8-d9b6-4fd7-bdc4-78ec9a332bc1", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                # Refine the strategy by changing individual lines with probability 0.15\n                for i in range(self.h):\n                    if np.random.rand() < 0.15:\n                        # Randomly select a direction\n                        dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                        new_x[i] += dx * np.random.uniform(0, 1)\n                        new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "32952734-4af7-484a-9a06-ec3e6678eeca", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p * 0.15 or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "18f6e75b-2228-4868-a2ce-f130a0dcc816", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n        self.refine_probability = 0.15\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                if np.random.rand() < self.refine_probability:\n                    # Refine the solution by changing one line at a time\n                    for k in range(self.dim):\n                        if np.random.rand() < 0.5:\n                            # Change the value of the variable\n                            new_x[i, k] += np.random.uniform(-0.1, 0.1)\n                            new_x[i, k] = np.clip(new_x[i, k], self.lower_bound, self.upper_bound)\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search with Adaptive Probabilistic Refinement\" algorithm.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "dd864714-51b3-4fbe-8656-374d35dbb975", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "2dec2a1a-65af-4d77-bc02-071b9c0a12d9", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # initial probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n        self.p_adjustment = 0.15  # adjustment factor for probability\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Adjust probability based on convergence\n            if self.p > 0.01:\n                self.p *= (1 - self.p_adjustment)\n            elif self.p < 0.01:\n                self.p *= (1 + self.p_adjustment)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability adjustment", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "9248d720-50b5-45e5-876a-f22edc913403", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                # Refine individual lines with probability 0.15\n                if np.random.rand() < self.p:\n                    for i in range(self.h):\n                        for j in range(self.d):\n                            # Randomly select a direction\n                            dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                            new_x[i] += dx * np.random.uniform(0, 1)\n                            new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive exploration-exploitation trade-off and probability 0.15 for refining individual lines.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "79ab23e9-41ac-49a2-be4d-9e2eec0373c6", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Refine strategy by changing individual lines\n            if np.random.rand() < self.p:\n                # Randomly select a dimension\n                dim = np.random.randint(0, self.dim)\n                # Randomly select a direction\n                dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                # Change the value of the selected dimension\n                self.x[dim] += dx * np.random.uniform(0, 1)\n                self.x[dim] = np.clip(self.x[dim], self.lower_bound, self.upper_bound)\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm combining strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "cb205155-6826-43b5-a9bb-85d2c4d2c937", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Refine the strategy with adaptive probability\n            refine_prob = self.p * (1 + np.random.uniform(-0.1, 0.1))\n            if np.random.rand() < refine_prob:\n                # Change the individual lines of the selected solution\n                for i in range(self.h):\n                    for j in range(self.d):\n                        # Randomly select a direction\n                        dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                        new_x[i] += dx * np.random.uniform(0, 1)\n                        new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n                # Calculate the objective function values\n                f_new = [func(xi) for xi in new_x]\n\n                # Update the best solution\n                if np.min(f_new) < self.best_f:\n                    self.best_x = new_x[np.argmin(f_new)]\n                    self.best_f = np.min(f_new)\n\n                # Acceptance criteria\n                if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                    self.x = new_x\n                    self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "83d82962-2999-45c8-a371-c6bd3db258f9", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm combining strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "e09b9f81-465a-4b7e-ac0a-ba5f18f0ee9b", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                # Refine the strategy with adaptive probability\n                refine_prob = np.random.rand()\n                if refine_prob < self.p:\n                    # Randomly select an individual to refine\n                    refine_idx = np.random.choice(self.h)\n                    # Generate a new harmony by changing one line of the selected individual\n                    new_x[refine_idx] += np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[refine_idx] = np.clip(new_x[refine_idx], self.lower_bound, self.upper_bound)\n                    # Calculate the new objective function value\n                    f_new[refine_idx] = func(new_x[refine_idx])\n                    # Update the best solution if necessary\n                    if np.min(f_new) < self.best_f:\n                        self.best_x = new_x[np.argmin(f_new)]\n                        self.best_f = np.min(f_new)\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability to adjust exploration-exploitation trade-off.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "dc85ed0d-6863-4ff9-8398-61dc93537898", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                # Refine the strategy with a 0.15 probability\n                if np.random.rand() < 0.15:\n                    # Randomly change one dimension of the new solution\n                    idx = np.random.randint(0, self.dim)\n                    new_x[i, idx] = np.clip(new_x[i, idx] + np.random.uniform(-0.5, 0.5), self.lower_bound, self.upper_bound)\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search with Adaptive Exploration\" algorithm", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "24d0f91e-ea4d-4394-8713-d0836ab20cc1", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n                # Refine the strategy by changing individual lines with probability 0.15\n                if np.random.rand() < 0.15:\n                    for k in range(self.h):\n                        for l in range(self.dim):\n                            if np.random.rand() < 0.15:\n                                self.x[k, l] += np.random.uniform(-0.1, 0.1)\n                                self.x[k, l] = np.clip(self.x[k, l], self.lower_bound, self.upper_bound)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability for exploring better solutions.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "12c552a4-0543-4c75-901c-938743139450", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Refine strategy with probability 0.15\n            if np.random.rand() < 0.15:\n                # Randomly select a dimension to change\n                dim_to_change = np.random.randint(0, self.dim)\n                # Randomly select a new value\n                new_value = np.random.uniform(self.lower_bound, self.upper_bound)\n                # Change the value\n                self.x[dim_to_change] = new_value\n                # Update the best solution\n                if np.min([func(xi) for xi in self.x]) < self.best_f:\n                    self.best_x = self.x[np.argmin([func(xi) for xi in self.x])]\n                    self.best_f = np.min([func(xi) for xi in self.x])\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "3cc30078-db53-41f1-a65a-557c0ab3ab37", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "4c767378-76ae-48db-af61-ba99fdcc8828", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # initial probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Adaptive probability adjustment\n            prob_adj = 0.15 * (1 - (self.best_f - np.min(f_new)) / (self.budget * self.h * self.d))\n            self.p = max(0, min(1, self.p + prob_adj))\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability adjustment.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "521ff341-d254-4c4c-90ee-a0a67db84437", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Refine the strategy with probability 0.15\n            if np.random.rand() < 0.15:\n                # Select a random individual\n                idx = np.random.randint(0, self.h)\n                # Change its lines\n                new_idx = np.random.randint(0, self.dim)\n                new_x[idx, new_idx] += np.random.uniform(-0.5, 0.5)\n                new_x[idx, new_idx] = np.clip(new_x[idx, new_idx], self.lower_bound, self.upper_bound)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive exploration-exploitation trade-off", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "43b6f3aa-ff74-4930-b4d2-85fa1aa763df", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria with adaptive probability adjustment\n            if np.random.rand() < self.p * 0.85 or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n                # Refine the strategy with probability 0.15\n                if np.random.rand() < 0.15:\n                    # Randomly change one dimension\n                    idx = np.random.randint(0, self.dim)\n                    self.x[idx] = np.clip(self.x[idx] + np.random.uniform(-self.upper_bound, self.upper_bound), self.lower_bound, self.upper_bound)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability adjustment for exploration-exploitation trade-off.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "fa35d447-5438-4652-8d0a-55d772560bfa", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # initial probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n        self.p_refine = 0.15  # probability for refining the strategy\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Refine the strategy\n            if np.random.rand() < self.p_refine:\n                # Randomly select a solution to refine\n                idx = np.random.randint(0, self.h)\n                # Generate new harmonies\n                new_x = np.copy(self.x)\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[idx] += dx * np.random.uniform(0, 1)\n                    new_x[idx] = np.clip(new_x[idx], self.lower_bound, self.upper_bound)\n\n                # Calculate the objective function values\n                f_new = [func(xi) for xi in new_x]\n\n                # Update the best solution\n                if np.min(f_new) < self.best_f:\n                    self.best_x = new_x[np.argmin(f_new)]\n                    self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "bf53ea40-fccf-46f3-9172-080e9b495c2f", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # adaptive probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability of accepting worse solutions.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "4ce22039-51ad-40de-9784-b7962a10d0c1", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f or np.random.rand() < 0.15:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search with Adaptive Probability\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off with a probability of 0.15.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "8a2e5a6d-3678-448f-955f-be44879902de", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                # Refine the strategy by changing individual lines\n                for k in range(self.h):\n                    for l in range(self.d):\n                        if np.random.rand() < self.p:\n                            new_x[k] += np.random.uniform(-self.upper_bound, self.upper_bound)\n                            new_x[k] = np.clip(new_x[k], self.lower_bound, self.upper_bound)\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "c738acdd-f1eb-4dcc-b4ea-7553f894dd5b", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Refine the strategy with probability 0.15\n            if np.random.rand() < self.p:\n                for i in range(self.h):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    self.x[i] += dx * np.random.uniform(0, 1)\n                    self.x[i] = np.clip(self.x[i], self.lower_bound, self.upper_bound)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off with probability 0.15.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "e6dc9ac0-a015-4570-94d2-42dd912ba2c2", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.random.rand() < 0.15 or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with probability adjustment for adaptive exploration-exploitation trade-off.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "58295d5c-a926-48af-8063-e2ad6ef4cd94", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n                # Refine the strategy with probability 0.15\n                if np.random.rand() < self.p:\n                    for k in range(self.dim):\n                        if np.random.rand() < self.p:\n                            self.x[k] = np.clip(self.x[k] + np.random.uniform(-self.upper_bound, self.upper_bound), self.lower_bound, self.upper_bound)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off with probability 0.15.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "edef4409-6479-419b-863b-a0bc78777d9a", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n        self.adaptive_p = 0.15  # adaptive probability\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n                # Refine strategy with adaptive probability\n                if np.random.rand() < self.adaptive_p:\n                    # Randomly change the probability of accepting worse solutions\n                    self.p = np.random.uniform(0, 1)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "be450f1d-ecd8-4473-8360-9a4aaae7d748", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")\n", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search with Adaptive Probability\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off with a probability of 0.15.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "867e7102-6e9e-41f5-96be-d295f25e05c2", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm combining Harmony Search and Multi-Directional Search for adaptive exploration-exploitation trade-off", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "25d55531-1916-4ba8-bc64-c4b9655dc538", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions, adjusted to 0.15\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria with adaptive probability\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability adjustment", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "9ff245cc-2c01-4730-9f6e-580829147be8", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # initial probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Adaptive probability adjustment\n            if np.random.rand() < self.p * (1 - (_ / self.budget)) or np.min(f_new) < self.best_f:\n                self.p = np.random.uniform(0.15, 0.5)  # adjust probability between 0.15 and 0.5\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability adjustment for exploration-exploitation trade-off.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "f8227f62-5998-4af7-a7d1-523f3577ec12", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                # Refine the strategy with probability 0.15\n                if np.random.rand() < self.p:\n                    # Randomly select a line of the current solution\n                    line_idx = np.random.randint(0, self.dim)\n                    # Change the value of the selected line\n                    new_x[i, line_idx] += np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i, line_idx] = np.clip(new_x[i, line_idx], self.lower_bound, self.upper_bound)\n                    # Calculate the new objective function value\n                    f_new = [func(xi) for xi in new_x]\n                    # Update the best solution\n                    if np.min(f_new) < self.best_f:\n                        self.best_x = new_x[np.argmin(f_new)]\n                        self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off with probability 0.15.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "162f800f-5ce4-4268-a491-f17dc0530736", "solution": "import numpy as np\nimport random\nimport time\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n            time.sleep(0.1)  # pause for 0.1 seconds\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "401b3d43-d982-4bb9-8dbc-6eab563fd729", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability to adjust exploration-exploitation trade-off.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "20aa407d-6f63-48cb-8ed0-86deba671fcb", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Refine strategy by changing individual lines with probability 0.15\n            if np.random.rand() < 0.15:\n                idx = np.random.randint(0, self.h)\n                new_idx = np.random.randint(0, self.dim)\n                new_x[idx, new_idx] += np.random.uniform(-0.3, 0.3)\n                new_x[idx, new_idx] = np.clip(new_x[idx, new_idx], self.lower_bound, self.upper_bound)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "ed05b2a3-d0be-45d2-abff-e31af03bc8f5", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n        self.probability_adjustment = 0.15\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.random.rand() < self.probability_adjustment or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off with probability adjustment.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "2f2a245a-d106-4c74-be35-fb5b2e5f4686", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Refine the strategy with a probability of 0.15\n            if np.random.rand() < 0.15:\n                # Randomly select two individuals\n                idx1, idx2 = np.random.randint(0, self.h, 2)\n                # Swap the values of the two individuals\n                new_x[idx1, :] = new_x[idx2, :]\n                # Calculate the objective function values\n                f_new = [func(xi) for xi in new_x]\n                # Update the best solution\n                if np.min(f_new) < self.best_f:\n                    self.best_x = new_x[np.argmin(f_new)]\n                    self.best_f = np.min(f_new)\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search with Adaptive Probability\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off and refine the strategy with a probability of 0.15.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "f7db81b1-8f6a-4229-8b8f-ed81e50e5490", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Probability-based line search\n            if np.random.rand() < self.p:\n                for i in range(self.h):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n                    # Calculate the objective function value\n                    f_new = func(new_x[i])\n                    # Update the best solution\n                    if f_new < self.best_f:\n                        self.best_x = new_x[i]\n                        self.best_f = f_new\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with probability-based line search.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "9840a428-f7b8-420f-86cb-1a8324ae363e", "solution": "import numpy as np\nimport random\nimport copy\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm combining Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "7d68cf46-2623-49fa-a5a6-9c787c271ab7", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                # Refine strategy with probability 0.15\n                if np.random.rand() < self.p:\n                    for k in range(self.h):\n                        # Randomly select a direction\n                        dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                        new_x[k] += dx * np.random.uniform(0, 1)\n                        new_x[k] = np.clip(new_x[k], self.lower_bound, self.upper_bound)\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off with probability 0.15 to refine its strategy.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "82793a08-5dd2-466f-b9a2-2c0cc90d12c9", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Refine the strategy with adaptive probability\n            for _ in range(int(self.budget * 0.15)):\n                # Randomly select an individual\n                idx = np.random.randint(0, self.h)\n                # Randomly select a direction\n                dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                # Change the individual line by the direction\n                new_x[idx] += dx * np.random.uniform(0, 1)\n                new_x[idx] = np.clip(new_x[idx], self.lower_bound, self.upper_bound)\n                # Calculate the objective function value\n                f_new = [func(xi) for xi in new_x]\n                # Update the best solution if necessary\n                if np.min(f_new) < self.best_f:\n                    self.best_x = new_x[np.argmin(f_new)]\n                    self.best_f = np.min(f_new)\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search with Adaptive Probability\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off with a probability of 0.15.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "8388569f-37e0-4e1f-bcf1-49230bd102e4", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # initial probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Adaptive probability adjustment\n            if np.random.rand() < self.p * 0.15:\n                # Randomly change the direction of the worst individual\n                worst_idx = np.argmin(f_new)\n                worst_x = new_x[worst_idx]\n                worst_x += np.random.uniform(-self.upper_bound, self.upper_bound) * np.random.uniform(0, 1)\n                worst_x = np.clip(worst_x, self.lower_bound, self.upper_bound)\n                f_new[worst_idx] = func(worst_x)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability to adjust exploration-exploitation trade-off.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "52ae187e-d54f-4139-b8af-96d7af5da815", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                # Refine the strategy by changing individual lines with probability 0.15\n                if np.random.rand() < 0.15:\n                    idx = np.random.randint(0, self.h)\n                    new_x[idx] = np.clip(new_x[idx] + np.random.uniform(-self.upper_bound, self.upper_bound), self.lower_bound, self.upper_bound)\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "43f8856e-f377-416e-8aaa-56ab58d407e9", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Refine the strategy by changing individual lines with a probability of 0.15\n            if np.random.rand() < self.p:\n                for i in range(self.h):\n                    for j in range(self.dim):\n                        if np.random.rand() < self.p:\n                            self.x[i, j] += np.random.uniform(-0.5, 0.5)\n                            self.x[i, j] = np.clip(self.x[i, j], self.lower_bound, self.upper_bound)\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm combining Harmony Search and Multi-Directional Search for adaptive exploration-exploitation trade-off.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "d31e0f54-2f13-44f2-bcb5-cf2c85473f7d", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # initial probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Adaptive probability adjustment\n            prob_adjustment = np.random.rand()\n            if prob_adjustment < 0.15:\n                self.p = 0.5 * (1 + np.random.uniform(-0.2, 0.2))\n                self.p = max(0.1, min(0.9, self.p))  # ensure probability within bounds\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability adjustment.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "1eceec34-8d0f-4e67-83f9-d6c36159f16e", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                # Refine the solution with probability 0.15\n                if np.random.rand() < self.p:\n                    self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n                else:\n                    self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm combining Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off with probability 0.15.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "69bb18c6-0b1f-4a3a-b477-b8ef9bb75930", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                # Refine the strategy by changing individual lines with probability 0.15\n                for k in range(self.h):\n                    if np.random.rand() < self.p:\n                        for l in range(self.dim):\n                            new_x[k][l] += np.random.uniform(-0.1, 0.1)\n                            new_x[k][l] = np.clip(new_x[k][l], self.lower_bound, self.upper_bound)\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "c01a0bb6-e2a8-436e-88db-15003b547a93", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # initial probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.p_refine = 0.15  # probability of refining existing solutions\n        self.p_adapt = 0.1  # probability of adapting the probability of accepting worse solutions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Refine existing solutions with probability p_refine\n            if np.random.rand() < self.p_refine:\n                # Randomly select an existing solution\n                i = np.random.randint(0, self.h)\n                # Generate a new harmony by perturbing the selected solution\n                new_x[i] += np.random.uniform(-self.upper_bound, self.upper_bound) * np.random.uniform(0, 1)\n                new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n                # Calculate the objective function value of the new harmony\n                f_new = [func(xi) for xi in new_x]\n                # Update the best solution if the new harmony is better\n                if np.min(f_new) < self.best_f:\n                    self.best_x = new_x[np.argmin(f_new)]\n                    self.best_f = np.min(f_new)\n\n            # Adapt the probability of accepting worse solutions with probability p_adapt\n            if np.random.rand() < self.p_adapt:\n                self.p = 0.5 * (1 + np.random.uniform(-0.1, 0.1))\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability for exploring new solutions.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "9036ae8b-9d92-41f5-80d4-2b0be6e95c4c", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n                # Refine the strategy by changing individual lines with a probability of 0.15\n                if np.random.rand() < self.p:\n                    for i in range(self.h):\n                        for j in range(self.dim):\n                            if np.random.rand() < self.p:\n                                self.x[i, j] += np.random.uniform(-0.1, 0.1)\n                                self.x[i, j] = np.clip(self.x[i, j], self.lower_bound, self.upper_bound)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search with Adaptive Probability\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off with a probability of 0.15.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "9b6d9dc1-e69f-428f-a602-104f71ed7907", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                # Refine the solution with a probability of 0.15\n                if np.random.rand() < self.p:\n                    # Randomly select two individuals\n                    i1, i2 = np.random.choice(self.h, size=2, replace=False)\n                    # Calculate the new individual by taking the average of the two individuals\n                    new_x[i1] = (new_x[i1] + new_x[i2]) / 2\n                    # Update the best solution\n                    if np.min(f_new) < self.best_f:\n                        self.best_x = new_x[np.argmin(f_new)]\n                        self.best_f = np.min(f_new)\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off with a probability of 0.15.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "a4f8e5a8-9f03-4d89-a7a9-5320f329118a", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "9d5d4268-42e3-4365-9b96-13ec8cb15e81", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n        self.adaptive_p = 0.15  # adaptive probability of accepting worse solutions\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.random.rand() < self.adaptive_p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search with Adaptive Exploration\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "b003cd72-d4f1-4994-b217-85987c38c9f9", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "c90a1ef4-3658-4091-9aba-559d48d67ebf", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # initial probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n        self.probability_adjustment = 0.15\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n            else:\n                # Adjust probability based on exploration-exploitation trade-off\n                if np.mean(f_new) < np.mean(self.best_f):\n                    self.p *= (1 - self.probability_adjustment)\n                else:\n                    self.p *= (1 + self.probability_adjustment)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability adjustment.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "9a337fc7-5064-4114-b4ec-89ddc8eea8d3", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # initial probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n        self.p_adjustment = 0.15  # probability adjustment for refinement\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Refine the strategy with adaptive probability adjustment\n            if np.random.rand() < self.p_adjustment:\n                # Randomly change the probability of accepting worse solutions\n                self.p = np.random.uniform(0.0, 1.0)\n                # Update the best solution\n                if np.min(f_new) < self.best_f:\n                    self.best_x = new_x[np.argmin(f_new)]\n                    self.best_f = np.min(f_new)\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability adjustment for exploration-exploitation trade-off.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "6665ad45-a1d1-401a-b904-8d47c88e52b4", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                # Refine the strategy by changing individual lines with probability 0.15\n                refine = np.random.rand(self.h) < 0.15\n                for k, flag in enumerate(refine):\n                    if flag:\n                        # Randomly select a direction\n                        dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                        new_x[k] += dx * np.random.uniform(0, 1)\n                        new_x[k] = np.clip(new_x[k], self.lower_bound, self.upper_bound)\n                        # Update the best solution\n                        f_new = [func(xi) for xi in new_x]\n                        if np.min(f_new) < self.best_f:\n                            self.best_x = new_x[np.argmin(f_new)]\n                            self.best_f = np.min(f_new)\n\n            self.x = new_x\n            self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search with Adaptive Probability\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "5c0bab95-5fea-427d-a9f0-4bcbf761aa67", "solution": "import numpy as np\nimport random\nimport copy\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "d245b51b-36f0-4e51-9837-d1fd47370d34", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # initial probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n        self.p_adjustment = 0.15  # adjustment factor for probability\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Adjust probability based on success rate\n            success_rate = np.sum([1 for _ in range(self.h) if np.min([func(xi) for xi in new_x]) < self.best_f]) / self.h\n            self.p = max(0.01, self.p - self.p_adjustment * success_rate)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability adjustment.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "f1494fbe-0aae-4523-8dd2-1304cc45a56c", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # initial probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n        self.p_adjustment = 0.15  # probability adjustment factor\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria with adaptive probability adjustment\n            if np.random.rand() < self.p * (1 + self.p_adjustment * np.random.rand()):\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability adjustment.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "a0f00e23-5f1c-4b5e-9517-91609a69b17c", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # adaptive probability for refining its strategy\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability for refining its strategy.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "5d4e868d-4588-45bd-9927-49801b97953e", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # initial probability of accepting worse solutions\n        self.p_mutate = 0.15  # probability of changing the individual\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f or np.random.rand() < self.p_mutate:\n                # Refine the strategy by changing the individual lines\n                for k in range(self.dim):\n                    if np.random.rand() < self.p_mutate:\n                        new_x[i, k] += np.random.uniform(-self.upper_bound, self.upper_bound)\n                        new_x[i, k] = np.clip(new_x[i, k], self.lower_bound, self.upper_bound)\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability of accepting worse solutions.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "245fd3dd-5e34-4f76-98e0-f9f2f96bffb5", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                # Refine the strategy with adaptive probability\n                refined_x = self.refine_strategy(new_x, self.p)\n                self.x = refined_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n    def refine_strategy(self, x, p):\n        refined_x = np.copy(x)\n        for i in range(self.h):\n            # Randomly select a direction\n            dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n            refined_x[i] += dx * np.random.uniform(0, 1)\n            refined_x[i] = np.clip(refined_x[i], self.lower_bound, self.upper_bound)\n\n            # Apply probability to change the individual line\n            if np.random.rand() < p:\n                refined_x[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n        return refined_x\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search with Adaptive Probability\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off with a probability of 0.15.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "bfb61b26-3eec-4735-82e4-7891c64802e3", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Refine the strategy by changing individual lines with a probability of 0.15\n            if np.random.rand() < 0.15:\n                for k in range(self.h):\n                    for l in range(self.dim):\n                        if np.random.rand() < 0.15:\n                            new_x[k][l] += np.random.uniform(-0.1, 0.1)\n                            new_x[k][l] = np.clip(new_x[k][l], self.lower_bound, self.upper_bound)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search with Adaptive Probabilities\" algorithm", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "f881654e-588b-4bb5-bf50-d21ea744ad31", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # initial probability of accepting worse solutions\n        self.p_decay = 0.15  # probability decay rate\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Adaptive probability adjustment\n            self.p = max(0, self.p - self.p_decay)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability adjustment for exploration-exploitation trade-off.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "35da7588-b170-4687-a1cf-c687e549bfe1", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.15  # adaptive probability\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability and refined strategy.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "fa2abb0d-5ea6-406b-bf23-3ed1371c045c", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n        self.p_line_search = 0.15  # probability of changing the individual lines\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                # Probabilistic line search to refine the strategy\n                if np.random.rand() < self.p_line_search:\n                    # Generate new individuals by changing one line at a time\n                    new_individual = self.x.copy()\n                    for k in range(self.dim):\n                        new_individual[k] += np.random.uniform(-0.1, 0.1)\n                        new_individual[k] = np.clip(new_individual[k], self.lower_bound, self.upper_bound)\n                    new_f = func(new_individual)\n                    if new_f < self.best_f:\n                        self.best_x = new_individual\n                        self.best_f = new_f\n\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive exploration-exploitation trade-off and probabilistic line search.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "7d8d1655-ccd9-40c0-82d1-1fdd716db093", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # initial probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.p_refine = 0.15  # probability for refining the strategy\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Refine the strategy with adaptive probability\n            refine = np.random.rand()\n            if refine < self.p_refine:\n                # Refine the probability of accepting worse solutions\n                self.p = 0.5 * self.p + 0.5 * (1 - self.p)\n\n            # Acceptance criteria\n            if refine < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm with adaptive probability refinement", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
{"id": "8c9551ff-cbf6-425a-8206-ad24db0d498b", "solution": "import numpy as np\nimport random\n\nclass MultiDirectionalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.p = 0.5  # probability of accepting worse solutions\n        self.h = 10  # harmony size\n        self.d = 5  # number of directions\n        self.x = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.h, self.dim))\n        self.best_x = np.copy(self.x[0])\n        self.best_f = func(self.x[0])\n        self.refine_prob = 0.15\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Generate new harmonies\n            new_x = np.copy(self.x)\n            for i in range(self.h):\n                for j in range(self.d):\n                    # Randomly select a direction\n                    dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                    new_x[i] += dx * np.random.uniform(0, 1)\n                    new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n            # Calculate the objective function values\n            f_new = [func(xi) for xi in new_x]\n\n            # Update the best solution\n            if np.min(f_new) < self.best_f:\n                self.best_x = new_x[np.argmin(f_new)]\n                self.best_f = np.min(f_new)\n\n            # Acceptance criteria\n            if np.random.rand() < self.p or np.min(f_new) < self.best_f:\n                self.x = new_x\n                self.best_f = np.min(f_new)\n\n                # Refine the solution with 10% probability\n                if np.random.rand() < self.refine_prob:\n                    for i in range(self.h):\n                        # Randomly select a direction\n                        dx = np.random.uniform(-self.upper_bound, self.upper_bound)\n                        new_x[i] += dx * np.random.uniform(0, 1)\n                        new_x[i] = np.clip(new_x[i], self.lower_bound, self.upper_bound)\n\n                        # Calculate the objective function values\n                        f_new = [func(xi) for xi in new_x]\n\n                        # Update the best solution\n                        if np.min(f_new) < self.best_f:\n                            self.best_x = new_x[np.argmin(f_new)]\n                            self.best_f = np.min(f_new)\n\n            # Print the best solution\n            print(f\"Best solution: f({self.best_x}) = {self.best_f}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    multi_directional_harmony_search = MultiDirectionalHarmonySearch(budget, dim)\n    multi_directional_harmony_search(\"func\")", "name": "MultiDirectionalHarmonySearch", "description": "Novel \"Multi-Directional Harmony Search\" algorithm, combining the strengths of Harmony Search and Multi-Directional Search to adaptively adjust exploration-exploitation trade-off.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05d4d0d7-9210-4e7e-afaa-87903ff6d5a8", "metadata": {}, "mutation_prompt": null}
