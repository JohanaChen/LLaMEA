{"id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm, combining the benefits of particle swarm optimization and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 33, in <module>\n  File \"<string>\", line 20, in __call__\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n.", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 33, in <module>\n  File \"<string>\", line 20, in __call__\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "5354c9da-459d-4839-93b0-40015c2c09bc", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Line search using probability-based adaptation\n            if np.random.rand() < self.probability:\n                # Get the current particle and its corresponding best value\n                particle = self.particles[i]\n                best_value = self.rbest[i]\n                # Calculate the step size for the line search\n                step_size = np.random.uniform(0.1, 0.5)\n                # Calculate the new particle position\n                new_particle = particle + step_size * np.sign(particle)\n                # Evaluate the new particle position\n                new_value = func(new_particle)\n                # Check if the new particle position is better than the current best\n                if new_value < best_value:\n                    self.particles[i] = new_particle\n                    self.rbest[i] = new_value\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm combined with probability-based line search to adapt to changing problem landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "fdfc0903-9386-48ea-97bf-a78942ce5540", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.mutation_rate = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Apply mutation with adaptive rate\n            if np.random.rand() < self.mutation_rate:\n                self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm with adaptive mutation rate", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "e2048a44-653a-463b-aa1a-d05a90cc8368", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n    def refine_solution(self):\n        # Refine the solution by changing individual lines with a probability of 0.35\n        for i in range(self.budget):\n            if random.random() < self.probability:\n                # Randomly select a dimension to change\n                dim = random.randint(0, self.dim-1)\n                # Randomly select a new value between -5.0 and 5.0\n                new_value = np.random.uniform(-5.0, 5.0)\n                # Change the value of the selected dimension\n                self.particles[i, dim] = new_value\n                # Update the personal best and global best\n                self.pbest[i, dim] = self.particles[i]\n                self.rbest[i, dim] = func(self.particles[i])\n                # Check if the current best is better than the stored best\n                if np.any(self.rbest < self.memory[i], axis=1):\n                    self.memory[i] = self.rbest\n        # Return the refined solution\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)\n\nrefined_solution = psm.refine_solution()\nprint(refined_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm combining particle swarm optimization and memory-based learning for diverse black box optimization problems.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "6d41c93b-fc23-42d8-8a38-18b0e8bdd5e3", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.pbest_update_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy by updating the best individual with a certain probability\n            if np.random.rand() < self.pbest_update_prob:\n                self.pbest[np.random.randint(0, self.budget), :] = self.particles[np.random.randint(0, self.budget), :]\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm combining PSO and memory-based learning.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "cd829112-1f5c-46fe-a78b-8a9068bd592b", "solution": "import numpy as np\n\nclass PSM_E:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.evolution_rate = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Evolution step: randomly replace particles with better solutions\n            if np.random.rand() < self.evolution_rate:\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        self.particles[i, j] = self.particles[np.random.choice(self.particles.shape[0]), j]\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm_e = PSM_E(budget=10, dim=2)\nbest_solution = psm_e(func)\nprint(best_solution)", "name": "PSM_E", "description": "Novel \"Particle Swarm with Memory and Evolution\" (PSM-E) algorithm, combining the benefits of particle swarm optimization, memory-based learning, and evolution to handle diverse black box optimization problems.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "912aa344-07ca-4732-888a-269889c3f5c7", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probs = np.ones((budget, dim)) / budget\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Update the probabilities of the particles\n            self.probs = np.random.choice([0.35, 0.65], size=self.budget, replace=True)\n            self.probs[i] = 0.35\n            # Select the particles to refine the strategy\n            refine_particles = np.random.choice(self.budget, size=int(0.35 * self.budget), replace=False)\n            # Refine the strategy of the selected particles\n            for j in refine_particles:\n                self.particles[j] = self.particles[j] + 0.1 * (self.rbest - self.particles[j])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm that combines particle swarm optimization and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "81debfef-6fc4-4674-b4a4-ab2e73d6a387", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the current best solution with a probability of 0.35\n            if np.random.rand() < self.refine_probability:\n                new_solution = self.particles[i] + np.random.uniform(-0.1, 0.1, (self.dim,))\n                values = func(new_solution)\n                if values < self.rbest[i]:\n                    self.rbest[i] = values\n                    self.memory[i] = values\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm combined with probabilistic refinement.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "78be1a2e-5736-46d7-80c9-f39d4e594a67", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            if random.random() < self.probability:\n                self.particles[i] = self.pbest[i] + 0.5 * (self.rbest - self.particles[i])\n            else:\n                self.particles[i] = self.pbest[i] + 0.5 * (self.rbest - self.particles[i]) + 0.5 * (self.particles[i] + np.random.uniform(-1, 1, self.dim))\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm combining PSO and memory-based learning.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "7f9e3e66-d097-4ee3-827a-2bf35892e7cf", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.mutation_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Adaptive mutation\n            if random.random() < self.mutation_prob:\n                # Randomly select a particle to mutate\n                idx = random.randint(0, self.budget - 1)\n                # Generate a new particle by perturbing the current particle\n                new_particle = self.particles[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                # Check if the new particle is better than the current particle\n                new_values = func(new_particle)\n                if np.any(new_values < values):\n                    self.particles[idx] = new_particle\n                    self.rbest[idx] = new_values\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm with adaptive mutation.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "9bb294d9-fdf0-4a42-a75b-f7fd79ceebcc", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.learning_rate = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy using learning from experience\n            if i % 10 == 0 and i!= 0:\n                # Select 20% of the best individuals\n                best_individuals = np.random.choice(self.pbest, size=int(0.2 * self.budget), replace=False)\n                # Randomly replace 20% of the particles with the best individuals\n                if random.random() < 0.2:\n                    self.particles[i] = best_individuals[np.random.choice(len(best_individuals))]\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory and Learning\" algorithm, combining the benefits of particle swarm optimization, memory-based learning, and learning from experience.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "8655c22b-0bea-4513-b6f8-09f2051fbe17", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.mutation_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Apply mutation with probability\n            if random.random() < self.mutation_prob:\n                # Randomly select a particle to mutate\n                idx = random.randint(0, self.budget - 1)\n                # Generate a new random value within the bounds\n                new_value = np.random.uniform(-5.0, 5.0)\n                # Replace the particle with the new value\n                self.particles[idx] = new_value\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm combined with probability-based mutation to refine the search strategy.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "796cef30-e7f4-4a10-8eb6-1583a452142f", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy with 35% probability\n            if np.random.rand() < self.refine_probability:\n                self.refine_particles(i)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n    def refine_particles(self, index):\n        # Refine the particles by changing their values with a certain probability\n        for _ in range(int(self.budget * self.refine_probability)):\n            # Select a particle to refine\n            particle_index = np.random.choice(self.budget)\n            # Change the value of the particle with a certain probability\n            if np.random.rand() < 0.5:\n                self.particles[particle_index] += np.random.uniform(-0.5, 0.5, self.dim)\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm, combining the benefits of particle swarm optimization and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "020da830-185d-4f78-8bb6-ef03d8a43a4f", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy with probability\n            if np.random.rand() < self.refine_probability:\n                # Select a particle to refine\n                idx = np.random.choice(self.particles.shape[0])\n                # Refine the particle using the PSO update rule\n                self.particles[idx] = self.particles[idx] + 0.5 * (self.pbest[idx] - self.particles[idx]) + 0.5 * (self.rbest - self.particles[idx])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm combined with probability-based refinement.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "78596473-66aa-42a7-aa93-7f17770df2ad", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the solution with probability 0.35\n            if np.random.rand() < self.refine_probability:\n                # Randomly select a particle to refine\n                j = np.random.randint(0, self.budget)\n                # Refine the selected particle\n                self.particles[j] = self.particles[j] + np.random.uniform(-0.1, 0.1, self.dim)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm with probabilistic refinement.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "ce7955b4-e261-4c70-8563-ffe6573a45f0", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.adaptive_rate = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Adaptive mutation\n            if np.random.rand() < self.adaptive_rate:\n                # Randomly select an individual from the memory\n                individual = random.choice(list(self.memory.keys()))\n                # Select a random dimension to mutate\n                dimension = np.random.randint(0, self.dim)\n                # Mutate the selected dimension\n                self.particles[i, dimension] += np.random.uniform(-1.0, 1.0)\n                # Ensure the mutation is within the bounds\n                self.particles[i, dimension] = np.clip(self.particles[i, dimension], -5.0, 5.0)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory and Adaptive Mutation\" algorithm", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "99a0a5ec-3293-42c5-8448-85e25dd92fc1", "solution": "import numpy as np\n\nclass PSMAM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.mutation_prob = 0.35\n        self.mutation_rate = 0.1\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Apply adaptive mutation\n            if np.random.rand() < self.mutation_prob:\n                mutation_index = np.random.choice(self.particles.shape[0])\n                mutated_particle = self.particles[mutation_index] + np.random.uniform(-self.mutation_rate, self.mutation_rate, self.dim)\n                self.particles[mutation_index] = mutated_particle\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsmam = PSMAM(budget=10, dim=2)\nbest_solution = psmam(func)\nprint(best_solution)", "name": "PSMAM", "description": "Novel \"Particle Swarm with Memory and Adaptive Mutation\" (PSM-AM) algorithm combining the benefits of particle swarm optimization, memory-based learning, and adaptive mutation to handle diverse black box optimization problems.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "a67e214b-3aea-41a4-b0f7-8d78f0b12041", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy with a probability of 0.35\n            if np.random.rand() < self.probability:\n                self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm, combining the benefits of particle swarm optimization and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "9c68b97d-09e4-4616-ae26-3cc9756449dc", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy with a probability\n            if random.random() < self.probability:\n                # Select a random particle to refine\n                idx = random.randint(0, self.budget-1)\n                # Refine the particle using a small step size\n                self.particles[idx] = self.particles[idx] + 0.01 * (self.rbest[idx] - self.particles[idx])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm, combining PSO and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "622bf56d-e779-46fd-bea9-c197a0d84fef", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy with probability 0.35\n            if random.random() < self.probability:\n                # Randomly select two particles to refine\n                j = random.randint(0, self.budget-1)\n                k = random.randint(0, self.budget-1)\n                # Calculate the new particle position\n                new_particle = self.particles[j] + 0.1 * (self.particles[k] - self.particles[j])\n                # Update the particles\n                self.particles[i] = new_particle\n                # Update the personal best and global best\n                self.pbest[i] = self.particles[i]\n                self.rbest[i] = func(self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm combining PSO and memory-based learning for black box optimization.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "2940b07c-95a5-44e3-b277-317cc34178b4", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy with a probability of 0.35\n            if random.random() < self.refine_probability:\n                # Randomly select a particle to refine\n                idx = random.randint(0, self.budget - 1)\n                # Refine the particle by adding a random perturbation\n                self.particles[idx] += np.random.uniform(-0.1, 0.1, self.dim)\n                # Update the personal best and global best\n                self.pbest[idx] = self.particles[idx]\n                self.rbest[idx] = func(self.particles[idx])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm combining PSO and memory-based learning.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "e034303d-eab7-480b-91ad-70486ec9f80d", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule with probability\n            if np.random.rand() < self.probability:\n                self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm, combining the benefits of particle swarm optimization and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "2fd22b68-8a66-4dde-90a1-fa085e3e86d6", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.mutation_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Adaptive mutation\n            if random.random() < self.mutation_prob:\n                # Generate a random index\n                idx = random.randint(0, self.dim - 1)\n                # Generate a random value between -5.0 and 5.0\n                value = np.random.uniform(-5.0, 5.0)\n                # Update the particle\n                self.particles[i, idx] += value\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm with adaptive mutation probability.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "646b8df2-8d14-4161-aa4d-47956212d5af", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.mutation_rate = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Apply adaptive mutation\n            if np.random.rand() < self.mutation_rate:\n                mutation_index = np.random.choice(self.budget)\n                self.particles[mutation_index] += np.random.uniform(-0.5, 0.5, self.dim)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory and Adaptive Mutation\" algorithm, combining the benefits of particle swarm optimization, memory-based learning, and adaptive mutation to handle diverse black box optimization problems.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "5ebc49b1-c14e-4e72-8ae0-a2fddc2c62d9", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            update_rule = np.random.choice([0.5, 0.5, 0.5, 0.5], p=[self.probability, self.probability, self.probability, 1-self.probability])\n            self.particles[i] = self.particles[i] + update_rule * (self.pbest[i] - self.particles[i]) + update_rule * (self.rbest - self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm combining PSO and memory-based learning to handle diverse black box optimization problems", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "61703510-4ad4-4c49-9455-5697fa958ac4", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.lr = 0.35  # adaptive learning rate\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule with adaptive learning rate\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * self.lr * (self.rbest - self.particles[i])\n            # Refine the strategy by changing the individual lines with probability 0.35\n            if random.random() < 0.35:\n                for j in range(self.dim):\n                    if random.random() < 0.35:\n                        self.particles[i, j] += random.uniform(-0.1, 0.1)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory and Adaptive Learning Rate\" algorithm combining the benefits of particle swarm optimization, memory-based learning, and adaptive learning rate to handle diverse black box optimization problems.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "891148e3-a14b-4558-b153-959ed2c5d161", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm, combining the benefits of particle swarm optimization and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "a70ed6ad-47aa-49f3-8919-ddd4c7325e74", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.mutation_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Apply probability-based mutation\n            if random.random() < self.mutation_prob:\n                # Randomly select a dimension to mutate\n                dim_to_mutate = random.randint(0, self.dim-1)\n                # Generate a new value for the dimension\n                new_value = np.random.uniform(-5.0, 5.0)\n                # Update the particle with the new value\n                self.particles[i, dim_to_mutate] = new_value\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm incorporating probability-based mutation to refine strategy.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "d8804493-7837-4121-94c8-d758d3319cee", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy with 35% probability\n            if np.random.rand() < self.refine_probability:\n                # Randomly select a particle to refine\n                refine_particle_index = np.random.randint(0, self.budget)\n                # Refine the particle's position using the PSO update rule\n                refine_particle = self.particles[refine_particle_index]\n                refine_particle = refine_particle + 0.5 * (self.pbest[refine_particle_index] - refine_particle) + 0.5 * (self.rbest - refine_particle)\n                # Replace the particle's position with the refined position\n                self.particles[refine_particle_index] = refine_particle\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm, combining PSO and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "904aa518-ae60-4ad0-9960-770fc1580b8e", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy with a probability of 0.35\n            if np.random.rand() < self.refine_probability:\n                # Randomly select a particle to refine\n                j = np.random.randint(0, self.budget)\n                # Update the particle using a probabilistic update rule\n                self.particles[j] = self.particles[j] + np.random.uniform(-1.0, 1.0, self.dim)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm with probabilistic strategy refinement", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "e01ec8c1-e600-42b2-b45b-70e95989a3e3", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the solution with probability 0.35\n            if np.random.rand() < self.refine_prob:\n                # Select a random particle to refine\n                idx = np.random.choice(self.particles.shape[0])\n                # Refine the particle by perturbing its coordinates\n                self.particles[idx] = self.particles[idx] + np.random.uniform(-0.1, 0.1, self.dim)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm combined with probability-based refinement", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "697b7ab4-9650-4f89-99e9-e4455dfe9e81", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_rate = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the solution with a probability of 0.35\n            if random.random() < self.refine_rate:\n                # Select a random particle to refine\n                index = random.choice([i for i in range(self.budget) if i not in self.memory])\n                # Refine the particle by adding a small random perturbation\n                self.particles[index] += np.random.uniform(-0.1, 0.1, self.dim)\n                # Update the personal best and global best\n                values = func(self.particles[index])\n                self.pbest[index] = self.particles[index]\n                self.rbest[index] = values\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm, combining particle swarm optimization and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "f4dc2d73-2068-4fcd-91f5-a008801ec1d5", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.mutation_probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Adaptive mutation strategy\n            if np.random.rand() < self.mutation_probability:\n                # Randomly select a dimension to mutate\n                dim_to_mutate = np.random.choice(self.dim)\n                # Mutate the particle in the selected dimension\n                self.particles[i, dim_to_mutate] += np.random.uniform(-1.0, 1.0)\n                # Ensure the mutated value is within the bounds\n                self.particles[i, dim_to_mutate] = np.clip(self.particles[i, dim_to_mutate], -5.0, 5.0)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm with adaptive mutation strategy", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "3ed9cb3e-bd46-46bf-ae4f-3e8224e32d14", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.update_probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule with probabilistic update\n            if np.random.rand() < self.update_probability:\n                self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm with probabilistic update rule for diverse black box optimization problems", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "b938d85f-1110-49c7-8225-fdfeeccda82d", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            if random.random() < self.probability:\n                self.particles[i] = self.pbest[i] + np.random.uniform(-0.5, 0.5, self.dim)\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm combining PSO and memory-based learning for diverse black box optimization problems.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "aa71247d-6671-4c66-9896-7c72e634735a", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy with a probability of 0.35\n            if np.random.rand() < self.refine_probability:\n                # Generate a new particle by perturbing the current particle\n                new_particle = self.particles[i] + np.random.uniform(-0.5, 0.5, self.dim)\n                # Evaluate the function at the new particle\n                new_values = func(new_particle)\n                # Update the personal best and global best if the new values are better\n                if np.any(new_values < self.rbest, axis=1):\n                    self.pbest[i] = new_particle\n                    self.rbest[np.argmin(self.rbest, axis=1)] = new_values\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm combining particle swarm optimization and memory-based learning for diverse black box optimization problems.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "41fe7f67-7d4a-4be9-b302-15ef25d348b5", "solution": "import numpy as np\n\nclass PSMAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.adaptation_rate = 0.35\n        self.adaptation_count = 0\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Adaptive learning\n            if np.random.rand() < self.adaptation_rate:\n                self.adaptation_count += 1\n                if self.adaptation_count % 10 == 0:\n                    # Update the particles with a random walk\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm_adaptive = PSMAdaptive(budget=10, dim=2)\nbest_solution = psm_adaptive(func)\nprint(best_solution)", "name": "PSMAdaptive", "description": "Novel \"Particle Swarm with Memory and Adaptive Learning\" algorithm", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "1747f8df-bec3-47f7-99ee-121eed28d0ce", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n        # Refine the particles with a probability\n        if random.random() < self.refine_probability:\n            for i in range(self.budget):\n                # Refine the particles by perturbing them\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                self.particles[i] += perturbation\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm with probability-based refinement.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "e7ea574b-8dda-4fab-b99a-abf2f950fd3e", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the solution with a probability of 0.35\n            if random.random() < self.refine_prob:\n                # Randomly select a particle to refine\n                refine_particle = random.choice(self.particles)\n                # Refine the particle by perturbing its coordinates\n                refine_particle += np.random.uniform(-0.1, 0.1, self.dim)\n                # Ensure the refined particle stays within the search space\n                refine_particle = np.clip(refine_particle, -5.0, 5.0)\n                # Update the particle\n                self.particles[i] = refine_particle\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm combining PSO and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "0973b4b5-adbc-41e8-ae00-18e6dc457e0b", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.proba = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            if np.random.rand() < self.proba:\n                self.particles[i] = self.pbest[i] + np.random.uniform(-0.1, 0.1, self.dim)\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm combining PSO and memory-based learning to optimize black box functions.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "71d9ac06-e2b7-4342-b64c-85a55a8c69bf", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the particles with a probability of 0.35\n            if random.random() < self.refine_prob:\n                self.particles[i] = self.particles[i] + 0.1 * (self.rbest - self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm, combining the benefits of particle swarm optimization and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "69fff184-048b-4c75-b892-83ad297ac3c6", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            for j in range(self.dim):\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < self.probability:\n                    self.particles[i, j] = self.pbest[i, j] + np.random.uniform(-1, 1)\n                if r2 < self.probability:\n                    self.particles[i, j] = self.rbest[i, j] + np.random.uniform(-1, 1)\n            # Add noise to the particles\n            self.particles[i] += np.random.normal(0, 0.1, self.dim)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm combining PSO and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "c70e363b-dd13-4d6d-89f6-ad426b4c8542", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            if random.random() < self.probability:\n                # Refine the strategy by changing individual lines\n                index = np.random.choice(self.budget)\n                self.particles[index] = self.pbest[index] + np.random.uniform(-1, 1, self.dim)\n                self.particles[index] = np.clip(self.particles[index], -5.0, 5.0)\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm, combining PSO and memory-based learning for diverse black box optimization.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "344774e0-1084-4a53-8e52-21510a129a72", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the solution with a probability of 0.35\n            if np.random.rand() < self.refine_prob:\n                # Randomly select two particles\n                j = np.random.choice(self.budget)\n                k = np.random.choice(self.budget)\n                # Swap the two particles\n                self.particles[i], self.particles[j] = self.particles[j], self.particles[i]\n                # Update the personal best and global best\n                self.pbest[i] = self.particles[i]\n                self.rbest[i] = func(self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm, combining particle swarm optimization and memory-based learning.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "abfa55c7-a8ad-4e09-967a-4466ea0f6fe9", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            for j in range(self.dim):\n                r1 = random.random()\n                if r1 < self.probability:\n                    self.particles[i, j] += 0.5 * (self.pbest[i, j] - self.particles[i, j]) + 0.5 * (self.rbest - self.particles[i, j])\n                else:\n                    self.particles[i, j] += 0.5 * (self.rbest[j] - self.particles[i, j]) + 0.5 * (self.rbest - self.particles[i, j])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm combining PSO and memory-based learning for diverse black box optimization.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "4a33f4c1-4d75-4565-ac4d-7a24eb0fbe63", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the solution with probability 0.35\n            if np.random.rand() < self.refine_prob:\n                # Randomly select a particle to refine\n                j = np.random.randint(0, self.budget)\n                # Refine the particle by adding a small random perturbation\n                self.particles[j] += np.random.uniform(-0.1, 0.1, self.dim)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm, combining the benefits of particle swarm optimization and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "5a6e266f-3733-4da8-901a-ac51a0f01396", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.pbest_update_probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Update the personal best with a probability\n            if np.random.rand() < self.pbest_update_probability:\n                self.pbest[i] = self.particles[i]\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm, combining particle swarm optimization and memory-based learning.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "ee64e724-0ce9-45aa-8d1f-da63fe13bf13", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.mutation_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Apply probabilistic mutation\n            if np.random.rand() < self.mutation_prob:\n                mutation = np.random.uniform(-1.0, 1.0, (self.dim,))\n                self.particles[i] += mutation\n                self.pbest[i] += mutation\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm with probabilistic mutation", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "bce97a24-18e8-46d9-9c1b-b5415252a203", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n    def refine_strategy(self):\n        for i in range(self.budget):\n            if random.random() < self.probability:\n                # Randomly select a particle\n                j = random.randint(0, self.budget - 1)\n                # Randomly select a dimension\n                k = random.randint(0, self.dim - 1)\n                # Randomly select a value between -5.0 and 5.0\n                new_value = random.uniform(-5.0, 5.0)\n                # Update the particle\n                self.particles[i, k] = new_value\n                # Update the personal best\n                self.pbest[i, k] = self.particles[i, k]\n                # Update the global best\n                self.rbest[i, k] = self.particles[i, k]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm combining PSO and memory-based learning for diverse black box optimization problems.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "a21c2e5c-e0e3-4884-abd0-99667de40956", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy by changing individual lines with a certain probability\n            if np.random.rand() < self.probability:\n                # Change the first dimension\n                self.particles[i, 0] += np.random.uniform(-1.0, 1.0)\n                # Change the second dimension\n                self.particles[i, 1] += np.random.uniform(-1.0, 1.0)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm, combining the benefits of particle swarm optimization and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "0695eda3-ddfd-4e63-9c9f-cdbf3b2f8fd3", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy with a probability of 0.35\n            if random.random() < self.probability:\n                # Randomly select an existing particle to refine\n                j = random.randint(0, self.budget-1)\n                # Refine the selected particle\n                self.particles[j] = self.particles[j] + self.probability * (self.rbest - self.particles[j])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm combining particle swarm optimization and memory-based learning.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "933a2c4d-72d9-4129-acac-abc8a3f5ed03", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy with probability\n            if np.random.rand() < self.refine_prob:\n                # Randomly select a particle\n                j = np.random.randint(0, self.budget)\n                # Refine the particle using the memory-based learning\n                self.particles[j] = self.particles[j] + 0.1 * (self.memory[j] - self.particles[j])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm with probability-based refinement.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "3f9410a3-c640-4aaa-b487-bf7262dd70cb", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.adaptive_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            if np.random.rand() < self.adaptive_prob:\n                mutation = np.random.uniform(-0.5, 0.5, (self.dim,))\n                self.particles[i] += mutation\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory and Adaptive Mutation\" algorithm", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "f522a400-992a-4d0a-b9e7-e44f3ae94b95", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.adaptive_mutation_rate = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Apply adaptive mutation\n            if random.random() < self.adaptive_mutation_rate:\n                # Select a random particle to mutate\n                idx = random.randint(0, self.budget - 1)\n                # Generate a new random value within the search space\n                new_value = np.random.uniform(-5.0, 5.0)\n                # Update the particle with the new value\n                self.particles[idx] = np.array([new_value] + self.particles[idx][1:])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory and Adaptive Mutation\" algorithm, combining the benefits of particle swarm optimization, memory-based learning, and adaptive mutation to handle diverse black box optimization problems.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "b546a3d9-a01d-4fb1-bbaa-8a150bda689e", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy by changing individual lines with a certain probability\n            if random.random() < self.probability:\n                self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm, combining the benefits of particle swarm optimization and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "69a2fbcb-e2b4-4354-a2e8-17e2c661cb3c", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule with probability\n            if np.random.rand() < self.probability:\n                self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm, combining the benefits of particle swarm optimization and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "05e69bc0-e4b2-40f5-b65d-eb94619f6540", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy with a probability of 0.35\n            if random.random() < self.probability:\n                # Randomly select an individual to refine\n                j = random.choice(self.particles[i])\n                # Refine the individual by perturbing its coordinates\n                j += np.random.uniform(-0.1, 0.1, self.dim)\n                # Update the particle\n                self.particles[i] = j\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm, combining particle swarm optimization and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "af0daee3-e06a-4c21-ac0a-18e8660ad0e6", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the solution with a probability of 0.35\n            if random.random() < self.refine_prob:\n                # Randomly select a particle to refine\n                j = random.randint(0, self.budget-1)\n                # Refine the particle by adding a random noise\n                self.particles[j] += np.random.uniform(-0.1, 0.1, self.dim)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm combining PSO and memory-based learning for diverse black box optimization problems.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "c3ac96c2-6d76-4d3a-8044-81817de46dd7", "solution": "import numpy as np\nimport random\n\nclass PSML:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.learning_rate = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Apply learning from experience\n            for j in range(self.dim):\n                if random.random() < self.learning_rate:\n                    self.particles[i, j] += np.random.uniform(-0.1, 0.1)\n            # Ensure the particles are within the search space\n            self.particles[i] = np.clip(self.particles[i], -5.0, 5.0)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]", "name": "PSML", "description": "Novel \"Particle Swarm with Memory and Learning\" (PSML) algorithm, combining the benefits of particle swarm optimization, memory-based learning, and learning from experience.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "c8655a2b-e5e9-41af-bb80-d5ec943f18bb", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            # Add adaptive mutation strategy\n            if random.random() < self.probability:\n                mutation = np.random.uniform(-1.0, 1.0, self.dim)\n                self.particles[i] += mutation\n            # Perform line search using probability-based method\n            if random.random() < self.probability:\n                direction = self.pbest[i] - self.particles[i]\n                step_size = np.random.uniform(0.1, 1.0)\n                self.particles[i] += direction * step_size\n            # Check bounds\n            self.particles[i] = np.clip(self.particles[i], -5.0, 5.0)\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm with adaptive mutation strategy and probability-based line search.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "d99673da-2a78-4261-a150-3098e36fb3b0", "solution": "import numpy as np\nimport random\n\nclass PSEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.evolution_rate = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Apply evolutionary adaptation\n            if random.random() < self.evolution_rate:\n                # Select a random particle\n                j = random.randint(0, self.budget - 1)\n                # Replace the particle with a new one\n                self.particles[j] = np.random.uniform(-5.0, 5.0, (1, self.dim))\n                # Update the personal best and global best\n                self.pbest[j] = self.particles[j]\n                self.rbest[j] = func(self.particles[j])\n                # Check if the new particle is better than the stored best\n                if np.any(self.rbest[j] < self.rbest, axis=1):\n                    self.memory[j] = self.rbest[j]\n                    self.rbest[np.argmin(self.rbest, axis=1)] = self.rbest[j]\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSEM", "description": "Novel \"Particle Swarm with Memory and Evolutionary Adaptation\" (PSEM) algorithm, combining the benefits of particle swarm optimization, memory-based learning, and evolutionary adaptation to handle diverse black box optimization problems.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "28b6c9bd-09e9-45fb-b392-2b6e82fba121", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy with a probability of 0.35\n            if random.random() < self.probability:\n                # Randomly select a particle to refine\n                idx = random.randint(0, self.budget - 1)\n                # Refine the particle by adding a random perturbation\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                self.particles[idx] += perturbation\n                # Update the personal best and global best\n                self.pbest[idx] = self.particles[idx]\n                self.rbest[idx] = func(self.particles[idx])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm combining particle swarm optimization and memory-based learning.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "e032902c-be08-45e4-9052-69a86577f100", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy with 35% probability\n            if random.random() < self.refine_probability:\n                # Randomly select a particle to refine\n                index = random.randint(0, self.budget - 1)\n                # Update the particle using a small step size\n                self.particles[index] += 0.1 * (self.rbest - self.particles[index])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm combining PSO and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "3098e4a2-4cfb-4e6e-bcf3-374a48599a4b", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule with probability-based exploration-exploitation trade-off\n            update = np.random.rand(self.dim) < self.probability\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            self.particles[i][update] += np.random.uniform(-1.0, 1.0, self.dim)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm with probability-based updates for adaptive exploration-exploitation trade-off.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "c4913e44-fe53-4535-9f98-24cf6ee88e1a", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy with a probability of 0.35\n            if random.random() < self.refine_probability:\n                # Select a random particle to refine\n                index = random.randint(0, self.budget-1)\n                # Refine the particle by perturbing its coordinates\n                self.particles[index] += np.random.uniform(-0.1, 0.1, self.dim)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm combining PSO and memory-based learning for diverse black box optimization problems.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "5cc072e5-68ee-46cc-bc65-22db1bbd9eb0", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the particles with probability 0.35\n            if random.random() < self.refine_prob:\n                for j in range(self.dim):\n                    if random.random() < 0.5:\n                        self.particles[i, j] += np.random.uniform(-0.1, 0.1)\n                    else:\n                        self.particles[i, j] -= np.random.uniform(-0.1, 0.1)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm, combining the benefits of particle swarm optimization and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "d72d580e-b79e-453f-8a2e-cb22e2263e03", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule with probability-based refinement\n            if random.random() < self.probability:\n                self.particles[i] = self.pbest[i] + 0.5 * (self.rbest - self.particles[i]) + 0.5 * (self.pbest[i] - self.particles[i])\n            else:\n                self.particles[i] = self.particles[i] + 0.5 * (self.rbest - self.particles[i]) + 0.5 * (self.pbest[i] - self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm with probability-based update rule", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "10468873-14a4-4d1e-9550-e0048c490736", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            if np.random.rand() < self.probability:\n                # Refine the strategy by changing the individual lines\n                new_particles = self.particles[i] + np.random.uniform(-0.5, 0.5, self.dim)\n                self.particles[i] = np.clip(new_particles, -5.0, 5.0)\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm combining PSO and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "7b607bbe-8384-42ec-9a91-f5841562d5e0", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.adaptation_rate = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Apply adaptive mutation\n            if np.random.rand() < self.adaptation_rate:\n                # Select a random particle from the memory\n                mem_idx = np.random.choice(list(self.memory.keys()))\n                mem_particle = self.particles[mem_idx]\n                # Mutate the current particle by adding a random value from the memory\n                self.particles[i] += np.random.uniform(-self.memory[mem_idx], self.memory[mem_idx])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory and Adaptive Mutation\" algorithm combining the benefits of particle swarm optimization, memory-based learning, and adaptive mutation to handle diverse black box optimization problems.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "a2937313-2632-47e7-93b2-30a88ca6b07a", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.pbest_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the particles with probability 0.35\n            if np.random.rand() < self.pbest_prob:\n                self.particles[i] = np.random.uniform(-5.0, 5.0, (1, self.dim))\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm, combining the benefits of particle swarm optimization and memory-based learning.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "5971932d-5076-4fd7-82f3-e79dbfc9bb36", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy with a probability of 0.35\n            if np.random.rand() < self.refine_probability:\n                self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm, combining the benefits of particle swarm optimization and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "a9a3df9b-d88f-46ba-a3ce-c2ab32d6ba2f", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            update_rule = np.random.choice([0.5, 1.0, 1.5], p=[1-self.probability, self.probability, self.probability])\n            self.particles[i] = self.particles[i] + update_rule * (self.pbest[i] - self.particles[i]) + update_rule * (self.rbest - self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm combining PSO and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "ba665087-f301-4ede-b97d-405958862fa3", "solution": "# import numpy as np\n# import random\n\n# class PSM:\n#     def __init__(self, budget, dim):\n#         self.budget = budget\n#         self.dim = dim\n#         self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n#         self.pbest = np.zeros((budget, dim))\n#         self.rbest = np.zeros((budget, dim))\n#         self.memory = {}\n#         self.probability = 0.35\n\n#     def __call__(self, func):\n#         for i in range(self.budget):\n#             # Evaluate the function at the current particles\n#             values = func(self.particles[i])\n#             # Update the personal best and global best\n#             self.pbest[i] = self.particles[i]\n#             self.rbest[i] = values\n#             # Check if the current best is better than the stored best\n#             if np.any(values < self.rbest, axis=1):\n#                 self.memory[i] = values\n#                 self.rbest[np.argmin(self.rbest, axis=1)] = values\n#             # Update the particles using the PSO update rule\n#             if random.random() < self.probability:\n#                 self.particles[i] = self.pbest[i] + random.uniform(-0.1, 0.1, self.dim)\n#                 self.particles[i] = self.particles[i] + 0.5 * (self.rbest - self.particles[i])\n#                 self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i])\n#         # Return the best solution found\n#         return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# # Example usage\n# def func(x):\n#     return np.sum(x**2)\n\n# psm = PSM(budget=10, dim=2)\n# best_solution = psm(func)\n# print(best_solution)\n# ```", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm, combining particle swarm optimization and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "449ff3b9-5a96-4871-af60-dbab3a265f4e", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy with a probability of 0.35\n            if random.random() < self.refine_prob:\n                # Select a random particle to refine\n                idx = random.randint(0, self.budget - 1)\n                # Refine the particle using a small step size\n                self.particles[idx] += 0.1 * (self.rbest[idx] - self.particles[idx])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm combining particle swarm optimization and memory-based learning.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "665ad7b4-392a-42f9-ad12-66fd48dc021b", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.pbest_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            # with probability 0.35, update the particle to its personal best\n            if np.random.rand() < self.pbest_prob:\n                self.particles[i] = self.pbest[i]\n            else:\n                self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm, combining particle swarm optimization and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "b5624d1a-2e05-41aa-8649-aa26b1dd140f", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy with probability 0.35\n            if random.random() < self.refine_prob:\n                # Refine the particle by changing one of its dimensions\n                idx = random.randint(0, self.dim - 1)\n                self.particles[i, idx] += np.random.uniform(-0.1, 0.1)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm combining particle swarm optimization and memory-based learning.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "b49be421-cd8e-4207-a662-a52880451925", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            if np.random.rand() < self.probability:\n                self.particles[i] = self.pbest[i] + np.random.uniform(-0.5, 0.5, self.dim)\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm combining particle swarm optimization and memory-based learning.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "c008c796-b6e7-43fb-a966-913228d3e624", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Adaptive mutation strategy\n            if np.random.rand() < self.probability:\n                mutation = np.random.uniform(-0.5, 0.5, (self.dim,))\n                self.particles[i] += mutation\n        # Probability-based line search\n        if np.random.rand() < self.probability:\n            search_direction = np.random.uniform(-1.0, 1.0, (self.dim,))\n            step_size = np.max(np.abs(search_direction))\n            self.particles[i] += step_size * search_direction\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm with adaptive mutation strategy and probability-based line search.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "77977588-2777-4961-981f-49f3934db804", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy with probability 0.35\n            if np.random.rand() < self.probability:\n                self.particles[i] = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm, combining particle swarm optimization and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "7334a80b-3a23-4a6e-a8f8-7e595f1d6ce4", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.adaptation_rate = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Adapt the particles based on the best solution found\n            if i > 0 and np.any(values < self.rbest[np.argmin(self.rbest, axis=1)]):\n                # Select particles to adapt\n                adapt_particles = random.sample(range(self.budget), int(self.budget * self.adaptation_rate))\n                # Update the particles\n                for j in adapt_particles:\n                    # Select a random dimension to adapt\n                    dim_to_adapt = random.randint(0, self.dim - 1)\n                    # Generate a new value for the dimension\n                    new_value = np.random.uniform(-5.0, 5.0)\n                    # Update the particle\n                    self.particles[j, dim_to_adapt] = new_value\n                    # Update the personal best and global best\n                    values = func(self.particles[j])\n                    self.pbest[j] = self.particles[j]\n                    self.rbest[j] = values\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory and Adaptation\" algorithm combining the benefits of particle swarm optimization, memory-based learning, and adaptation to handle diverse black box optimization problems.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "3a73514d-3cba-4fcc-97de-29cf42182842", "solution": "import numpy as np\n\nclass PSMEL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.elite_size = int(budget * 0.35)\n        self.elite = np.random.uniform(-5.0, 5.0, (self.elite_size, dim))\n        self.mutation_rate = 0.1\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the elite\n            if i < self.elite_size:\n                self.elite[i] = self.particles[i]\n                self.elite[np.argmin(self.elite, axis=1)] = self.particles[i]\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Apply mutation\n            if np.random.rand() < self.mutation_rate:\n                self.particles[i] += np.random.uniform(-0.1, 0.1, (self.dim,))\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm_el = PSMEL(budget=10, dim=2)\nbest_solution = psm_el(func)\nprint(best_solution)", "name": "PSMEL", "description": "Novel \"Particle Swarm with Memory and Evolutionary Learning\" (PSM-EL) algorithm, combining the benefits of particle swarm optimization, memory-based learning, and evolutionary learning to handle diverse black box optimization problems.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "bdc1e5c0-e354-4776-858e-be19247d6729", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm, combining the benefits of particle swarm optimization and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "5d217d11-c7b2-43ea-976a-39318c6559e9", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.adaptive_mutations = np.zeros((budget, dim))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Apply adaptive mutation\n            if np.random.rand() < 0.35:\n                mutation_index = np.random.choice(self.budget)\n                self.adaptive_mutations[mutation_index] = np.random.uniform(-1.0, 1.0, self.dim)\n                self.particles[mutation_index] += self.adaptive_mutations[mutation_index]\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory and Adaptive Mutation\" algorithm, combining the benefits of particle swarm optimization, memory-based learning, and adaptive mutation to handle diverse black box optimization problems.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "fc064c8d-9629-475d-9c95-d0143bd28111", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            update = np.random.rand(self.dim) < self.probability\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            self.particles[i, update] = self.particles[i, update] + np.random.uniform(-1, 1, self.dim)\n            # Add noise to the particles to simulate exploration\n            self.particles[i] += np.random.normal(0, 0.1, self.dim)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm, combining the benefits of particle swarm optimization and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "bdcb29c1-9eab-40bf-a450-052603d7317f", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy with probability 0.35\n            if np.random.rand() < self.refine_prob:\n                # Randomly select two particles\n                j = np.random.choice(self.budget)\n                k = np.random.choice(self.budget)\n                # Swap the particles\n                self.particles[i], self.particles[j] = self.particles[j], self.particles[i]\n                # Update the personal best and global best\n                self.pbest[i] = self.particles[i]\n                self.rbest[i] = func(self.particles[i])\n                # Check if the current best is better than the stored best\n                if np.any(self.rbest < self.rbest, axis=1):\n                    self.memory[i] = self.rbest[np.argmin(self.rbest, axis=1)]\n                    self.rbest[np.argmin(self.rbest, axis=1)] = self.rbest[i]\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm with probability-based strategy refinement.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "296c146a-6230-4c4f-9ef8-95bd78f2468c", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            update = np.random.choice([True, False], p=[self.probability, 1-self.probability])\n            if update:\n                self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Update the particles with the stored best\n            if i > 0:\n                self.particles[i] = self.particles[i] + self.probability * (self.memory[i] - self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm combining particle swarm optimization and memory-based learning.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "6f9cbaee-1bf7-4c9d-a30a-af25242ad479", "solution": "import numpy as np\n\nclass PSMAdapt:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.adaptation_rate = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Adapt the strategy\n            if np.random.rand() < self.adaptation_rate:\n                # Select a random particle to adapt\n                idx = np.random.randint(0, self.budget)\n                # Update the particle using the PSO update rule\n                self.particles[idx] = self.particles[idx] + 0.5 * (self.pbest[idx] - self.particles[idx]) + 0.5 * (self.rbest - self.particles[idx])\n                # Update the personal best and global best\n                self.pbest[idx] = self.particles[idx]\n                self.rbest[idx] = func(self.particles[idx])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm_adapt = PSMAdapt(budget=10, dim=2)\nbest_solution = psm_adapt(func)\nprint(best_solution)", "name": "PSMAdapt", "description": "Novel \"Particle Swarm with Memory and Adaptation\" algorithm that combines the benefits of particle swarm optimization, memory-based learning, and adaptation to refine the search strategy.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "80e6ba6c-c632-473c-81f6-77b4b9ff5aaa", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.adaptive_lr = 0.5\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule with adaptive learning rate\n            self.particles[i] = self.particles[i] + self.adaptive_lr * (self.pbest[i] - self.particles[i]) + self.adaptive_lr * (self.rbest - self.particles[i])\n            # Refine the strategy with 35% probability\n            if np.random.rand() < 0.35:\n                # Get the best individual from the memory\n                best_individual = np.argmin(self.rbest, axis=1)\n                # Update the particles with the best individual\n                self.particles[i] = self.particles[best_individual]\n                # Update the personal best and global best\n                self.pbest[i] = self.particles[i]\n                self.rbest[i] = func(self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory and Adaptive Learning Rate\" algorithm, combining the benefits of particle swarm optimization, memory-based learning, and adaptive learning rate to handle diverse black box optimization problems.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "18aff3b0-0231-4793-9061-533d20c1e488", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy with 35% probability\n            if random.random() < self.refine_probability:\n                # Select a random particle to refine\n                idx = random.randint(0, self.budget - 1)\n                # Refine the particle by perturbing its position\n                self.particles[idx] += np.random.uniform(-0.1, 0.1, self.dim)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm combining PSO and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "36a80573-0b34-404d-9f8f-e8a72223a1c0", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.mutation_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            new_particles = self.particles + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Apply probabilistic mutation\n            mutation_mask = np.random.rand(self.budget, self.dim) < self.mutation_prob\n            new_particles[mutation_mask] = new_particles[mutation_mask] + np.random.uniform(-0.1, 0.1, size=new_particles[mutation_mask].shape)\n            self.particles[i] = new_particles[i]\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm with probabilistic mutation.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "c44f33c7-06f4-4cfa-a324-d6b6bf5da55c", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule with probability\n            if random.random() < self.probability:\n                self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            else:\n                # Introduce a small random perturbation to the particles\n                self.particles[i] += np.random.uniform(-0.1, 0.1, self.dim)\n            # Check if the current best is better than the stored best in memory\n            if i > 0 and np.any(values < self.memory[i-1], axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm, combining the benefits of particle swarm optimization and memory-based learning to handle diverse black box optimization problems.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "f19cb4f2-c25a-4589-ba2d-029692c5533a", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy by changing individual lines with probability 0.35\n            if np.random.rand() < self.probability:\n                for j in range(self.dim):\n                    if np.random.rand() < self.probability:\n                        self.particles[i, j] = np.random.uniform(-5.0, 5.0)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm combining particle swarm optimization and memory-based learning.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "61b1ad38-26ad-4dd1-a5fe-b91279df15d6", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.refine_probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n    def refine(self):\n        for i in range(self.budget):\n            # Refine the particles with a probability of 0.35\n            if random.random() < self.refine_probability:\n                # Generate a new particle by perturbing the current particle\n                new_particle = self.particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # Evaluate the new particle\n                values = func(new_particle)\n                # Update the personal best and global best\n                if np.any(values < self.rbest, axis=1):\n                    self.memory[i] = values\n                    self.rbest[np.argmin(self.rbest, axis=1)] = values\n                    self.particles[i] = new_particle\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm, combining particle swarm optimization and memory-based learning.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "e7291489-5456-4b4b-b40b-5782733d06b5", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.mutation_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Apply probability-based mutation\n            if random.random() < self.mutation_prob:\n                # Randomly select an individual to mutate\n                idx = random.randint(0, self.budget - 1)\n                # Mutate the selected individual\n                self.particles[idx] += np.random.uniform(-1.0, 1.0, self.dim)\n                # Ensure the mutated individual is within the bounds\n                self.particles[idx] = np.clip(self.particles[idx], -5.0, 5.0)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm combined with probability-based mutation and exploration.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "5480d003-1cf0-40e5-8b7a-d4a120e3a13d", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.mutation_probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Apply mutation with probability\n            if np.random.rand() < self.mutation_probability:\n                # Randomly select two particles\n                j = np.random.randint(0, self.budget)\n                k = np.random.randint(0, self.budget)\n                # Swap the particles\n                self.particles[i], self.particles[j] = self.particles[j], self.particles[i]\n                # Update the personal best and global best\n                self.pbest[i] = self.particles[i]\n                self.rbest[i] = func(self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm combined with probability-based mutation to refine the search strategy.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "b771cf11-4e00-4c45-995c-dba0ee4e7207", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.mutation_rate = 0.35\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Apply probabilistic line search to update the particles\n            if random.random() < self.probability:\n                for j in range(self.dim):\n                    if random.random() < self.mutation_rate:\n                        self.particles[i, j] += random.uniform(-0.1, 0.1)\n                    self.particles[i, j] = np.clip(self.particles[i, j], -5.0, 5.0)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm with adaptive mutation rate and probabilistic line search", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "e945c9fe-9042-483a-af3f-f7576029c747", "solution": "import numpy as np\n\nclass PSMDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.de = 0.5\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Apply differential evolution\n            for j in range(self.dim):\n                diff = np.random.uniform(-1, 1, (self.budget,))\n                new_particle = self.particles[i] + self.de * diff\n                values = func(new_particle)\n                if np.any(values < self.rbest, axis=1):\n                    self.memory[i] = values\n                    self.rbest[np.argmin(self.rbest, axis=1)] = values\n                    self.particles[i] = new_particle\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsmde = PSMDE(budget=10, dim=2)\nbest_solution = psmde(func)\nprint(best_solution)", "name": "PSMDE", "description": "Novel \"Particle Swarm with Memory and Differential Evolution\" (PSM-DE) algorithm, combining the benefits of particle swarm optimization, memory-based learning, and differential evolution to handle diverse black box optimization problems.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "0484f9fb-c619-42ce-85d2-e9aa185bbf0e", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy with a 35% probability\n            if random.random() < self.probability:\n                # Get the best solution from the memory\n                best_solution = self.memory[np.argmin(self.rbest, axis=1)]\n                # Update the particles with the best solution\n                self.particles[i] = best_solution + np.random.uniform(-0.5, 0.5, self.dim)\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" (PSM) algorithm combining benefits of particle swarm optimization and memory-based learning.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "d0eecd26-d832-468a-9f8b-3650c3c2f7ff", "solution": "import numpy as np\nimport random\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule\n            self.particles[i] = self.particles[i] + 0.5 * (self.pbest[i] - self.particles[i]) + 0.5 * (self.rbest - self.particles[i])\n            # Refine the strategy with probability 0.35\n            if random.random() < self.probability:\n                # Randomly select a particle\n                idx = random.randint(0, self.budget - 1)\n                # Replace the particle with a new one\n                self.particles[i] = np.random.uniform(-5.0, 5.0, (1, self.dim))\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory\" algorithm combining PSO and memory-based learning.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
{"id": "487d3e80-583d-4430-bce9-4f4ae9023ac4", "solution": "import numpy as np\n\nclass PSM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = np.random.uniform(-5.0, 5.0, (budget, dim))\n        self.pbest = np.zeros((budget, dim))\n        self.rbest = np.zeros((budget, dim))\n        self.memory = {}\n        self.learning_rate = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Evaluate the function at the current particles\n            values = func(self.particles[i])\n            # Update the personal best and global best\n            self.pbest[i] = self.particles[i]\n            self.rbest[i] = values\n            # Check if the current best is better than the stored best\n            if np.any(values < self.rbest, axis=1):\n                self.memory[i] = values\n                self.rbest[np.argmin(self.rbest, axis=1)] = values\n            # Update the particles using the PSO update rule with adaptive learning rate\n            self.particles[i] = self.particles[i] + self.learning_rate * (self.pbest[i] - self.particles[i]) + (1-self.learning_rate) * (self.rbest - self.particles[i])\n        # Return the best solution found\n        return self.rbest[np.argmin(self.rbest, axis=1)]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\npsm = PSM(budget=10, dim=2)\nbest_solution = psm(func)\nprint(best_solution)", "name": "PSM", "description": "Novel \"Particle Swarm with Memory and Adaptive Learning Rate\" algorithm, combining the benefits of particle swarm optimization, memory-based learning, and adaptive learning rate to handle diverse black box optimization problems.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "df1db1a7-97c5-43cd-aa32-de7e0951ea04", "metadata": {}, "mutation_prompt": null}
