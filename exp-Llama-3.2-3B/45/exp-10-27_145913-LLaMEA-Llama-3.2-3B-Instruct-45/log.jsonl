{"id": "3aeff718-372a-487c-bace-e7d1f975e57a", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) for black box optimization", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 74, in <module>\n  File \"<string>\", line 23, in __call__\n  File \"<string>\", line 49, in evaluate_harmony\nIndexError: invalid index to scalar variable.\n.", "error": "IndexError('invalid index to scalar variable.')Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 74, in <module>\n  File \"<string>\", line 23, in __call__\n  File \"<string>\", line 49, in evaluate_harmony\nIndexError: invalid index to scalar variable.\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "7c304f52-886f-4091-833e-549f6faf4f79", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        # Perform probabilistic mutation\n        for i in range(self.dim):\n            if random.random() < self.mutation_prob:\n                # Select a random solution from the harmony memory\n                index = random.randint(0, self.harmony_size - 1)\n                # Create a new solution by changing the individual line\n                new_solution[i] = self.harmony[index, i] + random.uniform(-1.0, 1.0)\n                # Ensure the new solution is within the bounds\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n                # Evaluate the new solution\n                value = func(new_solution)\n                # Update the best solution if necessary\n                if value < self.best_value:\n                    self.best_solution = new_solution\n                    self.best_value = value\n                # Update the harmony memory if necessary\n                if self.evaluate_harmony(func, value):\n                    self.harmony[index, i] = new_solution[i]\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) for black box optimization with probabilistic mutation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "5a1c6fbf-cc0b-4f97-ad13-63749c1ae344", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.adaptive_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        # Refine the strategy with adaptive probability\n        for i in range(self.dim):\n            if random.random() < self.adaptive_prob:\n                index = random.randint(0, self.harmony_size - 1)\n                new_value = self.harmony[index, i] + random.uniform(-1, 1)\n                if new_value < self.lower_bound:\n                    new_value = self.lower_bound\n                elif new_value > self.upper_bound:\n                    new_value = self.upper_bound\n                self.harmony[self.harmony[:, 0] == self.harmony[index, 0], i] = new_value\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) for black box optimization with adaptive probability.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "195450db-4d9a-4d88-ae0a-381e532cd309", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.p = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory with probability p\n            if random.random() < self.p:\n                index = random.randint(0, self.harmony_size - 1)\n                new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel Self-Adaptive Harmony Search with Evolution Strategy for black box optimization.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "3fb02ba5-ca82-477c-9b3d-5f1165a5386e", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        # Refine the strategy with probabilistic mutation\n        if random.random() < self.probability:\n            self.refine_strategy()\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_strategy(self):\n        # Refine the strategy by changing individual lines\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            # Change the individual line with a probability of 0.45\n            if random.random() < self.probability:\n                self.harmony[index, i] = random.uniform(self.lower_bound, self.upper_bound)\n        # Update the harmony memory\n        self.harmony = np.sort(self.harmony, axis=0)\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy and Probabilistic Mutation for Black Box Optimization", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "b13d63bc-e3ea-495d-839b-890aa5207f5f", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Refine the strategy with probability\n            if random.random() < self.probability:\n                self.refine_strategy(new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_strategy(self, new_solution, value):\n        # Refine the strategy by changing individual lines with probability\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] = self.lower_bound + (self.upper_bound - self.lower_bound) * random.random()\n        return new_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel SAHES-ES algorithm with probability-based strategy refinement.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "fe87cc0a-8045-4ab9-a26c-11f299261339", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func, value=None):\n        if value is None:\n            values = func(self.harmony)\n        else:\n            values = func(self.harmony)\n            values[self.harmony[:, 0] == value] = value\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel metaheuristic algorithm using Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) and probability-based line search for black box optimization.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "7f62224f-eb08-409d-8fc8-c0a9068c214a", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory with a probability of 0.45\n            if random.random() < self.probability:\n                index = random.randint(0, self.harmony_size - 1)\n                new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel Self-Adaptive Harmony Search with Evolution Strategy for black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "42e27a76-cd36-4e07-8b64-783c909d0b7e", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func, value=None):\n        if value is None:\n            values = func(self.harmony)\n        else:\n            values = [value] + func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if value is None and values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n        elif value is not None and value < self.best_value:\n            self.best_solution = self.harmony[np.argmin(values)]\n            self.best_value = value\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            # With probability 0.45, change the individual line\n            if random.random() < self.probability:\n                new_solution[i] = self.harmony[index, i] + np.random.uniform(-1, 1)\n            else:\n                new_solution[i] = self.harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy and Stochastic Universal Sampling", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "0ebc448f-10a9-446b-8400-9a4b0965acd0", "solution": "import numpy as np\nimport random\n\nclass ProbabilisticSAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        # Refine the strategy by changing individual lines with a probability\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                index = random.randint(0, self.harmony_size - 1)\n                new_value = self.harmony[index, i] + random.uniform(-1, 1)\n                if new_value < self.lower_bound:\n                    new_value = self.lower_bound\n                elif new_value > self.upper_bound:\n                    new_value = self.upper_bound\n                self.harmony[self.harmony[:, 0] == index, i] = new_value\n\n        return self.best_value\n\n    def evaluate_harmony(self, func, value):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = ProbabilisticSAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "ProbabilisticSAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy and Probabilistic Mutation", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"ProbabilisticSAHES_ES.evaluate_harmony() missing 1 required positional argument: 'value'\").", "error": "TypeError(\"ProbabilisticSAHES_ES.evaluate_harmony() missing 1 required positional argument: 'value'\")", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "f7ac2e82-caf0-428b-b286-c898c32dbed3", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                # Apply probabilistic mutation to refine the strategy\n                if random.random() < self.probability:\n                    self.harmony = self.mutate_harmony(self.harmony)\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def mutate_harmony(self, harmony):\n        # Apply probabilistic mutation to refine the strategy\n        mutated_harmony = np.copy(harmony)\n        for i in range(self.harmony_size):\n            for j in range(self.dim):\n                if random.random() < self.probability:\n                    mutated_harmony[i, j] += np.random.uniform(-1, 1)\n                    mutated_harmony[i, j] = np.clip(mutated_harmony[i, j], self.lower_bound, self.upper_bound)\n        return mutated_harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) for black box optimization using probabilistic mutation.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "0bd22e34-6568-48e6-981f-14640d33b789", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES_Probability:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refinement_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n            # Refine the solution with probability 0.45\n            if random.random() < self.refinement_probability:\n                self.refine_solution(new_solution)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_solution(self, solution):\n        # Refine the solution by changing individual lines with probability 0.45\n        for i in range(self.dim):\n            if random.random() < self.refinement_probability:\n                # Select a random individual line\n                index = random.randint(0, self.dim - 1)\n                # Generate a new value with probability 0.45\n                if random.random() < 0.45:\n                    new_value = np.random.uniform(self.lower_bound, self.upper_bound)\n                else:\n                    new_value = solution[index]\n                solution[index] = new_value\n        return solution\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES_Probability(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES_Probability", "description": "Self-Adaptive Harmony Search with Evolution Strategy and Probability-Based Refinement", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "0abffde5-8efb-41da-8f39-0436053e1f4e", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func, value=None):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if value is not None and values[0] < value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        mutation_mask = np.random.rand(self.harmony_size) < self.mutation_probability\n        self.harmony[mutation_mask] = new_solution\n        return self.harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) using probability-based mutation", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 24 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 24 is out of bounds for axis 0 with size 1')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "6cd97a1f-a55a-45ce-aaf6-ad90f3ed0227", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func, value=None):\n        if value is None:\n            values = func(self.harmony)\n        else:\n            values = np.array([value])\n        # Select the best solutions\n        indices = np.argsort(values)\n        # Update the best solution if necessary\n        if value is None:\n            if values[0] < self.best_value:\n                self.best_solution = self.harmony[indices[0]]\n                self.best_value = values[0]\n        else:\n            if values[0] < self.best_value:\n                self.best_solution = self.harmony[indices[0]]\n                self.best_value = values[0]\n        # Refine the strategy using probability 0.45\n        if np.random.rand() < self.probability:\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            new_value = func(new_solution)\n            # Update the best solution if necessary\n            if new_value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = new_value\n        return True\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) using probability 0.45 to refine strategy", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "25609447-dd40-47e1-828b-84863c4885af", "solution": "import numpy as np\nimport random\n\nclass HSES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refine_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                # Refine the solution with a probability of 0.45\n                if random.random() < self.refine_probability:\n                    new_solution = self.refine_solution(new_solution)\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func, value):\n        # Evaluate the harmony memory\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n        return values[0] < self.best_value\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def refine_solution(self, solution):\n        # Refine the solution by changing 45% of its lines\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.refine_probability:\n                refined_solution[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        return refined_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = HSES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "HSES", "description": "Novel Harmony Search with Evolution Strategy (HSES) for black box optimization", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"HSES.evaluate_harmony() missing 1 required positional argument: 'value'\").", "error": "TypeError(\"HSES.evaluate_harmony() missing 1 required positional argument: 'value'\")", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "d47bac7d-472d-47c7-ac95-5b90606e8070", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            # Refine the solution with a probability of 0.45\n            if random.random() < self.probability:\n                new_solution[i] = harmony[index, i] + np.random.uniform(-1.0, 1.0)\n            else:\n                new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel SAHES-ES algorithm with probabilistic refinement of individual lines.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "0162dce1-32df-4d77-a51b-d233cc96dd6c", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refine_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        # Refine individual lines with probability 0.45\n        for i in range(self.dim):\n            if random.random() < self.refine_probability:\n                # Select a random solution from the harmony memory\n                index = random.randint(0, self.harmony_size - 1)\n                # Refine the line\n                self.harmony[index, i] += np.random.uniform(-1.0, 1.0)\n                # Ensure bounds\n                self.harmony[index, i] = np.clip(self.harmony[index, i], self.lower_bound, self.upper_bound)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) using probability to refine individual lines", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "e402deab-3ea8-4aa9-bda9-48ecffb366c8", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func, value=None):\n        if value is None:\n            values = func(self.harmony)\n        else:\n            values = np.array([value])\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory with a probability of 0.45\n            if random.random() < self.probability:\n                index = random.randint(0, self.harmony_size - 1)\n                new_solution[i] = harmony[index, i]\n            else:\n                # Create a new solution randomly\n                new_solution[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) for black box optimization.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "5a450031-7c38-4ce6-a2c6-f58e14629118", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refine_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Refine the solution with probability 0.45\n            if random.random() < self.refine_probability:\n                new_solution = self.refine_solution(new_solution)\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def refine_solution(self, solution):\n        # Refine the solution by changing individual lines with probability 0.45\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.refine_probability:\n                new_solution[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel SAHES-ES algorithm with probability-based refinement", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "246fd3a8-c862-4bbe-bffd-0038b671171b", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refine_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        for i in range(self.harmony_size):\n            if np.random.rand() < self.refine_probability:\n                harmony[i] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy using probability to refine the strategy.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "3430a94d-b9ba-407f-99e2-3908dcddccf5", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refinement_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        # Refine the strategy using probability-based refinement\n        if np.random.rand() < self.refinement_probability:\n            # Select a random solution from the harmony memory\n            index = np.random.randint(0, self.harmony_size - 1)\n            # Create a new solution using the selected solution\n            new_solution = self.harmony[index]\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n\n    def evaluate_harmony(self, func, value=None):\n        if value is None:\n            values = func(self.harmony)\n        else:\n            values = func(self.harmony)\n            # Replace the value with the new solution\n            values[self.harmony[:, 0] == value] = func(value)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = np.random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) for black box optimization using probability-based refinement.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "0b36a2b4-15f3-4f58-8f3c-5e0cc22d3c61", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refine_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Refine the solution with probability 0.45\n            if random.random() < self.refine_probability:\n                new_solution = self.refine_solution(new_solution)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_solution(self, solution):\n        # Refine the solution by changing individual lines with probability 0.45\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.refine_probability:\n                refined_solution[i] = self.lower_bound + (self.upper_bound - self.lower_bound) * random.random()\n        return refined_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) for black box optimization with probability-based refinement.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "bb2aa501-ca42-4c0c-8be0-19ed98486348", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.p_refine = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                # Refine the strategy with probability 0.45\n                if random.random() < self.p_refine:\n                    self.harmony = self.refine_harmony(self.harmony, new_solution, value)\n                else:\n                    self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_harmony(self, harmony, new_solution, value):\n        # Refine the harmony memory with probability 0.45\n        for i in range(self.harmony_size):\n            if random.random() < self.p_refine:\n                # Change the individual lines of the selected solution\n                for j in range(self.dim):\n                    index = random.randint(0, self.dim - 1)\n                    harmony[i, index] = new_solution[index]\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) for black box optimization.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "f4a207d1-853a-4ef6-b25c-e338e0c556b4", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.p_mutate = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                # Apply probabilistic mutation and selection\n                if random.random() < self.p_mutate:\n                    new_solution = self.mutate(new_solution)\n                self.harmony = self.select(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def mutate(self, solution):\n        # Apply probabilistic mutation\n        for i in range(self.dim):\n            if random.random() < self.p_mutate:\n                solution[i] += random.uniform(-1, 1)\n                solution[i] = max(self.lower_bound, min(solution[i], self.upper_bound))\n        return solution\n\n    def select(self, harmony, new_solution, value):\n        # Apply probabilistic selection\n        selected = harmony[np.argsort([value] + [func(x) for x in harmony])]\n        selected = selected[:int(self.population_size * 0.5)]\n        if len(selected) < self.population_size:\n            selected = np.random.choice(selected, self.population_size, replace=True)\n        return selected\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel SAHES-ES with probabilistic mutation and selection", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "1242241a-97e1-4b02-9ce7-0937729aef36", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        indices = np.where(harmony[:, 0] == value)[0]\n        for i in indices:\n            # Apply probabilistic mutation\n            if random.random() < self.probability:\n                new_solution[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        harmony[indices] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) for black box optimization with probabilistic mutation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "51e11a61-d0cc-423d-847e-97c61c7aeb10", "solution": "import numpy as np\nimport random\n\nclass SAHES_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.de_param = {\n            'F': 0.5,\n            'CR': 0.5,\n            'c1': 1.5,\n            'c2': 1.5\n        }\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        # Differential Evolution\n        for i in range(self.population_size):\n            # Select two random solutions from the harmony memory\n            x1, x2 = self.harmony[np.random.choice(self.harmony_size, 2, replace=False)]\n            # Calculate the target solution\n            target = self.harmony[np.argmin([self.evaluate_harmony(func, self.evaluate_harmony(func, x1)) for x1 in self.harmony])]\n\n            # Calculate the differential vector\n            differential = self.de_param['F'] * (target - self.harmony[i]) + self.de_param['CR'] * (x2 - self.harmony[i])\n            # Update the solution\n            self.harmony[i] = self.harmony[i] + differential\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory with probability 0.45\n            if random.random() < self.de_param['CR']:\n                index = random.randint(0, self.harmony_size - 1)\n                new_solution[i] = harmony[index, i]\n            else:\n                new_solution[i] = harmony[np.random.choice(self.harmony_size, 1, replace=False), i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_DE(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_DE", "description": "Self-Adaptive Harmony Search with Evolution Strategy and Differential Evolution for black box optimization", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "0833807d-2019-4880-b7f1-34a0230f7e80", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        # Probabilistic mutation to refine the strategy\n        if random.random() < self.mutation_prob:\n            self.mutate_solution(self.best_solution)\n\n    def evaluate_harmony(self, func, value=None):\n        if value is None:\n            values = func(self.harmony)\n        else:\n            values = func(self.harmony[np.argsort(value)])\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def mutate_solution(self, solution):\n        # Probabilistic mutation to refine the strategy\n        for i in range(self.dim):\n            if random.random() < self.mutation_prob:\n                # Randomly change the individual lines of the solution\n                solution[i] = random.uniform(self.lower_bound, self.upper_bound)\n        return solution\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy using probabilistic mutation", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "18bc7ae4-cf6f-4a56-b590-a3174612c45a", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refine_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = np.zeros(self.dim)\n            for i in range(self.dim):\n                # Select a random solution from the harmony memory\n                index = random.randint(0, self.harmony_size - 1)\n                new_solution[i] = self.harmony[index, i]\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Refine the individual lines with probability 0.45\n            if random.random() < self.refine_probability:\n                # Select a random line to refine\n                line_index = random.randint(0, self.dim - 1)\n                # Refine the line by adding a random value between -1 and 1\n                new_solution[line_index] += random.uniform(-1, 1)\n                # Evaluate the new solution\n                value = func(new_solution)\n                # Update the best solution if necessary\n                if value < self.best_value:\n                    self.best_solution = new_solution\n                    self.best_value = value\n                # Update the harmony memory if necessary\n                if self.evaluate_harmony(func, value):\n                    self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy using probability to refine individual lines.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "4877780a-d62c-4039-9bd8-bf127482e51a", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        # Refine the new solution with a probability of 0.45\n        if random.random() < self.probability:\n            for j in range(self.dim):\n                # Select a random solution from the harmony memory\n                index = random.randint(0, self.harmony_size - 1)\n                new_solution[j] += harmony[index, j] * random.uniform(-1, 1)\n                # Ensure the new solution is within the bounds\n                new_solution[j] = np.clip(new_solution[j], self.lower_bound, self.upper_bound)\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) for black box optimization", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "30cbdbe5-14ac-4149-bd37-407f2a46bff0", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        indices_to_change = np.where(harmony[:, 0] == value)[0]\n        for index in indices_to_change:\n            if random.random() < self.mutation_prob:\n                # Apply mutation to the selected solution\n                new_solution[index, :] = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        harmony[indices_to_change, :] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) for black box optimization using probability-based mutation.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "9989614c-cb21-4a70-b82d-03640ed3ea76", "solution": "import numpy as np\nimport random\n\nclass Hybrid_SA_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                # Refine the strategy using Evolution Strategy\n                self.refine_strategy(self.harmony, new_solution, value)\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def refine_strategy(self, harmony, new_solution, value):\n        # Refine the strategy using Evolution Strategy\n        for i in range(self.dim):\n            # Calculate the standard deviation\n            std_dev = np.std(harmony[:, i])\n            # If the standard deviation is greater than 1, refine the solution\n            if std_dev > 1:\n                # Calculate the new solution using the probability\n                new_solution[i] = harmony[np.random.choice(self.harmony_size, p=[self.probability, 1-self.probability]), i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = Hybrid_SA_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "Hybrid_SA_ES", "description": "Novel hybrid algorithm combining Self-Adaptive Harmony Search (SAHS) with Evolution Strategy (ES) to optimize black box functions.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "6b7e5fc2-8ffc-47b6-81d3-69d0bd7c2e3a", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refinement_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        # Refine the strategy with probabilistic refinement\n        if random.random() < self.refinement_probability:\n            new_solution = self.refine_solution(self.best_solution)\n            value = func(new_solution)\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_solution(self, solution):\n        # Refine the solution with probabilistic refinement\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.refinement_probability:\n                # Randomly change the individual lines of the solution\n                refined_solution[i] = solution[i] + random.uniform(-1, 1)\n                # Ensure the solution stays within the bounds\n                refined_solution[i] = np.clip(refined_solution[i], self.lower_bound, self.upper_bound)\n        return refined_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy and Probabilistic Refinement", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "7b68f814-db57-424c-a327-6f8af711a0a6", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        # Refine the strategy by changing individual lines with a probability of 0.45\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                index = random.randint(0, self.harmony_size - 1)\n                new_value = random.uniform(self.lower_bound, self.upper_bound)\n                self.harmony[index, i] = new_value\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) for black box optimization", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "08387637-851b-4d18-b8be-ca99548f436e", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                # Apply probabilistic mutation\n                if random.random() < self.mutation_probability:\n                    self.harmony = self.mutate_harmony(self.harmony, new_solution, value)\n                else:\n                    self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def mutate_harmony(self, harmony, new_solution, value):\n        # Apply probabilistic mutation\n        mutated_harmony = harmony.copy()\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            # Create a new solution using the harmony memory\n            mutated_solution = np.zeros(self.dim)\n            for j in range(self.dim):\n                # Select a random solution from the harmony memory\n                mutated_index = random.randint(0, self.harmony_size - 1)\n                mutated_solution[j] = harmony[mutated_index, j]\n            # Evaluate the mutated solution\n            mutated_value = func(mutated_solution)\n            # Update the mutated harmony memory if necessary\n            if mutated_value < value:\n                mutated_harmony[self.harmony[:, 0] == value] = mutated_solution\n        return mutated_harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy using probabilistic mutation", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "610b9eb2-3f32-4531-bad9-2892341d3850", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.adaptive_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        # Refine the strategy with adaptive probability\n        refine_prob = random.random()\n        if refine_prob < self.adaptive_prob:\n            new_solution = self.refine_solution(self.harmony, self.best_solution)\n            value = func(new_solution)\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_solution(self, harmony, best_solution):\n        # Refine the best solution by changing individual lines with adaptive probability\n        refined_solution = best_solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.adaptive_prob:\n                refined_solution[i] = harmony[np.random.randint(0, self.harmony_size), i]\n        return refined_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel SAHES-ES with adaptive probability for black box optimization", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "513e8604-0187-48a9-ae67-2a7b20c9678c", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            # With a probability of 0.45, mutate the new solution\n            if random.random() < self.mutation_probability:\n                new_solution[i] = random.uniform(self.lower_bound, self.upper_bound)\n            else:\n                new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) with probabilistic mutation", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "bf72594f-7d55-4b2d-bfea-bff6e38fe508", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Refine the strategy using probability-based mutation\n            if random.random() < self.mutation_probability:\n                self.refine_solution(new_solution)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_solution(self, solution):\n        # Refine the solution using probability-based mutation\n        for i in range(self.dim):\n            if random.random() < self.mutation_probability:\n                # Apply mutation to the solution\n                solution[i] = solution[i] + random.uniform(-1, 1)\n                # Ensure the solution stays within the bounds\n                solution[i] = np.clip(solution[i], self.lower_bound, self.upper_bound)\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel SAHES-ES algorithm with adaptive mutation and probability-based refinement.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "e32e33c4-9b25-4c91-83a0-11d93658da28", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        indices_to_update = np.where(self.harmony[:, 0] == value)[0]\n        for i in indices_to_update:\n            # Randomly change the solution with a probability of 0.45\n            if random.random() < self.probability:\n                harmony[i, :] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel metaheuristic algorithm combining Self-Adaptive Harmony Search (SAHS) and Evolution Strategy (ES) for black box optimization.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "25ee0951-10ad-48b2-a33d-d1088bf1fbf2", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                # Apply mutation with probability\n                if random.random() < self.mutation_prob:\n                    new_solution = self.mutate_solution(new_solution)\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def mutate_solution(self, solution):\n        # Apply mutation\n        mutated_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.mutation_prob:\n                mutated_solution[i] += np.random.uniform(-1, 1)\n                mutated_solution[i] = max(self.lower_bound, min(self.upper_bound, mutated_solution[i]))\n        return mutated_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) for black box optimization with probability-based mutation.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "4bdab846-c0fe-4c06-920f-cb5425a19f61", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refinement_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Refine the best solution with probability 0.45\n            if random.random() < self.refinement_probability:\n                self.refine_solution(self.best_solution, value)\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def refine_solution(self, solution, value):\n        # Refine the solution with probability 0.45\n        if random.random() < self.refinement_probability:\n            # Change 45% of the individual lines of the solution\n            for i in range(self.dim):\n                if random.random() < 0.45:\n                    solution[i] = self.lower_bound + (self.upper_bound - self.lower_bound) * random.random()\n            # Evaluate the refined solution\n            refined_value = func(solution)\n            # Update the best solution if necessary\n            if refined_value < value:\n                self.best_solution = solution\n                self.best_value = refined_value\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel SAHES-ES algorithm with probability-based refinement for black box optimization.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "220b879b-64da-4eb7-b26b-f847e7307aa5", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refinement_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Refine the strategy with probability\n            if random.random() < self.refinement_probability:\n                self.refine_strategy(self.harmony, self.best_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_strategy(self, harmony, best_solution, value):\n        # Refine the strategy by changing individual lines\n        for i in range(self.dim):\n            # Calculate the probability of changing the current line\n            probability = random.random()\n            if probability < 0.45:\n                # Change the current line\n                index = np.where(self.harmony[:, i] == best_solution[i])[0][0]\n                self.harmony[index, i] = random.uniform(self.lower_bound, self.upper_bound)\n                # Evaluate the new solution\n                new_value = func(self.harmony)\n                # Update the best solution if necessary\n                if new_value < value:\n                    self.best_solution = self.harmony[0]\n                    self.best_value = new_value\n                # Update the harmony memory if necessary\n                if self.evaluate_harmony(func, new_value):\n                    self.harmony = self.update_harmony(self.harmony, self.harmony, new_value)", "name": "SAHES_ES", "description": "Novel SAHES-ES algorithm with probability-based strategy refinement", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('SAHES_ES.evaluate_harmony() takes 2 positional arguments but 3 were given').", "error": "TypeError('SAHES_ES.evaluate_harmony() takes 2 positional arguments but 3 were given')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "bf612267-6534-49a9-9db8-bd9e9255c1be", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        for i in range(self.population_size):\n            # Apply mutation with probability\n            if random.random() < self.probability:\n                # Change individual lines of the solution\n                for j in range(self.dim):\n                    harmony[i, j] += np.random.uniform(-1, 1)\n                    harmony[i, j] = np.clip(harmony[i, j], self.lower_bound, self.upper_bound)\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel metaheuristic algorithm combining Harmony Search and Evolution Strategy with probability-based mutation refinement.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "7702b144-fd78-49c2-b552-905c795f61f9", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func, value=None):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if value is not None and values[0] < value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            if random.random() < self.probability:\n                new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel Self-Adaptive Harmony Search with Evolution Strategy for black box optimization", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 29 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 29 is out of bounds for axis 0 with size 1')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "4cafea28-6c18-4750-aa48-70b577be861a", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        # Refine the strategy by changing the individual lines with a certain probability\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                # Select a random solution from the harmony memory\n                index = random.randint(0, self.harmony_size - 1)\n                # Change the value of the individual line with a certain probability\n                if random.random() < 0.5:\n                    self.harmony[index, i] += np.random.uniform(-1, 1)\n                # Ensure the value is within the bounds\n                self.harmony[index, i] = np.clip(self.harmony[index, i], self.lower_bound, self.upper_bound)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel metaheuristic algorithm combining Self-Adaptive Harmony Search (SAHS) with Evolution Strategy (ES) for black box optimization.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "eec51346-1d8f-4489-ba88-d56aee0a268b", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory with probability 0.45\n            if random.random() < self.mutation_prob:\n                index = random.randint(0, self.harmony_size - 1)\n                new_solution[i] = harmony[index, i]\n            else:\n                new_solution[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) with probability-based mutation", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "7fe5eb20-f219-44fa-b2d5-0ed8195ccfc1", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        # Refine the strategy using adaptive probability refinement\n        refined_harmony = self.refine_harmony(self.harmony, self.probability)\n        self.harmony = refined_harmony\n\n        return self.best_value\n\n    def evaluate_harmony(self, func, value=False):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if value and values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_harmony(self, harmony, probability):\n        # Refine the harmony memory using adaptive probability refinement\n        refined_harmony = np.copy(harmony)\n        for i in range(self.harmony_size):\n            # Refine the solution with a probability of 0.45\n            if random.random() < probability:\n                refined_harmony[i] = self.create_new_solution(refined_harmony)\n        return refined_harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) and Adaptive Probability Refinement for black box optimization.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 1')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "493dc872-e473-4d35-aefe-75bd1bf16912", "solution": "import numpy as np\nimport random\n\nclass ProbabilisticSAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                # Apply probabilistic mutation to the harmony memory\n                self.harmony = self.apply_probabilistic_mutation(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def apply_probabilistic_mutation(self, harmony, new_solution, value):\n        # Apply probabilistic mutation to the harmony memory\n        mutated_harmony = harmony.copy()\n        for i in range(self.dim):\n            # Check if the current dimension should be mutated\n            if random.random() < self.mutation_probability:\n                # Select a random solution from the harmony memory\n                index = random.randint(0, self.harmony_size - 1)\n                # Mutate the current dimension\n                mutated_harmony[i] = new_solution[index, i]\n        return mutated_harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = ProbabilisticSAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "ProbabilisticSAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy using Probabilistic Mutation for black box optimization.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "d0cedcdf-7de2-43bc-8df8-481402b9771e", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                # Apply mutation with probability\n                if random.random() < self.mutation_prob:\n                    new_solution = self.mutate_solution(new_solution)\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func, value):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if value < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = value\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def mutate_solution(self, solution):\n        # Apply mutation\n        mutated_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.mutation_prob:\n                mutated_solution[i] = solution[i] + random.uniform(-1, 1)\n                # Ensure bounds\n                mutated_solution[i] = max(self.lower_bound, min(mutated_solution[i], self.upper_bound))\n        return mutated_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) for black box optimization with probability-based mutation.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"SAHES_ES.evaluate_harmony() missing 1 required positional argument: 'value'\").", "error": "TypeError(\"SAHES_ES.evaluate_harmony() missing 1 required positional argument: 'value'\")", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "aa24117b-4274-4675-9e7f-73e029e5361f", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES_ProbRefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refinement_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n                # Refine the solution with probability 0.45\n                if random.random() < self.refinement_prob:\n                    self.refine_solution(new_solution)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_solution(self, solution):\n        # Refine the solution by changing individual lines with probability 0.45\n        for i in range(self.dim):\n            if random.random() < self.refinement_prob:\n                # Change the individual line\n                solution[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        return solution\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES_ProbRefine(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES_ProbRefine", "description": "Self-Adaptive Harmony Search with Evolution Strategy using Probability Refinement", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "44d97b5f-49ee-420e-aef7-c528e0444f0c", "solution": "import numpy as np\nimport random\n\nclass AdaptiveSAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        # Probabilistic mutation\n        if random.random() < self.probability:\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            # Generate a new solution by changing one dimension of the selected solution\n            new_solution = self.harmony[index, :]\n            new_solution[random.randint(0, self.dim - 1)] += random.uniform(-1, 1)\n            # Ensure the new solution is within the bounds\n            new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony[index, :] = new_solution\n\n    def evaluate_harmony(self, func, value=None):\n        if value is None:\n            values = func(self.harmony)\n        else:\n            values = [func(solution) for solution in self.harmony]\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = AdaptiveSAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "AdaptiveSAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy and Probabilistic Mutation for black box optimization.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "76de675a-73b1-4774-b09f-6caef0c486e5", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func, value=None):\n        if value is None:\n            values = func(self.harmony)\n        else:\n            values = [value] + func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory with mutation probability\n            if random.random() < self.mutation_prob:\n                index = random.randint(0, self.harmony_size - 1)\n                new_solution[i] = harmony[index, i] + np.random.uniform(-1, 1)\n            else:\n                new_solution[i] = harmony[random.randint(0, self.harmony_size - 1), i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel SAHES-ES with mutation probability refinement", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "514eaf68-1e26-4d66-8cea-3cc5d0b054f6", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES_Probability:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refinement_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Refine the best solution with probability 0.45\n            if random.random() < self.refinement_probability:\n                self.refine_solution(self.best_solution, value)\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_solution(self, solution, value):\n        # Refine the solution by changing individual lines with probability 0.45\n        for i in range(self.dim):\n            if random.random() < self.refinement_probability:\n                solution[i] += np.random.uniform(-0.1, 0.1)\n                solution[i] = np.clip(solution[i], self.lower_bound, self.upper_bound)\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES_Probability(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES_Probability", "description": "Self-Adaptive Harmony Search with Evolution Strategy using Probability-Based Refinement", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "e5caea2d-1cb6-4776-b25f-4e329122e560", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        # Refine the strategy by changing individual lines with a probability of 0.45\n        if np.random.rand() < self.probability:\n            self.refine_strategy()\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_strategy(self):\n        # Refine the strategy by changing individual lines with a probability of 0.45\n        for i in range(self.dim):\n            if np.random.rand() < self.probability:\n                # Select a random solution from the harmony memory\n                index = random.randint(0, self.harmony_size - 1)\n                # Change the individual line\n                self.harmony[index, i] += np.random.uniform(-1, 1)\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) for black box optimization.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "bb388534-f5b8-427f-a157-6c2308d5d9ca", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.p = 0.45  # probability to change individual lines\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                # Change individual lines with probability p\n                if random.random() < self.p:\n                    new_solution = self.change_individual_lines(new_solution)\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func, value=False):\n        if value:\n            values = func(self.harmony)\n        else:\n            values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def change_individual_lines(self, new_solution):\n        # Change individual lines with probability p\n        changed_solution = new_solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.p:\n                changed_solution[i] = self.lower_bound + (self.upper_bound - self.lower_bound) * random.random()\n        return changed_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel Self-Adaptive Harmony Search with Evolution Strategy for black box optimization", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "636ee5e1-a8ca-46e5-8310-4da349ea7230", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func, value=None):\n        values = func(self.harmony)\n        # Select the best solutions\n        if value is not None:\n            self.harmony = self.harmony[np.argsort(values)]\n            self.harmony = self.harmony[np.argsort(values)[::-1]]\n            self.harmony = self.harmony[:self.population_size]\n        else:\n            self.harmony = self.harmony[np.argsort(values)]\n            # Update the best solution if necessary\n            if values[0] < self.best_value:\n                self.best_solution = self.harmony[0]\n                self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        probability = random.random()\n        if probability < self.mutation_prob:\n            # Apply mutation\n            for i in range(self.dim):\n                if random.random() < self.mutation_prob:\n                    new_solution[i] += random.uniform(-1, 1)\n                    new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy using probability-based mutation.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "6d49ceca-6eb2-4cc4-b082-cf010c2b207c", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func, value):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if value < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = value\n        # Refine the strategy by probabilistically changing the individual lines\n        for i in range(self.dim):\n            if random.random() < self.mutation_probability:\n                index = random.randint(0, self.harmony_size - 1)\n                self.harmony[index, i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        return True\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) for black box optimization with probabilistic mutation.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"SAHES_ES.evaluate_harmony() missing 1 required positional argument: 'value'\").", "error": "TypeError(\"SAHES_ES.evaluate_harmony() missing 1 required positional argument: 'value'\")", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "85062233-31c5-4f57-b293-ecbdd39ea470", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refinement_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Refine the solution with a probability of 0.45\n            if random.random() < self.refinement_probability:\n                self.refine_solution(new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_solution(self, solution, value):\n        # Refine the solution by changing individual lines with a probability of 0.45\n        for i in range(self.dim):\n            if random.random() < self.refinement_probability:\n                solution[i] = self.lower_bound + (self.upper_bound - self.lower_bound) * random.random()\n        # Evaluate the refined solution\n        refined_value = func(solution)\n        # Update the best solution if necessary\n        if refined_value < value:\n            self.best_solution = solution\n            self.best_value = refined_value\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) for black box optimization using probabilistic refinement.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "99c786ab-0674-42f0-96a8-2a196856d474", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n\n            # Probability-based line search\n            if random.random() < self.probability:\n                # Select two random solutions from the harmony memory\n                indices = random.sample(range(self.harmony_size), 2)\n                # Create a new solution by linearly interpolating between the two selected solutions\n                new_solution = self.linear_interpolation(self.harmony[indices[0]], self.harmony[indices[1]])\n                # Evaluate the new solution\n                value = func(new_solution)\n                # Update the best solution if necessary\n                if value < self.best_value:\n                    self.best_solution = new_solution\n                    self.best_value = value\n\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def linear_interpolation(self, solution1, solution2):\n        # Linearly interpolate between two solutions\n        alpha = random.random()\n        new_solution = solution1 + alpha * (solution2 - solution1)\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy and Probability-based Line Search for Black Box Optimization", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "71cea7ce-06de-41a1-9b96-602e7c1d8ab7", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                # Apply probability-based mutation\n                if random.random() < self.mutation_prob:\n                    new_solution = self.mutate_solution(new_solution)\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def mutate_solution(self, solution):\n        # Apply probability-based mutation\n        mutated_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.mutation_prob:\n                mutated_solution[i] += random.uniform(-1.0, 1.0)\n                mutated_solution[i] = np.clip(mutated_solution[i], self.lower_bound, self.upper_bound)\n        return mutated_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy using probability-based mutation", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "363334c2-33e9-4af6-8ff0-d8eb6e26225a", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory with probability 0.45\n            if random.random() < self.mutation_prob:\n                index = random.randint(0, self.harmony_size - 1)\n                new_solution[i] = harmony[index, i]\n            else:\n                new_solution[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) with probability-based mutation", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "f808da19-0539-4cef-88a0-d26ef4314d29", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func, value=None):\n        if value is not None:\n            # Evaluate the harmony memory\n            values = func(self.harmony)\n            # Select the best solutions\n            self.harmony = self.harmony[np.argsort(values)]\n            # Update the best solution if necessary\n            if values[0] < self.best_value:\n                self.best_solution = self.harmony[0]\n                self.best_value = values[0]\n            # Update the harmony memory\n            self.harmony = self.harmony[np.argsort(values)]\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = self.harmony[0]\n                self.best_value = value\n        else:\n            values = func(self.harmony)\n            # Select the best solutions\n            self.harmony = self.harmony[np.argsort(values)]\n            # Update the best solution if necessary\n            if values[0] < self.best_value:\n                self.best_solution = self.harmony[0]\n                self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            # Check if the mutation is allowed\n            if random.random() < self.mutation_probability:\n                # Apply mutation\n                new_solution[i] = (1 - self.mutation_probability) * harmony[index, i] + self.mutation_probability * np.random.uniform(self.lower_bound, self.upper_bound)\n            else:\n                new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) using probability-based mutation.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "839afd2d-fc86-4bf1-a477-9292a14540c5", "solution": "import numpy as np\nimport random\nimport copy\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.p_change = 0.45\n        self.p_mutation = 0.1\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        # Refine the strategy\n        for i in range(self.harmony_size):\n            # Randomly change the individual lines of the selected solution\n            if random.random() < self.p_change:\n                index = random.randint(0, self.dim - 1)\n                new_value = random.uniform(self.lower_bound, self.upper_bound)\n                self.harmony[i, index] = new_value\n                # Evaluate the new solution\n                value = func(self.harmony[i])\n                # Update the best solution if necessary\n                if value < self.best_value:\n                    self.best_solution = self.harmony[i]\n                    self.best_value = value\n                # Update the harmony memory if necessary\n                if self.evaluate_harmony(func, value):\n                    self.harmony[i] = new_solution\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) for black box optimization", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "62cc201c-8896-44ab-8591-86a12efdb456", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n            # Apply probability-based mutation\n            if random.random() < self.mutation_prob:\n                # Select a random solution from the harmony memory\n                index = random.randint(0, self.harmony_size - 1)\n                # Create a new solution by changing one line of the selected solution\n                new_solution = self.harmony[index, :]\n                # Change a random line of the new solution\n                index = random.randint(0, self.dim - 1)\n                new_solution[index] = random.uniform(self.lower_bound, self.upper_bound)\n                # Evaluate the new solution\n                value = func(new_solution)\n                # Update the best solution if necessary\n                if value < self.best_value:\n                    self.best_solution = new_solution\n                    self.best_value = value\n                # Update the harmony memory if necessary\n                if self.evaluate_harmony(func, value):\n                    self.harmony[index, :] = new_solution\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel metaheuristic algorithm based on Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) and probability-based mutation.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "3145b3e3-d201-4569-ad69-93b2f274a6a6", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refinement_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                # Refine the solution with probability 0.45\n                if random.random() < self.refinement_prob:\n                    new_solution = self.refine_solution(new_solution, self.harmony)\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_solution(self, new_solution, harmony):\n        # Refine the solution by replacing 45% of its components\n        refined_solution = new_solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.refinement_prob:\n                index = random.randint(0, self.dim - 1)\n                refined_solution[index] = harmony[np.random.randint(0, self.harmony_size - 1), index]\n        return refined_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy and Probability Refinement for black box optimization", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "418e7bca-b665-4a86-a0d8-2c9e3926bfec", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        # Probability-based replacement\n        replacement = np.random.choice(len(self.harmony), size=int(self.probability * self.population_size), replace=False)\n        for i in replacement:\n            index = np.random.randint(0, self.harmony_size - 1)\n            self.harmony[i] = self.harmony[index]\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy using Probability-Based Replacement", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "27ff3de3-3a8e-48a7-9671-77e8a7ec6bc9", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func, value=None):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if value is not None and values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        # Apply mutation with probability\n        if random.random() < self.mutation_prob:\n            # Randomly select two solutions from the harmony memory\n            index1 = random.randint(0, self.harmony_size - 1)\n            index2 = random.randint(0, self.harmony_size - 1)\n            # Swap the corresponding dimensions\n            new_solution = np.array([harmony[index1, i], harmony[index2, i] for i in range(self.dim)])\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) for black box optimization using probability-based mutation.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('did you forget parentheses around the comprehension target?', ('<string>', 67, 38, '            new_solution = np.array([harmony[index1, i], harmony[index2, i] for i in range(self.dim)])\\n', 67, 76)).", "error": "SyntaxError('did you forget parentheses around the comprehension target?', ('<string>', 67, 38, '            new_solution = np.array([harmony[index1, i], harmony[index2, i] for i in range(self.dim)])\\n', 67, 76))", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "d32d98b2-af0a-4d8d-9c71-45d24b65bd10", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func, value):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory with probability\n            if random.random() < self.probability:\n                index = random.randint(0, self.harmony_size - 1)\n                new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy using probability to refine individual lines", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"SAHES_ES.evaluate_harmony() missing 1 required positional argument: 'value'\").", "error": "TypeError(\"SAHES_ES.evaluate_harmony() missing 1 required positional argument: 'value'\")", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "8ddf025c-cb9f-4e21-9374-b6352e9adfc7", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                # Refine the strategy with probability 0.45\n                if random.random() < self.probability:\n                    self.harmony = self.refine_harmony(self.harmony, new_solution, value)\n                else:\n                    self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_harmony(self, harmony, new_solution, value):\n        # Refine the harmony memory by replacing the worst solution with the new solution\n        worst_index = np.argmin(harmony[:, 0])\n        harmony[worst_index, :] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel Self-Adaptive Harmony Search with Evolution Strategy for black box optimization", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "44ed13b0-22a4-4b7b-89d6-19d3e7150305", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                # Apply mutation with probability\n                if random.random() < self.mutation_prob:\n                    new_solution = self.mutate_solution(new_solution)\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def mutate_solution(self, solution):\n        # Apply mutation\n        mutated_solution = solution.copy()\n        for i in range(self.dim):\n            # Randomly change the value with probability\n            if random.random() < self.mutation_prob:\n                mutated_solution[i] += random.uniform(-1.0, 1.0)\n                # Ensure bounds are not exceeded\n                mutated_solution[i] = max(self.lower_bound, min(mutated_solution[i], self.upper_bound))\n        return mutated_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) with probability-based mutation for black box optimization.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "77a2450d-8fd9-4526-b238-cc6d00818ede", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        # Refine the strategy by changing individual lines with a probability of 0.45\n        if random.random() < self.probability:\n            new_solution = self.refine_solution(self.harmony, self.best_solution)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_solution(self, harmony, solution):\n        # Refine the solution by changing individual lines with a probability of 0.45\n        new_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_solution[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        return new_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) algorithm for black box optimization.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "416fc4de-24ef-42b7-b8e1-46001fbc5e39", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                # Apply probability-based mutation\n                if random.random() < self.mutation_prob:\n                    self.harmony = self.mutate_harmony(self.harmony, new_solution)\n                else:\n                    self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def mutate_harmony(self, harmony, new_solution):\n        # Apply probability-based mutation\n        mutated_harmony = harmony.copy()\n        for i in range(self.harmony_size):\n            if random.random() < self.mutation_prob:\n                mutated_harmony[i, :] = new_solution\n        return mutated_harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) for black box optimization with probability-based mutation.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "fc0e2c83-8197-47ac-894d-bf5e9badc77a", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.adaptive_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                # Refine the search strategy with adaptive probability\n                refined_harmony = self.refine_harmony(self.harmony, new_solution, value, self.adaptive_prob)\n                self.harmony = refined_harmony\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def refine_harmony(self, harmony, new_solution, value, prob):\n        # Refine the harmony memory with adaptive probability\n        refined_harmony = harmony.copy()\n        for i in range(self.dim):\n            # Randomly select a solution from the harmony memory with adaptive probability\n            if random.random() < prob:\n                index = random.randint(0, self.harmony_size - 1)\n                refined_harmony[i, 0] = index\n                refined_harmony[i, 1:] = new_solution[i]\n        return refined_harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel SAHES-ES algorithm with adaptive probability for refining the search strategy", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "fb1f6566-acb7-4e64-87d7-b387308eccac", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refinement_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Refine the strategy with probability 0.45\n            if random.random() < self.refinement_probability:\n                self.refine_strategy(self.harmony, self.best_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_strategy(self, harmony, best_solution, value):\n        # Refine the strategy by changing the individual lines of the best solution\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            # Change the value of the current dimension\n            harmony[index, i] = best_solution[i] + random.uniform(-1, 1)\n            # Ensure the new value is within the bounds\n            harmony[index, i] = np.clip(harmony[index, i], self.lower_bound, self.upper_bound)\n        # Evaluate the refined harmony memory\n        values = func(self.harmony)\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel SAHES-ES algorithm with probability-based strategy refinement", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "28d3bc10-189d-438f-b140-1004c7655135", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refinement_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n\n            # Refine the solution with probability 0.45\n            if random.random() < self.refinement_prob:\n                self.refine_solution(new_solution, value)\n\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func, value=None):\n        if value is None:\n            values = func(self.harmony)\n        else:\n            values = func(self.harmony[np.argsort([value])])\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if value is not None and values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def refine_solution(self, solution, value):\n        # Refine the solution by changing 45% of its components\n        for i in range(self.dim):\n            if random.random() < self.refinement_prob:\n                solution[i] += np.random.uniform(-0.1, 0.1)\n                solution[i] = np.clip(solution[i], self.lower_bound, self.upper_bound)\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel SAHES-ES with probability-based refinement for black box optimization", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 7 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 7 is out of bounds for axis 0 with size 1')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "ae2fa255-76a1-4436-8def-d5123a68d94c", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES_Probabilistic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n            # Apply probabilistic mutation\n            if random.random() < self.mutation_probability:\n                # Randomly select two solutions from the harmony memory\n                index1 = random.randint(0, self.harmony_size - 1)\n                index2 = random.randint(0, self.harmony_size - 1)\n                # Create a new solution by adding a random value to the first solution\n                new_solution = self.harmony[index1] + np.random.uniform(-1, 1, self.dim)\n                # Evaluate the new solution\n                value = func(new_solution)\n                # Update the best solution if necessary\n                if value < self.best_value:\n                    self.best_solution = new_solution\n                    self.best_value = value\n                # Update the harmony memory if necessary\n                if self.evaluate_harmony(func, value):\n                    self.harmony[index1] = new_solution\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES_Probabilistic(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES_Probabilistic", "description": "Self-Adaptive Harmony Search with Evolution Strategy and Probabilistic Mutation", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "30f94753-bd6d-4abe-a632-d3cea0f7b53e", "solution": "import numpy as np\nimport random\n\nclass PDS_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func, value=None):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if value is not None and values[0] < value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        if np.random.rand() < self.probability:\n            harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = PDS_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "PDS_ES", "description": "Novel metaheuristic algorithm using Probability-Driven Harmony Search with Evolution Strategy", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 34 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 34 is out of bounds for axis 0 with size 1')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "350123ca-983e-40a8-9b3b-1cb8e9d27633", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        # Apply mutation with probability 0.45\n        if random.random() < self.mutation_prob:\n            new_solution = self.mutate_solution(self.harmony, self.mutation_prob)\n            value = func(new_solution)\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            self.harmony = self.update_harmony(self.harmony, new_solution, value)\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def mutate_solution(self, harmony, mutation_prob):\n        # Select a random solution from the harmony memory\n        index = random.randint(0, self.harmony_size - 1)\n        # Create a new solution by changing one element of the selected solution\n        new_solution = harmony[index, :]\n        # Randomly change one element of the new solution\n        idx = random.randint(0, self.dim - 1)\n        new_solution[idx] = np.random.uniform(self.lower_bound, self.upper_bound)\n        return new_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel SAHES-ES algorithm with probability-based mutation for black box optimization", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "44e1fcfe-4b63-4cf7-bfa6-c39028be3840", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                # Refine the strategy by changing individual lines with probability 0.45\n                self.harmony = self.refine_harmony(self.harmony, new_solution, value, self.probability)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_harmony(self, harmony, new_solution, value, probability):\n        # Refine the strategy by changing individual lines with probability 0.45\n        refined_harmony = np.copy(harmony)\n        for i in range(self.harmony_size):\n            if np.random.rand() < probability:\n                # Change individual lines with probability 0.45\n                for j in range(self.dim):\n                    if np.random.rand() < probability:\n                        refined_harmony[i, j] = new_solution[j]\n        return refined_harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) for black box optimization.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "72087043-0e61-452b-875d-5f964e2e251e", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_prob = 0.45\n        self.mutation_rate = 0.1\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n            # Refine the strategy with adaptive mutation probability\n            if random.random() < self.mutation_prob:\n                self.refine_strategy(self.harmony, self.mutation_rate)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_strategy(self, harmony, mutation_rate):\n        # Refine the strategy with adaptive mutation probability\n        for i in range(self.dim):\n            if random.random() < self.mutation_prob:\n                if random.random() < 0.5:\n                    # Change the individual line\n                    index = random.randint(0, self.harmony_size - 1)\n                    harmony[index, i] += random.uniform(-mutation_rate, mutation_rate)\n                    # Ensure the value is within the bounds\n                    harmony[index, i] = np.clip(harmony[index, i], self.lower_bound, self.upper_bound)\n                else:\n                    # Change the individual value\n                    harmony[self.harmony[:, 0] == i, i] += random.uniform(-mutation_rate, mutation_rate)\n                    # Ensure the value is within the bounds\n                    harmony[self.harmony[:, 0] == i, i] = np.clip(harmony[self.harmony[:, 0] == i, i], self.lower_bound, self.upper_bound)\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel SAHES-ES algorithm with adaptive mutation probability", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "86b8fe1b-1be9-4bd7-a866-6e6e8cbe6456", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        replace_indices = np.random.choice(self.harmony_size, size=int(self.probability * self.harmony_size), replace=False)\n        harmony[replace_indices] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy and Probability-Based Replacement for black box optimization", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "8fc0c843-6066-45db-b88e-25e39d4c2640", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES_ProbRef:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refinement_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Refine the solution with probability 0.45\n            if random.random() < self.refinement_probability:\n                new_solution = self.refine_solution(new_solution)\n                # Evaluate the refined solution\n                value = func(new_solution)\n                # Update the best solution if necessary\n                if value < self.best_value:\n                    self.best_solution = new_solution\n                    self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_solution(self, solution):\n        # Refine the solution by changing individual lines with probability 0.45\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.refinement_probability:\n                refined_solution[i] = solution[i] + np.random.uniform(-0.1, 0.1)\n                # Ensure bounds are not exceeded\n                refined_solution[i] = np.clip(refined_solution[i], self.lower_bound, self.upper_bound)\n        return refined_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES_ProbRef(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES_ProbRef", "description": "Self-Adaptive Harmony Search with Evolution Strategy and Probability Refinement for black box optimization", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "e9680ddd-bbc9-48f8-b935-71af5bebbefe", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refine_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Refine the existing solutions with probability 0.45\n            if random.random() < self.refine_probability:\n                self.refine_solution(new_solution)\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_solution(self, solution):\n        # Refine the solution by changing individual lines with probability 0.45\n        for i in range(self.dim):\n            if random.random() < self.refine_probability:\n                # Change the individual line\n                solution[i] += random.uniform(-1.0, 1.0)\n                # Ensure the solution stays within the bounds\n                solution[i] = np.clip(solution[i], self.lower_bound, self.upper_bound)\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel SAHES-ES algorithm with probability-based refinement.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "aa13edf1-cb89-4bfe-8dff-8b9fce12bdea", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        for i in range(self.dim):\n            # With probability 0.45, change the individual line\n            if random.random() < self.mutation_prob:\n                index = random.randint(0, self.harmony_size - 1)\n                harmony[index, i] = new_solution[i]\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy using probability-based mutation", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "b674f077-59b7-45b8-8181-a39ceaec92c2", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                # Replace 45% of the harmony memory with the new solution\n                replacement_indices = np.random.choice(self.harmony_size, size=int(self.harmony_size * self.probability), replace=False)\n                self.harmony[replacement_indices] = new_solution\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func, value=None):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if value is not None and values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy using Probability-Based Replacement", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 47 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 47 is out of bounds for axis 0 with size 1')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "d2639399-0575-4d38-aa1c-20abcbc6a9c1", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                # Refine the individual solutions using probability\n                self.refine_individuals(self.harmony, new_solution, value)\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def refine_individuals(self, harmony, new_solution, value):\n        # Refine the individual solutions using probability\n        for i in range(self.harmony_size):\n            # Calculate the probability of refining the individual solution\n            prob = self.probability * (1 - (value - harmony[i, 0]) / (self.best_value - harmony[0, 0]))\n            if random.random() < prob:\n                # Refine the individual solution\n                index = random.randint(0, self.dim - 1)\n                harmony[i, index] = new_solution[index]\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy using probability to refine individual solutions", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "ab7769d3-efe4-4af3-bf60-a71f11e19b3e", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refinement_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Refine the existing solutions with probability 0.45\n            if random.random() < self.refinement_probability:\n                self.refine_solution(self.harmony, new_solution, value)\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def refine_solution(self, harmony, new_solution, value):\n        # Refine the existing solutions\n        for i in range(self.harmony_size):\n            # Calculate the difference between the new solution and the existing solution\n            diff = np.sum((new_solution - harmony[i]) ** 2)\n            # Update the existing solution with probability 0.45\n            if random.random() < self.refinement_probability:\n                harmony[i] = new_solution\n        # Update the harmony memory\n        harmony = np.sort(harmony, axis=0)\n        self.harmony = harmony[:self.harmony_size]\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel SAHES-ES with probability-based refinement", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "9db68f0f-fa4e-48d4-aa3c-5a2834c859d2", "solution": "import numpy as np\nimport random\n\nclass Novel_SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.p_change = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        # Refine the strategy by changing individual lines\n        refined_harmony = np.copy(self.harmony)\n        for i in range(self.harmony_size):\n            for j in range(self.dim):\n                if np.random.rand() < self.p_change:\n                    refined_harmony[i, j] = np.random.uniform(self.lower_bound, self.upper_bound)\n        self.harmony = refined_harmony\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = Novel_SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "Novel_SAHES_ES", "description": "Novel Self-Adaptive Harmony Search with Evolution Strategy for black box optimization", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "ab303698-93e1-43d3-bae4-a74175cac6bd", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func, value=None):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if value is not None and value < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = value\n        elif values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory with probability 0.45\n            if random.random() < self.mutation_prob:\n                index = random.randint(0, self.harmony_size - 1)\n                new_solution[i] = harmony[index, i]\n            else:\n                new_solution[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy using probability-based mutation", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "52829b2e-22de-4da6-a26a-8935beaa8479", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) for black box optimization", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "915d3a02-272a-44b3-be89-e63e45e36b50", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func, value=False):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if not value and values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n        # Refine the strategy by changing individual lines with a probability of 0.45\n        if random.random() < self.probability:\n            for i in range(self.dim):\n                index = random.randint(0, self.harmony_size - 1)\n                new_value = random.uniform(self.lower_bound, self.upper_bound)\n                self.harmony[index, i] = new_value\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) for black box optimization.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "94377c4c-773e-4c9d-99a0-10601a33509c", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refine_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Refine the strategy with probability\n            if random.random() < self.refine_probability:\n                self.refine_solution(new_solution)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_solution(self, solution):\n        # Refine the solution by changing individual lines with probability\n        for i in range(self.dim):\n            if random.random() < self.refine_probability:\n                new_value = solution[i] + random.uniform(-1, 1)\n                if new_value < self.lower_bound:\n                    new_value = self.lower_bound\n                elif new_value > self.upper_bound:\n                    new_value = self.upper_bound\n                solution[i] = new_value\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy (SAHES-ES) using probability to refine the strategy", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "812012c9-3313-4d66-bd75-cd1fff6d4f2b", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refinement_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Refine the best solution with probability\n            if random.random() < self.refinement_probability:\n                self.refine_best_solution(self.best_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_best_solution(self, best_solution, value):\n        # Refine the best solution\n        new_solution = best_solution.copy()\n        for i in range(self.dim):\n            # Randomly change the value with probability\n            if random.random() < self.refinement_probability:\n                new_solution[i] += random.uniform(-1, 1)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        # Evaluate the refined solution\n        refined_value = func(new_solution)\n        # Update the best solution if necessary\n        if refined_value < value:\n            self.best_solution = new_solution\n            self.best_value = refined_value\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel SAHES-ES algorithm with probability-based refinement for black box optimization", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "c0c41952-0f40-4bf4-a26c-25cf016ffb26", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refine_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                # Refine the individual lines with probability 0.45\n                if random.random() < self.refine_prob:\n                    new_solution = self.refine_solution(new_solution, self.harmony)\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def refine_solution(self, new_solution, harmony):\n        # Refine the individual lines with probability 0.45\n        refined_solution = new_solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.refine_prob:\n                refined_solution[i] = harmony[random.randint(0, self.harmony_size - 1), i]\n        return refined_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy using probability to refine individual lines.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "359945b2-01b7-4c6f-8c06-602de4826fb9", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory with probability 0.45\n            if random.random() < self.mutation_prob:\n                index = random.randint(0, self.harmony_size - 1)\n                new_solution[i] = harmony[index, i]\n            else:\n                new_solution[i] = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand()\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel SAHES-ES algorithm with probability-based mutation for black box optimization", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "9f1de5f9-905b-42e2-b56d-ec05603d9d7c", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refine_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        # Refine the best solution with probability 0.45\n        if random.random() < self.refine_probability:\n            self.refine_solution(self.best_solution)\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_solution(self, solution):\n        # Refine the solution by changing 45% of its elements\n        for i in range(self.dim):\n            if random.random() < self.refine_probability:\n                solution[i] = self.lower_bound + (self.upper_bound - self.lower_bound) * random.random()\n        return solution\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy using probability to refine the solution.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "a2117df3-d768-4eaf-9003-f32c3dd026df", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func, value=False):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if value:\n            if values[0] < self.best_value:\n                self.best_solution = self.harmony[0]\n                self.best_value = values[0]\n        else:\n            if values[0] < self.best_value:\n                self.best_solution = self.harmony[0]\n                self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n            # Apply mutation with probability\n            if random.random() < self.mutation_probability:\n                # Randomly change the individual line\n                new_solution[i] += random.uniform(-1.0, 1.0)\n                new_solution[i] = max(self.lower_bound, min(new_solution[i], self.upper_bound))\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy using probability-based mutation", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "4de8c4db-3453-48a6-8f83-98fd86d2dc75", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refinement_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        # Refine the strategy using probability-based refinement\n        if random.random() < self.refinement_probability:\n            refined_solution = self.refine_solution(self.best_solution)\n            # Evaluate the refined solution\n            refined_value = func(refined_solution)\n            # Update the best solution if necessary\n            if refined_value < self.best_value:\n                self.best_solution = refined_solution\n                self.best_value = refined_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n    def refine_solution(self, solution):\n        # Refine the solution using probability-based refinement\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            # Randomly select a fraction of the solution's components to refine\n            if random.random() < self.refinement_probability:\n                refined_solution[i] = solution[i] + np.random.uniform(-1, 1)\n                # Ensure the solution remains within the bounds\n                refined_solution[i] = np.clip(refined_solution[i], self.lower_bound, self.upper_bound)\n        return refined_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy and Probability-Based Refinement", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "0457aa5c-2bf5-485e-879c-fdebe7eee58d", "solution": "import numpy as np\nimport random\n\nclass ProbSAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_prob = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            # With a probability of 0.45, mutate the new solution\n            if random.random() < self.mutation_prob:\n                new_solution[i] = random.uniform(self.lower_bound, self.upper_bound)\n            else:\n                new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = ProbSAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "ProbSAHES_ES", "description": "Novel SAHES-ES algorithm with probabilistic mutation for black box optimization.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "f7a68396-18c6-4b5f-99af-14cdacf87e00", "solution": "import numpy as np\nimport random\n\nclass SAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.refine_probability = 0.45\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Refine the solution with a probability\n            if random.random() < self.refine_probability:\n                new_solution = self.refine_solution(new_solution)\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def refine_solution(self, solution):\n        # Refine the solution by changing individual lines with a probability\n        refined_solution = solution.copy()\n        for i in range(self.dim):\n            if random.random() < self.refine_probability:\n                refined_solution[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        return refined_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = SAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "SAHES_ES", "description": "Novel SAHES-ES algorithm with probabilistic refinement and harmonic selection", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
{"id": "3dcf39ce-72eb-480a-8ea4-d4f199e92e74", "solution": "import numpy as np\nimport random\n\nclass AdaptiveSAHES_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_size = 50\n        self.population_size = 100\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.mutation_prob = 0.45\n        self.mutation_step = 0.1\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_value\n\n        if self.best_solution is None:\n            # Initialize the harmony memory with random solutions\n            self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_size, self.dim))\n            # Evaluate the harmony memory\n            self.evaluate_harmony(func)\n\n        for _ in range(self.budget):\n            # Create a new solution using the harmony memory\n            new_solution = self.create_new_solution(self.harmony)\n            # Evaluate the new solution\n            value = func(new_solution)\n            # Update the best solution if necessary\n            if value < self.best_value:\n                self.best_solution = new_solution\n                self.best_value = value\n            # Update the harmony memory if necessary\n            if self.evaluate_harmony(func, value):\n                self.harmony = self.update_harmony(self.harmony, new_solution, value)\n            # Update the population size if necessary\n            if len(self.harmony) < self.population_size:\n                self.harmony = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.population_size, self.dim))\n                self.evaluate_harmony(func)\n\n            # Apply probabilistic mutation\n            if random.random() < self.mutation_prob:\n                for i in range(self.dim):\n                    # Select a random solution from the harmony memory\n                    index = random.randint(0, self.harmony_size - 1)\n                    # Update the solution using the mutation step\n                    self.harmony[index, i] += self.mutation_step * (self.upper_bound - self.lower_bound) * random.random() - 0.5 * self.mutation_step * (self.upper_bound - self.lower_bound)\n                    # Ensure the solution is within the bounds\n                    self.harmony[index, i] = np.clip(self.harmony[index, i], self.lower_bound, self.upper_bound)\n\n        return self.best_value\n\n    def evaluate_harmony(self, func):\n        values = func(self.harmony)\n        # Select the best solutions\n        self.harmony = self.harmony[np.argsort(values)]\n        # Update the best solution if necessary\n        if values[0] < self.best_value:\n            self.best_solution = self.harmony[0]\n            self.best_value = values[0]\n\n    def create_new_solution(self, harmony):\n        # Create a new solution using the harmony memory\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Select a random solution from the harmony memory\n            index = random.randint(0, self.harmony_size - 1)\n            new_solution[i] = harmony[index, i]\n        return new_solution\n\n    def update_harmony(self, harmony, new_solution, value):\n        # Update the harmony memory\n        harmony[self.harmony[:, 0] == value] = new_solution\n        return harmony\n\n# Example usage\ndef func(x):\n    return np.sum(x ** 2)\n\nbudget = 100\ndim = 10\noptimizer = AdaptiveSAHES_ES(budget, dim)\nbest_value = optimizer(func)\nprint(\"Best value:\", best_value)", "name": "AdaptiveSAHES_ES", "description": "Self-Adaptive Harmony Search with Evolution Strategy and Probabilistic Mutation for black box optimization", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "3aeff718-372a-487c-bace-e7d1f975e57a", "metadata": {}, "mutation_prompt": null}
