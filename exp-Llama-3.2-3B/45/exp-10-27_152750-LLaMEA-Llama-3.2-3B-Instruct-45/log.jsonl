{"id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy\" algorithm for black box optimization.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 70, in <module>\n  File \"<string>\", line 37, in __call__\n  File \"/opt/conda/lib/python3.11/random.py\", line 439, in sample\n    raise TypeError(\"Population must be a sequence.  \"\nTypeError: Population must be a sequence.  For dicts or sets, use sorted(d).\n.", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 70, in <module>\n  File \"<string>\", line 37, in __call__\n  File \"/opt/conda/lib/python3.11/random.py\", line 439, in sample\n    raise TypeError(\"Population must be a sequence.  \"\nTypeError: Population must be a sequence.  For dicts or sets, use sorted(d).\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "5a14a506-8560-4f01-9e0b-c36453b79332", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.adaptive_probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Update crossover probability based on fitness\n                self.crossover_probability = np.mean(fitness) * self.adaptive_probability\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Probability\" for black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "0539e448-74fc-48e1-8394-dcac7e1c01f1", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.adaptive_crossover_probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Adaptive crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.adaptive_crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        # Random crossover\n                        parent1, parent2 = random.sample(parents, 2)\n                        crossover_point = np.random.randint(0, self.dim)\n                        child = parent1[:crossover_point] + parent2[crossover_point:]\n                        offspring.append(child)\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "84af759f-e78d-4ec8-b3af-403c5999d203", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.update_probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Update individuals with probability\n                if random.random() < self.update_probability:\n                    updated_individual = self.update_individual(offspring[i])\n                    offspring[i] = updated_individual\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n    def update_individual(self, individual):\n        # Randomly select 2 features to update\n        indices = random.sample(range(self.dim), 2)\n        new_individual = individual.copy()\n        new_individual[indices] += np.random.uniform(-1.0, 1.0, size=2)\n        return new_individual\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Probabilistic Individual Updates\" algorithm for black box optimization.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "2578d9d6-a095-4a6b-a386-47978101c1d6", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n        self.adaptive_crossover_probability = 0.0\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Adaptive crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.adaptive_crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        parent = parents[np.random.randint(0, len(parents))]\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring.append(parent + mutation)\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n            # Update adaptive crossover probability\n            if len(self.fitness_history) > 10:\n                self.adaptive_crossover_probability = np.mean([np.min(fitness_history[i:i+10]) for i in range(len(fitness_history)-10)])\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Probability\" algorithm for black box optimization.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'fitness_history' is not defined\").", "error": "NameError(\"name 'fitness_history' is not defined\")", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "763e2352-eb47-41ee-a9cf-25bd3b9fbfb9", "solution": "import numpy as np\nimport random\nimport time\nimport copy\n\nclass DifferentialEvolutionWithHybridEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.hybridization_rate = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using differential evolution\n                parents = []\n                for j in range(self.population_size):\n                    individual = population[j]\n                    target = population[(np.random.randint(0, self.population_size) + j) % self.population_size]\n                    differential = target - individual\n                    mutant = individual + differential * np.random.uniform(-1.0, 1.0, size=self.dim)\n                    parents.append(mutant)\n\n                # Hybridize with evolutionary strategy\n                hybridized_parents = []\n                for j in range(self.population_size):\n                    if random.random() < self.hybridization_rate:\n                        individual = parents[j]\n                        mutant = population[np.random.randint(0, self.population_size)]\n                        hybridized_parent = (individual + mutant) / 2\n                        hybridized_parents.append(hybridized_parent)\n                    else:\n                        hybridized_parents.append(parents[j])\n\n                # Crossover\n                offspring = []\n                for j in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(hybridized_parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(hybridized_parents[np.random.randint(0, len(hybridized_parents))])\n\n                # Mutation\n                for j in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[j] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = DifferentialEvolutionWithHybridEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "DifferentialEvolutionWithHybridEvolutionStrategy", "description": "Novel \"Differential Evolution with Hybrid Evolution Strategy\" algorithm for black box optimization", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "40eceb6a-c1b5-49b0-9c66-b03c892be948", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.45\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2 + np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Probabilistic Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "002033ec-fbef-4ffb-8483-e09217e35caf", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Update crossover probability based on fitness\n                self.crossover_probability = max(0.1, self.crossover_probability * (1 - (self.fitness_history[-1] - np.min(self.fitness_history)) / (self.fitness_history[0] - np.min(self.fitness_history))))\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Probability\" for black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "3578acf1-4a0e-4ab1-8bbb-47e6272f5070", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Probabilistic line search\n                for j in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        # Select a random individual to modify\n                        parent_index = np.random.randint(0, self.population_size)\n                        parent = offspring[parent_index]\n                        # Calculate the new individual by adding the mutation to the parent\n                        new_individual = parent + mutation\n                        # Check if the new individual is better than the original parent\n                        if func(new_individual) < func(parent):\n                            offspring[parent_index] = new_individual\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Probabilistic Line Search\" algorithm for black box optimization.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "a102b6bf-f7a7-481f-9d23-1a9d54702c22", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover with probability 0.45\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) * 0.55 + np.random.uniform(-0.1, 0.1, size=self.dim)\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation with probability 0.45\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy\" algorithm with probability-based crossover and mutation for black box optimization.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "f3aec41d-3371-42f9-87eb-24e7411dcf2e", "solution": "import numpy as np\nimport random\nimport time\n\nclass MultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Update crossover probability based on fitness\n                self.crossover_probability = max(0, min(self.crossover_probability + self.adaptive_probability * (1 - np.mean(fitness)), 1))\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = ms(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "MultiObjectiveEvolutionStrategy", "description": "Novel \"Multi-Objective Evolution Strategy with Adaptive Probability\" algorithm for black box optimization.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "35952f87-5b7e-46ac-bbbc-ea41ca24dda8", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.adaptive_probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability + (self.adaptive_probability - self.crossover_probability) * random.random():\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability + (self.adaptive_probability - self.mutation_probability) * random.random():\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Probabilities\" algorithm for black box optimization.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "151b6c4b-36a3-4d7e-974e-7d00d467701a", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.45  # Changed mutation probability\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        # Change individual lines with probability 0.45\n                        if random.random() < 0.45:\n                            offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Probability-Based Mutation\" algorithm for black box optimization.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "d6e8be36-3048-48ff-b4ae-4c477f2fd02d", "solution": "import numpy as np\nimport random\nimport time\n\nclass MultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Probabilistic crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) * random.uniform(0.45, 0.55)\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = ms(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "MultiObjectiveEvolutionStrategy", "description": "Novel \"Multi-Objective Evolution Strategy with Probabilistic Crossover and Mutation\" algorithm for black box optimization", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "eb8775d6-e7b8-45d3-91e8-5e8a22e8df82", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n        self.crossover_probabilities = [self.adaptive_probability] * self.population_size\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for j in range(self.population_size):\n                    parent1, parent2 = random.sample(parents, 2)\n                    if random.random() < self.crossover_probabilities[j]:\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Probability\" algorithm for black box optimization.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "05dacbfb-bd58-4fc2-a0af-f96080eb77a4", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Update individuals with probabilistic changes\n                for j in range(self.population_size):\n                    if random.random() < self.probability:\n                        # Change one dimension of the individual\n                        index = random.randint(0, self.dim - 1)\n                        offspring[j][index] += np.random.uniform(-1.0, 1.0)\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Probabilistic Individual Updates\" algorithm for black box optimization.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "15c446a1-1340-4714-821d-cddc45bb3a6e", "solution": "import numpy as np\nimport random\nimport time\nimport copy\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.hybrid_mutation_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Hybrid mutation\n                for i in range(self.population_size):\n                    if random.random() < self.hybrid_mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n                    elif random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Hybrid Mutation\" algorithm for black box optimization", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "01ceff86-2781-4ad8-8ac5-e6f01056c2c3", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.45\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Adaptive crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        # Randomly select either parent or parent1\n                        if random.random() < 0.5:\n                            offspring.append(parent1)\n                        else:\n                            offspring.append(parent2)\n\n                # Adaptive mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy\" with adaptive crossover and mutation probability.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "79a3cc00-86cf-4320-8ddd-b86317ad976d", "solution": "import numpy as np\nimport random\nimport time\n\nclass MultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Probabilistic line search\n                for j in range(self.population_size):\n                    if random.random() < 0.45:\n                        # Randomly select a parent and a direction\n                        parent = parents[np.random.randint(0, len(parents))]\n                        direction = np.random.uniform(-1.0, 1.0, size=self.dim)\n\n                        # Calculate the new individual\n                        new_individual = parent + direction * 0.1\n\n                        # Replace the worst individual\n                        offspring = np.sort(population, axis=0)\n                        offspring = np.delete(offspring, np.argmin(fitness), axis=0)\n                        offspring = np.vstack((offspring, [new_individual]))\n                        population = offspring\n\n                        # Evaluate fitness for each individual\n                        fitness = np.array([func(individual) for individual in population])\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = MultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "MultiObjectiveEvolutionStrategy", "description": "Novel \"Multi-Objective Evolution Strategy with Probabilistic Line Search\" algorithm for black box optimization.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "e5109e88-a330-47fc-859a-051d1a3977f5", "solution": "import numpy as np\nimport random\nimport time\n\nclass MultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Update crossover probability based on fitness\n                self.crossover_probability = max(0.0, min(self.crossover_probability + 0.01 * (1 - fitness[np.argmin(fitness)]), 1.0))\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update adaptive probability\n            self.mutation_probability = max(0.0, min(self.mutation_probability + 0.01 * (1 - fitness[np.argmin(fitness)]), 1.0))\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = MultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "MultiObjectiveEvolutionStrategy", "description": "Novel \"Multi-Objective Evolution Strategy with Adaptive Probability\" algorithm for black box optimization.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "bdae0105-9466-48fb-9480-baebe5b37120", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n        self.probability = 0.9\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Update probability based on fitness\n                fitness_min = np.min(fitness)\n                if fitness_min < 1e-6:\n                    self.probability += self.adaptive_probability\n                else:\n                    self.probability -= self.adaptive_probability / (fitness_min + 1e-6)\n\n                # Ensure probability is within bounds\n                self.probability = max(0.0, min(1.0, self.probability))\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Probability\" algorithm for black box optimization", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "03a9d6eb-a827-4590-a7e9-83858d9d7fab", "solution": "import numpy as np\nimport random\n\nclass MultiObjectiveEvolutionaryStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Probabilistic mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation * random.random()\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmes = MultiObjectiveEvolutionaryStrategy(budget=100, dim=10)\nbest_fitness, best_individual = mes(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "MultiObjectiveEvolutionaryStrategy", "description": "Novel \"Multi-Objective Evolutionary Strategy with Probabilistic Mutation\" algorithm for black box optimization.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "0f7c218b-2f1e-400e-881f-08b54e3e340a", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.adaptive_probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability + (self.adaptive_probability - self.crossover_probability) * np.random.rand():\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Probability\" algorithm for black box optimization.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "32394a1c-f811-47aa-bf9d-6683ce1c67ad", "solution": "import numpy as np\nimport random\nimport time\n\nclass MultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        child *= 0.5  # Reduce the scale of the child to avoid large values\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n                        offspring[i] *= 0.5  # Reduce the scale of the mutated individual to avoid large values\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = MultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "MultiObjectiveEvolutionStrategy", "description": "Novel \"Multi-Objective Evolution Strategy with Crossover and Mutation\" for black box optimization.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "6323b44c-d9a3-4899-998b-85736f321cfb", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.45\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover with probability-based selection\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        # Select parent with higher fitness\n                        parent = parents[np.argmax(fitness)]\n                        offspring.append(parent)\n\n                # Mutation with probability-based selection\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy\" algorithm with probability-based crossover and mutation for black box optimization.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "22d77d6f-e30d-4ac5-b22c-21e4d76ead45", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using probability-based selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Probability-based Selection\" algorithm for black box optimization", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "65e1c8af-3687-42de-b465-1f738209a943", "solution": "import numpy as np\nimport random\nimport time\nimport copy\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n        self.adaptive_probability_history = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n                # Update adaptive probability\n                if i % 10 == 0:  # update every 10 generations\n                    new_adaptive_probability = np.mean([self.adaptive_probability for _ in range(self.population_size)])\n                    if new_adaptive_probability < self.adaptive_probability:\n                        self.adaptive_probability = new_adaptive_probability\n                    else:\n                        self.adaptive_probability = self.adaptive_probability * (1 - self.adaptive_probability)\n                    self.adaptive_probability_history.append(self.adaptive_probability)\n\n                # Update fitness history and best individuals\n                self.fitness_history.append(fitness)\n                self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")\n", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Probability\" algorithm for black box optimization", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "2bb77502-e3a0-45a1-9604-b58846920001", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        # Change individual lines with 0.45 probability\n                        if random.random() < 0.45:\n                            index = np.random.randint(0, self.dim)\n                            parent1, parent2 = random.sample(parents, 2)\n                            child = np.copy(parent1)\n                            child[index] = (parent1[index] + parent2[index]) / 2\n                            offspring.append(child)\n                        else:\n                            offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy\" algorithm for black box optimization with 0.45 probability of changing individual lines.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "e5346a23-2296-4b07-bae3-4899cb09dd0d", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy\" algorithm with adaptive mutation and crossover probabilities for black box optimization.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "cb5f710f-c4d6-4447-b2e0-f076fa5ad0cf", "solution": "import numpy as np\nimport random\n\nclass MultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.45\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Adaptive crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        # Adapt crossover probability based on distance between parents\n                        if np.linalg.norm(parent1 - parent2) > 1.0:\n                            self.crossover_probability += 0.01\n                            if self.crossover_probability > 1.0:\n                                self.crossover_probability = 1.0\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = MultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "MultiObjectiveEvolutionStrategy", "description": "Novel \"Multi-Objective Evolution Strategy with Adaptive Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "e75a8b60-451d-4667-87cf-fc0575746ddc", "solution": "import numpy as np\nimport random\nimport time\n\nclass AdaptiveCrossoverSelection:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.adaptive_crossover = True\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if self.adaptive_crossover:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        # Adaptive crossover\n                        if random.random() < 0.45:\n                            parent1, parent2 = random.sample(parents, 2)\n                            child = (parent1 + parent2) / 2\n                            offspring.append(child)\n                        else:\n                            # Random crossover\n                            parent1, parent2 = random.sample(parents, 2)\n                            child = np.concatenate((parent1[:self.dim//2], parent2[self.dim//2:]))\n                            offspring.append(child)\n\n                    # Mutation\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nac = AdaptiveCrossoverSelection(budget=100, dim=10)\nbest_fitness, best_individual = ac(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "AdaptiveCrossoverSelection", "description": "Novel \"Adaptive Crossover-Selection\" algorithm for black box optimization", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "59483595-5a31-4263-8389-6c4758fc8f20", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.adaptive_crossover_probability = 0.45\n        self.adaptive_mutation_probability = 0.05\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.adaptive_crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        parent_index = random.randint(0, len(parents) - 1)\n                        offspring.append(parents[parent_index])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.adaptive_mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Crossover and Mutation\" for black box optimization.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "15085134-beb8-4b9e-b8aa-0ea6c308c3de", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Update adaptive probability\n                adaptive_probability = np.mean([random.random() for _ in range(self.population_size)])\n                self.crossover_probability = adaptive_probability * 0.9 + 0.1 * self.adaptive_probability\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Probability\" algorithm for black box optimization", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "aa222f4e-2085-46cd-b28e-1d0f23d45895", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.selection_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection with probability adjustment\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    tournament_fitness = np.array([func(population[tournament[j]]) for j in tournament])\n                    tournament_indices = np.argsort(tournament_fitness)[:2]\n                    tournament_parents = [population[tournament_indices[j]] for j in range(2)]\n                    if random.random() < self.selection_probability:\n                        parent1, parent2 = random.sample(tournament_parents, 2)\n                        parents.append((parent1, parent2))\n                    else:\n                        parents.append(tournament_parents[0])\n\n                # Crossover\n                offspring = []\n                for parent1, parent2 in parents:\n                    if random.random() < self.crossover_probability:\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Hybrid Selection and Probability Adjustment\" algorithm for black box optimization.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "be030aed-64b8-4a27-8d87-a717cddd2ae7", "solution": "import numpy as np\nimport random\nimport time\n\nclass MultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.line_search_probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Line search\n                for j in range(self.population_size):\n                    if random.random() < self.line_search_probability:\n                        # Generate a new individual with a probability of 0.5\n                        new_individual = np.random.uniform(-5.0, 5.0, size=self.dim)\n                        new_fitness = func(new_individual)\n                        if new_fitness < fitness[j]:\n                            offspring[j] = new_individual\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = MultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "MultiObjectiveEvolutionStrategy", "description": "Novel \"Multi-Objective Evolution Strategy with Probability-Based Line Search\" algorithm for black box optimization.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "ba586581-58dd-4bd0-aad9-3e15529e621b", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n        self.crossover_probability_history = []\n        self.mutation_probability_history = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Update crossover and mutation probabilities\n                crossover_probability = self.crossover_probability + (self.adaptive_probability - self.crossover_probability) * np.random.uniform(0, 1)\n                mutation_probability = self.mutation_probability + (self.adaptive_probability - self.mutation_probability) * np.random.uniform(0, 1)\n                self.crossover_probability_history.append(crossover_probability)\n                self.mutation_probability_history.append(mutation_probability)\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")\n\n# Plot the adaptive probabilities\nimport matplotlib.pyplot as plt\nplt.plot(es.crossover_probability_history, label='Crossover Probability')\nplt.plot(es.mutation_probability_history, label='Mutation Probability')\nplt.legend()\nplt.show()", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Probability\" for black box optimization.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "47e88b6f-52e9-4c0d-a468-5f4629bfdf90", "solution": "import numpy as np\nimport random\nimport time\n\nclass MultiObjectiveEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Update crossover probability based on fitness\n                self.crossover_probability = self.adaptive_probability * (1 - np.mean(fitness))\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmae = MultiObjectiveEvolutionaryAlgorithm(budget=100, dim=10)\nbest_fitness, best_individual = mae(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "MultiObjectiveEvolutionaryAlgorithm", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Adaptive Probability\" for black box optimization.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "fa4d9726-bb48-41ae-b03c-65e1a4e2d031", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover with probability\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation with probability\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy\" algorithm for black box optimization with probability-based crossover and mutation.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "b2a357a5-615a-48e4-abc5-7760ea50bd68", "solution": "import numpy as np\nimport random\nimport time\nimport functools\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n        self.probability = self.crossover_probability\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Update probability\n                new_probability = self.adaptive_probability + (self.mutation_probability - self.adaptive_probability) * np.random.uniform(0, 1)\n                self.probability = max(0, min(1, new_probability))\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Probabilities\" algorithm for black box optimization.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "77976fef-5fc6-4d5a-b833-b8d20d4ee412", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Probabilistic line search\n                for i in range(self.population_size):\n                    if random.random() < self.probability:\n                        # Generate a new individual by perturbing the current one\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        new_individual = offspring[i] + mutation\n                        # Evaluate fitness for the new individual\n                        new_fitness = func(new_individual)\n                        # Replace the current individual if the new one is better\n                        if new_fitness < fitness[i]:\n                            offspring[i] = new_individual\n                            fitness[i] = new_fitness\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Probabilistic Line Search\" algorithm for black box optimization.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "c17e2d30-e49e-4f39-a620-d112a6529b8d", "solution": "import numpy as np\nimport random\nimport time\n\nclass MultiSwarmEvolutionaryStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Multi-swarm mutation\n                for individual in offspring:\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        individual += mutation\n                        if random.random() < 0.45:\n                            individual *= random.random()\n                            individual = np.clip(individual, -5.0, 5.0)\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = MultiSwarmEvolutionaryStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "MultiSwarmEvolutionaryStrategy", "description": "Novel \"Multi-Swarm Evolutionary Strategy\" algorithm for black box optimization with probability-based individual mutation.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "84387666-1fd0-4732-9870-f1db6a8c5523", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Adaptive crossover probability\n                crossover_prob = self.adaptive_probability\n                if i % 20 == 0:  # update probability every 20 generations\n                    crossover_prob = self.adaptive_probability + (0.05 * np.random.uniform(-0.1, 0.1))\n                crossover_prob = max(0, min(crossover_prob, 1))  # ensure probability is within bounds\n\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < crossover_prob:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Probability\" for black box optimization", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "cc568774-fb70-43a1-92eb-c76e3fb078cd", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover with probabilistic selection\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        parent = parents[np.random.randint(0, len(parents))]\n                        offspring.append(parent)\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Probabilistic Crossover\" for black box optimization.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "b6522260-7db2-494d-a235-748c78f23a25", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.adaptive_crossover_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Adaptive crossover probability\n                new_crossover_probability = self.adaptive_crossover_probability * (1 - (i / self.budget))\n                if new_crossover_probability < 0.1:\n                    new_crossover_probability = 0.1\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < new_crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Crossover Probability\" algorithm for black box optimization.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "07553c77-3049-46dc-9d55-e688faa265d1", "solution": "import numpy as np\nimport random\nimport time\nimport copy\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.45\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = copy.deepcopy(parent1)\n                        for j in range(self.dim):\n                            if random.random() < 0.5:\n                                child[j] += parent2[j] - parent1[j]\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy\" with probability-based crossover and mutation for black box optimization.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "15193e59-3e48-4d86-a91c-6955a1f53282", "solution": "import numpy as np\nimport random\nimport time\nimport inspect\n\nclass MultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.45\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = parent1 + parent2 / 2  # modified crossover\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = ms(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "MultiObjectiveEvolutionStrategy", "description": "Novel \"Multi-Objective Evolutionary Strategy with Probability-based Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "de1708f6-5abb-4a85-b703-b50d9a3c50d2", "solution": "import numpy as np\nimport random\nimport time\n\nclass MultiObjectiveEvolutionaryStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n        self.adaptive_probabilities = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Adapt probability\n                self.adaptive_probabilities.append(np.mean([random.random() for _ in range(self.population_size)]))\n                if np.mean(self.adaptive_probabilities) < self.adaptive_probability:\n                    self.crossover_probability *= 0.9\n                    self.mutation_probability *= 0.9\n                else:\n                    self.crossover_probability *= 0.8\n                    self.mutation_probability *= 0.8\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = MultiObjectiveEvolutionaryStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "MultiObjectiveEvolutionaryStrategy", "description": "Novel \"Multi-Objective Evolutionary Strategy with Adaptive Probabilities\" algorithm for black box optimization.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "bcadb9d4-1a0f-4ab4-943c-1ed020d03d17", "solution": "import numpy as np\nimport random\nimport time\n\nclass AdaptiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.adaptation_rate = 0.45\n        self.adaptation_counter = 0\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Hybrid crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        # Adaptive mutation\n                        if random.random() < self.adaptation_rate:\n                            mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                            child += mutation\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n            # Adaptation\n            if self.adaptation_counter < self.budget * 0.1:\n                self.adaptation_rate += 0.01\n                self.adaptation_counter += 1\n            else:\n                self.adaptation_rate -= 0.01\n                self.adaptation_counter = 0\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\naes = AdaptiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = aes(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "AdaptiveEvolutionStrategy", "description": "Novel \"Adaptive Evolution Strategy with Hybrid Crossover and Mutation\" algorithm for black box optimization.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "d626926b-e264-4b28-afb5-c53717fa92b6", "solution": "import numpy as np\nimport random\nimport time\nimport copy\n\nclass MultiObjectiveEvolutionaryStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.selection_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using probabilistic selection\n                parents = []\n                for _ in range(self.population_size):\n                    if random.random() < self.selection_probability:\n                        tournament = random.sample(range(self.population_size), 3)\n                        parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                    else:\n                        parents.append(population[np.random.randint(0, len(population))])\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = MultiObjectiveEvolutionaryStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "MultiObjectiveEvolutionaryStrategy", "description": "Novel \"Multi-Objective Evolutionary Strategy with Probabilistic Selection\" algorithm for black box optimization.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "bd545b09-e69b-483b-aeaa-255fe2d8ab9f", "solution": "import numpy as np\nimport random\nimport time\n\nclass MultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.45\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = ms(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "MultiObjectiveEvolutionStrategy", "description": "Novel \"Multi-Objective Evolutionary Strategy with Probabilistic Crossover\" for black box optimization.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "e0f2ae62-b69f-41a4-8599-9182b33ef2b4", "solution": "import numpy as np\nimport random\nimport time\n\nclass MultiFidelityEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.fidelity_levels = 5\n        self.fidelity_mapping = np.linspace(0, 1, self.fidelity_levels)\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        # Fidelity-based selection\n        fidelity_scores = np.random.uniform(0, 1, size=self.population_size)\n        fidelity_mapping = np.dsplit(self.fidelity_mapping, self.fidelity_levels)\n        for i in range(self.fidelity_levels):\n            fidelity_mask = (fidelity_scores < fidelity_mapping[i]) & (fidelity_scores >= fidelity_mapping[i+1])\n            fidelity_scores[fidelity_mask] = i\n        population = population[fidelity_scores]\n\n        # Update best individuals\n        self.best_individuals = np.array([np.min(fitness) for fitness in self.fitness_history])\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmfs = MultiFidelityEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = mfs(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "MultiFidelityEvolutionStrategy", "description": "Novel \"Multi-Fidelity Evolution Strategy\" algorithm for black box optimization using multi-fidelity evaluations.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "a6a41ebf-d74a-4059-bdc7-68753f4444ff", "solution": "import numpy as np\nimport random\nimport time\nimport functools\n\nclass MultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Update adaptive probability\n                adaptive_fitness = np.array([func(individual) for individual in offspring])\n                adaptive_fitness = np.sort(adaptive_fitness)\n                self.adaptive_probability = adaptive_fitness[0] / adaptive_fitness[-1]\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = MultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "MultiObjectiveEvolutionStrategy", "description": "Novel \"Multi-Objective Evolution Strategy with Adaptive Probability\" algorithm for black box optimization.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "c5595855-e91b-4e53-9cdc-22defd0d9cb2", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n        self.adaptive_crossover_probability = 0.0\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.adaptive_crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        parent = parents[np.random.randint(0, len(parents))]\n                        child = parent + np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring.append(child)\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n                # Update adaptive crossover probability\n                self.adaptive_crossover_probability = np.mean([func(individual) for individual in offspring]) / np.mean([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Probability\" algorithm for black box optimization.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "fed1fbe6-3378-4f98-8199-e361da15888b", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.line_search_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Probabilistic line search\n                for j in range(self.population_size):\n                    if random.random() < self.line_search_probability:\n                        # Generate a random direction\n                        direction = np.random.uniform(-1.0, 1.0, size=self.dim)\n\n                        # Perform line search\n                        step_size = np.random.uniform(0.1, 0.5)\n                        new_individual = offspring[j] + step_size * direction\n                        fitness[j] = func(new_individual)\n\n                        # Check if new individual is better\n                        if fitness[j] < fitness[np.argmin(fitness)]:\n                            offspring[j] = new_individual\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Probabilistic Line Search\" algorithm for black box optimization.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "ae0107b4-cb3f-40c1-aa6d-7b08e3c713c5", "solution": "import numpy as np\nimport random\nimport time\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.adaptation_rate = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n        self.differential_evolution_population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n        self.hybrid_population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            self.differential_evolution_population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n            self.hybrid_population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in self.differential_evolution_population])\n\n            # Differential evolution\n            for j in range(self.population_size):\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(self.differential_evolution_population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Hybrid mutation\n                for k in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[k] += self.adaptation_rate * mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                self.differential_evolution_population = np.delete(self.differential_evolution_population, np.argmin(fitness), axis=0)\n                self.differential_evolution_population = np.vstack((self.differential_evolution_population, offspring))\n\n                # Update hybrid population\n                self.hybrid_population = np.sort(self.hybrid_population, axis=0)\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in self.differential_evolution_population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nade = AdaptiveDifferentialEvolution(budget=100, dim=10)\nbest_fitness, best_individual = ade(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "AdaptiveDifferentialEvolution", "description": "Novel \"Adaptive Differential Evolution with Hybrid Mutation\" algorithm for black box optimization.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "a3c57ff4-439a-485c-8750-8960645997a3", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using probability-based tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.choices(range(self.population_size), weights=[self.fitness_history[j] for j in range(self.population_size)], k=3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Probability-Based Selection\" algorithm for black box optimization.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "0db5a5ed-9479-485b-887f-12b646e93466", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n        self.crossover_probabilities = [self.adaptive_probability]*self.population_size\n        self.mutation_probabilities = [self.adaptive_probability]*self.population_size\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probabilities[_]:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probabilities[i]:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Probability\" algorithm for black box optimization.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "73909e36-70ac-421b-b8e7-8ff04f1c828f", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.45\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy\" algorithm with adaptive crossover and mutation probabilities", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "e266b3ae-f618-4954-9a4a-b6c492df0e78", "solution": "import numpy as np\nimport random\nimport time\nimport copy\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.adaptive_mutation_probability = 0.45\n        self.adaptive_crossover_probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.adaptive_crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.adaptive_mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy\" algorithm for black box optimization with adaptive mutation probability and crossover probability.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "3d9b7180-1b84-4e12-adbe-66188d3a9cf2", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.adaptive_crossover_probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Adaptive crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.adaptive_crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        # Random crossover\n                        parent1, parent2 = random.sample(parents, 2)\n                        crossover_point = random.randint(0, self.dim - 1)\n                        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                        offspring.append(child)\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "fe02aff4-f787-4d7b-9142-7cdda21559bf", "solution": "import numpy as np\nimport random\nimport time\nimport copy\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Probabilistic crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) * 0.45 + parent1 * 0.55\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Probabilistic Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "d6a9495a-7ef1-4578-9615-5c3c7049e7f2", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.probability_line_crossover = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = self.line_crossover(parent1, parent2)\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n    def line_crossover(self, parent1, parent2):\n        # Generate a random line between two parents\n        line = np.random.uniform(-5.0, 5.0, size=self.dim)\n\n        # Create a new individual by combining the parents along the line\n        child = (parent1 + line) * (1 - self.probability_line_crossover) + (parent2 + line) * self.probability_line_crossover\n\n        return child\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Probabilistic Line Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "df66c679-80aa-470a-a478-fa2d8bb27691", "solution": "import numpy as np\nimport random\nimport time\nimport copy\n\nclass MultiSwarmEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.swarm_size = 10\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize swarms with random points\n            swarms = [np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim)) for _ in range(self.swarm_size)]\n\n            # Evaluate fitness for each swarm\n            fitness = [np.array([func(individual) for individual in swarm]) for swarm in swarms]\n\n            # Multi-swarm evolution\n            for _ in range(100):  # 100 generations\n                # Select swarms using tournament selection\n                swarms = [swarm for _ in range(self.swarm_size)]\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.swarm_size), 3)\n                    swarms[tournament[np.argmin([np.min(individuals) for individuals in swarms[tournament]])]] += [swarm[tournament[np.argmin([np.min(individuals) for individuals in swarms[tournament]])]] for swarm in swarms[tournament]]\n\n                # Crossover\n                for j in range(self.swarm_size):\n                    swarms[j] = [self.crossover(swarms[j][i], swarms[j][i+1]) for i in range(self.population_size-1)]\n\n                # Mutation\n                for j in range(self.swarm_size):\n                    for i in range(self.population_size):\n                        if random.random() < self.mutation_probability:\n                            mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                            swarms[j][i] += mutation\n\n                # Replace worst individual\n                swarms = [np.sort(swarm, axis=0) for swarm in swarms]\n                swarms = [swarm[np.argmin(fitness[j])] for j, swarm in enumerate(swarms)]\n\n                # Evaluate fitness for each individual\n                fitness = [np.array([func(individual) for individual in swarm]) for swarm in swarms]\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin([np.min(individuals) for individuals in swarms]))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min([np.min(individuals) for individuals in swarms]), swarms[np.argmin([np.min(individuals) for individuals in swarms])]\n\n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_probability:\n            child = (parent1 + parent2) / 2\n            return child\n        else:\n            return parent1\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmses = MultiSwarmEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_swarm = mses(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best swarm: {best_swarm}\")", "name": "MultiSwarmEvolutionStrategy", "description": "Novel \"Multi-Swarm Evolution Strategy\" algorithm for black box optimization", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'swarm' is not defined\").", "error": "NameError(\"name 'swarm' is not defined\")", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "ace57e3e-8d82-449d-bb20-bee54daa8bb3", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.probability_line_search = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Probabilistic line search\n                for j in range(self.population_size):\n                    if random.random() < self.probability_line_search:\n                        # Generate a new individual by perturbing the current individual\n                        new_individual = offspring[j] + np.random.uniform(-0.1, 0.1, size=self.dim)\n                        # Evaluate the new individual\n                        new_fitness = func(new_individual)\n                        # If the new individual is better, replace the current individual\n                        if new_fitness < fitness[j]:\n                            offspring[j] = new_individual\n                            fitness[j] = new_fitness\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Probabilistic Line Search\" algorithm for black box optimization.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "deebc715-cd00-42f6-af9d-7f1ac252043d", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.adaptive_probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability + self.adaptive_probability * np.random.uniform(-0.1, 0.1):\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability + self.adaptive_probability * np.random.uniform(-0.1, 0.1):\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Probability\" algorithm for black box optimization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "3b89f56b-49da-4f6f-9892-c5feff6fa844", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Line search\n                line_search = np.array([func(offspring[i] + mutation * self.probability) for i in range(self.population_size)])\n                line_search = np.sort(line_search)\n                best_individual = offspring[np.argmin(line_search)]\n\n                # Replace worst individual\n                offspring = np.delete(offspring, np.argmin(line_search), axis=0)\n                offspring = np.vstack((offspring, best_individual))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in offspring])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Probability-Based Line Search\" algorithm for black box optimization.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "2cbe4b13-63a1-4ade-850b-e782d240edb5", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Probabilistic Line Replacement\n                for j in range(self.dim):\n                    if random.random() < 0.45:\n                        mutation = np.random.uniform(-1.0, 1.0, size=1)\n                        offspring[:, j] += mutation\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Probabilistic Line Replacement\" algorithm for black box optimization", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "366bdce9-bfeb-4c7f-b289-ebedb15c6cca", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.45\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy\" algorithm with probabilistic mutation and crossover.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "68b950b7-4903-4fa5-9a56-be85b5471a07", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.replacement_probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual with a new one with replacement probability\n                if random.random() < self.replacement_probability:\n                    new_individual = np.random.uniform(-5.0, 5.0, size=self.dim)\n                    offspring[i] = new_individual\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Probabilistic Individual Replacement\" algorithm for black box optimization.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "74d6016e-ca92-47ec-b85e-483e932e7ba4", "solution": "import numpy as np\nimport random\nimport time\nimport copy\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Probabilistic mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Probabilistic Mutation\" algorithm for black box optimization.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "e73dd6cd-ecaf-4a01-9b03-029a45e3e533", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.adaptive_probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n                # Update adaptive probability\n                self.adaptive_probability = np.mean([np.min(fitness), np.max(fitness)])\n\n                # Limit adaptive probability\n                self.adaptive_probability = min(max(self.adaptive_probability, 0.0), 1.0)\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Probability\" algorithm for black box optimization", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "5b63049e-d077-4602-9531-081b283c161c", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.adaptive_probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Update crossover probability\n                self.crossover_probability *= self.adaptive_probability\n                if self.crossover_probability < 0.1:\n                    self.crossover_probability = 0.1\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Probability\" algorithm for black box optimization", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "0311a0d9-2deb-4a74-9d9f-99187f0c4a4b", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability * 0.45 + 0.55 * 0.5:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability * 0.45 + 0.55 * 0.1:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Hybrid Probabilities\" algorithm for black box optimization.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "31b7e492-f9c8-4643-acf1-6adf2536b38e", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.45\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover with probabilistic selection\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) * random.random() + (parent1 + parent2) * (1 - random.random())\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Probabilistic Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "633f83a9-9a09-42c0-a11a-ab4eb2a2a862", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover with probabilistic selection\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                    else:\n                        child = parents[np.random.randint(0, len(parents))]\n                    offspring.append(child)\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Probabilistic Crossover\" algorithm for black box optimization", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "c4425e30-9402-4de4-9455-c2c779b14678", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.adaptive_crossover_probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Adaptive crossover probability\n                crossover_probability = self.adaptive_crossover_probability + random.random() * (1 - self.adaptive_crossover_probability)\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Crossover Probability\" algorithm for black box optimization.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "4b2d3fae-4e6a-4c19-96d0-0c89eb2ef7ee", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.line_search_probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Line search\n                if random.random() < self.line_search_probability:\n                    best_individual = np.argmin(fitness)\n                    best_point = population[best_individual]\n                    best_direction = -fitness[best_individual] / np.linalg.norm(fitness - fitness[best_individual])\n                    step_size = 0.1\n                    while True:\n                        new_point = best_point + step_size * best_direction\n                        new_fitness = func(new_point)\n                        if new_fitness < fitness[best_individual]:\n                            best_point = new_point\n                            best_individual = np.argmin(new_fitness)\n                            break\n                        step_size *= 0.9\n                        if step_size < 0.001:\n                            break\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Probability-Based Line Search\" algorithm for black box optimization.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "101365ec-2ce7-4b28-9f60-e7d4e0487f2f", "solution": "import numpy as np\nimport random\n\nclass MultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.45\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Adaptive crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        crossover_point = np.random.uniform(0, self.dim)\n                        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = MultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "MultiObjectiveEvolutionStrategy", "description": "Novel \"Multi-Objective Evolution Strategy with Adaptive Crossover Probability\" algorithm for black box optimization.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "d626fdc2-9017-49f8-9f30-fdf7c6acb75a", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        # Apply probability-based crossover\n                        if random.random() < self.probability:\n                            child = parent1 + np.random.uniform(-1.0, 1.0, size=self.dim)\n                        else:\n                            child = parent2 + np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy\" with probability-based crossover and mutation for black box optimization.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "47843f25-5dd1-4b3b-bedd-dedfa6d083bc", "solution": "import numpy as np\nimport random\nimport time\n\nclass DifferentialEvolutionWithAdaptiveProbability:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n        self.differential_evolution_matrix = np.zeros((self.population_size, self.population_size))\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Differential evolution\n            for j in range(self.population_size):\n                # Select parents using differential evolution\n                parent1 = population[np.random.randint(0, self.population_size)]\n                parent2 = population[np.random.randint(0, self.population_size)]\n                child = (parent1 + self.differential_evolution_matrix[j] * (parent2 - parent1))\n                child = child + np.random.uniform(-1.0, 1.0, size=self.dim)\n\n                # Crossover\n                if random.random() < self.crossover_probability:\n                    child = (child + parent1) / 2\n                else:\n                    child = parent2\n\n                # Mutation\n                if random.random() < self.mutation_probability:\n                    mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                    child += mutation\n\n                # Replace worst individual\n                offspring = np.array([child])\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Update differential evolution matrix\n                self.differential_evolution_matrix[j] = parent2 - parent1\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\ndeap = DifferentialEvolutionWithAdaptiveProbability(budget=100, dim=10)\nbest_fitness, best_individual = deap(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "DifferentialEvolutionWithAdaptiveProbability", "description": "Novel \"Differential Evolution with Adaptive Probability\" algorithm for black box optimization.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (100,) (10,) ').", "error": "ValueError('operands could not be broadcast together with shapes (100,) (10,) ')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "76d2f672-e435-4bd7-ab5c-7b146db553bb", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover with probability-based selection\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        if random.random() < 0.45:\n                            child = (parent1 + parent2) / 2\n                        else:\n                            child = parent1\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation with probability-based selection\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        if random.random() < 0.45:\n                            offspring[i] += mutation\n                        else:\n                            offspring[i] = offspring[i]\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy\" algorithm with probability-based crossover and mutation.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "fe7b687d-373a-4e25-a650-cecdcf758ac2", "solution": "import numpy as np\nimport random\nimport time\n\nclass BlackHoleEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.adaptive_crossover_probability = 0.45\n        self.adaptive_mutation_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n        self.population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            self.population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in self.population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(self.population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.adaptive_crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.adaptive_mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                self.population = np.delete(self.population, np.argmin(fitness), axis=0)\n                self.population = np.vstack((self.population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in self.population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = BlackHoleEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "BlackHoleEvolutionStrategy", "description": "Novel \"Black Hole Evolution Strategy\" algorithm for black box optimization using adaptive mutation and crossover probabilities.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "ccbc8eb0-5491-4ab7-b5aa-ccfcda66550d", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.45\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2 + np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy\" with probabilistic crossover and mutation for black box optimization.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "542bb496-576a-444c-bdf2-6138285acb92", "solution": "import numpy as np\nimport random\nimport time\n\nclass MultiObjectiveEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using probability-based selection\n                parents = []\n                for _ in range(self.population_size):\n                    if random.random() < 0.45:\n                        parents.append(population[np.random.randint(0, self.population_size)])\n                    else:\n                        tournament = random.sample(range(self.population_size), 3)\n                        parents.append(population[tournament[np.argmin(fitness[tournament])]])\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmae = MultiObjectiveEvolutionaryAlgorithm(budget=100, dim=10)\nbest_fitness, best_individual = mae(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "MultiObjectiveEvolutionaryAlgorithm", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Probability-Based Selection and Crossover\" for black box optimization.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "b2345a5e-cc0e-40e0-a922-2be0347a0a72", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.adaptive_probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Update crossover probability based on fitness\n                self.crossover_probability = self.adaptive_probability + (1 - self.adaptive_probability) * (1 - np.mean(fitness))\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Probability\" algorithm for black box optimization.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "c37a363e-0bde-4045-b3aa-bcb291d524e3", "solution": "import numpy as np\nimport random\n\nclass MultiObjectiveEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using probability-based tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.choices(range(self.population_size), weights=[0.45]*self.population_size, k=3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nma = MultiObjectiveEvolutionaryAlgorithm(budget=100, dim=10)\nbest_fitness, best_individual = ma(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "MultiObjectiveEvolutionaryAlgorithm", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Probability-Based Selection and Crossover\" for black box optimization.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "9f1ddec0-fbba-4983-a84f-aa63b25705d2", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.line_search_probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Line search\n                if random.random() < self.line_search_probability:\n                    # Select a random individual\n                    individual = population[np.random.randint(0, self.population_size)]\n                    # Evaluate fitness at the individual's position\n                    fitness_at_individual = func(individual)\n                    # Evaluate fitness at the individual's position with a small perturbation\n                    perturbed_individual = individual + np.random.uniform(-0.1, 0.1, size=self.dim)\n                    fitness_at_perturbed_individual = func(perturbed_individual)\n                    # Choose the better fitness value\n                    if fitness_at_individual < fitness_at_perturbed_individual:\n                        offspring[i] = individual\n                    else:\n                        offspring[i] = perturbed_individual\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Probabilistic Line Search\" algorithm for black box optimization.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "5eede6f7-19f0-4d4b-bd18-5fed98ada5ff", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.adaptive_probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n    def adapt_probabilities(self, fitness):\n        # Adapt crossover and mutation probabilities based on the fitness\n        self.crossover_probability = 0.9 - (fitness / self.budget) * 0.1\n        self.mutation_probability = 0.1 + (fitness / self.budget) * 0.1\n        self.adaptive_probability = 0.45 + (fitness / self.budget) * 0.1\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")\n\n# Adapt probabilities\nfitness = np.min(es.fitness_history)\nes.adapt_probabilities(fitness)", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy\" with adaptive mutation probability and crossover probability.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "60be9452-55f5-4042-b8e1-6d2345e68ec8", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.adaptive_crossover_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.adaptive_crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        # Adaptive crossover probability\n                        if random.random() < 0.5:\n                            parent1, parent2 = random.sample(parents, 2)\n                            child = (parent1 + parent2) / 2\n                            offspring.append(child)\n                        else:\n                            parent1 = parents[np.random.randint(0, len(parents))]\n                            offspring.append(parent1)\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Crossover and Mutation\" algorithm for black box optimization.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "eb6187d5-e534-44ae-a940-6f8899a932f6", "solution": "import numpy as np\nimport random\nimport time\n\nclass MultiObjectiveEvolutionaryAlgorithmWithAdaptiveProbability:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Update adaptive probability\n                adaptive_fitness = np.array([func(individual) for individual in offspring])\n                adaptive_probability = np.mean(adaptive_fitness)\n                self.adaptive_probability = np.clip(self.adaptive_probability + (adaptive_probability - self.adaptive_probability) * 0.1, 0, 1)\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nema = MultiObjectiveEvolutionaryAlgorithmWithAdaptiveProbability(budget=100, dim=10)\nbest_fitness, best_individual = ema(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "MultiObjectiveEvolutionaryAlgorithmWithAdaptiveProbability", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Adaptive Probability\" for black box optimization.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "95249aa0-1750-4e0c-94df-8a2d60d98a33", "solution": "import numpy as np\nimport random\nimport time\n\nclass MultiObjectiveEvolutionaryStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Update crossover probability\n                self.crossover_probability = self.adaptive_probability + (1 - self.adaptive_probability) * np.mean([np.mean([np.mean([np.min([func(offspring[j][k]) for k in range(self.dim)]) for j in range(self.population_size)]) for i in range(self.population_size)])])\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = MultiObjectiveEvolutionaryStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "MultiObjectiveEvolutionaryStrategy", "description": "Novel \"Multi-Objective Evolutionary Strategy with Adaptive Probability\" algorithm for black box optimization.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "694d3bef-3c29-435a-87aa-8459ccde272e", "solution": "import numpy as np\nimport random\nimport time\nimport copy\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Probabilistic line search\n                for _ in range(int(self.population_size * self.probability)):\n                    idx = np.random.randint(0, self.population_size)\n                    new_individual = copy.deepcopy(offspring[idx])\n                    for j in range(self.dim):\n                        step = np.random.uniform(-1.0, 1.0)\n                        new_individual[j] += step\n                        if func(new_individual) < func(offspring[idx][j]):\n                            offspring[idx][j] = new_individual[j]\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Probabilistic Line Search\" algorithm for black box optimization.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "eab73acf-0681-4e58-83fc-c7a71cd5e135", "solution": "import numpy as np\nimport random\nimport time\n\nclass ProbabilisticEvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.selection_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using probabilistic tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    if random.random() < self.selection_probability:\n                        tournament = random.sample(range(self.population_size), 3)\n                        parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                    else:\n                        parents.append(np.random.choice(population, 1)[0])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\npes = ProbabilisticEvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = pes(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "ProbabilisticEvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Probabilistic Evolutionary Multi-Objective Evolution Strategy\" algorithm for black box optimization.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "6ab3bc34-3151-4b2f-897e-6a040e4a03b7", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover with probabilistic selection\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        if random.random() < 0.45:  # 45% chance of changing individual lines\n                            child = (parent1 + parent2) / 2\n                            child = child + np.random.uniform(-1.0, 1.0, size=self.dim)\n                        else:\n                            child = parent1\n                    else:\n                        child = parents[np.random.randint(0, len(parents))]\n\n                    offspring.append(child)\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy\" algorithm with probabilistic crossover and mutation for black box optimization.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "3785bd7b-9808-460f-b468-0c8040c908b3", "solution": "import numpy as np\nimport random\nimport time\nimport copy\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Probabilistic mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        if random.random() < self.probability:\n                            offspring[i] += mutation\n                        else:\n                            offspring[i] -= mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Probabilistic Mutation\" algorithm for black box optimization", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "673c238b-4834-4fe8-9654-20b647fb1e65", "solution": "import numpy as np\nimport random\nimport time\n\nclass MultiObjectiveEvolutionaryOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.adaptive_probability = 0.45\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Update crossover probability based on fitness\n                self.crossover_probability = self.adaptive_probability * (1 - np.mean(fitness))\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nemo = MultiObjectiveEvolutionaryOptimization(budget=100, dim=10)\nbest_fitness, best_individual = emo(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "MultiObjectiveEvolutionaryOptimization", "description": "Novel \"Multi-Objective Evolutionary Optimization with Adaptive Probability\" algorithm for black box optimization.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "9a654cd7-ce6f-4bb6-ba53-af74d08cc43a", "solution": "import numpy as np\nimport random\nimport time\nimport copy\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover with probability-based selection\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        # Select crossover points with probability 0.45\n                        if random.random() < 0.45:\n                            child = child + np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation with probability-based selection\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy\" algorithm with probability-based crossover and mutation for black box optimization.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "c0aaeef3-b1f9-44b6-b919-96a74bc19746", "solution": "import numpy as np\nimport random\nimport time\n\nclass MultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.45\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        # Select parent randomly\n                        parent = parents[np.random.randint(0, len(parents))]\n                        offspring.append(parent)\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = MultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "MultiObjectiveEvolutionStrategy", "description": "Novel \"Multi-Objective Evolution Strategy with Probabilistic Crossover\" for black box optimization.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "c5222597-3358-4e96-ba0b-97685a1bfe25", "solution": "import numpy as np\nimport random\nimport time\n\nclass EvolutionaryMultiObjectiveEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.adaptive_probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability * self.adaptive_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        offspring.append(parents[np.random.randint(0, len(parents))])\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nes = EvolutionaryMultiObjectiveEvolutionStrategy(budget=100, dim=10)\nbest_fitness, best_individual = es(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "EvolutionaryMultiObjectiveEvolutionStrategy", "description": "Novel \"Evolutionary Multi-Objective Evolution Strategy with Adaptive Probability\" algorithm for black box optimization.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
{"id": "07db7071-d749-49b6-b463-d3988820c2d0", "solution": "import numpy as np\nimport random\nimport time\nimport functools\n\nclass MultiObjectiveEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.fitness_history = []\n        self.best_individuals = []\n        self.adaptive_crossover_probability = 0.45\n\n    def __call__(self, func):\n        start_time = time.time()\n        for i in range(self.budget):\n            # Initialize population with random points\n            population = np.random.uniform(-5.0, 5.0, size=(self.population_size, self.dim))\n\n            # Evaluate fitness for each individual\n            fitness = np.array([func(individual) for individual in population])\n\n            # Evolutionary strategy\n            for _ in range(100):  # 100 generations\n                # Select parents using tournament selection\n                parents = []\n                for _ in range(self.population_size):\n                    tournament = random.sample(range(self.population_size), 3)\n                    parents.append(population[tournament[np.argmin(fitness[tournament])]])\n                parents = np.array(parents)\n\n                # Adaptive crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    if random.random() < self.adaptive_crossover_probability:\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = (parent1 + parent2) / 2\n                        offspring.append(child)\n                    else:\n                        # Random crossover\n                        parent1, parent2 = random.sample(parents, 2)\n                        child = np.concatenate((parent1[:self.dim//2], parent2[self.dim//2:]))\n                        offspring.append(child)\n\n                # Mutation\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        offspring[i] += mutation\n\n                # Replace worst individual\n                offspring = np.sort(offspring, axis=0)\n                population = np.delete(population, np.argmin(fitness), axis=0)\n                population = np.vstack((population, offspring))\n\n                # Evaluate fitness for each individual\n                fitness = np.array([func(individual) for individual in population])\n\n            # Update fitness history and best individuals\n            self.fitness_history.append(fitness)\n            self.best_individuals.append(np.argmin(fitness))\n\n        end_time = time.time()\n        print(f\"Optimization time: {end_time - start_time} seconds\")\n        return np.min(self.fitness_history), self.best_individuals[-1]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmae = MultiObjectiveEvolutionaryAlgorithm(budget=100, dim=10)\nbest_fitness, best_individual = mae(func)\nprint(f\"Best fitness: {best_fitness}\")\nprint(f\"Best individual: {best_individual}\")", "name": "MultiObjectiveEvolutionaryAlgorithm", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Adaptive Crossover and Mutation\" for black box optimization.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "ce395854-2484-432f-bbec-2c425f8b7d0a", "metadata": {}, "mutation_prompt": null}
