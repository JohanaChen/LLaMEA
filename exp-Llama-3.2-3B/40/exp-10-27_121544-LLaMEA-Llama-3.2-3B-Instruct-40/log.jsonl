{"id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 32\nSyntaxError: keyword argument repeated: strategy\n.", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 32, 142, None, 32, 158))Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 32\nSyntaxError: keyword argument repeated: strategy\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "87882a9a-e27f-4a4f-a40b-2835de8ea4da", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.probability = 0.4\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        new_individuals = []\n        for _ in range(int(self.budget * self.probability)):\n            individual = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n            new_individuals.append(individual)\n\n        for individual in new_individuals:\n            func(individual)\n\n        updated_individuals = []\n        for individual in new_individuals:\n            # Refine the strategy of the individual with a probability of 0.4\n            if random.random() < self.probability:\n                strategy = random.choice(['sbx', 'rand1', 'log-uniform'])\n                if strategy =='sbx':\n                    cxpb = random.uniform(0.0, 1.0)\n                elif strategy == 'rand1':\n                    cxpb = random.uniform(0.0, 1.0)\n                else:\n                    cxpb = random.uniform(0.0, 1.0)\n                mu = random.uniform(0.0, 1.0)\n                w = random.uniform(0.0, 1.0)\n                if w == 1.0:\n                    scaling = random.choice(['uniform', 'log-uniform'])\n                else:\n                    scaling = 'uniform'\n                if scaling == 'log-uniform':\n                    scaling = 'uniform'\n                updated_individuals.append((individual, cxpb, mu, w, strategy, scaling))\n            else:\n                updated_individuals.append(individual)\n\n        # Evaluate the fitness of the updated individuals\n        fitness_values = []\n        for individual in updated_individuals:\n            func(individual[0])\n            fitness_values.append(individual[1])\n\n        # Select the best individual\n        best_individual = min(updated_individuals, key=lambda x: fitness_values[updated_individuals.index(x)])\n\n        return best_individual[0], fitness_values[updated_individuals.index(best_individual)]\n\n# Example usage:\ndef f1(x):\n    return x[0]**2 + x[1]**2\n\ndef f2(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1])\n\ndef f3(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1]) + 0.01 * x[0]**2 * np.sin(10 * x[0])\n\ndef f4(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1]) + 0.01 * x[0]**2 * np.sin(10 * x[0]) + 0.01 * x[1]**2 * np.cos(10 * x[1])\n\ndef f5(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1]) + 0.01 * x[0]**2 * np.sin(10 * x[0]) + 0.01 * x[1]**2 * np.cos(10 * x[1]) + 0.001 * x[0]**4 * np.sin(10 * x[0])\n\ndef f6(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1]) + 0.01 * x[0]**2 * np.sin(10 * x[0]) + 0.01 * x[1]**2 * np.cos(10 * x[1]) + 0.001 * x[0]**4 * np.sin(10 * x[0]) + 0.001 * x[1]**4 * np.cos(10 * x[1])\n\ndef f7(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1]) + 0.01 * x[0]**2 * np.sin(10 * x[0]) + 0.01 * x[1]**2 * np.cos(10 * x[1]) + 0.001 * x[0]**4 * np.sin(10 * x[0]) + 0.001 * x[1]**4 * np.cos(10 * x[1]) + 0.0001 * x[0]**6 * np.sin(10 * x[0])\n\ndef f8(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1]) + 0.01 * x[0]**2 * np.sin(10 * x[0]) + 0.01 * x[1]**2 * np.cos(10 * x[1]) + 0.001 * x[0]**4 * np.sin(10 * x[0]) + 0.001 * x[1]**4 * np.cos(10 * x[1]) + 0.0001 * x[0]**6 * np.sin(10 * x[0]) + 0.0001 * x[1]**6 * np.cos(10 * x[1])\n\ndef f9(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1]) + 0.01 * x[0]**2 * np.sin(10 * x[0]) + 0.01 * x[1]**2 * np.cos(10 * x[1]) + 0.001 * x[0]**4 * np.sin(10 * x[0]) + 0.001 * x[1]**4 * np.cos(10 * x[1]) + 0.0001 * x[0]**6 * np.sin(10 * x[0]) + 0.0001 * x[1]**6 * np.cos(10 * x[1]) + 0.00001 * x[0]**8 * np.sin(10 * x[0])\n\ndef f10(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1]) + 0.01 * x[0]**2 * np.sin(10 * x[0]) + 0.01 * x[1]**2 * np.cos(10 * x[1]) + 0.001 * x[0]**4 * np.sin(10 * x[0]) + 0.001 * x[1]**4 * np.cos(10 * x[1]) + 0.0001 * x[0]**6 * np.sin(10 * x[0]) + 0.0001 * x[1]**6 * np.cos(10 * x[1]) + 0.00001 * x[0]**8 * np.sin(10 * x[0]) + 0.00001 * x[1]**8 * np.cos(10 * x[1])\n\ndef f11(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1]) + 0.01 * x[0]**2 * np.sin(10 * x[0]) + 0.01 * x[1]**2 * np.cos(10 * x[1]) + 0.001 * x[0]**4 * np.sin(10 * x[0]) + 0.001 * x[1]**4 * np.cos(10 * x[1]) + 0.0001 * x[0]**6 * np.sin(10 * x[0]) + 0.0001 * x[1]**6 * np.cos(10 * x[1]) + 0.00001 * x[0]**8 * np.sin(10 * x[0]) + 0.00001 * x[1]**8 * np.cos(10 * x[1]) + 0.000001 * x[0]**10 * np.sin(10 * x[0])\n\ndef f12(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1]) + 0.01 * x[0]**2 * np.sin(10 * x[0]) + 0.01 * x[1]**2 * np.cos(10 * x[1]) + 0.001 * x[0]**4 * np.sin(10 * x[0]) + 0.001 * x[1]**4 * np.cos(10 * x[1]) + 0.0001 * x[0]**6 * np.sin(10 * x[0]) + 0.0001 * x[1]**6 * np.cos(10 * x[1]) + 0.00001 * x[0]**8 * np.sin(10 * x[0]) + 0.00001 * x[1]**8 * np.cos(10 * x[1]) + 0.000001 * x[0]**10 * np.sin(10 * x[0]) + 0.000001 * x[1]**10 * np.cos(10 * x[1])\n\ndef f13(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1]) + 0.01 * x[0]**2 * np.sin(10 * x[0]) + 0.01 * x[1]**2 * np.cos(10 * x[1]) + 0.001 * x[0]**4 * np.sin(10 * x[0]) + 0.001 * x[1]**4 * np.cos(10 * x[1]) + 0.0001 * x[0]**6 * np.sin(10 * x[0]) + 0.0001 * x[1]**6 * np.cos(10 * x[1]) + 0.00001 * x[0]**8 * np.sin(10 * x[0]) + 0.00001 * x[1]**8 * np.cos(10 * x[1]) + 0.000001 * x[0]**10 * np.sin(10 * x[0]) + 0.000001 * x[1]**10 * np.cos(10 * x[1]) + 0.0000001 * x[0]**12 * np.sin(10 * x[0])\n\ndef f14(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1]) + 0.01 * x[0]**2 * np.sin(10 * x[0]) + 0.01 * x[1]**2 * np.cos(10 * x[1]) + 0.001 * x[0]**4 * np.sin(10 * x[0]) + 0.001 * x[1]**4 * np.cos(10 * x[1]) + 0.0001 * x[0]**6 * np.sin(10 * x[0]) + 0.0001 * x[1]**6 * np.cos(10 * x[1]) + 0.00001 * x[0]**8 * np.sin(10 * x[0]) + 0.00001 * x[1]**8 * np.cos(10 * x[1]) + 0.000001 * x[0]**10 * np.sin(10 * x[0]) + 0.000001 * x[1]**10 * np.cos(10 * x[1]) + 0.0000001 * x[0]**12 * np.sin(10 * x[0]) + 0.0000001 * x[1]**12 * np.cos(10 * x[1])\n\ndef f15(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1]) + 0.01 * x[0]**2 * np.sin(10 * x[0]) + 0.01 * x[1]**2 * np.cos(10 * x[1]) + 0.001 * x[0]**4 * np.sin(10 * x[0]) + 0.001 * x[1]**4 * np.cos(10 * x[1]) + 0.0001 * x[0]**6 * np.sin(10 * x[0]) + 0.0001 * x[1]**6 * np.cos(10 * x[1]) + 0.00001 * x[0]**8 * np.sin(10 * x[0]) + 0.00001 * x[1]**8 * np.cos(10 * x[1]) + 0.000001 * x[0]**10 * np.sin(10 * x[0]) + 0.000001 * x[1]**10 * np.cos(10 * x[1]) + 0.0000001 * x[0]**12 * np.sin(10 * x[0]) + 0.0000001 * x[1]**12 * np.cos(10 * x[1]) + 0.00000001 * x[0]**14 * np.sin(10 * x[0])\n\ndef f16(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1]) + 0.01 * x[0]**2 * np.sin(10 * x[0]) + 0.01 * x[1]**2 * np.cos(10 * x[1]) + 0.001 * x[0]**4 * np.sin(10 * x[0]) + 0.001 * x[1]**4 * np.cos(10 * x[1]) + 0.0001 * x[0]**6 * np.sin(10 * x[0]) + 0.0001 * x[1]**6 * np.cos(10 * x[1]) + 0.00001 * x[0]**8 * np.sin(10 * x[0]) + 0.00001 * x[1]**8 * np.cos(10 * x[1]) + 0.000001 * x[0]**10 * np.sin(10 * x[0]) + 0.000001 * x[1]**10 * np.cos(10 * x[1]) + 0.0000001 * x[0]**12 * np.sin(10 * x[0]) + 0.0000001 * x[1]**12 * np.cos(10 * x[1]) + 0.00000001 * x[0]**14 * np.sin(10 * x[0]) + 0.00000001 * x[1]**14 * np.cos(10 * x[1])\n\ndef f17(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1]) + 0.01 * x[0]**2 * np.sin(10 * x[0]) + 0.01 * x[1]**2 * np.cos(10 * x[1]) + 0.001 * x[0]**4 * np.sin(10 * x[0]) + 0.001 * x[1]**4 * np.cos(10 * x[1]) + 0.0001 * x[0]**6 * np.sin(10 * x[0]) + 0.0001 * x[1]**6 * np.cos(10 * x[1]) + 0.00001 * x[0]**8 * np.sin(10 * x[0]) + 0.00001 * x[1]**8 * np.cos(10 * x[1]) + 0.000001 * x[0]**10 * np.sin(10 * x[0]) + 0.000001 * x[1]**10 * np.cos(10 * x[1]) + 0.0000001 * x[0]**12 * np.sin(10 * x[0]) + 0.0000001 * x[1]**12 * np.cos(10 * x[1]) + 0.00000001 * x[0]**14 * np.sin(10 * x[0]) + 0.00000001 * x[1]**14 * np.cos(10 * x[1]) + 0.000000001 * x[0]**16 * np.sin(10 * x[0])\n\ndef f18(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1]) + 0.01 * x[0]**2 * np.sin(10 * x[0]) + 0.01 * x[1]**2 * np.cos(10 * x[1]) + 0.001 * x[0]**4 * np.sin(10 * x[0]) + 0.001 * x[1]**4 * np.cos(10 * x[1]) + 0.0001 * x[0]**6 * np.sin(10 * x[0]) + 0.0001 * x[1]**6 * np.cos(10 * x[1]) + 0.00001 * x[0]**8 * np.sin(10 * x[0]) + 0.00001 * x[1]**8 * np.cos(10 * x[1]) + 0.000001 * x[0]**10 * np.sin(10 * x[0]) + 0.000001 * x[1]**10 * np.cos(10 * x[1]) + 0.0000001 * x[0]**12 * np.sin(10 * x[0]) + 0.0000001 * x[1]**12 * np.cos(10 * x[1]) + 0.00000001 * x[0]**14 * np.sin(10 * x[0]) + 0.00000001 * x[1]**14 * np.cos(10 * x[1]) + 0.000000001 * x[0]**16 * np.sin(10 * x[0]) + 0.000000001 * x[1]**16 * np.cos(10 * x[1])\n\ndef f19(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1]) + 0.01 * x[0]**2 * np.sin(10 * x[0]) + 0.01 * x[1]**2 * np.cos(10 * x[1]) + 0.001 * x[0]**4 * np.sin(10 * x[0]) + 0.001 * x[1]**4 * np.cos(10 * x[1]) + 0.0001 * x[0]**6 * np.sin(10 * x[0]) + 0.0001 * x[1]**6 * np.cos(10 * x[1]) + 0.00001 * x[0]**8 * np.sin(10 * x[0]) + 0.00001 * x[1]**8 * np.cos(10 * x[1]) + 0.000001 * x[0]**10 * np.sin(10 * x[0]) + 0.000001 * x[1]**10 * np.cos(10 * x[1]) + 0.0000001 * x[0]**12 * np.sin(10 * x[0]) + 0.0000001 * x[1]**12 * np.cos(10 * x[1]) + 0.00000001 * x[0]**14 * np.sin(10 * x[0]) + 0.00000001 * x[1]**14 * np.cos(10 * x[1]) + 0.000000001 * x[0]**16 * np.sin(10 * x[0]) + 0.000000001 * x[1]**16 * np.cos(10 * x[1])\n\ndef f20(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1]) + 0.01 * x[0]**2 * np.sin(10 * x[0]) + 0.01 * x[1]**2 * np.cos(10 * x[1]) + 0.001 * x[0]**4 * np.sin(10 * x[0]) + 0.001 * x[1]**4 * np.cos(10 * x[1]) + 0.0001 * x[0]**6 * np.sin(10 * x[0]) + 0.0001 * x[1]**6 * np.cos(10 * x[1]) + 0.00001 * x[0]**8 * np.sin(10 * x[0]) + 0.00001 * x[1]**8 * np.cos(10 * x[1]) + 0.000001 * x[0]**10 * np.sin(10 * x[0]) + 0.000001 * x[1]**10 * np.cos(10 * x[1]) + 0.0000001 * x[0]**12 * np.sin(10 * x[0]) + 0.0000001 * x[1]**12 * np.cos(10 * x[1]) + 0.00000001 * x[0]**14 * np.sin(10 * x[0]) + 0.00000001 * x[1]**14 * np.cos(10 * x[1]) + 0.000000001 * x[0]**16 * np.sin(10 * x[0]) + 0.000000001 * x[1]**16 * np.cos(10 * x[1])\n\ndef f21(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1]) + 0.01 * x[0]**2 * np.sin(10 * x[0]) + 0.01 * x[1]**2 * np.cos(10 * x[1]) + 0.001 * x[0]**4 * np.sin(10 * x[0]) + 0.001 * x[1]**4 * np.cos(10 * x[1]) + 0.0001 * x[0]**6 * np.sin(10 * x[0]) + 0.0001 * x[1]**6 * np.cos(10 * x[1]) + 0.00001 * x[0]**8 * np.sin(10 * x[0]) + 0.00001 * x[1]**8 * np.cos(10 * x[1]) + 0.000001 * x[0]**10 * np.sin(10 * x[0]) + 0.000001 * x[1]**10 * np.cos(10 * x[1]) + 0.0000001 * x[0]**12 * np.sin(10 * x[0]) + 0.0000001 * x[1]**12 * np.cos(10 * x[1]) + 0.00000001 * x[0]**14 * np.sin(10 * x[0]) + 0.00000001 * x[1]**14 * np.cos(10 * x[1]) + 0.000000001 * x[0]**16 * np.sin(10 * x[0]) + 0.000000001 * x[1]**16 * np.cos(10 * x[1])\n\ndef f22(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1]) + 0.01 * x[0]**2 * np.sin(10 * x[0]) + 0.01 * x[1]**2 * np.cos(10 * x[1]) + 0.001 * x[0]**4 * np.sin(10 * x[0]) + 0.001 * x[1]**4 * np.cos(10 * x[1]) + 0.0001 * x[0]**6 * np.sin(10 * x[0]) + 0.0001 * x[1]**6 * np.cos(10 * x[1]) + 0.00001 * x[0]**8 * np.sin(10 * x[0]) + 0.00001 * x[1]**8 * np.cos(10 * x[1]) + 0.000001 * x[0]**10 * np.sin(10 * x[0]) + 0.000001 * x[1]**10 * np.cos(10 * x[1]) + 0.0000001 * x[0]**12 * np.sin(10 * x[0]) + 0.0000001 * x[1]**12 * np.cos(10 * x[1]) + 0.00000001 * x[0]**14 * np.sin(10 * x[0]) + 0.00000001 * x[1]**14 * np.cos(10 * x[1]) + 0.000000001 * x[0]**16 * np.sin(10 * x[0]) + 0.000000001 * x[1]**16 * np.cos(10 * x[1])\n\ndef f23(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1]) + 0.01 * x[0]**2 * np.sin(10 * x[0]) + 0.01 * x[1]**2 * np.cos(10 * x[1]) + 0.001 * x[0]**4 * np.sin(10 * x[0]) + 0.001 * x[1]**4 * np.cos(10 * x[1]) + 0.0001 * x[0]**6 * np.sin(10 * x[0]) + 0.0001 * x[1]**6 * np.cos(10 * x[1]) + 0.00001 * x[0]**8 * np.sin(10 * x[0]) + 0.00001 * x[1]**8 * np.cos(10 * x[1]) + 0.000001 * x[0]**10 * np.sin(10 * x[0]) + 0.000001 * x[1]**10 * np.cos(10 * x[1]) + 0.0000001 * x[0]**12 * np.sin(10 * x[0]) + 0.0000001 * x[1]**12 * np.cos(10 * x[1]) + 0.00000001 * x[0]**14 * np.sin(10 * x[0]) + 0.00000001 * x[1]**14 * np.cos(10 * x[1]) + 0.000000001 * x[0]**16 * np.sin(10 * x[0])\n\ndef f24(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1]) + 0.01 * x[0]**2 * np.sin(10 * x[0]) + 0.01 * x[1]**2 * np.cos(10 * x[1]) + 0.001 * x[0]**4 * np.sin(10 * x[0]) + 0.001 * x[1]**4 * np.cos(10 * x[1]) + 0.0001 * x[0]**6 * np.sin(10 * x[0]) + 0.0001 * x[1]**6 * np.cos(10 * x[1]) + 0.00001 * x[0]**8 * np.sin(10 * x[0]) + 0.00001 * x[1]**8 * np.cos(10 * x[1]) + 0.000001 * x[0]**10 * np.sin(10 * x[0]) + 0.000001 * x[1]**10 * np.cos(10 * x[1]) + 0.0000001 * x[0]**12 * np.sin(10 * x[0]) + 0.0000001 * x[1]**12 * np.cos(10 * x[1]) + 0.00000001 * x[0]**14 * np.sin(10 * x[0]) + 0.00000001 * x[1]**14 * np.cos(10 * x[1]) + 0.000000001 * x[0]**16 * np.sin(10 * x[0])\n\n# Example usage:\ndef main():\n    algorithm = HybridEvolutionaryAlgorithm(100, 2)\n    def func(x):\n        return x[0]**2 + x[1]**2\n    best_individual, _ = algorithm(func)\n    print(best_individual)\n\nif __name__ == \"__main__\":\n    main()", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization using Probability Refinement", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "47b787a6-f2e1-49f3-926e-a1126d3c5b31", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "a3a496a4-1908-4a18-b619-d6ffefa296b1", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.strategy ='sbx'\n        self.cpb = 0.5\n        self.mu = 0.5\n        self.w = 0.5\n        self.rand1_prob = 0.4\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy)\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def mutate(self, individual):\n        if random.random() < self.rand1_prob:\n            idx = random.randint(0, self.dim-1)\n            individual[idx] += random.uniform(-1, 1)\n            if individual[idx] < self.bounds[idx][0]:\n                individual[idx] = self.bounds[idx][0]\n            elif individual[idx] > self.bounds[idx][1]:\n                individual[idx] = self.bounds[idx][1]\n        return individual\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.rand1_prob:\n                child[i] = parent2[i]\n        return child\n\ndef evaluateBBOB(func, algorithm):\n    if func.__name__ == 'f1':\n        return func(np.array([-5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0]))\n    elif func.__name__ == 'f2':\n        return func(np.array([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]))\n    elif func.__name__ == 'f3':\n        return func(np.array([-5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0]))\n    elif func.__name__ == 'f4':\n        return func(np.array([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]))\n    elif func.__name__ == 'f5':\n        return func(np.array([-5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0]))\n    elif func.__name__ == 'f6':\n        return func(np.array([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]))\n    elif func.__name__ == 'f7':\n        return func(np.array([-5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0]))\n    elif func.__name__ == 'f8':\n        return func(np.array([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]))\n    elif func.__name__ == 'f9':\n        return func(np.array([-5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0]))\n    elif func.__name__ == 'f10':\n        return func(np.array([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]))\n    elif func.__name__ == 'f11':\n        return func(np.array([-5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0]))\n    elif func.__name__ == 'f12':\n        return func(np.array([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]))\n    elif func.__name__ == 'f13':\n        return func(np.array([-5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0]))\n    elif func.__name__ == 'f14':\n        return func(np.array([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]))\n    elif func.__name__ == 'f15':\n        return func(np.array([-5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0]))\n    elif func.__name__ == 'f16':\n        return func(np.array([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]))\n    elif func.__name__ == 'f17':\n        return func(np.array([-5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0]))\n    elif func.__name__ == 'f18':\n        return func(np.array([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]))\n    elif func.__name__ == 'f19':\n        return func(np.array([-5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0]))\n    elif func.__name__ == 'f20':\n        return func(np.array([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]))\n    elif func.__name__ == 'f21':\n        return func(np.array([-5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0]))\n    elif func.__name__ == 'f22':\n        return func(np.array([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]))\n    elif func.__name__ == 'f23':\n        return func(np.array([-5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0, -5.0]))\n    elif func.__name__ == 'f24':\n        return func(np.array([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]))\n\n# Usage:\nalgorithm = HybridEvolutionaryAlgorithm(100, 10)\nbest_individual = algorithm(heavycost)\n\n# Update the best individual in the population\ndef update_best_individual(individual):\n    if individual < best_individual:\n        best_individual = individual\n    return best_individual\n\n# Update the population\ndef update_population(population, algorithm, func):\n    new_population = []\n    for individual in population:\n        new_individual = algorithm(individual, func)\n        new_individual = update_best_individual(new_individual)\n        new_population.append(new_individual)\n    return new_population\n\n# Main loop\ndef main():\n    population = [np.random.uniform(-5.0, 5.0, 10) for _ in range(100)]\n    for i in range(100):\n        population = update_population(population, algorithm, evaluateBBOB)\n        print(f\"Iteration {i+1}: Best individual = {best_individual}\")\n\nif __name__ == \"__main__\":\n    main()", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 38, 162, None, 38, 178)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 38, 162, None, 38, 178))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "916cf467-59e6-4ef9-9892-22617116f2c8", "solution": "import numpy as np\nimport random\nimport code\nimport operator\n\nclass AdaptiveHEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.population = [self.x0]\n        self.fitnesses = [self.f(self.x0)]\n        self.strategies = [0.5]\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return self.adaptive_differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return self.adaptive_differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return self.adaptive_differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return self.adaptive_differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return self.adaptive_differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return self.adaptive_differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return self.adaptive_differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return self.adaptive_differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return self.adaptive_differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return self.adaptive_differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return self.adaptive_differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return self.adaptive_differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return self.adaptive_differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return self.adaptive_differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return self.adaptive_differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return self.adaptive_differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return self.adaptive_differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return self.adaptive_differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return self.adaptive_differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return self.adaptive_differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return self.adaptive_differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return self.adaptive_differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return self.adaptive_differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return self.adaptive_differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def adaptive_differential_evolution(self, func, bounds, x0=None, tol=1e-5, x0_init=None, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform'):\n        if x0 is None:\n            x0 = np.random.uniform(bounds[0][0], bounds[0][1], self.dim)\n        if x0_init is not None:\n            x0 = x0_init\n\n        population = [x0]\n        fitnesses = [self.f(func, x0)]\n\n        for _ in range(self.budget - 1):\n            new_individuals = []\n            new_fitnesses = []\n            for individual in population:\n                for _ in range(int(cxpb * len(population))):\n                    new_individual = individual + np.random.uniform(-1, 1, self.dim)\n                    new_individual = [min(max(i, bounds[i][0]), bounds[i][1]) for i in range(self.dim)]\n                    new_individuals.append(new_individual)\n                    new_fitness = self.f(func, new_individual)\n                    new_fitnesses.append(new_fitness)\n\n            population = population + new_individuals\n            fitnesses = fitnesses + new_fitnesses\n\n            # Adaptive strategy selection\n            strategies = [0.4, 0.3, 0.3]\n            strategy_idx = np.random.choice(len(strategies), p=strategies)\n            strategy = strategies[strategy_idx]\n\n            # Adaptive mutation\n            for i in range(len(population)):\n                if np.random.rand() < strategy:\n                    mutation = np.random.uniform(-1, 1, self.dim)\n                    population[i] = [min(max(i, bounds[i][0]), bounds[i][1]) for i in range(self.dim)]\n\n        # Select the best individual\n        best_individual = min(population, key=self.f)\n        best_fitness = self.f(func, best_individual)\n\n        return best_individual, best_fitness\n\n    def f(self, func, x):\n        return func(x)\n\n# Usage\nif __name__ == \"__main__\":\n    bbb = AdaptiveHEACOMBBO(budget=100, dim=10)\n    for func_name in ['f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'f11', 'f12', 'f13', 'f14', 'f15', 'f16', 'f17', 'f18', 'f19', 'f20', 'f21', 'f22', 'f23', 'f24']:\n        func = globals()[func_name]\n        result = bbb(func)\n        print(f\"Function: {func_name}, Result: {result}\")", "name": "AdaptiveHEACOMBBO", "description": "Novel Hybrid Evolutionary Algorithm with Adaptive Mutation for Black Box Optimization", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError(\"duplicate argument 'strategy' in function definition\").", "error": "SyntaxError(\"duplicate argument 'strategy' in function definition\")", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "73a689f9-0fb7-4bbd-b231-257cee477cf4", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "54a7abcc-562b-4227-94b2-c199e9baf585", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.logger = []\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def evaluate_fitness(self, individual):\n        if individual is None:\n            raise ValueError(\"Individual cannot be None\")\n        if not isinstance(individual, dict):\n            raise ValueError(\"Individual must be a dictionary\")\n        if not all(key in individual for key in self.logger):\n            raise ValueError(\"Individual dictionary must contain all keys in the logger\")\n        for key in individual:\n            if key not in self.logger:\n                raise ValueError(\"Individual dictionary must contain all keys in the logger\")\n            if not isinstance(individual[key], str):\n                raise ValueError(\"Individual values must be strings\")\n            if individual[key] not in self.logger[key]:\n                raise ValueError(\"Individual values must be in the logger\")\n        return individual\n\n    def refine_strategy(self, individual):\n        for key in individual:\n            if individual[key] =='sbx':\n                individual[key] = random.choice(['sbx', 'rand1', 'uniform', 'log-uniform'])\n            elif individual[key] == 'rand1':\n                individual[key] = random.choice(['sbx', 'rand1', 'uniform', 'log-uniform'])\n            elif individual[key] == 'uniform':\n                individual[key] = random.choice(['sbx', 'rand1', 'uniform', 'log-uniform'])\n            elif individual[key] == 'log-uniform':\n                individual[key] = random.choice(['sbx', 'rand1', 'uniform', 'log-uniform'])\n\n# Usage:\nif __name__ == \"__main__\":\n    bbo = HEACOMBBO(budget=10, dim=10)\n    f1 = lambda x: x[0]**2 + 2*x[1]**2\n    print(bbo(f1))", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) with probabilistic strategy refinement", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 34, 142, None, 34, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 34, 142, None, 34, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "b4b70f27-418c-4cb7-b819-9874e89fcdd2", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.crossover_probability = 0.4\n        self.mutation_probability = 0.1\n        self.adaptive_strategy = True\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        population = [np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim) for _ in range(100)]\n\n        for _ in range(self.budget):\n            fitness = [func(individual) for individual in population]\n            best_individual = np.argmin(fitness)\n            best_individual = population[best_individual]\n\n            if random.random() < self.crossover_probability:\n                parent1, parent2 = random.sample(population, 2)\n                child1 = self.crossover(parent1, parent2)\n                child2 = self.crossover(parent2, parent1)\n                population.append(child1)\n                population.append(child2)\n\n            if random.random() < self.mutation_probability:\n                if self.adaptive_strategy:\n                    if random.random() < 0.5:\n                        mutation = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n                    else:\n                        mutation = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n                else:\n                    mutation = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n                population.append(best_individual + mutation)\n\n            population.sort(key=lambda individual: func(individual))\n\n        return np.min([func(individual) for individual in population]), np.min([func(individual) for individual in population])\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if random.random() < self.crossover_probability:\n                if random.random() < 0.5:\n                    child.append(parent1[i])\n                else:\n                    child.append(parent2[i])\n            else:\n                child.append(random.choice([parent1[i], parent2[i]]))\n        return child\n\n# Usage\nfunc = lambda x: x[0]**2 + x[1]**2\nalgorithm = HybridEvolutionaryAlgorithm(100, 2)\nresult = algorithm(func)\nprint(result)", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm with Adaptive Crossover and Mutation for Black Box Optimization", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "25a9ca6a-8b7b-475c-af2d-5d64df6b0610", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "ec962551-2f5e-41c1-9b80-988919305726", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "b888f2ec-2a71-4c80-aba7-c353604217f6", "solution": "import numpy as np\nimport random\nimport string\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.population_size = 100\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.8\n        self.random_search_rate = 0.2\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        # Initialize population\n        population = [np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim) for _ in range(self.population_size)]\n\n        # Evaluate population\n        fitnesses = []\n        for individual in population:\n            fitnesses.append(func(individual))\n\n        # Select parents\n        parents = []\n        for _ in range(self.population_size):\n            parent_index = np.random.choice(self.population_size)\n            parents.append(population[parent_index])\n\n        # Crossover\n        offspring = []\n        for _ in range(self.population_size):\n            parent1, parent2 = random.sample(parents, 2)\n            child = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n            for i in range(self.dim):\n                if random.random() < self.crossover_rate:\n                    child[i] = (parent1[i] + parent2[i]) / 2\n            offspring.append(child)\n\n        # Mutation\n        for individual in offspring:\n            if random.random() < self.mutation_rate:\n                mutation = np.random.uniform(-1, 1, self.dim)\n                individual += mutation\n\n        # Random search\n        for _ in range(int(self.budget * self.random_search_rate)):\n            new_individual = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n            fitness = func(new_individual)\n            if fitness < np.min(fitnesses):\n                population[fitnesses.index(np.min(fitnesses))] = new_individual\n                fitnesses.append(fitness)\n\n        # Evaluate new population\n        new_fitnesses = []\n        for individual in population:\n            new_fitnesses.append(func(individual))\n\n        # Replace worst individual\n        worst_index = np.argmin(new_fitnesses)\n        population[worst_index] = offspring[np.random.choice(len(offspring))]\n\n        # Return best individual\n        return np.min(population), population[np.argmin(new_fitnesses)]\n\n# Usage\ndef f1(x):\n    return x[0]**2 + x[1]**2\n\ndef f2(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.sin(10 * x[1])\n\ndef f3(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.sin(10 * x[1]) + 0.01 * np.sin(100 * x[0]) + 0.01 * np.sin(100 * x[1])\n\ndef f4(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.sin(10 * x[1]) + 0.01 * np.sin(100 * x[0]) + 0.01 * np.sin(100 * x[1]) + 0.001 * np.sin(1000 * x[0]) + 0.001 * np.sin(1000 * x[1])\n\ndef f5(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.sin(10 * x[1]) + 0.01 * np.sin(100 * x[0]) + 0.01 * np.sin(100 * x[1]) + 0.001 * np.sin(1000 * x[0]) + 0.001 * np.sin(1000 * x[1]) + 0.0001 * np.sin(10000 * x[0]) + 0.0001 * np.sin(10000 * x[1])\n\ndef f6(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.sin(10 * x[1]) + 0.01 * np.sin(100 * x[0]) + 0.01 * np.sin(100 * x[1]) + 0.001 * np.sin(1000 * x[0]) + 0.001 * np.sin(1000 * x[1]) + 0.0001 * np.sin(10000 * x[0]) + 0.0001 * np.sin(10000 * x[1]) + 0.00001 * np.sin(100000 * x[0]) + 0.00001 * np.sin(100000 * x[1])\n\ndef f7(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.sin(10 * x[1]) + 0.01 * np.sin(100 * x[0]) + 0.01 * np.sin(100 * x[1]) + 0.001 * np.sin(1000 * x[0]) + 0.001 * np.sin(1000 * x[1]) + 0.0001 * np.sin(10000 * x[0]) + 0.0001 * np.sin(10000 * x[1]) + 0.00001 * np.sin(100000 * x[0]) + 0.00001 * np.sin(100000 * x[1]) + 0.000001 * np.sin(1000000 * x[0]) + 0.000001 * np.sin(1000000 * x[1])\n\ndef f8(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.sin(10 * x[1]) + 0.01 * np.sin(100 * x[0]) + 0.01 * np.sin(100 * x[1]) + 0.001 * np.sin(1000 * x[0]) + 0.001 * np.sin(1000 * x[1]) + 0.0001 * np.sin(10000 * x[0]) + 0.0001 * np.sin(10000 * x[1]) + 0.00001 * np.sin(100000 * x[0]) + 0.00001 * np.sin(100000 * x[1]) + 0.000001 * np.sin(1000000 * x[0]) + 0.000001 * np.sin(1000000 * x[1]) + 0.0000001 * np.sin(10000000 * x[0]) + 0.0000001 * np.sin(10000000 * x[1])\n\ndef f9(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.sin(10 * x[1]) + 0.01 * np.sin(100 * x[0]) + 0.01 * np.sin(100 * x[1]) + 0.001 * np.sin(1000 * x[0]) + 0.001 * np.sin(1000 * x[1]) + 0.0001 * np.sin(10000 * x[0]) + 0.0001 * np.sin(10000 * x[1]) + 0.00001 * np.sin(100000 * x[0]) + 0.00001 * np.sin(100000 * x[1]) + 0.000001 * np.sin(1000000 * x[0]) + 0.000001 * np.sin(1000000 * x[1]) + 0.0000001 * np.sin(10000000 * x[0]) + 0.0000001 * np.sin(10000000 * x[1]) + 0.00000001 * np.sin(100000000 * x[0]) + 0.00000001 * np.sin(100000000 * x[1])\n\ndef f10(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.sin(10 * x[1]) + 0.01 * np.sin(100 * x[0]) + 0.01 * np.sin(100 * x[1]) + 0.001 * np.sin(1000 * x[0]) + 0.001 * np.sin(1000 * x[1]) + 0.0001 * np.sin(10000 * x[0]) + 0.0001 * np.sin(10000 * x[1]) + 0.00001 * np.sin(100000 * x[0]) + 0.00001 * np.sin(100000 * x[1]) + 0.000001 * np.sin(1000000 * x[0]) + 0.000001 * np.sin(1000000 * x[1]) + 0.0000001 * np.sin(10000000 * x[0]) + 0.0000001 * np.sin(10000000 * x[1]) + 0.00000001 * np.sin(100000000 * x[0]) + 0.00000001 * np.sin(100000000 * x[1]) + 0.000000001 * np.sin(1000000000 * x[0]) + 0.000000001 * np.sin(1000000000 * x[1])\n\ndef f11(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.sin(10 * x[1]) + 0.01 * np.sin(100 * x[0]) + 0.01 * np.sin(100 * x[1]) + 0.001 * np.sin(1000 * x[0]) + 0.001 * np.sin(1000 * x[1]) + 0.0001 * np.sin(10000 * x[0]) + 0.0001 * np.sin(10000 * x[1]) + 0.00001 * np.sin(100000 * x[0]) + 0.00001 * np.sin(100000 * x[1]) + 0.000001 * np.sin(1000000 * x[0]) + 0.000001 * np.sin(1000000 * x[1]) + 0.0000001 * np.sin(10000000 * x[0]) + 0.0000001 * np.sin(10000000 * x[1]) + 0.00000001 * np.sin(100000000 * x[0]) + 0.00000001 * np.sin(100000000 * x[1]) + 0.000000001 * np.sin(1000000000 * x[0]) + 0.000000001 * np.sin(1000000000 * x[1]) + 0.0000000001 * np.sin(10000000000 * x[0]) + 0.0000000001 * np.sin(10000000000 * x[1])\n\ndef f12(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.sin(10 * x[1]) + 0.01 * np.sin(100 * x[0]) + 0.01 * np.sin(100 * x[1]) + 0.001 * np.sin(1000 * x[0]) + 0.001 * np.sin(1000 * x[1]) + 0.0001 * np.sin(10000 * x[0]) + 0.0001 * np.sin(10000 * x[1]) + 0.00001 * np.sin(100000 * x[0]) + 0.00001 * np.sin(100000 * x[1]) + 0.000001 * np.sin(1000000 * x[0]) + 0.000001 * np.sin(1000000 * x[1]) + 0.0000001 * np.sin(10000000 * x[0]) + 0.0000001 * np.sin(10000000 * x[1]) + 0.00000001 * np.sin(100000000 * x[0]) + 0.00000001 * np.sin(100000000 * x[1]) + 0.000000001 * np.sin(1000000000 * x[0]) + 0.000000001 * np.sin(1000000000 * x[1]) + 0.0000000001 * np.sin(10000000000 * x[0]) + 0.0000000001 * np.sin(10000000000 * x[1]) + 0.00000000001 * np.sin(100000000000 * x[0]) + 0.00000000001 * np.sin(100000000000 * x[1])\n\ndef f13(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.sin(10 * x[1]) + 0.01 * np.sin(100 * x[0]) + 0.01 * np.sin(100 * x[1]) + 0.001 * np.sin(1000 * x[0]) + 0.001 * np.sin(1000 * x[1]) + 0.0001 * np.sin(10000 * x[0]) + 0.0001 * np.sin(10000 * x[1]) + 0.00001 * np.sin(100000 * x[0]) + 0.00001 * np.sin(100000 * x[1]) + 0.000001 * np.sin(1000000 * x[0]) + 0.000001 * np.sin(1000000 * x[1]) + 0.0000001 * np.sin(10000000 * x[0]) + 0.0000001 * np.sin(10000000 * x[1]) + 0.00000001 * np.sin(100000000 * x[0]) + 0.00000001 * np.sin(100000000 * x[1]) + 0.000000001 * np.sin(1000000000 * x[0]) + 0.000000001 * np.sin(1000000000 * x[1]) + 0.0000000001 * np.sin(10000000000 * x[0]) + 0.0000000001 * np.sin(10000000000 * x[1]) + 0.00000000001 * np.sin(100000000000 * x[0]) + 0.00000000001 * np.sin(100000000000 * x[1])\n\ndef f14(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.sin(10 * x[1]) + 0.01 * np.sin(100 * x[0]) + 0.01 * np.sin(100 * x[1]) + 0.001 * np.sin(1000 * x[0]) + 0.001 * np.sin(1000 * x[1]) + 0.0001 * np.sin(10000 * x[0]) + 0.0001 * np.sin(10000 * x[1]) + 0.00001 * np.sin(100000 * x[0]) + 0.00001 * np.sin(100000 * x[1]) + 0.000001 * np.sin(1000000 * x[0]) + 0.000001 * np.sin(1000000 * x[1]) + 0.0000001 * np.sin(10000000 * x[0]) + 0.0000001 * np.sin(10000000 * x[1]) + 0.00000001 * np.sin(100000000 * x[0]) + 0.00000001 * np.sin(100000000 * x[1]) + 0.000000001 * np.sin(1000000000 * x[0]) + 0.000000001 * np.sin(1000000000 * x[1]) + 0.0000000001 * np.sin(10000000000 * x[0]) + 0.0000000001 * np.sin(10000000000 * x[1]) + 0.00000000001 * np.sin(100000000000 * x[0]) + 0.00000000001 * np.sin(100000000000 * x[1])\n\ndef f15(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.sin(10 * x[1]) + 0.01 * np.sin(100 * x[0]) + 0.01 * np.sin(100 * x[1]) + 0.001 * np.sin(1000 * x[0]) + 0.001 * np.sin(1000 * x[1]) + 0.0001 * np.sin(10000 * x[0]) + 0.0001 * np.sin(10000 * x[1]) + 0.00001 * np.sin(100000 * x[0]) + 0.00001 * np.sin(100000 * x[1]) + 0.000001 * np.sin(1000000 * x[0]) + 0.000001 * np.sin(1000000 * x[1]) + 0.0000001 * np.sin(10000000 * x[0]) + 0.0000001 * np.sin(10000000 * x[1]) + 0.00000001 * np.sin(100000000 * x[0]) + 0.00000001 * np.sin(100000000 * x[1]) + 0.000000001 * np.sin(1000000000 * x[0]) + 0.000000001 * np.sin(1000000000 * x[1]) + 0.0000000001 * np.sin(10000000000 * x[0]) + 0.0000000001 * np.sin(10000000000 * x[1]) + 0.00000000001 * np.sin(100000000000 * x[0]) + 0.00000000001 * np.sin(100000000000 * x[1])\n\ndef f16(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.sin(10 * x[1]) + 0.01 * np.sin(100 * x[0]) + 0.01 * np.sin(100 * x[1]) + 0.001 * np.sin(1000 * x[0]) + 0.001 * np.sin(1000 * x[1]) + 0.0001 * np.sin(10000 * x[0]) + 0.0001 * np.sin(10000 * x[1]) + 0.00001 * np.sin(100000 * x[0]) + 0.00001 * np.sin(100000 * x[1]) + 0.000001 * np.sin(1000000 * x[0]) + 0.000001 * np.sin(1000000 * x[1]) + 0.0000001 * np.sin(10000000 * x[0]) + 0.0000001 * np.sin(10000000 * x[1]) + 0.00000001 * np.sin(100000000 * x[0]) + 0.00000001 * np.sin(100000000 * x[1]) + 0.000000001 * np.sin(1000000000 * x[0]) + 0.000000001 * np.sin(1000000000 * x[1]) + 0.0000000001 * np.sin(10000000000 * x[0]) + 0.0000000001 * np.sin(10000000000 * x[1]) + 0.00000000001 * np.sin(100000000000 * x[0]) + 0.00000000001 * np.sin(100000000000 * x[1])\n\ndef f17(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.sin(10 * x[1]) + 0.01 * np.sin(100 * x[0]) + 0.01 * np.sin(100 * x[1]) + 0.001 * np.sin(1000 * x[0]) + 0.001 * np.sin(1000 * x[1]) + 0.0001 * np.sin(10000 * x[0]) + 0.0001 * np.sin(10000 * x[1]) + 0.00001 * np.sin(100000 * x[0]) + 0.00001 * np.sin(100000 * x[1]) + 0.000001 * np.sin(1000000 * x[0]) + 0.000001 * np.sin(1000000 * x[1]) + 0.0000001 * np.sin(10000000 * x[0]) + 0.0000001 * np.sin(10000000 * x[1]) + 0.00000001 * np.sin(100000000 * x[0]) + 0.00000001 * np.sin(100000000 * x[1]) + 0.000000001 * np.sin(1000000000 * x[0]) + 0.000000001 * np.sin(1000000000 * x[1]) + 0.0000000001 * np.sin(10000000000 * x[0]) + 0.0000000001 * np.sin(10000000000 * x[1]) + 0.00000000001 * np.sin(100000000000 * x[0]) + 0.00000000001 * np.sin(100000000000 * x[1])\n\ndef f18(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.sin(10 * x[1]) + 0.01 * np.sin(100 * x[0]) + 0.01 * np.sin(100 * x[1]) + 0.001 * np.sin(1000 * x[0]) + 0.001 * np.sin(1000 * x[1]) + 0.0001 * np.sin(10000 * x[0]) + 0.0001 * np.sin(10000 * x[1]) + 0.00001 * np.sin(100000 * x[0]) + 0.00001 * np.sin(100000 * x[1]) + 0.000001 * np.sin(1000000 * x[0]) + 0.000001 * np.sin(1000000 * x[1]) + 0.0000001 * np.sin(10000000 * x[0]) + 0.0000001 * np.sin(10000000 * x[1]) + 0.00000001 * np.sin(100000000 * x[0]) + 0.00000001 * np.sin(100000000 * x[1]) + 0.000000001 * np.sin(1000000000 * x[0]) + 0.000000001 * np.sin(1000000000 * x[1]) + 0.0000000001 * np.sin(10000000000 * x[0]) + 0.0000000001 * np.sin(10000000000 * x[1]) + 0.00000000001 * np.sin(100000000000 * x[0]) + 0.00000000001 * np.sin(100000000000 * x[1])\n\ndef f19(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.sin(10 * x[1]) + 0.01 * np.sin(100 * x[0]) + 0.01 * np.sin(100 * x[1]) + 0.001 * np.sin(1000 * x[0]) + 0.001 * np.sin(1000 * x[1]) + 0.0001 * np.sin(10000 * x[0]) + 0.0001 * np.sin(10000 * x[1]) + 0.00001 * np.sin(100000 * x[0]) + 0.00001 * np.sin(100000 * x[1]) + 0.000001 * np.sin(1000000 * x[0]) + 0.000001 * np.sin(1000000 * x[1]) + 0.0000001 * np.sin(10000000 * x[0]) + 0.0000001 * np.sin(10000000 * x[1]) + 0.00000001 * np.sin(100000000 * x[0]) + 0.00000001 * np.sin(100000000 * x[1]) + 0.000000001 * np.sin(1000000000 * x[0]) + 0.000000001 * np.sin(1000000000 * x[1]) + 0.0000000001 * np.sin(10000000000 * x[0]) + 0.0000000001 * np.sin(10000000000 * x[1]) + 0.00000000001 * np.sin(100000000000 * x[0]) + 0.00000000001 * np.sin(100000000000 * x[1])\n\ndef f20(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.sin(10 * x[1]) + 0.01 * np.sin(100 * x[0]) + 0.01 * np.sin(100 * x[1]) + 0.001 * np.sin(1000 * x[0]) + 0.001 * np.sin(1000 * x[1]) + 0.0001 * np.sin(10000 * x[0]) + 0.0001 * np.sin(10000 * x[1]) + 0.00001 * np.sin(100000 * x[0]) + 0.00001 * np.sin(100000 * x[1]) + 0.000001 * np.sin(1000000 * x[0]) + 0.000001 * np.sin(1000000 * x[1]) + 0.0000001 * np.sin(10000000 * x[0]) + 0.0000001 * np.sin(10000000 * x[1]) + 0.00000001 * np.sin(100000000 * x[0]) + 0.00000001 * np.sin(100000000 * x[1]) + 0.000000001 * np.sin(1000000000 * x[0]) + 0.000000001 * np.sin(1000000000 * x[1]) + 0.0000000001 * np.sin(10000000000 * x[0]) + 0.0000000001 * np.sin(10000000000 * x[1]) + 0.00000000001 * np.sin(100000000000 * x[0]) + 0.00000000001 * np.sin(100000000000 * x[1])\n\ndef f21(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.sin(10 * x[1]) + 0.01 * np.sin(100 * x[0]) + 0.01 * np.sin(100 * x[1]) + 0.001 * np.sin(1000 * x[0]) + 0.001 * np.sin(1000 * x[1]) + 0.0001 * np.sin(10000 * x[0]) + 0.0001 * np.sin(10000 * x[1]) + 0.00001 * np.sin(100000 * x[0]) + 0.00001 * np.sin(100000 * x[1]) + 0.000001 * np.sin(1000000 * x[0]) + 0.000001 * np.sin(1000000 * x[1]) + 0.0000001 * np.sin(10000000 * x[0]) + 0.0000001 * np.sin(10000000 * x[1]) + 0.00000001 * np.sin(100000000 * x[0]) + 0.00000001 * np.sin(100000000 * x[1]) + 0.000000001 * np.sin(1000000000 * x[0]) + 0.000000001 * np.sin(1000000000 * x[1]) + 0.0000000001 * np.sin(10000000000 * x[0]) + 0.0000000001 * np.sin(10000000000 * x[1]) + 0.00000000001 * np.sin(100000000000 * x[0]) + 0.00000000001 * np.sin(100000000000 * x[1])\n\ndef f22(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.sin(10 * x[1]) + 0.01 * np.sin(100 * x[0]) + 0.01 * np.sin(100 * x[1]) + 0.001 * np.sin(1000 * x[0]) + 0.001 * np.sin(1000 * x[1]) + 0.0001 * np.sin(10000 * x[0]) + 0.0001 * np.sin(10000 * x[1]) + 0.00001 * np.sin(100000 * x[0]) + 0.00001 * np.sin(100000 * x[1]) + 0.000001 * np.sin(1000000 * x[0]) + 0.000001 * np.sin(1000000 * x[1]) + 0.0000001 * np.sin(10000000 * x[0]) + 0.0000001 * np.sin(10000000 * x[1]) + 0.00000001 * np.sin(100000000 * x[0]) + 0.00000001 * np.sin(100000000 * x[1]) + 0.000000001 * np.sin(1000000000 * x[0]) + 0.000000001 * np.sin(1000000000 * x[1]) + 0.0000000001 * np.sin(10000000000 * x[0]) + 0.0000000001 * np.sin(10000000000 * x[1]) + 0.00000000001 * np.sin(100000000000 * x[0]) + 0.00000000001 * np.sin(100000000000 * x[1])\n\ndef f23(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.sin(10 * x[1]) + 0.01 * np.sin(100 * x[0]) + 0.01 * np.sin(100 * x[1]) + 0.001 * np.sin(1000 * x[0]) + 0.001 * np.sin(1000 * x[1]) + 0.0001 * np.sin(10000 * x[0]) + 0.0001 * np.sin(10000 * x[1]) + 0.00001 * np.sin(100000 * x[0]) + 0.00001 * np.sin(100000 * x[1]) + 0.000001 * np.sin(1000000 * x[0]) + 0.000001 * np.sin(1000000 * x[1]) + 0.0000001 * np.sin(10000000 * x[0]) + 0.0000001 * np.sin(10000000 * x[1]) + 0.00000001 * np.sin(100000000 * x[0]) + 0.00000001 * np.sin(100000000 * x[1]) + 0.000000001 * np.sin(1000000000 * x[0]) + 0.000000001 * np.sin(1000000000 * x[1]) + 0.0000000001 * np.sin(10000000000 * x[0]) + 0.0000000001 * np.sin(10000000000 * x[1]) + 0.00000000001 * np.sin(100000000000 * x[0]) + 0.00000000001 * np.sin(100000000000 * x[1])\n\ndef f24(x):\n    return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.sin(10 * x[1]) + 0.01 * np.sin(100 * x[0]) + 0.01 * np.sin(100 * x[1]) + 0.001 * np.sin(1000 * x[0]) + 0.001 * np.sin(1000 * x[1]) + 0.0001 * np.sin(10000 * x[0]) + 0.0001 * np.sin(10000 * x[1]) + 0.00001 * np.sin(100000 * x[0]) + 0.00001 * np.sin(100000 * x[1]) + 0.000001 * np.sin(1000000 * x[0]) + 0.000001 * np.sin(1000000 * x[1]) + 0.0000001 * np.sin(10000000 * x[0]) + 0.0000001 * np.sin(10000000 * x[1]) + 0.00000001 * np.sin(100000000 * x[0]) + 0.00000001 * np.sin(100000000 * x[1]) + 0.000000001 * np.sin(1000000000 * x[0]) + 0.000000001 * np.sin(1000000000 * x[1]) + 0.0000000001 * np.sin(10000000000 * x[0]) + 0.0000000001 * np.sin(10000000000 * x[1]) + 0.00000000001 * np.sin(100000000000 * x[0]) + 0.00000000001 * np.sin(100000000000 * x[1])\n\nhybrid_evolutionary_algorithm = HybridEvolutionaryAlgorithm(budget=10, dim=2)\n\ndef evaluate_bbob(func, algorithm):\n    # Initialize logger\n    logger = {}\n    logger['name'] = 'HybridEvolutionaryAlgorithm'\n    logger['description'] = 'Hybrid Evolutionary Algorithm with Crossover, Mutation, and Random Search for Black Box Optimization'\n    logger['score'] = -np.inf\n\n    # Evaluate function\n    best_fitness = np.inf\n    for _ in range(algorithm.budget):\n        fitness, individual = algorithm()\n        if fitness < best_fitness:\n            best_fitness = fitness\n            logger['best_individual'] = individual\n            logger['best_fitness'] = fitness\n\n    # Update score\n    algorithm.score = best_fitness\n\n    return logger\n\n# Usage\nlogger = evaluate_bbob(f1, hybrid_evolutionary_algorithm)\nprint(logger)", "name": "HybridEvolutionaryAlgorithm", "description": "Hybrid Evolutionary Algorithm with Crossover, Mutation, and Random Search for Black Box Optimization", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"HybridEvolutionaryAlgorithm.__call__() missing 1 required positional argument: 'func'\").", "error": "TypeError(\"HybridEvolutionaryAlgorithm.__call__() missing 1 required positional argument: 'func'\")", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "cd223c58-c7d5-408b-9b10-881d58a173f7", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass HybridEvolutionaryAlgorithmWithCrossoverAndMutationForBlackBoxOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.population_size = 100\n        self.mutation_rate = 0.1\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        population = [np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim) for _ in range(self.population_size)]\n\n        for _ in range(self.budget):\n            # Evaluate the fitness of each individual\n            fitness = [func(individual) for individual in population]\n\n            # Select the fittest individuals\n            fittest_individuals = np.argsort(fitness)[:self.population_size // 2]\n\n            # Create a new generation by crossover and mutation\n            new_generation = []\n            for _ in range(self.population_size):\n                if random.random() < 0.4:\n                    parent1, parent2 = random.sample(fittest_individuals, 2)\n                    child = (population[parent1] + population[parent2]) / 2\n                    if random.random() < self.mutation_rate:\n                        child += np.random.uniform(-0.1, 0.1, self.dim)\n                else:\n                    child = population[fittest_individuals[np.random.randint(0, self.population_size // 2)]]\n                new_generation.append(child)\n\n            # Replace the old population with the new generation\n            population = new_generation\n\n        # Return the best individual\n        return min(population, key=func)\n\n# Usage\ndef f1(x):\n    return sum(x**2)\n\ndef f2(x):\n    return sum(x**2) + 0.1 * np.sum(x**2)\n\ndef f3(x):\n    return sum(x**2) + 0.1 * np.sum(x**2) + 0.01 * np.sum(x**2)\n\ndef f4(x):\n    return sum(x**2) + 0.1 * np.sum(x**2) + 0.01 * np.sum(x**2) + 0.001 * np.sum(x**2)\n\ndef f5(x):\n    return sum(x**2) + 0.1 * np.sum(x**2) + 0.01 * np.sum(x**2) + 0.001 * np.sum(x**2) + 0.0001 * np.sum(x**2)\n\ndef f6(x):\n    return sum(x**2) + 0.1 * np.sum(x**2) + 0.01 * np.sum(x**2) + 0.001 * np.sum(x**2) + 0.0001 * np.sum(x**2) + 0.00001 * np.sum(x**2)\n\ndef f7(x):\n    return sum(x**2) + 0.1 * np.sum(x**2) + 0.01 * np.sum(x**2) + 0.001 * np.sum(x**2) + 0.0001 * np.sum(x**2) + 0.00001 * np.sum(x**2) + 0.000001 * np.sum(x**2)\n\ndef f8(x):\n    return sum(x**2) + 0.1 * np.sum(x**2) + 0.01 * np.sum(x**2) + 0.001 * np.sum(x**2) + 0.0001 * np.sum(x**2) + 0.00001 * np.sum(x**2) + 0.000001 * np.sum(x**2) + 0.0000001 * np.sum(x**2)\n\ndef f9(x):\n    return sum(x**2) + 0.1 * np.sum(x**2) + 0.01 * np.sum(x**2) + 0.001 * np.sum(x**2) + 0.0001 * np.sum(x**2) + 0.00001 * np.sum(x**2) + 0.000001 * np.sum(x**2) + 0.0000001 * np.sum(x**2) + 0.00000001 * np.sum(x**2)\n\ndef f10(x):\n    return sum(x**2) + 0.1 * np.sum(x**2) + 0.01 * np.sum(x**2) + 0.001 * np.sum(x**2) + 0.0001 * np.sum(x**2) + 0.00001 * np.sum(x**2) + 0.000001 * np.sum(x**2) + 0.0000001 * np.sum(x**2) + 0.00000001 * np.sum(x**2) + 0.000000001 * np.sum(x**2)\n\ndef f11(x):\n    return sum(x**2) + 0.1 * np.sum(x**2) + 0.01 * np.sum(x**2) + 0.001 * np.sum(x**2) + 0.0001 * np.sum(x**2) + 0.00001 * np.sum(x**2) + 0.000001 * np.sum(x**2) + 0.0000001 * np.sum(x**2) + 0.00000001 * np.sum(x**2) + 0.000000001 * np.sum(x**2) + 0.0000000001 * np.sum(x**2)\n\ndef f12(x):\n    return sum(x**2) + 0.1 * np.sum(x**2) + 0.01 * np.sum(x**2) + 0.001 * np.sum(x**2) + 0.0001 * np.sum(x**2) + 0.00001 * np.sum(x**2) + 0.000001 * np.sum(x**2) + 0.0000001 * np.sum(x**2) + 0.00000001 * np.sum(x**2) + 0.000000001 * np.sum(x**2) + 0.0000000001 * np.sum(x**2) + 0.00000000001 * np.sum(x**2)\n\ndef f13(x):\n    return sum(x**2) + 0.1 * np.sum(x**2) + 0.01 * np.sum(x**2) + 0.001 * np.sum(x**2) + 0.0001 * np.sum(x**2) + 0.00001 * np.sum(x**2) + 0.000001 * np.sum(x**2) + 0.0000001 * np.sum(x**2) + 0.00000001 * np.sum(x**2) + 0.000000001 * np.sum(x**2) + 0.0000000001 * np.sum(x**2) + 0.00000000001 * np.sum(x**2) + 0.000000000001 * np.sum(x**2)\n\ndef f14(x):\n    return sum(x**2) + 0.1 * np.sum(x**2) + 0.01 * np.sum(x**2) + 0.001 * np.sum(x**2) + 0.0001 * np.sum(x**2) + 0.00001 * np.sum(x**2) + 0.000001 * np.sum(x**2) + 0.0000001 * np.sum(x**2) + 0.00000001 * np.sum(x**2) + 0.000000001 * np.sum(x**2) + 0.0000000001 * np.sum(x**2) + 0.00000000001 * np.sum(x**2) + 0.000000000001 * np.sum(x**2) + 0.0000000000001 * np.sum(x**2)\n\ndef f15(x):\n    return sum(x**2) + 0.1 * np.sum(x**2) + 0.01 * np.sum(x**2) + 0.001 * np.sum(x**2) + 0.0001 * np.sum(x**2) + 0.00001 * np.sum(x**2) + 0.000001 * np.sum(x**2) + 0.0000001 * np.sum(x**2) + 0.00000001 * np.sum(x**2) + 0.000000001 * np.sum(x**2) + 0.0000000001 * np.sum(x**2) + 0.00000000001 * np.sum(x**2) + 0.000000000001 * np.sum(x**2) + 0.0000000000001 * np.sum(x**2) + 0.00000000000001 * np.sum(x**2)\n\ndef f16(x):\n    return sum(x**2) + 0.1 * np.sum(x**2) + 0.01 * np.sum(x**2) + 0.001 * np.sum(x**2) + 0.0001 * np.sum(x**2) + 0.00001 * np.sum(x**2) + 0.000001 * np.sum(x**2) + 0.0000001 * np.sum(x**2) + 0.00000001 * np.sum(x**2) + 0.000000001 * np.sum(x**2) + 0.0000000001 * np.sum(x**2) + 0.00000000001 * np.sum(x**2) + 0.000000000001 * np.sum(x**2) + 0.0000000000001 * np.sum(x**2) + 0.00000000000001 * np.sum(x**2) + 0.000000000000001 * np.sum(x**2)\n\ndef f17(x):\n    return sum(x**2) + 0.1 * np.sum(x**2) + 0.01 * np.sum(x**2) + 0.001 * np.sum(x**2) + 0.0001 * np.sum(x**2) + 0.00001 * np.sum(x**2) + 0.000001 * np.sum(x**2) + 0.0000001 * np.sum(x**2) + 0.00000001 * np.sum(x**2) + 0.000000001 * np.sum(x**2) + 0.0000000001 * np.sum(x**2) + 0.00000000001 * np.sum(x**2) + 0.000000000001 * np.sum(x**2) + 0.0000000000001 * np.sum(x**2) + 0.00000000000001 * np.sum(x**2) + 0.000000000000001 * np.sum(x**2) + 0.0000000000000001 * np.sum(x**2)\n\ndef f18(x):\n    return sum(x**2) + 0.1 * np.sum(x**2) + 0.01 * np.sum(x**2) + 0.001 * np.sum(x**2) + 0.0001 * np.sum(x**2) + 0.00001 * np.sum(x**2) + 0.000001 * np.sum(x**2) + 0.0000001 * np.sum(x**2) + 0.00000001 * np.sum(x**2) + 0.000000001 * np.sum(x**2) + 0.0000000001 * np.sum(x**2) + 0.00000000001 * np.sum(x**2) + 0.000000000001 * np.sum(x**2) + 0.0000000000001 * np.sum(x**2) + 0.00000000000001 * np.sum(x**2) + 0.000000000000001 * np.sum(x**2) + 0.0000000000000001 * np.sum(x**2)\n\ndef f19(x):\n    return sum(x**2) + 0.1 * np.sum(x**2) + 0.01 * np.sum(x**2) + 0.001 * np.sum(x**2) + 0.0001 * np.sum(x**2) + 0.00001 * np.sum(x**2) + 0.000001 * np.sum(x**2) + 0.0000001 * np.sum(x**2) + 0.00000001 * np.sum(x**2) + 0.000000001 * np.sum(x**2) + 0.0000000001 * np.sum(x**2) + 0.00000000001 * np.sum(x**2) + 0.000000000001 * np.sum(x**2) + 0.0000000000001 * np.sum(x**2) + 0.00000000000001 * np.sum(x**2) + 0.000000000000001 * np.sum(x**2) + 0.0000000000000001 * np.sum(x**2)\n\ndef f20(x):\n    return sum(x**2) + 0.1 * np.sum(x**2) + 0.01 * np.sum(x**2) + 0.001 * np.sum(x**2) + 0.0001 * np.sum(x**2) + 0.00001 * np.sum(x**2) + 0.000001 * np.sum(x**2) + 0.0000001 * np.sum(x**2) + 0.00000001 * np.sum(x**2) + 0.000000001 * np.sum(x**2) + 0.0000000001 * np.sum(x**2) + 0.00000000001 * np.sum(x**2) + 0.000000000001 * np.sum(x**2) + 0.0000000000001 * np.sum(x**2) + 0.00000000000001 * np.sum(x**2) + 0.000000000000001 * np.sum(x**2) + 0.0000000000000001 * np.sum(x**2)\n\ndef f21(x):\n    return sum(x**2) + 0.1 * np.sum(x**2) + 0.01 * np.sum(x**2) + 0.001 * np.sum(x**2) + 0.0001 * np.sum(x**2) + 0.00001 * np.sum(x**2) + 0.000001 * np.sum(x**2) + 0.0000001 * np.sum(x**2) + 0.00000001 * np.sum(x**2) + 0.000000001 * np.sum(x**2) + 0.0000000001 * np.sum(x**2) + 0.00000000001 * np.sum(x**2) + 0.000000000001 * np.sum(x**2) + 0.0000000000001 * np.sum(x**2) + 0.00000000000001 * np.sum(x**2) + 0.000000000000001 * np.sum(x**2) + 0.0000000000000001 * np.sum(x**2)\n\ndef f22(x):\n    return sum(x**2) + 0.1 * np.sum(x**2) + 0.01 * np.sum(x**2) + 0.001 * np.sum(x**2) + 0.0001 * np.sum(x**2) + 0.00001 * np.sum(x**2) + 0.000001 * np.sum(x**2) + 0.0000001 * np.sum(x**2) + 0.00000001 * np.sum(x**2) + 0.000000001 * np.sum(x**2) + 0.0000000001 * np.sum(x**2) + 0.00000000001 * np.sum(x**2) + 0.000000000001 * np.sum(x**2) + 0.0000000000001 * np.sum(x**2) + 0.00000000000001 * np.sum(x**2) + 0.000000000000001 * np.sum(x**2) + 0.0000000000000001 * np.sum(x**2)\n\ndef f23(x):\n    return sum(x**2) + 0.1 * np.sum(x**2) + 0.01 * np.sum(x**2) + 0.001 * np.sum(x**2) + 0.0001 * np.sum(x**2) + 0.00001 * np.sum(x**2) + 0.000001 * np.sum(x**2) + 0.0000001 * np.sum(x**2) + 0.00000001 * np.sum(x**2) + 0.000000001 * np.sum(x**2) + 0.0000000001 * np.sum(x**2) + 0.00000000001 * np.sum(x**2) + 0.000000000001 * np.sum(x**2) + 0.0000000000001 * np.sum(x**2) + 0.00000000000001 * np.sum(x**2) + 0.000000000000001 * np.sum(x**2) + 0.0000000000000001 * np.sum(x**2)\n\ndef f24(x):\n    return sum(x**2) + 0.1 * np.sum(x**2) + 0.01 * np.sum(x**2) + 0.001 * np.sum(x**2) + 0.0001 * np.sum(x**2) + 0.00001 * np.sum(x**2) + 0.000001 * np.sum(x**2) + 0.0000001 * np.sum(x**2) + 0.00000001 * np.sum(x**2) + 0.000000001 * np.sum(x**2) + 0.0000000001 * np.sum(x**2) + 0.00000000001 * np.sum(x**2) + 0.000000000001 * np.sum(x**2) + 0.0000000000001 * np.sum(x**2) + 0.00000000000001 * np.sum(x**2) + 0.000000000000001 * np.sum(x**2) + 0.0000000000000001 * np.sum(x**2)\n\n# Usage\nalgorithm = HybridEvolutionaryAlgorithmWithCrossoverAndMutationForBlackBoxOptimization(budget=100, dim=10)\nresult = algorithm(f1)\nprint(result)", "name": "HybridEvolutionaryAlgorithmWithCrossoverAndMutationForBlackBoxOptimization", "description": "Novel Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "232e1e19-653f-4604-850c-4dfe83fa202a", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "08677bc3-111d-4b34-92f5-f8c944751a66", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "35a7c01a-3ad7-4ee6-8282-35828249d462", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.strategies = ['sbx', 'rand1', 'uniform', 'log-uniform']\n        self.strategy_refinement_prob = 0.4\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def refine_strategy(self, individual):\n        strategy = random.choices(self.strategies, weights=[0.4, 0.3, 0.2, 0.1])[0]\n        if strategy =='sbx':\n            individual['cxpb'] = random.uniform(0, 1)\n        elif strategy == 'rand1':\n            individual['cxpb'] = random.uniform(0, 1)\n        elif strategy == 'uniform':\n            individual['scaling'] = random.choice(['uniform', 'log-uniform'])\n        elif strategy == 'log-uniform':\n            individual['scaling'] = random.choice(['uniform', 'log-uniform'])\n\n# Usage:\nif __name__ == \"__main__\":\n    heacombbo = HEACOMBBO(budget=10, dim=5)\n    func = 'f2'  # replace with the desired function\n    result = heacombbo(func)\n    print(result)", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) with probability-based strategy refinement.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 35, 142, None, 35, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 35, 142, None, 35, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "99d050c4-27ab-4919-833f-034bd2ff7a06", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        def adaptive_crossover(individual):\n            new_individual = list(individual)\n            for i in range(self.dim):\n                if random.random() < 0.4:\n                    new_individual[i] = random.uniform(self.bounds[i][0], self.bounds[i][1])\n            return tuple(new_individual)\n\n        def adaptive_mutation(individual):\n            new_individual = list(individual)\n            for i in range(self.dim):\n                if random.random() < 0.4:\n                    new_individual[i] = random.uniform(self.bounds[i][0], self.bounds[i][1])\n            return tuple(new_individual)\n\n        def evaluate_fitness(individual):\n            return func(*individual)\n\n        def optimize():\n            population = [self.x0]\n            for _ in range(self.budget):\n                new_population = []\n                while len(new_population) < self.dim:\n                    parent1 = random.choice(population)\n                    parent2 = random.choice(population)\n                    child = (0.5 * parent1 + 0.5 * parent2)\n                    child = adaptive_crossover(child)\n                    child = adaptive_mutation(child)\n                    new_population.append(child)\n                population = new_population\n            fitness = [evaluate_fitness(individual) for individual in population]\n            best_individual = population[np.argmin(fitness)]\n            return best_individual, np.min(fitness)\n\n        return optimize()\n\n# Usage\nbudget = 100\ndim = 10\nfunc = lambda x: x[0]**2 + x[1]**2\nheacombbo = HybridEvolutionaryAlgorithm(budget, dim)\nbest_individual, best_fitness = heacombbo(func)\nprint(f\"Best Individual: {best_individual}\")\nprint(f\"Best Fitness: {best_fitness}\")", "name": "HybridEvolutionaryAlgorithm", "description": "Hybrid Evolutionary Algorithm with Adaptive Crossover and Mutation for Black Box Optimization", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"can't multiply sequence by non-int of type 'float'\").", "error": "TypeError(\"can't multiply sequence by non-int of type 'float'\")", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "8e83d684-d84c-4ea6-8fd7-9b1e7859ea7d", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass BBOBMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.probability = 0.4\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        def crossover(individual1, individual2):\n            if np.random.rand() < self.probability:\n                new_individual = individual1 + individual2\n            else:\n                new_individual = individual1\n            return new_individual\n\n        def mutate(individual):\n            if np.random.rand() < self.probability:\n                new_individual = individual + np.random.uniform(-1, 1, self.dim)\n            else:\n                new_individual = individual\n            return new_individual\n\n        def evaluate_fitness(individual):\n            return func(individual)\n\n        def evaluateBBOB(func, population_size=100, budget=self.budget, dim=self.dim, bounds=self.bounds):\n            population = np.random.uniform(bounds[0][0], bounds[0][1], (population_size, dim))\n            for _ in range(budget):\n                new_population = []\n                for i in range(population_size):\n                    individual1 = population[i]\n                    individual2 = population[np.random.randint(0, population_size)]\n                    new_individual = crossover(individual1, individual2)\n                    new_individual = mutate(new_individual)\n                    new_population.append(new_individual)\n                population = np.array(new_population)\n            fitness = np.array([evaluate_fitness(individual) for individual in population])\n            return population, fitness\n\n        population, fitness = evaluateBBOB(func)\n        return np.argmin(fitness), np.min(fitness)\n\n# Usage\ndef f1(x):\n    return x[0]**2 + x[1]**2\n\ndef f2(x):\n    return x[0]**2 + 2*x[1]**2\n\ndef f3(x):\n    return x[0]**3 + 2*x[1]**3\n\ndef f4(x):\n    return x[0]**4 + 4*x[1]**4\n\ndef f5(x):\n    return x[0]**5 + 5*x[1]**5\n\ndef f6(x):\n    return x[0]**6 + 6*x[1]**6\n\ndef f7(x):\n    return x[0]**7 + 7*x[1]**7\n\ndef f8(x):\n    return x[0]**8 + 8*x[1]**8\n\ndef f9(x):\n    return x[0]**9 + 9*x[1]**9\n\ndef f10(x):\n    return x[0]**10 + 10*x[1]**10\n\ndef f11(x):\n    return x[0]**11 + 11*x[1]**11\n\ndef f12(x):\n    return x[0]**12 + 12*x[1]**12\n\ndef f13(x):\n    return x[0]**13 + 13*x[1]**13\n\ndef f14(x):\n    return x[0]**14 + 14*x[1]**14\n\ndef f15(x):\n    return x[0]**15 + 15*x[1]**15\n\ndef f16(x):\n    return x[0]**16 + 16*x[1]**16\n\ndef f17(x):\n    return x[0]**17 + 17*x[1]**17\n\ndef f18(x):\n    return x[0]**18 + 18*x[1]**18\n\ndef f19(x):\n    return x[0]**19 + 19*x[1]**19\n\ndef f20(x):\n    return x[0]**20 + 20*x[1]**20\n\ndef f21(x):\n    return x[0]**21 + 21*x[1]**21\n\ndef f22(x):\n    return x[0]**22 + 22*x[1]**22\n\ndef f23(x):\n    return x[0]**23 + 23*x[1]**23\n\ndef f24(x):\n    return x[0]**24 + 24*x[1]**24\n\nbudget = 100\ndim = 2\nsolution = BBOBMutation(budget, dim)\nbest_individual, best_fitness = solution(f1)\nprint(f\"Best individual: {best_individual}, Best fitness: {best_fitness}\")", "name": "BBOBMutation", "description": "Novel metaheuristic algorithm with probability-based crossover and mutation for black box optimization", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "ed0ab6cc-59ed-4c40-a025-2cd25d6bbf9f", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\nimport copy\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def refine_strategy(self, func):\n        if func.__name__ == 'f1':\n            return'sbx'\n        elif func.__name__ == 'f2':\n            return'sbx'\n        elif func.__name__ == 'f3':\n            return'sbx'\n        elif func.__name__ == 'f4':\n            return'sbx'\n        elif func.__name__ == 'f5':\n            return'sbx'\n        elif func.__name__ == 'f6':\n            return'sbx'\n        elif func.__name__ == 'f7':\n            return'sbx'\n        elif func.__name__ == 'f8':\n            return'sbx'\n        elif func.__name__ == 'f9':\n            return'sbx'\n        elif func.__name__ == 'f10':\n            return'sbx'\n        elif func.__name__ == 'f11':\n            return'sbx'\n        elif func.__name__ == 'f12':\n            return'sbx'\n        elif func.__name__ == 'f13':\n            return'sbx'\n        elif func.__name__ == 'f14':\n            return'sbx'\n        elif func.__name__ == 'f15':\n            return'sbx'\n        elif func.__name__ == 'f16':\n            return'sbx'\n        elif func.__name__ == 'f17':\n            return'sbx'\n        elif func.__name__ == 'f18':\n            return'sbx'\n        elif func.__name__ == 'f19':\n            return'sbx'\n        elif func.__name__ == 'f20':\n            return'sbx'\n        elif func.__name__ == 'f21':\n            return'sbx'\n        elif func.__name__ == 'f22':\n            return'sbx'\n        elif func.__name__ == 'f23':\n            return'sbx'\n        elif func.__name__ == 'f24':\n            return'sbx'\n\n    def evaluate_fitness(self, individual):\n        func_name = individual.__class__.__name__\n        func = globals()[func_name]\n        if self.budget > 0:\n            func()\n            self.budget -= 1\n        return func()\n\n    def mutate(self, individual):\n        func_name = individual.__class__.__name__\n        func = globals()[func_name]\n        new_individual = copy.deepcopy(individual)\n        new_func = self.refine_strategy(func)\n        new_individual.__class__.__name__ = new_func\n        new_func = globals()[new_func]\n        new_individual = new_func()\n        return new_individual\n\n    def crossover(self, parent1, parent2):\n        child = copy.deepcopy(parent1)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent2[i]\n        return child\n\n    def evolve(self, population, num_generations):\n        for _ in range(num_generations):\n            population = sorted(population, key=lambda individual: self.evaluate_fitness(individual))\n            new_population = []\n            for i in range(len(population) // 2):\n                parent1, parent2 = random.sample(population, 2)\n                child = self.crossover(parent1, parent2)\n                new_population.append(child)\n                new_population.append(self.mutate(child))\n            population = new_population\n        return population\n\n# Usage:\nif __name__ == \"__main__\":\n    population = [HEACOMBBO(100, 10) for _ in range(50)]\n    final_population = population\n    for individual in final_population:\n        individual.x0 = np.random.uniform(individual.bounds[0][0], individual.bounds[0][1], individual.dim)\n    num_generations = 10\n    final_population = population\n    for _ in range(num_generations):\n        final_population = population\n        population = population\n        population = final_population\n        population = population\n        population = population\n        population = population\n        population = population\n        population = population\n        population = population\n        population = population\n        population = population\n        population = population\n        population = population\n    print(final_population[0].evaluate_fitness(final_population[0]))", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) with strategy refinement.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 34, 142, None, 34, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 34, 142, None, 34, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "86e7157c-a955-4ae5-ac39-22b9cc8a37dc", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nfrom deap import base, creator, tools, algorithms\nimport random\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        population_size = 100\n        mutation_rate = 0.1\n        cxpb = 0.4\n\n        # Initialize the population\n        creator.create(\"FitnessMin\", base.Fitness, weights=(-1.0,))\n        creator.create(\"Individual\", list, fitness=creator.FitnessMin)\n\n        toolbox = base.Toolbox()\n        toolbox.register(\"attr_float\", random.uniform, self.bounds[0][0], self.bounds[0][1])\n        toolbox.register(\"individual\", tools.initRepeat, creator.Individual, toolbox.attr_float, self.dim)\n        toolbox.register(\"population\", tools.initRepeat, list, toolbox.individual)\n\n        toolbox.register(\"evaluate\", func)\n        toolbox.register(\"mate\", tools.cxTwoPoint)\n        toolbox.register(\"mutate\", tools.mutPolynomialBounded, low=self.bounds[0][0], up=self.bounds[0][1], eta=20.0)\n        toolbox.register(\"select\", tools.selTournament, tournsize=3)\n\n        # Initialize the population\n        population = toolbox.population(n=population_size)\n        HGA = algorithms.HGA(toolbox, ngen=100, cxpb=cxpb, mutpb=mutation_rate, stats=tools.Statistics(lambda ind: ind.fitness.values))\n        HGA evolve(population)\n\n        # Evaluate the fitness of the population\n        fitnesses = toolbox.map(toolbox.evaluate, population)\n        for ind, fit in zip(population, fitnesses):\n            ind.fitness.values = fit\n\n        # Select the best individual\n        best_individual = tools.selBest(population, 1)[0]\n\n        return best_individual.f, best_individual\n\n# Usage\ndef func(individual):\n    return np.sum(np.abs(np.sin(np.cos(np.array(individual)))) ** 2)\n\nheacombbo = HybridEvolutionaryAlgorithm(50, 2)\nbest_individual = heacombbo(func)\nprint(best_individual)", "name": "HybridEvolutionaryAlgorithm", "description": "Novel hybrid algorithm combining the benefits of genetic algorithms and differential evolution for black box optimization.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 38, 13, '        HGA evolve(population)\\n', 38, 19)).", "error": "SyntaxError('invalid syntax', ('<string>', 38, 13, '        HGA evolve(population)\\n', 38, 19))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "647c7561-bba0-482b-b920-94184e8d8cac", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "b07729ea-6b23-492e-b888-dbd01564b036", "solution": "import numpy as np\nimport random\nimport copy\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        def mutate(individual):\n            mutation_rate = 0.4\n            new_individual = copy.deepcopy(individual)\n            for i in range(self.dim):\n                if random.random() < mutation_rate:\n                    new_individual[i] = random.uniform(self.bounds[i][0], self.bounds[i][1])\n            return new_individual\n\n        def crossover(parent1, parent2):\n            crossover_rate = 0.4\n            new_individual = copy.deepcopy(parent1)\n            for i in range(self.dim):\n                if random.random() < crossover_rate:\n                    new_individual[i] = parent2[i]\n            return new_individual\n\n        def evaluate_fitness(individual):\n            return func(individual)\n\n        population_size = 10\n        population = [np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim) for _ in range(population_size)]\n\n        for _ in range(self.budget):\n            new_population = []\n            for _ in range(population_size):\n                parent1, parent2 = random.sample(population, 2)\n                child = crossover(parent1, parent2)\n                child = mutate(child)\n                new_population.append(child)\n            population = new_population\n\n        best_individual = min(population, key=evaluate_fitness)\n        return evaluate_fitness(best_individual), best_individual\n\ndef func(x):\n    # Example function\n    return x[0]**2 + x[1]**2\n\nheacombbo = HEACOMBBO(100, 2)\nbest_fitness, best_individual = heacombbo(func)\nprint(f\"Best Fitness: {best_fitness}, Best Individual: {best_individual}\")", "name": "HEACOMBBO", "description": "Novel Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) using probability to refine strategy.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "faf46655-5e24-4728-98fa-cd2ed7fd85d5", "solution": "import numpy as np\nimport random\nimport copy\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        def refine_strategy(individual):\n            strategy = copy.deepcopy(individual['strategy'])\n            for i in range(self.dim):\n                if random.random() < 0.4:\n                    strategy[i] = random.choice(['sbx', 'rand1', 'uniform'])\n            return {'individual': individual,'strategy': strategy}\n\n        def evaluateBBOB(func, individual):\n            code = f\"def f(x):\\n    return {func.__name__}(x)\"\n            exec(code, globals())\n            result = eval('f(individual[\"x\"])')\n            individual['fitness'] = -result\n            return individual\n\n        def crossover(parent1, parent2):\n            child = {}\n            for i in range(self.dim):\n                if random.random() < 0.5:\n                    child['x'][i] = parent1['x'][i]\n                else:\n                    child['x'][i] = parent2['x'][i]\n            child['strategy'] = parent1['strategy']\n            child['fitness'] = parent1['fitness']\n            return child\n\n        def mutate(individual):\n            if random.random() < 0.1:\n                individual['x'][random.randint(0, self.dim-1)] += np.random.uniform(-1, 1)\n                individual['x'][random.randint(0, self.dim-1)] = max(self.bounds[0][0], min(individual['x'][random.randint(0, self.dim-1)], self.bounds[0][1]))\n            return individual\n\n        population = [{'x': self.x0,'strategy':'sbx', 'fitness': 0} for _ in range(10)]\n        for _ in range(self.budget):\n            population = sorted(population, key=lambda x: x['fitness'])\n            if population[0]['fitness']!= 0:\n                individual = population[0]\n                new_individual = evaluateBBOB(func, individual)\n                population[0] = new_individual\n                if random.random() < 0.5:\n                    new_individual = crossover(population[1], population[0])\n                    population[1] = new_individual\n                if random.random() < 0.1:\n                    new_individual = mutate(population[1])\n                    population[1] = new_individual\n            else:\n                break\n        return population[0]['x'], population[0]['fitness']\n\n# Example usage:\nbudget = 100\ndim = 10\nfunc = lambda x: x[0]**2 + x[1]**2\nalgorithm = HybridEvolutionaryAlgorithm(budget, dim)\nresult = algorithm(func)\nprint(result)", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization using Probability Refinement", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "6e2442b5-5266-45b8-ac63-46cba4697d72", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "e902a4a9-fcb3-4ed5-aa6c-647276404d57", "solution": "import numpy as np\nimport random\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return self.f1(func)\n        elif func.__name__ == 'f2':\n            return self.f2(func)\n        elif func.__name__ == 'f3':\n            return self.f3(func)\n        elif func.__name__ == 'f4':\n            return self.f4(func)\n        elif func.__name__ == 'f5':\n            return self.f5(func)\n        elif func.__name__ == 'f6':\n            return self.f6(func)\n        elif func.__name__ == 'f7':\n            return self.f7(func)\n        elif func.__name__ == 'f8':\n            return self.f8(func)\n        elif func.__name__ == 'f9':\n            return self.f9(func)\n        elif func.__name__ == 'f10':\n            return self.f10(func)\n        elif func.__name__ == 'f11':\n            return self.f11(func)\n        elif func.__name__ == 'f12':\n            return self.f12(func)\n        elif func.__name__ == 'f13':\n            return self.f13(func)\n        elif func.__name__ == 'f14':\n            return self.f14(func)\n        elif func.__name__ == 'f15':\n            return self.f15(func)\n        elif func.__name__ == 'f16':\n            return self.f16(func)\n        elif func.__name__ == 'f17':\n            return self.f17(func)\n        elif func.__name__ == 'f18':\n            return self.f18(func)\n        elif func.__name__ == 'f19':\n            return self.f19(func)\n        elif func.__name__ == 'f20':\n            return self.f20(func)\n        elif func.__name__ == 'f21':\n            return self.f21(func)\n        elif func.__name__ == 'f22':\n            return self.f22(func)\n        elif func.__name__ == 'f23':\n            return self.f23(func)\n        elif func.__name__ == 'f24':\n            return self.f24(func)\n\n    def f1(self, func):\n        # Differential Evolution\n        res = differential_evolution(func, self.bounds)\n        return res.x, res.fun\n\n    def f2(self, func):\n        # Differential Evolution with initial guess\n        res = differential_evolution(func, self.bounds, x0=self.x0)\n        return res.x, res.fun\n\n    def f3(self, func):\n        # Differential Evolution with initial guess and tolerance\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        return res.x, res.fun\n\n    def f4(self, func):\n        # Differential Evolution with initial guess, tolerance, and initial guess\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        return res.x, res.fun\n\n    def f5(self, func):\n        # Differential Evolution with initial guess, tolerance, initial guess, and strategy\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        return res.x, res.fun\n\n    def f6(self, func):\n        # Differential Evolution with initial guess, tolerance, initial guess, strategy, and crossover probability\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        return res.x, res.fun\n\n    def f7(self, func):\n        # Differential Evolution with initial guess, tolerance, initial guess, strategy, crossover probability, and mutation probability\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        return res.x, res.fun\n\n    def f8(self, func):\n        # Differential Evolution with initial guess, tolerance, initial guess, strategy, crossover probability, mutation probability, and weighting\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        return res.x, res.fun\n\n    def f9(self, func):\n        # Differential Evolution with initial guess, tolerance, initial guess, strategy, crossover probability, mutation probability, weighting, and scaling strategy\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        return res.x, res.fun\n\n    def f10(self, func):\n        # Differential Evolution with initial guess, tolerance, initial guess, strategy, crossover probability, mutation probability, weighting, scaling strategy, and scaling method\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        return res.x, res.fun\n\n    def f11(self, func):\n        # Differential Evolution with initial guess, tolerance, initial guess, strategy, crossover probability, mutation probability, weighting, scaling strategy, scaling method, and scaling method\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        return res.x, res.fun\n\n    def f12(self, func):\n        # Differential Evolution with initial guess, tolerance, initial guess, strategy, crossover probability, mutation probability, weighting, scaling strategy, scaling method, scaling method, and scaling method\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        return res.x, res.fun\n\n    def f13(self, func):\n        # Differential Evolution with initial guess, tolerance, initial guess, strategy, crossover probability, mutation probability, weighting, scaling strategy, scaling method, scaling method, scaling method, and scaling method\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        return res.x, res.fun\n\n    def f14(self, func):\n        # Differential Evolution with initial guess, tolerance, initial guess, strategy, crossover probability, mutation probability, weighting, scaling strategy, scaling method, scaling method, scaling method, scaling method, and scaling method\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        return res.x, res.fun\n\n    def f15(self, func):\n        # Differential Evolution with initial guess, tolerance, initial guess, strategy, crossover probability, mutation probability, weighting, scaling strategy, scaling method, scaling method, scaling method, scaling method, scaling method, and scaling method\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        return res.x, res.fun\n\n    def f16(self, func):\n        # Differential Evolution with initial guess, tolerance, initial guess, strategy, crossover probability, mutation probability, weighting, scaling strategy, scaling method, scaling method, scaling method, scaling method, scaling method, scaling method, and scaling method\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        return res.x, res.fun\n\n    def f17(self, func):\n        # Differential Evolution with initial guess, tolerance, initial guess, strategy, crossover probability, mutation probability, weighting, scaling strategy, scaling method, scaling method, scaling method, scaling method, scaling method, scaling method, scaling method, and scaling method\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        return res.x, res.fun\n\n    def f18(self, func):\n        # Differential Evolution with initial guess, tolerance, initial guess, strategy, crossover probability, mutation probability, weighting, scaling strategy, scaling method, scaling method, scaling method, scaling method, scaling method, scaling method, scaling method, scaling method, and scaling method\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        return res.x, res.fun\n\n    def f19(self, func):\n        # Differential Evolution with initial guess, tolerance, initial guess, strategy, crossover probability, mutation probability, weighting, scaling strategy, scaling method, scaling method, scaling method, scaling method, scaling method, scaling method, scaling method, scaling method, and scaling method\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        return res.x, res.fun\n\n    def f20(self, func):\n        # Differential Evolution with initial guess, tolerance, initial guess, strategy, crossover probability, mutation probability, weighting, scaling strategy, scaling method, scaling method, scaling method, scaling method, scaling method, scaling method, scaling method, scaling method, and scaling method\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        return res.x, res.fun\n\n    def f21(self, func):\n        # Differential Evolution with initial guess, tolerance, initial guess, strategy, crossover probability, mutation probability, weighting, scaling strategy, scaling method, scaling method, scaling method, scaling method, scaling method, scaling method, scaling method, scaling method, and scaling method\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        return res.x, res.fun\n\n    def f22(self, func):\n        # Differential Evolution with initial guess, tolerance, initial guess, strategy, crossover probability, mutation probability, weighting, scaling strategy, scaling method, scaling method, scaling method, scaling method, scaling method, scaling method, scaling method, scaling method, and scaling method\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        return res.x, res.fun\n\n    def f23(self, func):\n        # Differential Evolution with initial guess, tolerance, initial guess, strategy, crossover probability, mutation probability, weighting, scaling strategy, scaling method, scaling method, scaling method, scaling method, scaling method, scaling method, scaling method, scaling method, and scaling method\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        return res.x, res.fun\n\n    def f24(self, func):\n        # Differential Evolution with initial guess, tolerance, initial guess, strategy, crossover probability, mutation probability, weighting, scaling strategy, scaling method, scaling method, scaling method, scaling method, scaling method, scaling method, scaling method, scaling method, and scaling method\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        return res.x, res.fun\n\n    def refine(self, func):\n        # Refine the solution using probability-based refinement\n        refined_x = []\n        for individual in self.x0:\n            if random.random() < 0.4:\n                # Apply mutation\n                individual = (individual + random.uniform(-0.1, 0.1),)\n                refined_x.append(individual)\n            else:\n                refined_x.append(individual)\n        self.x0 = refined_x\n        return self.x0\n\n# Example usage\nif __name__ == \"__main__\":\n    algorithm = HybridEvolutionaryAlgorithm(100, 10)\n    # Replace 'f1' with the desired function from the BBOB test suite\n    algorithm('f1')", "name": "HybridEvolutionaryAlgorithm", "description": "Hybrid Evolutionary Algorithm with Crossover, Mutation, and Probability-based Refinement for Black Box Optimization", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 106, 137, None, 106, 153)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 106, 137, None, 106, 153))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "4705df87-b7ce-482d-9a68-0fbaa304d124", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "021715ae-8eb4-45a1-9089-a0d887e9357c", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.probability = 0.4\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def refine_strategy(self, individual):\n        strategy = np.random.choice(['sbx', 'rand1', 'uniform', 'log-uniform'], p=[0.4, 0.3, 0.2, 0.1])\n        if strategy =='sbx':\n            individual['cxpb'] = np.random.uniform(0.0, 1.0)\n            individual['mu'] = np.random.uniform(0.0, 1.0)\n            individual['w'] = np.random.uniform(0.0, 1.0)\n        elif strategy == 'rand1':\n            individual['cxpb'] = np.random.uniform(0.0, 1.0)\n            individual['mu'] = np.random.uniform(0.0, 1.0)\n            individual['w'] = np.random.uniform(0.0, 1.0)\n        elif strategy == 'uniform':\n            individual['cxpb'] = np.random.uniform(0.0, 1.0)\n            individual['mu'] = np.random.uniform(0.0, 1.0)\n            individual['w'] = np.random.uniform(0.0, 1.0)\n        elif strategy == 'log-uniform':\n            individual['cxpb'] = np.random.uniform(0.0, 1.0)\n            individual['mu'] = np.random.uniform(0.0, 1.0)\n            individual['w'] = np.random.uniform(0.0, 1.0)\n        return individual\n\n    def evaluate_fitness(self, individual):\n        if individual['strategy'] =='sbx':\n            individual['func'] = lambda x: individual['f'](x, self.budget, self.dim, strategy='sbx', cxpb=individual['cxpb'], mu=individual['mu'], w=individual['w'])\n        elif individual['strategy'] == 'rand1':\n            individual['func'] = lambda x: individual['f'](x, self.budget, self.dim, strategy='rand1', cxpb=individual['cxpb'], mu=individual['mu'], w=individual['w'])\n        elif individual['strategy'] == 'uniform':\n            individual['func'] = lambda x: individual['f'](x, self.budget, self.dim, strategy='uniform', cxpb=individual['cxpb'], mu=individual['mu'], w=individual['w'])\n        elif individual['strategy'] == 'log-uniform':\n            individual['func'] = lambda x: individual['f'](x, self.budget, self.dim, strategy='log-uniform', cxpb=individual['cxpb'], mu=individual['mu'], w=individual['w'])\n        return individual['func']()\n\n# Usage\ndef f1(x, budget, dim, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5):\n    return sum(x**2)\n\ndef f2(x, budget, dim, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5):\n    return sum(x**3)\n\ndef f3(x, budget, dim, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5):\n    return sum(x**4)\n\ndef f4(x, budget, dim, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5):\n    return sum(x**5)\n\ndef f5(x, budget, dim, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5):\n    return sum(x**6)\n\ndef f6(x, budget, dim, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5):\n    return sum(x**7)\n\ndef f7(x, budget, dim, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5):\n    return sum(x**8)\n\ndef f8(x, budget, dim, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5):\n    return sum(x**9)\n\ndef f9(x, budget, dim, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5):\n    return sum(x**10)\n\ndef f10(x, budget, dim, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5):\n    return sum(x**11)\n\ndef f11(x, budget, dim, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5):\n    return sum(x**12)\n\ndef f12(x, budget, dim, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5):\n    return sum(x**13)\n\ndef f13(x, budget, dim, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5):\n    return sum(x**14)\n\ndef f14(x, budget, dim, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5):\n    return sum(x**15)\n\ndef f15(x, budget, dim, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5):\n    return sum(x**16)\n\ndef f16(x, budget, dim, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5):\n    return sum(x**17)\n\ndef f17(x, budget, dim, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5):\n    return sum(x**18)\n\ndef f18(x, budget, dim, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5):\n    return sum(x**19)\n\ndef f19(x, budget, dim, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5):\n    return sum(x**20)\n\ndef f20(x, budget, dim, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5):\n    return sum(x**21)\n\ndef f21(x, budget, dim, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5):\n    return sum(x**22)\n\ndef f22(x, budget, dim, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5):\n    return sum(x**23)\n\ndef f23(x, budget, dim, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5):\n    return sum(x**24)\n\ndef f24(x, budget, dim, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5):\n    return sum(x**25)\n\ndef evaluateBBOB(func, budget, dim):\n    heacombbo = HEACOMBBO(budget, dim)\n    best_individual = None\n    best_fitness = float('inf')\n    for _ in range(100):\n        individual = heacombbo.x0\n        for _ in range(heacombbo.budget):\n            individual = heacombbo.refine_strategy(individual)\n            individual['func'] = func(individual)\n            fitness = individual['func']()\n            if fitness < best_fitness:\n                best_individual = individual\n                best_fitness = fitness\n    return best_individual, best_fitness\n\n# Usage\nbest_individual, best_fitness = evaluateBBOB(f1, 10, 2)\nprint(\"Best Individual:\", best_individual)\nprint(\"Best Fitness:\", best_fitness)", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) with probability-based strategy refinement.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "ce2c112c-69b1-415e-a00c-078049ef57ad", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.population_size = 20\n        self.crossover_prob = 0.4\n        self.mutation_prob = 0.1\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        population = [np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim) for _ in range(self.population_size)]\n\n        for _ in range(self.budget):\n            fitness = [func(individual) for individual in population]\n            min_fitness_idx = np.argmin(fitness)\n            min_fitness_individual = population[min_fitness_idx]\n\n            new_population = []\n            for individual in population:\n                if random.random() < self.crossover_prob:\n                    new_individual = self.crossover(individual, min_fitness_individual)\n                else:\n                    new_individual = individual\n                if random.random() < self.mutation_prob:\n                    new_individual = self.mutate(new_individual)\n                new_population.append(new_individual)\n\n            population = new_population\n\n        min_fitness_individual = min(population, key=func)\n        return func(min_fitness_individual), min_fitness_individual\n\n    def crossover(self, parent1, parent2):\n        child = [0] * self.dim\n        for i in range(self.dim):\n            if random.random() < self.crossover_prob:\n                child[i] = random.choice([parent1[i], parent2[i]])\n            else:\n                child[i] = parent1[i]\n        return child\n\n    def mutate(self, individual):\n        mutated_individual = individual.copy()\n        for i in range(self.dim):\n            if random.random() < self.mutation_prob:\n                mutated_individual[i] += random.uniform(-1, 1)\n                mutated_individual[i] = max(self.bounds[i][0], min(self.bounds[i][1], mutated_individual[i]))\n        return mutated_individual\n\n# Example usage\ndef f1(x):\n    return x[0]**2 + x[1]**2\n\ndef f2(x):\n    return x[0]**2 + 2*x[1]**2\n\ndef f3(x):\n    return x[0]**2 + 3*x[1]**2\n\ndef f4(x):\n    return x[0]**2 + 4*x[1]**2\n\ndef f5(x):\n    return x[0]**2 + 5*x[1]**2\n\ndef f6(x):\n    return x[0]**2 + 6*x[1]**2\n\ndef f7(x):\n    return x[0]**2 + 7*x[1]**2\n\ndef f8(x):\n    return x[0]**2 + 8*x[1]**2\n\ndef f9(x):\n    return x[0]**2 + 9*x[1]**2\n\ndef f10(x):\n    return x[0]**2 + 10*x[1]**2\n\ndef f11(x):\n    return x[0]**2 + 11*x[1]**2\n\ndef f12(x):\n    return x[0]**2 + 12*x[1]**2\n\ndef f13(x):\n    return x[0]**2 + 13*x[1]**2\n\ndef f14(x):\n    return x[0]**2 + 14*x[1]**2\n\ndef f15(x):\n    return x[0]**2 + 15*x[1]**2\n\ndef f16(x):\n    return x[0]**2 + 16*x[1]**2\n\ndef f17(x):\n    return x[0]**2 + 17*x[1]**2\n\ndef f18(x):\n    return x[0]**2 + 18*x[1]**2\n\ndef f19(x):\n    return x[0]**2 + 19*x[1]**2\n\ndef f20(x):\n    return x[0]**2 + 20*x[1]**2\n\ndef f21(x):\n    return x[0]**2 + 21*x[1]**2\n\ndef f22(x):\n    return x[0]**2 + 22*x[1]**2\n\ndef f23(x):\n    return x[0]**2 + 23*x[1]**2\n\ndef f24(x):\n    return x[0]**2 + 24*x[1]**2\n\nbudget = 100\ndim = 2\nalgorithm = HybridEvolutionaryAlgorithm(budget, dim)\nfor func in [f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16, f17, f18, f19, f20, f21, f22, f23, f24]:\n    result = algorithm(func)\n    print(f\"Function: {func.__name__}, Result: {result[0]}, Individual: {result[1]}\")", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "ce069e9a-37e2-4105-84a6-05ee0803b229", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\n\nclass HybridBlackBoxOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        # Select a random individual from the current population\n        individual = np.random.choice(self.x0)\n\n        # Evaluate the fitness of the individual\n        fitness = func(individual)\n\n        # If the budget is not exhausted, refine the individual's strategy\n        if self.budget > 1:\n            # Randomly select two lines of the individual\n            line1, line2 = random.sample(range(self.dim), 2)\n\n            # Randomly select a new strategy\n            new_strategy = random.choice(['sbx', 'rand1', 'log-uniform'])\n\n            # Create a new individual with the refined strategy\n            new_individual = np.copy(individual)\n            new_individual[line1] = new_strategy\n            new_individual[line2] = new_strategy\n\n            # Evaluate the fitness of the new individual\n            new_fitness = func(new_individual)\n\n            # If the new individual's fitness is better, update the individual\n            if new_fitness < fitness:\n                individual = new_individual\n\n        # Return the individual and its fitness\n        return individual, fitness\n\n# Example usage:\ndef f1(x):\n    return np.sum(x**2)\n\ndef f2(x):\n    return np.sum(x**2) + 2 * np.sum(x)\n\ndef f3(x):\n    return np.sum(x**2) + 2 * np.sum(x) + 3 * np.sum(x**2)\n\ndef f4(x):\n    return np.sum(x**2) + 2 * np.sum(x) + 3 * np.sum(x**2) + 4 * np.sum(x)\n\ndef f5(x):\n    return np.sum(x**2) + 2 * np.sum(x) + 3 * np.sum(x**2) + 4 * np.sum(x) + 5 * np.sum(x**2)\n\ndef f6(x):\n    return np.sum(x**2) + 2 * np.sum(x) + 3 * np.sum(x**2) + 4 * np.sum(x) + 5 * np.sum(x**2) + 6 * np.sum(x)\n\ndef f7(x):\n    return np.sum(x**2) + 2 * np.sum(x) + 3 * np.sum(x**2) + 4 * np.sum(x) + 5 * np.sum(x**2) + 6 * np.sum(x) + 7 * np.sum(x**2)\n\ndef f8(x):\n    return np.sum(x**2) + 2 * np.sum(x) + 3 * np.sum(x**2) + 4 * np.sum(x) + 5 * np.sum(x**2) + 6 * np.sum(x) + 7 * np.sum(x**2) + 8 * np.sum(x**2)\n\ndef f9(x):\n    return np.sum(x**2) + 2 * np.sum(x) + 3 * np.sum(x**2) + 4 * np.sum(x) + 5 * np.sum(x**2) + 6 * np.sum(x) + 7 * np.sum(x**2) + 8 * np.sum(x**2) + 9 * np.sum(x**2)\n\ndef f10(x):\n    return np.sum(x**2) + 2 * np.sum(x) + 3 * np.sum(x**2) + 4 * np.sum(x) + 5 * np.sum(x**2) + 6 * np.sum(x) + 7 * np.sum(x**2) + 8 * np.sum(x**2) + 9 * np.sum(x**2) + 10 * np.sum(x**2)\n\ndef f11(x):\n    return np.sum(x**2) + 2 * np.sum(x) + 3 * np.sum(x**2) + 4 * np.sum(x) + 5 * np.sum(x**2) + 6 * np.sum(x) + 7 * np.sum(x**2) + 8 * np.sum(x**2) + 9 * np.sum(x**2) + 10 * np.sum(x**2) + 11 * np.sum(x**2)\n\ndef f12(x):\n    return np.sum(x**2) + 2 * np.sum(x) + 3 * np.sum(x**2) + 4 * np.sum(x) + 5 * np.sum(x**2) + 6 * np.sum(x) + 7 * np.sum(x**2) + 8 * np.sum(x**2) + 9 * np.sum(x**2) + 10 * np.sum(x**2) + 11 * np.sum(x**2) + 12 * np.sum(x**2)\n\ndef f13(x):\n    return np.sum(x**2) + 2 * np.sum(x) + 3 * np.sum(x**2) + 4 * np.sum(x) + 5 * np.sum(x**2) + 6 * np.sum(x) + 7 * np.sum(x**2) + 8 * np.sum(x**2) + 9 * np.sum(x**2) + 10 * np.sum(x**2) + 11 * np.sum(x**2) + 12 * np.sum(x**2) + 13 * np.sum(x**2)\n\ndef f14(x):\n    return np.sum(x**2) + 2 * np.sum(x) + 3 * np.sum(x**2) + 4 * np.sum(x) + 5 * np.sum(x**2) + 6 * np.sum(x) + 7 * np.sum(x**2) + 8 * np.sum(x**2) + 9 * np.sum(x**2) + 10 * np.sum(x**2) + 11 * np.sum(x**2) + 12 * np.sum(x**2) + 13 * np.sum(x**2) + 14 * np.sum(x**2)\n\ndef f15(x):\n    return np.sum(x**2) + 2 * np.sum(x) + 3 * np.sum(x**2) + 4 * np.sum(x) + 5 * np.sum(x**2) + 6 * np.sum(x) + 7 * np.sum(x**2) + 8 * np.sum(x**2) + 9 * np.sum(x**2) + 10 * np.sum(x**2) + 11 * np.sum(x**2) + 12 * np.sum(x**2) + 13 * np.sum(x**2) + 14 * np.sum(x**2) + 15 * np.sum(x**2)\n\ndef f16(x):\n    return np.sum(x**2) + 2 * np.sum(x) + 3 * np.sum(x**2) + 4 * np.sum(x) + 5 * np.sum(x**2) + 6 * np.sum(x) + 7 * np.sum(x**2) + 8 * np.sum(x**2) + 9 * np.sum(x**2) + 10 * np.sum(x**2) + 11 * np.sum(x**2) + 12 * np.sum(x**2) + 13 * np.sum(x**2) + 14 * np.sum(x**2) + 15 * np.sum(x**2) + 16 * np.sum(x**2)\n\ndef f17(x):\n    return np.sum(x**2) + 2 * np.sum(x) + 3 * np.sum(x**2) + 4 * np.sum(x) + 5 * np.sum(x**2) + 6 * np.sum(x) + 7 * np.sum(x**2) + 8 * np.sum(x**2) + 9 * np.sum(x**2) + 10 * np.sum(x**2) + 11 * np.sum(x**2) + 12 * np.sum(x**2) + 13 * np.sum(x**2) + 14 * np.sum(x**2) + 15 * np.sum(x**2) + 16 * np.sum(x**2) + 17 * np.sum(x**2)\n\ndef f18(x):\n    return np.sum(x**2) + 2 * np.sum(x) + 3 * np.sum(x**2) + 4 * np.sum(x) + 5 * np.sum(x**2) + 6 * np.sum(x) + 7 * np.sum(x**2) + 8 * np.sum(x**2) + 9 * np.sum(x**2) + 10 * np.sum(x**2) + 11 * np.sum(x**2) + 12 * np.sum(x**2) + 13 * np.sum(x**2) + 14 * np.sum(x**2) + 15 * np.sum(x**2) + 16 * np.sum(x**2) + 17 * np.sum(x**2) + 18 * np.sum(x**2)\n\ndef f19(x):\n    return np.sum(x**2) + 2 * np.sum(x) + 3 * np.sum(x**2) + 4 * np.sum(x) + 5 * np.sum(x**2) + 6 * np.sum(x) + 7 * np.sum(x**2) + 8 * np.sum(x**2) + 9 * np.sum(x**2) + 10 * np.sum(x**2) + 11 * np.sum(x**2) + 12 * np.sum(x**2) + 13 * np.sum(x**2) + 14 * np.sum(x**2) + 15 * np.sum(x**2) + 16 * np.sum(x**2) + 17 * np.sum(x**2) + 18 * np.sum(x**2) + 19 * np.sum(x**2)\n\ndef f20(x):\n    return np.sum(x**2) + 2 * np.sum(x) + 3 * np.sum(x**2) + 4 * np.sum(x) + 5 * np.sum(x**2) + 6 * np.sum(x) + 7 * np.sum(x**2) + 8 * np.sum(x**2) + 9 * np.sum(x**2) + 10 * np.sum(x**2) + 11 * np.sum(x**2) + 12 * np.sum(x**2) + 13 * np.sum(x**2) + 14 * np.sum(x**2) + 15 * np.sum(x**2) + 16 * np.sum(x**2) + 17 * np.sum(x**2) + 18 * np.sum(x**2) + 19 * np.sum(x**2) + 20 * np.sum(x**2)\n\ndef f21(x):\n    return np.sum(x**2) + 2 * np.sum(x) + 3 * np.sum(x**2) + 4 * np.sum(x) + 5 * np.sum(x**2) + 6 * np.sum(x) + 7 * np.sum(x**2) + 8 * np.sum(x**2) + 9 * np.sum(x**2) + 10 * np.sum(x**2) + 11 * np.sum(x**2) + 12 * np.sum(x**2) + 13 * np.sum(x**2) + 14 * np.sum(x**2) + 15 * np.sum(x**2) + 16 * np.sum(x**2) + 17 * np.sum(x**2) + 18 * np.sum(x**2) + 19 * np.sum(x**2) + 20 * np.sum(x**2) + 21 * np.sum(x**2)\n\ndef f22(x):\n    return np.sum(x**2) + 2 * np.sum(x) + 3 * np.sum(x**2) + 4 * np.sum(x) + 5 * np.sum(x**2) + 6 * np.sum(x) + 7 * np.sum(x**2) + 8 * np.sum(x**2) + 9 * np.sum(x**2) + 10 * np.sum(x**2) + 11 * np.sum(x**2) + 12 * np.sum(x**2) + 13 * np.sum(x**2) + 14 * np.sum(x**2) + 15 * np.sum(x**2) + 16 * np.sum(x**2) + 17 * np.sum(x**2) + 18 * np.sum(x**2) + 19 * np.sum(x**2) + 20 * np.sum(x**2) + 21 * np.sum(x**2) + 22 * np.sum(x**2)\n\ndef f23(x):\n    return np.sum(x**2) + 2 * np.sum(x) + 3 * np.sum(x**2) + 4 * np.sum(x) + 5 * np.sum(x**2) + 6 * np.sum(x) + 7 * np.sum(x**2) + 8 * np.sum(x**2) + 9 * np.sum(x**2) + 10 * np.sum(x**2) + 11 * np.sum(x**2) + 12 * np.sum(x**2) + 13 * np.sum(x**2) + 14 * np.sum(x**2) + 15 * np.sum(x**2) + 16 * np.sum(x**2) + 17 * np.sum(x**2) + 18 * np.sum(x**2) + 19 * np.sum(x**2) + 20 * np.sum(x**2) + 21 * np.sum(x**2) + 22 * np.sum(x**2) + 23 * np.sum(x**2)\n\ndef f24(x):\n    return np.sum(x**2) + 2 * np.sum(x) + 3 * np.sum(x**2) + 4 * np.sum(x) + 5 * np.sum(x**2) + 6 * np.sum(x) + 7 * np.sum(x**2) + 8 * np.sum(x**2) + 9 * np.sum(x**2) + 10 * np.sum(x**2) + 11 * np.sum(x**2) + 12 * np.sum(x**2) + 13 * np.sum(x**2) + 14 * np.sum(x**2) + 15 * np.sum(x**2) + 16 * np.sum(x**2) + 17 * np.sum(x**2) + 18 * np.sum(x**2) + 19 * np.sum(x**2) + 20 * np.sum(x**2) + 21 * np.sum(x**2) + 22 * np.sum(x**2) + 23 * np.sum(x**2) + 24 * np.sum(x**2)\n\noptimizer = HybridBlackBoxOptimizer(budget=10, dim=10)\nfor i in range(10):\n    func_name = f\"f{i+1}\"\n    func = globals()[func_name]\n    individual, fitness = optimizer(func)\n    print(f\"Individual: {individual}, Fitness: {fitness}\")", "name": "HybridBlackBoxOptimizer", "description": "Novel hybrid metaheuristic algorithm with crossover and mutation for black box optimization.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('too many indices for array: array is 0-dimensional, but 1 were indexed').", "error": "IndexError('too many indices for array: array is 0-dimensional, but 1 were indexed')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "74279aaa-d50b-45af-a1ef-e7b1e9ce2615", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.population_size = 100\n        self.population = np.random.uniform(self.bounds[0][0], self.bounds[0][1], (self.population_size, self.dim))\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        for _ in range(self.budget):\n            # Select parents using tournament selection\n            parents = self.select_parents()\n\n            # Crossover and mutate the selected parents\n            offspring = self.crossover_and_mutate(parents)\n\n            # Evaluate the fitness of the offspring\n            fitness = self.evaluate_fitness(offspring)\n\n            # Update the population\n            self.population = np.concatenate((self.population, offspring), axis=0)\n\n            # Refine the strategy of the selected individuals\n            self.refine_strategy()\n\n        # Return the best individual\n        return np.min(self.population, axis=0), np.min(self.population, axis=1)\n\n    def select_parents(self):\n        # Select 2 parents using tournament selection\n        parents = []\n        for _ in range(2):\n            tournament = np.random.choice(self.population, 5, replace=False)\n            winner = np.argmin(tournament)\n            parents.append(tournament[winner])\n        return parents\n\n    def crossover_and_mutate(self, parents):\n        # Perform crossover and mutation on the selected parents\n        offspring = []\n        for parent in parents:\n            child = parent + np.random.normal(0, 0.1, self.dim)\n            child = np.clip(child, self.bounds[0][0], self.bounds[0][1])\n            offspring.append(child)\n        return offspring\n\n    def evaluate_fitness(self, individuals):\n        # Evaluate the fitness of the individuals\n        fitness = []\n        for individual in individuals:\n            fitness.append(func(individual))\n        return fitness\n\n    def refine_strategy(self):\n        # Refine the strategy of the selected individuals\n        selected_individuals = np.random.choice(self.population, 20, replace=False)\n        for individual in selected_individuals:\n            strategy = np.random.choice(['sbx', 'rand1'], p=[0.4, 0.6])\n            if strategy =='sbx':\n                individual = individual + np.random.normal(0, 0.1, self.dim)\n                individual = np.clip(individual, self.bounds[0][0], self.bounds[0][1])\n            elif strategy == 'rand1':\n                individual = individual + np.random.normal(0, 0.1, self.dim)\n                individual = np.clip(individual, self.bounds[0][0], self.bounds[0][1])\n            individual = individual.tolist()\n\n# Example usage:\nfunc = lambda x: x[0]**2 + x[1]**2\nheacombbo = HybridEvolutionaryAlgorithm(100, 2)\nbest_individual, best_fitness = heacombbo(func)\nprint(f'Best individual: {best_individual}')\nprint(f'Best fitness: {best_fitness}')", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "21da5555-ea74-4b56-947d-becdc40c42fc", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "e11fe428-2a1b-4734-923e-1bc3f04ad260", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "a12a35b9-d162-47e6-87ed-78c2c918fe32", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.probability = 0.4\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def evaluate_fitness(self, individual):\n        func_name = individual[0]\n        func = globals()[func_name]\n        result = func(*individual[1:])\n        return result\n\n    def refine_strategy(self, individual):\n        func_name = individual[0]\n        func = globals()[func_name]\n        result = func(*individual[1:])\n        if np.random.rand() < self.probability:\n            # Refine the strategy by changing the individual lines\n            # For example, change the mutation strategy\n            individual[1] = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            individual = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n            result = self.evaluate_fitness(individual)\n            if result < np.nan:\n                # Update the individual with the refined strategy\n                individual = self.refine_strategy(individual)\n                result = self.evaluate_fitness(individual)\n            yield individual, result\n\n# Example usage:\nbudget = 100\ndim = 10\nheacombbo = HEACOMBBO(budget, dim)\nfor individual, result in heacombbo.optimize(func):\n    print(individual, result)", "name": "HEACOMBBO", "description": "Novel metaheuristic algorithm using Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) and probability-based strategy refinement.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "6db46306-65a2-41a3-9782-81d44fc271c1", "solution": "import numpy as np\nimport random\nimport copy\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.population_size = 20\n        self.population = [copy.deepcopy(self.x0) for _ in range(self.population_size)]\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        for _ in range(self.budget):\n            new_population = []\n            for individual in self.population:\n                # Crossover\n                if random.random() < 0.4:\n                    parent1, parent2 = random.sample(self.population, 2)\n                    child = [random.uniform(parent1[i], parent2[i]) for i in range(self.dim)]\n                else:\n                    child = individual\n\n                # Mutation\n                if random.random() < 0.1:\n                    mutation = random.uniform(-1, 1)\n                    child = [child[i] + mutation if random.random() < 0.5 else child[i] - mutation for i in range(self.dim)]\n\n                new_population.append(child)\n\n            self.population = new_population\n\n            # Evaluate fitness\n            fitness = [func(individual) for individual in self.population]\n            min_fitness = min(fitness)\n            min_index = fitness.index(min_fitness)\n            self.population = [individual for i, individual in enumerate(self.population) if i!= min_index]\n\n            # Replace worst individual\n            worst_individual = self.population[-1]\n            self.population[-1] = copy.deepcopy(self.population[min_index])\n\n        return self.population[0], func(self.population[0])\n\n# Usage\nbudget = 100\ndim = 10\nfunc = lambda x: sum([i**2 for i in x])\nalgorithm = HybridEvolutionaryAlgorithm(budget, dim)\nresult = algorithm(func)\nprint(result)", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "d9358f15-39ce-40fe-a524-d28bc220ac1a", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.population_size = 100\n        self.crossover_probability = 0.4\n        self.mutation_probability = 0.1\n        self.logger = []\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if len(self.logger) == 0:\n            self.logger.append(func(self.x0))\n\n        while self.budget > 0:\n            self.budget -= 1\n\n            # Select parents\n            parents = np.array([random.choice(self.logger) for _ in range(self.population_size)])\n\n            # Crossover\n            offspring = []\n            for _ in range(self.population_size):\n                parent1, parent2 = random.sample(parents, 2)\n                if random.random() < self.crossover_probability:\n                    child = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n                    child = child * (parent1 - parent2) + parent2\n                    offspring.append(child)\n                else:\n                    offspring.append(parent1)\n\n            # Mutation\n            for i in range(self.population_size):\n                if random.random() < self.mutation_probability:\n                    offspring[i] = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n            # Evaluate fitness\n            offspring_fitness = [func(individual) for individual in offspring]\n\n            # Replace worst individual\n            worst_index = np.argmin(offspring_fitness)\n            self.logger[worst_index] = offspring[worst_index]\n\n            # Update logger\n            self.logger.sort()\n            self.logger = self.logger[:self.population_size]\n\n        # Return best individual\n        best_individual = np.min(self.logger)\n        return best_individual, self.logger[0]\n\n# Example usage:\ndef f1(x):\n    return x[0]**2 + x[1]**2\n\ndef f2(x):\n    return x[0]**2 + x[1]**2 + 1e-6\n\ndef f3(x):\n    return x[0]**2 + x[1]**2 + 1e-6 + 1e-6\n\ndef f4(x):\n    return x[0]**2 + x[1]**2 + 1e-6 + 1e-6 + 1e-6\n\ndef f5(x):\n    return x[0]**2 + x[1]**2 + 1e-6 + 1e-6 + 1e-6 + 1e-6\n\ndef f6(x):\n    return x[0]**2 + x[1]**2 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6\n\ndef f7(x):\n    return x[0]**2 + x[1]**2 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6\n\ndef f8(x):\n    return x[0]**2 + x[1]**2 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6\n\ndef f9(x):\n    return x[0]**2 + x[1]**2 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6\n\ndef f10(x):\n    return x[0]**2 + x[1]**2 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6\n\ndef f11(x):\n    return x[0]**2 + x[1]**2 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6\n\ndef f12(x):\n    return x[0]**2 + x[1]**2 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6\n\ndef f13(x):\n    return x[0]**2 + x[1]**2 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6\n\ndef f14(x):\n    return x[0]**2 + x[1]**2 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6\n\ndef f15(x):\n    return x[0]**2 + x[1]**2 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6\n\ndef f16(x):\n    return x[0]**2 + x[1]**2 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6\n\ndef f17(x):\n    return x[0]**2 + x[1]**2 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6\n\ndef f18(x):\n    return x[0]**2 + x[1]**2 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6\n\ndef f19(x):\n    return x[0]**2 + x[1]**2 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6\n\ndef f20(x):\n    return x[0]**2 + x[1]**2 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6\n\ndef f21(x):\n    return x[0]**2 + x[1]**2 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6\n\ndef f22(x):\n    return x[0]**2 + x[1]**2 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6\n\ndef f23(x):\n    return x[0]**2 + x[1]**2 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6\n\ndef f24(x):\n    return x[0]**2 + x[1]**2 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6 + 1e-6\n\n# Example usage\nalgorithm = HybridEvolutionaryAlgorithm(budget=10, dim=2)\nbest_individual, best_fitness = algorithm(f1)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)\n\nbest_individual, best_fitness = algorithm(f2)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)\n\nbest_individual, best_fitness = algorithm(f3)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)\n\nbest_individual, best_fitness = algorithm(f4)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)\n\nbest_individual, best_fitness = algorithm(f5)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)\n\nbest_individual, best_fitness = algorithm(f6)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)\n\nbest_individual, best_fitness = algorithm(f7)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)\n\nbest_individual, best_fitness = algorithm(f8)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)\n\nbest_individual, best_fitness = algorithm(f9)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)\n\nbest_individual, best_fitness = algorithm(f10)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)\n\nbest_individual, best_fitness = algorithm(f11)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)\n\nbest_individual, best_fitness = algorithm(f12)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)\n\nbest_individual, best_fitness = algorithm(f13)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)\n\nbest_individual, best_fitness = algorithm(f14)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)\n\nbest_individual, best_fitness = algorithm(f15)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)\n\nbest_individual, best_fitness = algorithm(f16)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)\n\nbest_individual, best_fitness = algorithm(f17)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)\n\nbest_individual, best_fitness = algorithm(f18)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)\n\nbest_individual, best_fitness = algorithm(f19)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)\n\nbest_individual, best_fitness = algorithm(f20)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)\n\nbest_individual, best_fitness = algorithm(f21)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)\n\nbest_individual, best_fitness = algorithm(f22)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)\n\nbest_individual, best_fitness = algorithm(f23)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)\n\nbest_individual, best_fitness = algorithm(f24)\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)", "name": "HybridEvolutionaryAlgorithm", "description": "Novel hybrid evolutionary algorithm with crossover and mutation for black box optimization", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "255e0d9f-be96-41d0-b8e3-ef8e2f929ffd", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "9750008c-3754-4300-a3f6-891edd03fecf", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def hybrid_evolution(self, func, population_size=10, mutation_rate=0.1):\n        population = [np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim) for _ in range(population_size)]\n        for _ in range(50):\n            new_population = []\n            for individual in population:\n                if random.random() < mutation_rate:\n                    new_individual = individual + np.random.uniform(-1, 1, self.dim)\n                else:\n                    new_individual = individual\n                new_population.append(new_individual)\n            population = new_population\n        return self.f(func, population)\n\n    def f(self, func, population):\n        min_value = float('inf')\n        best_individual = None\n        for individual in population:\n            value = func(individual)\n            if value < min_value:\n                min_value = value\n                best_individual = individual\n        return min_value, best_individual\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2\n        return child\n\n    def mutation(self, individual):\n        mutation_index = random.randint(0, self.dim - 1)\n        mutation_amount = np.random.uniform(-1, 1)\n        individual[mutation_index] += mutation_amount\n        return individual\n\n# Usage\nbbo_test_suite = ['f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'f11', 'f12', 'f13', 'f14', 'f15', 'f16', 'f17', 'f18', 'f19', 'f20', 'f21', 'f22', 'f23', 'f24']\nfor func in bbo_test_suite:\n    heacombbo = HEACOMBBO(budget=50, dim=10)\n    result = heacombbo(func)\n    print(f\"Function: {func}, Min Value: {result[0]}, Best Individual: {result[1]}\")", "name": "HEACOMBBO", "description": "Novel Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) using probability 0.4 to refine the strategy.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "f0553274-6b6f-4647-9507-5c85502c5da8", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def hybridize(self, func):\n        new_individual = func(self.x0)\n        if random.random() < 0.4:\n            new_individual[0] += random.uniform(-1, 1)\n        if random.random() < 0.4:\n            new_individual[1] += random.uniform(-1, 1)\n        return new_individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            new_individual = self.hybridize(func)\n            func(new_individual)\n\n# Usage\ndef f1(x):\n    return (x[0] - 2)**2 + (x[1] - 2)**2\n\ndef f2(x):\n    return (x[0] - 1)**2 + (x[1] - 3)**2\n\ndef f3(x):\n    return (x[0] - 1)**2 + (x[1] - 2)**2\n\ndef f4(x):\n    return (x[0] - 2)**2 + (x[1] - 3)**2\n\ndef f5(x):\n    return (x[0] - 1)**2 + (x[1] - 2)**2 + (x[2] - 3)**2\n\ndef f6(x):\n    return (x[0] - 1)**2 + (x[1] - 2)**2 + (x[2] - 3)**2 + (x[3] - 4)**2\n\ndef f7(x):\n    return (x[0] - 1)**2 + (x[1] - 2)**2 + (x[2] - 3)**2 + (x[3] - 4)**2 + (x[4] - 5)**2\n\ndef f8(x):\n    return (x[0] - 1)**2 + (x[1] - 2)**2 + (x[2] - 3)**2 + (x[3] - 4)**2 + (x[4] - 5)**2 + (x[5] - 6)**2\n\ndef f9(x):\n    return (x[0] - 1)**2 + (x[1] - 2)**2 + (x[2] - 3)**2 + (x[3] - 4)**2 + (x[4] - 5)**2 + (x[5] - 6)**2 + (x[6] - 7)**2\n\ndef f10(x):\n    return (x[0] - 1)**2 + (x[1] - 2)**2 + (x[2] - 3)**2 + (x[3] - 4)**2 + (x[4] - 5)**2 + (x[5] - 6)**2 + (x[6] - 7)**2 + (x[7] - 8)**2\n\ndef f11(x):\n    return (x[0] - 1)**2 + (x[1] - 2)**2 + (x[2] - 3)**2 + (x[3] - 4)**2 + (x[4] - 5)**2 + (x[5] - 6)**2 + (x[6] - 7)**2 + (x[7] - 8)**2 + (x[8] - 9)**2\n\ndef f12(x):\n    return (x[0] - 1)**2 + (x[1] - 2)**2 + (x[2] - 3)**2 + (x[3] - 4)**2 + (x[4] - 5)**2 + (x[5] - 6)**2 + (x[6] - 7)**2 + (x[7] - 8)**2 + (x[8] - 9)**2 + (x[9] - 10)**2\n\ndef f13(x):\n    return (x[0] - 1)**2 + (x[1] - 2)**2 + (x[2] - 3)**2 + (x[3] - 4)**2 + (x[4] - 5)**2 + (x[5] - 6)**2 + (x[6] - 7)**2 + (x[7] - 8)**2 + (x[8] - 9)**2 + (x[9] - 10)**2 + (x[10] - 11)**2\n\ndef f14(x):\n    return (x[0] - 1)**2 + (x[1] - 2)**2 + (x[2] - 3)**2 + (x[3] - 4)**2 + (x[4] - 5)**2 + (x[5] - 6)**2 + (x[6] - 7)**2 + (x[7] - 8)**2 + (x[8] - 9)**2 + (x[9] - 10)**2 + (x[10] - 11)**2 + (x[11] - 12)**2\n\ndef f15(x):\n    return (x[0] - 1)**2 + (x[1] - 2)**2 + (x[2] - 3)**2 + (x[3] - 4)**2 + (x[4] - 5)**2 + (x[5] - 6)**2 + (x[6] - 7)**2 + (x[7] - 8)**2 + (x[8] - 9)**2 + (x[9] - 10)**2 + (x[10] - 11)**2 + (x[11] - 12)**2 + (x[12] - 13)**2\n\ndef f16(x):\n    return (x[0] - 1)**2 + (x[1] - 2)**2 + (x[2] - 3)**2 + (x[3] - 4)**2 + (x[4] - 5)**2 + (x[5] - 6)**2 + (x[6] - 7)**2 + (x[7] - 8)**2 + (x[8] - 9)**2 + (x[9] - 10)**2 + (x[10] - 11)**2 + (x[11] - 12)**2 + (x[12] - 13)**2 + (x[13] - 14)**2\n\ndef f17(x):\n    return (x[0] - 1)**2 + (x[1] - 2)**2 + (x[2] - 3)**2 + (x[3] - 4)**2 + (x[4] - 5)**2 + (x[5] - 6)**2 + (x[6] - 7)**2 + (x[7] - 8)**2 + (x[8] - 9)**2 + (x[9] - 10)**2 + (x[10] - 11)**2 + (x[11] - 12)**2 + (x[12] - 13)**2 + (x[13] - 14)**2 + (x[14] - 15)**2\n\ndef f18(x):\n    return (x[0] - 1)**2 + (x[1] - 2)**2 + (x[2] - 3)**2 + (x[3] - 4)**2 + (x[4] - 5)**2 + (x[5] - 6)**2 + (x[6] - 7)**2 + (x[7] - 8)**2 + (x[8] - 9)**2 + (x[9] - 10)**2 + (x[10] - 11)**2 + (x[11] - 12)**2 + (x[12] - 13)**2 + (x[13] - 14)**2 + (x[14] - 15)**2 + (x[15] - 16)**2\n\ndef f19(x):\n    return (x[0] - 1)**2 + (x[1] - 2)**2 + (x[2] - 3)**2 + (x[3] - 4)**2 + (x[4] - 5)**2 + (x[5] - 6)**2 + (x[6] - 7)**2 + (x[7] - 8)**2 + (x[8] - 9)**2 + (x[9] - 10)**2 + (x[10] - 11)**2 + (x[11] - 12)**2 + (x[12] - 13)**2 + (x[13] - 14)**2 + (x[14] - 15)**2 + (x[15] - 16)**2 + (x[16] - 17)**2\n\ndef f20(x):\n    return (x[0] - 1)**2 + (x[1] - 2)**2 + (x[2] - 3)**2 + (x[3] - 4)**2 + (x[4] - 5)**2 + (x[5] - 6)**2 + (x[6] - 7)**2 + (x[7] - 8)**2 + (x[8] - 9)**2 + (x[9] - 10)**2 + (x[10] - 11)**2 + (x[11] - 12)**2 + (x[12] - 13)**2 + (x[13] - 14)**2 + (x[14] - 15)**2 + (x[15] - 16)**2 + (x[16] - 17)**2 + (x[17] - 18)**2\n\ndef f21(x):\n    return (x[0] - 1)**2 + (x[1] - 2)**2 + (x[2] - 3)**2 + (x[3] - 4)**2 + (x[4] - 5)**2 + (x[5] - 6)**2 + (x[6] - 7)**2 + (x[7] - 8)**2 + (x[8] - 9)**2 + (x[9] - 10)**2 + (x[10] - 11)**2 + (x[11] - 12)**2 + (x[12] - 13)**2 + (x[13] - 14)**2 + (x[14] - 15)**2 + (x[15] - 16)**2 + (x[16] - 17)**2 + (x[17] - 18)**2 + (x[18] - 19)**2\n\ndef f22(x):\n    return (x[0] - 1)**2 + (x[1] - 2)**2 + (x[2] - 3)**2 + (x[3] - 4)**2 + (x[4] - 5)**2 + (x[5] - 6)**2 + (x[6] - 7)**2 + (x[7] - 8)**2 + (x[8] - 9)**2 + (x[9] - 10)**2 + (x[10] - 11)**2 + (x[11] - 12)**2 + (x[12] - 13)**2 + (x[13] - 14)**2 + (x[14] - 15)**2 + (x[15] - 16)**2 + (x[16] - 17)**2 + (x[17] - 18)**2 + (x[18] - 19)**2 + (x[19] - 20)**2\n\ndef f23(x):\n    return (x[0] - 1)**2 + (x[1] - 2)**2 + (x[2] - 3)**2 + (x[3] - 4)**2 + (x[4] - 5)**2 + (x[5] - 6)**2 + (x[6] - 7)**2 + (x[7] - 8)**2 + (x[8] - 9)**2 + (x[9] - 10)**2 + (x[10] - 11)**2 + (x[11] - 12)**2 + (x[12] - 13)**2 + (x[13] - 14)**2 + (x[14] - 15)**2 + (x[15] - 16)**2 + (x[16] - 17)**2 + (x[17] - 18)**2 + (x[18] - 19)**2 + (x[19] - 20)**2 + (x[20] - 21)**2\n\ndef f24(x):\n    return (x[0] - 1)**2 + (x[1] - 2)**2 + (x[2] - 3)**2 + (x[3] - 4)**2 + (x[4] - 5)**2 + (x[5] - 6)**2 + (x[6] - 7)**2 + (x[7] - 8)**2 + (x[8] - 9)**2 + (x[9] - 10)**2 + (x[10] - 11)**2 + (x[11] - 12)**2 + (x[12] - 13)**2 + (x[13] - 14)**2 + (x[14] - 15)**2 + (x[15] - 16)**2 + (x[16] - 17)**2 + (x[17] - 18)**2 + (x[18] - 19)**2 + (x[19] - 20)**2 + (x[20] - 21)**2 + (x[21] - 22)**2\n\n# Usage\nalgorithm = HybridEvolutionaryAlgorithm(100, 2)\nalgorithm.optimize(f1)", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "b762b03c-84c1-4ba2-8fe2-a581ebd3f7bd", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        def mutate(individual):\n            if np.random.rand() < 0.4:\n                individual = individual + np.random.uniform(-1, 1, self.dim)\n            return individual\n\n        def crossover(parent1, parent2):\n            if np.random.rand() < 0.5:\n                child = parent1 + parent2 - np.sum(parent1 + parent2, axis=0) / 2\n            else:\n                child = parent1 - parent2\n            return child\n\n        def hybrid_evolution(func):\n            population = [np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim) for _ in range(100)]\n            for _ in range(self.budget):\n                new_population = []\n                for individual in population:\n                    mutated_individual = mutate(individual)\n                    new_population.append(mutated_individual)\n                population = new_population\n                new_population = []\n                for i in range(len(population)):\n                    parent1, parent2 = population[np.random.choice(len(population), 2, replace=False)]\n                    child = crossover(parent1, parent2)\n                    new_population.append(child)\n                population = new_population\n            return differential_evolution(func, self.bounds, x0=np.mean(population, axis=0))\n\n        return hybrid_evolution(func)\n\n# Usage\nbudget = 100\ndim = 5\nfunc = lambda x: x[0]**2 + x[1]**2 + x[2]**2 + x[3]**2 + x[4]**2\nheacombbo = HEACOMBBO(budget, dim)\nresult = heacombbo(func)\nprint(result)", "name": "HEACOMBBO", "description": "Novel Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('only integer scalar arrays can be converted to a scalar index').", "error": "TypeError('only integer scalar arrays can be converted to a scalar index')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "64b209a4-e898-48f4-a8f1-cee42c660aae", "solution": "import numpy as np\nimport random\nimport time\nfrom scipy.optimize import differential_evolution\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.4\n        self.fitness_function = None\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if self.fitness_function is None:\n            self.fitness_function = func\n\n        for _ in range(self.population_size):\n            # Select parents\n            parents = random.sample(range(self.population_size), 2)\n\n            # Crossover\n            child1, child2 = self.crossover(parents)\n\n            # Mutation\n            child1 = self.mutate(child1)\n            child2 = self.mutate(child2)\n\n            # Evaluate fitness\n            fitness1 = self.evaluate_fitness(child1)\n            fitness2 = self.evaluate_fitness(child2)\n\n            # Replace worst individual\n            self.replace_worst(child1, fitness1)\n            self.replace_worst(child2, fitness2)\n\n        # Refine strategy\n        self.refine_strategy()\n\n        # Return best individual\n        return self.get_best_individual()\n\n    def crossover(self, parents):\n        child1 = parents[0].copy()\n        child2 = parents[1].copy()\n\n        # Crossover probability\n        if random.random() < self.crossover_rate:\n            for i in range(self.dim):\n                if random.random() < 0.5:\n                    child1[i] = parents[0][i]\n                else:\n                    child2[i] = parents[1][i]\n\n        return child1, child2\n\n    def mutate(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1, 1)\n\n        return individual\n\n    def evaluate_fitness(self, individual):\n        return self.fitness_function(individual)\n\n    def replace_worst(self, individual, fitness):\n        if fitness < self.get_best_individual()[1]:\n            self.population.remove(individual)\n            self.population.append(individual)\n\n    def refine_strategy(self):\n        # Select 20% of the population\n        selected_individuals = random.sample(self.population, int(0.2 * self.population_size))\n\n        # Change strategy for selected individuals\n        for individual in selected_individuals:\n            for i in range(self.dim):\n                if random.random() < 0.4:\n                    individual[i] += random.uniform(-1, 1)\n\n    def get_best_individual(self):\n        return min(self.population, key=lambda x: self.evaluate_fitness(x))\n\n# Example usage:\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    func = lambda x: x[0]**2 + x[1]**2\n    heacombbo = HybridEvolutionaryAlgorithm(budget, dim)\n    start_time = time.time()\n    best_individual, best_fitness = heacombbo(func)\n    print(\"Best individual:\", best_individual)\n    print(\"Best fitness:\", best_fitness)\n    print(\"Time taken:\", time.time() - start_time)", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'int' object has no attribute 'copy'\").", "error": "AttributeError(\"'int' object has no attribute 'copy'\")", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "07d64f2f-26cd-41d1-b44d-5cb11b11ea18", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        for _ in range(self.budget):\n            new_individual = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n            if np.random.rand() < 0.4:\n                new_individual = self.f(new_individual, func)\n            updated_individual = self.f(new_individual, func)\n            if updated_individual[0] < self.x0[0]:\n                self.x0 = updated_individual\n        return self.x0, self.f(self.x0, func)\n\n    def f(self, individual, func):\n        if np.random.rand() < 0.4:\n            individual = self.crossover(individual)\n            individual = self.mutation(individual)\n        return func(individual)\n\n    def crossover(self, individual):\n        new_individual = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        new_individual[1:] = individual[1:]\n        return new_individual\n\n    def mutation(self, individual):\n        new_individual = individual.copy()\n        for i in range(self.dim):\n            if np.random.rand() < 0.1:\n                new_individual[i] = np.random.uniform(self.bounds[0][0], self.bounds[0][1])\n        return new_individual\n\n# Example usage:\nclass BBOB:\n    def __init__(self, func):\n        self.func = func\n\n    def f(self, x):\n        return self.func(x)\n\n# Test the HybridEvolutionaryAlgorithm\ndef f1(x):\n    return np.sum(x**2)\n\ndef f2(x):\n    return np.sum(x**2) + 10 * np.sin(2 * np.pi * x)\n\ndef f3(x):\n    return np.sum(x**2) + 10 * np.sin(2 * np.pi * x) + 5 * x[0]\n\ndef f4(x):\n    return np.sum(x**2) + 10 * np.sin(2 * np.pi * x) + 5 * x[0] + 5 * x[1]\n\ndef f5(x):\n    return np.sum(x**2) + 10 * np.sin(2 * np.pi * x) + 5 * x[0] + 5 * x[1] + 2 * x[0] * x[1]\n\ndef f6(x):\n    return np.sum(x**2) + 10 * np.sin(2 * np.pi * x) + 5 * x[0] + 5 * x[1] + 2 * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1]\n\ndef f7(x):\n    return np.sum(x**2) + 10 * np.sin(2 * np.pi * x) + 5 * x[0] + 5 * x[1] + 2 * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1]\n\ndef f8(x):\n    return np.sum(x**2) + 10 * np.sin(2 * np.pi * x) + 5 * x[0] + 5 * x[1] + 2 * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1]\n\ndef f9(x):\n    return np.sum(x**2) + 10 * np.sin(2 * np.pi * x) + 5 * x[0] + 5 * x[1] + 2 * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1]\n\ndef f10(x):\n    return np.sum(x**2) + 10 * np.sin(2 * np.pi * x) + 5 * x[0] + 5 * x[1] + 2 * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1]\n\ndef f11(x):\n    return np.sum(x**2) + 10 * np.sin(2 * np.pi * x) + 5 * x[0] + 5 * x[1] + 2 * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1]\n\ndef f12(x):\n    return np.sum(x**2) + 10 * np.sin(2 * np.pi * x) + 5 * x[0] + 5 * x[1] + 2 * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1]\n\ndef f13(x):\n    return np.sum(x**2) + 10 * np.sin(2 * np.pi * x) + 5 * x[0] + 5 * x[1] + 2 * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1]\n\ndef f14(x):\n    return np.sum(x**2) + 10 * np.sin(2 * np.pi * x) + 5 * x[0] + 5 * x[1] + 2 * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1]\n\ndef f15(x):\n    return np.sum(x**2) + 10 * np.sin(2 * np.pi * x) + 5 * x[0] + 5 * x[1] + 2 * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1]\n\ndef f16(x):\n    return np.sum(x**2) + 10 * np.sin(2 * np.pi * x) + 5 * x[0] + 5 * x[1] + 2 * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1]\n\ndef f17(x):\n    return np.sum(x**2) + 10 * np.sin(2 * np.pi * x) + 5 * x[0] + 5 * x[1] + 2 * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1]\n\ndef f18(x):\n    return np.sum(x**2) + 10 * np.sin(2 * np.pi * x) + 5 * x[0] + 5 * x[1] + 2 * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1]\n\ndef f19(x):\n    return np.sum(x**2) + 10 * np.sin(2 * np.pi * x) + 5 * x[0] + 5 * x[1] + 2 * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1]\n\ndef f20(x):\n    return np.sum(x**2) + 10 * np.sin(2 * np.pi * x) + 5 * x[0] + 5 * x[1] + 2 * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1]\n\ndef f21(x):\n    return np.sum(x**2) + 10 * np.sin(2 * np.pi * x) + 5 * x[0] + 5 * x[1] + 2 * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1]\n\ndef f22(x):\n    return np.sum(x**2) + 10 * np.sin(2 * np.pi * x) + 5 * x[0] + 5 * x[1] + 2 * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1]\n\ndef f23(x):\n    return np.sum(x**2) + 10 * np.sin(2 * np.pi * x) + 5 * x[0] + 5 * x[1] + 2 * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1]\n\ndef f24(x):\n    return np.sum(x**2) + 10 * np.sin(2 * np.pi * x) + 5 * x[0] + 5 * x[1] + 2 * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] + 0.5 * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1] * x[0] * x[1]\n\n# Initialize the HybridEvolutionaryAlgorithm\nheacombbo = HybridEvolutionaryAlgorithm(budget=10, dim=10)\n\n# Test the HybridEvolutionaryAlgorithm\nbbo = BBO(f1)\nx0, f1_x0 = heacombbo(bbo)\nprint(\"x0:\", x0)\nprint(\"f1(x0):\", f1_x0)\n\nbbo = BBO(f2)\nx0, f2_x0 = heacombbo(bbo)\nprint(\"x0:\", x0)\nprint(\"f2(x0):\", f2_x0)\n\nbbo = BBO(f3)\nx0, f3_x0 = heacombbo(bbo)\nprint(\"x0:\", x0)\nprint(\"f3(x0):\", f3_x0)\n\nbbo = BBO(f4)\nx0, f4_x0 = heacombbo(bbo)\nprint(\"x0:\", x0)\nprint(\"f4(x0):\", f4_x0)\n\nbbo = BBO(f5)\nx0, f5_x0 = heacombbo(bbo)\nprint(\"x0:\", x0)\nprint(\"f5(x0):\", f5_x0)\n\nbbo = BBO(f6)\nx0, f6_x0 = heacombbo(bbo)\nprint(\"x0:\", x0)\nprint(\"f6(x0):\", f6_x0)\n\nbbo = BBO(f7)\nx0, f7_x0 = heacombbo(bbo)\nprint(\"x0:\", x0)\nprint(\"f7(x0):\", f7_x0)\n\nbbo = BBO(f8)\nx0, f8_x0 = heacombbo(bbo)\nprint(\"x0:\", x0)\nprint(\"f8(x0):\", f8_x0)\n\nbbo = BBO(f9)\nx0, f9_x0 = heacombbo(bbo)\nprint(\"x0:\", x0)\nprint(\"f9(x0):\", f9_x0)\n\nbbo = BBO(f10)\nx0, f10_x0 = heacombbo(bbo)\nprint(\"x0:\", x0)\nprint(\"f10(x0):\", f10_x0)\n\nbbo = BBO(f11)\nx0, f11_x0 = heacombbo(bbo)\nprint(\"x0:\", x0)\nprint(\"f11(x0):\", f11_x0)\n\nbbo = BBO(f12)\nx0, f12_x0 = heacombbo(bbo)\nprint(\"x0:\", x0)\nprint(\"f12(x0):\", f12_x0)\n\nbbo = BBO(f13)\nx0, f13_x0 = heacombbo(bbo)\nprint(\"x0:\", x0)\nprint(\"f13(x0):\", f13_x0)\n\nbbo = BBO(f14)\nx0, f14_x0 = heacombbo(bbo)\nprint(\"x0:\", x0)\nprint(\"f14(x0):\", f14_x0)\n\nbbo = BBO(f15)\nx0, f15_x0 = heacombbo(bbo)\nprint(\"x0:\", x0)\nprint(\"f15(x0):\", f15_x0)\n\nbbo = BBO(f16)\nx0, f16_x0 = heacombbo(bbo)\nprint(\"x0:\", x0)\nprint(\"f16(x0):\", f16_x0)\n\nbbo = BBO(f17)\nx0, f17_x0 = heacombbo(bbo)\nprint(\"x0:\", x0)\nprint(\"f17(x0):\", f17_x0)\n\nbbo = BBO(f18)\nx0, f18_x0 = heacombbo(bbo)\nprint(\"x0:\", x0)\nprint(\"f18(x0):\", f18_x0)\n\nbbo = BBO(f19)\nx0, f19_x0 = heacombbo(bbo)\nprint(\"x0:\", x0)\nprint(\"f19(x0):\", f19_x0)\n\nbbo = BBO(f20)\nx0, f20_x0 = heacombbo(bbo)\nprint(\"x0:\", x0)\nprint(\"f20(x0):\", f20_x0)\n\nbbo = BBO(f21)\nx0, f21_x0 = heacombbo(bbo)\nprint(\"x0:\", x0)\nprint(\"f21(x0):\", f21_x0)\n\nbbo = BBO(f22)\nx0, f22_x0 = heacombbo(bbo)\nprint(\"x0:\", x0)\nprint(\"f22(x0):\", f22_x0)\n\nbbo = BBO(f23)\nx0, f23_x0 = heacombbo(bbo)\nprint(\"x0:\", x0)\nprint(\"f23(x0):\", f23_x0)\n\nbbo = BBO(f24)\nx0, f24_x0 = heacombbo(bbo)\nprint(\"x0:\", x0)\nprint(\"f24(x0):\", f24_x0)", "name": "HybridEvolutionaryAlgorithm", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization using Probability Refinement", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'BBO' is not defined\").", "error": "NameError(\"name 'BBO' is not defined\")", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "57984e3f-52ff-496f-94d1-1f80047546dc", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def refine_strategy(self, func):\n        if self.budget == 0:\n            return\n\n        if func.__name__ == 'f1':\n            return\n        elif func.__name__ == 'f2':\n            return\n        elif func.__name__ == 'f3':\n            return\n        elif func.__name__ == 'f4':\n            return\n        elif func.__name__ == 'f5':\n            return\n        elif func.__name__ == 'f6':\n            return\n        elif func.__name__ == 'f7':\n            return\n        elif func.__name__ == 'f8':\n            return\n        elif func.__name__ == 'f9':\n            return\n        elif func.__name__ == 'f10':\n            return\n        elif func.__name__ == 'f11':\n            return\n        elif func.__name__ == 'f12':\n            return\n        elif func.__name__ == 'f13':\n            return\n        elif func.__name__ == 'f14':\n            return\n        elif func.__name__ == 'f15':\n            return\n        elif func.__name__ == 'f16':\n            return\n        elif func.__name__ == 'f17':\n            return\n        elif func.__name__ == 'f18':\n            return\n        elif func.__name__ == 'f19':\n            return\n        elif func.__name__ == 'f20':\n            return\n        elif func.__name__ == 'f21':\n            return\n        elif func.__name__ == 'f22':\n            return\n        elif func.__name__ == 'f23':\n            return\n        elif func.__name__ == 'f24':\n            return\n\n        # Refine the strategy by changing 40% of the individuals\n        individuals = np.random.choice(self.x0, size=self.dim, replace=False)\n        refined_individuals = individuals + np.random.normal(0, 0.1, size=self.dim)\n        refined_individuals = np.clip(refined_individuals, self.bounds[0][0], self.bounds[0][1])\n        self.x0 = refined_individuals\n\n# Example usage:\nbudget = 10\ndim = 5\nheacombbo = HEACOMBBO(budget, dim)\nfor _ in range(10):\n    func = np.random.choice(['f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'f11', 'f12', 'f13', 'f14', 'f15', 'f16', 'f17', 'f18', 'f19', 'f20', 'f21', 'f22', 'f23', 'f24'])\n    heacombbo(func)\n    heacombbo.refine_strategy(func)", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) with refinement strategy", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "dd939b86-f7e4-46bf-a6fe-7a3d63a1879c", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.prob_refine = 0.4\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def refine_strategy(self, individual):\n        if random.random() < self.prob_refine:\n            strategy = random.choice(['sbx', 'rand1', 'uniform'])\n            if strategy =='sbx':\n                cxpb = random.uniform(0, 1)\n                mu = random.uniform(0, 1)\n                w = random.uniform(0, 1)\n            elif strategy == 'rand1':\n                cxpb = random.uniform(0, 1)\n                mu = random.uniform(0, 1)\n                w = random.uniform(0, 1)\n            elif strategy == 'uniform':\n                cxpb = random.uniform(0, 1)\n                mu = random.uniform(0, 1)\n                w = random.uniform(0, 1)\n            individual['strategy'] = strategy\n            individual['cxpb'] = cxpb\n            individual['mu'] = mu\n            individual['w'] = w\n        return individual", "name": "HEACOMBBO", "description": "Novel Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization using probabilistic refinement.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 34, 142, None, 34, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 34, 142, None, 34, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "c964297a-6ebc-4c00-b0e2-d137cee09f6c", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "e6c0ed2c-1be9-4214-bbbb-141349bcf460", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.population = [self.x0]\n        self.logger = []\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def mutate(self, individual):\n        mutation_rate = 0.4\n        if random.random() < mutation_rate:\n            index = random.randint(0, self.dim - 1)\n            individual[index] += random.uniform(-1.0, 1.0)\n            individual[index] = max(self.bounds[index][0], min(individual[index], self.bounds[index][1]))\n        return individual\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        index = random.randint(0, self.dim - 1)\n        child[index] = parent2[index]\n        return child\n\n    def evaluate_fitness(self, individual):\n        result = func(individual)\n        if result is not None:\n            fitness = result.fun\n        else:\n            fitness = np.inf\n        return fitness\n\n    def evolve(self):\n        new_population = []\n        for _ in range(self.dim):\n            parent1, parent2 = random.sample(self.population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutate(child)\n            new_population.append(child)\n        self.population = new_population\n        return self.population\n\n# Example usage:\nbudget = 100\ndim = 10\nalgorithm = HybridEvolutionaryAlgorithm(budget, dim)\nfor _ in range(budget):\n    algorithm.evolve()", "name": "HybridEvolutionaryAlgorithm", "description": "Hybrid Evolutionary Algorithm with Adaptive Mutation and Crossover for Black Box Optimization", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 35, 142, None, 35, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 35, 142, None, 35, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "a04913de-a257-4d23-96c0-039198f6e46f", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.strategy_prob = 0.4\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        new_individual = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        while True:\n            fitness = func(new_individual)\n            if np.random.rand() < self.strategy_prob:\n                new_individual = self.mutate(new_individual)\n            if fitness!= np.nan:\n                break\n\n        return new_individual, func(new_individual)\n\n    def mutate(self, individual):\n        mutation_rate = 0.1\n        new_individual = individual.copy()\n        for i in range(self.dim):\n            if np.random.rand() < mutation_rate:\n                new_individual[i] = np.random.uniform(self.bounds[i][0], self.bounds[i][1])\n        return new_individual\n\n# Usage\nif __name__ == \"__main__\":\n    func = lambda x: x[0]**2 + x[1]**2\n    algorithm = HybridEvolutionaryAlgorithm(100, 2)\n    for _ in range(100):\n        individual, fitness = algorithm(func)\n        print(f\"Individual: {individual}, Fitness: {fitness}\")", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm with Crossover, Mutation and Adaptive Strategy for Black Box Optimization.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "87f48fd4-9f31-418a-9d23-2fff8cd589cd", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.strategy ='sbx'\n        self.cpb = 0.5\n        self.mu = 0.5\n        self.w = 0.5\n        self.strategy_refine_prob = 0.4\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy)\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.strategy, cxpb=self.cpb, mu=self.mu, w=self.w, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n\n    def refine_strategy(self):\n        for _ in range(int(self.budget * self.strategy_refine_prob)):\n            if np.random.rand() < 0.5:\n                self.strategy = np.random.choice(['sbx', 'rand1', 'log-uniform'])\n                self.cpb = np.random.uniform(0, 1)\n                self.mu = np.random.uniform(0, 1)\n                self.w = np.random.uniform(0, 1)\n            else:\n                self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) with strategy refinement.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 37, 162, None, 37, 178)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 37, 162, None, 37, 178))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "8cf0250d-434a-41c9-a68d-45b79c9c2b7d", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def hybridize(self, func):\n        import random\n        import copy\n\n        # Initialize the population\n        population = [copy.deepcopy(self.x0) for _ in range(100)]\n\n        # Initialize the best individual\n        best_individual = copy.deepcopy(self.x0)\n\n        # Initialize the best fitness\n        best_fitness = np.inf\n\n        # Main loop\n        for i in range(self.budget):\n            # Select the best individual\n            best_individual = max(population, key=lambda x: func(x))\n\n            # Evaluate the fitness\n            best_fitness = func(best_individual)\n\n            # Print the best individual and fitness\n            print(f\"Iteration {i+1}: Best Individual = {best_individual}, Best Fitness = {best_fitness}\")\n\n            # Refine the strategy\n            if random.random() < 0.4:\n                # Select a random individual\n                individual = random.choice(population)\n\n                # Refine the strategy\n                individual = self.refine_strategy(individual, func)\n\n                # Update the population\n                population = [copy.deepcopy(individual) if individual == best_individual else copy.deepcopy(individual) for individual in population]\n\n        # Return the best individual and fitness\n        return best_individual, best_fitness\n\n    def refine_strategy(self, individual, func):\n        # Select a random dimension\n        dim = random.randint(0, self.dim-1)\n\n        # Select a random value for the dimension\n        value = random.uniform(self.bounds[dim][0], self.bounds[dim][1])\n\n        # Create a new individual\n        new_individual = copy.deepcopy(individual)\n        new_individual[dim] = value\n\n        # Evaluate the fitness\n        new_fitness = func(new_individual)\n\n        # If the new individual has better fitness, return it\n        if new_fitness < func(individual):\n            return new_individual\n\n        # Otherwise, return the original individual\n        return individual\n\n# Usage\nimport numpy as np\nfrom scipy.optimize import differential_evolution\n\n# Define the functions\ndef f1(x):\n    return x[0]**2 + x[1]**2\n\ndef f2(x):\n    return x[0]**2 + x[1]**2 + x[2]**2 + x[3]**2\n\ndef f3(x):\n    return (x[0] - 2)**2 + (x[1] - 3)**2\n\ndef f4(x):\n    return (x[0] - 2)**2 + (x[1] - 3)**2 + (x[2] - 4)**2 + (x[3] - 5)**2\n\ndef f5(x):\n    return (x[0] - 2)**2 + (x[1] - 3)**2 + (x[2] - 4)**2 + (x[3] - 5)**2 + (x[4] - 6)**2\n\ndef f6(x):\n    return (x[0] - 2)**2 + (x[1] - 3)**2 + (x[2] - 4)**2 + (x[3] - 5)**2 + (x[4] - 6)**2 + (x[5] - 7)**2\n\ndef f7(x):\n    return (x[0] - 2)**2 + (x[1] - 3)**2 + (x[2] - 4)**2 + (x[3] - 5)**2 + (x[4] - 6)**2 + (x[5] - 7)**2 + (x[6] - 8)**2\n\ndef f8(x):\n    return (x[0] - 2)**2 + (x[1] - 3)**2 + (x[2] - 4)**2 + (x[3] - 5)**2 + (x[4] - 6)**2 + (x[5] - 7)**2 + (x[6] - 8)**2 + (x[7] - 9)**2\n\ndef f9(x):\n    return (x[0] - 2)**2 + (x[1] - 3)**2 + (x[2] - 4)**2 + (x[3] - 5)**2 + (x[4] - 6)**2 + (x[5] - 7)**2 + (x[6] - 8)**2 + (x[7] - 9)**2 + (x[8] - 10)**2\n\ndef f10(x):\n    return (x[0] - 2)**2 + (x[1] - 3)**2 + (x[2] - 4)**2 + (x[3] - 5)**2 + (x[4] - 6)**2 + (x[5] - 7)**2 + (x[6] - 8)**2 + (x[7] - 9)**2 + (x[8] - 10)**2 + (x[9] - 11)**2\n\ndef f11(x):\n    return (x[0] - 2)**2 + (x[1] - 3)**2 + (x[2] - 4)**2 + (x[3] - 5)**2 + (x[4] - 6)**2 + (x[5] - 7)**2 + (x[6] - 8)**2 + (x[7] - 9)**2 + (x[8] - 10)**2 + (x[9] - 11)**2 + (x[10] - 12)**2\n\ndef f12(x):\n    return (x[0] - 2)**2 + (x[1] - 3)**2 + (x[2] - 4)**2 + (x[3] - 5)**2 + (x[4] - 6)**2 + (x[5] - 7)**2 + (x[6] - 8)**2 + (x[7] - 9)**2 + (x[8] - 10)**2 + (x[9] - 11)**2 + (x[10] - 12)**2 + (x[11] - 13)**2\n\ndef f13(x):\n    return (x[0] - 2)**2 + (x[1] - 3)**2 + (x[2] - 4)**2 + (x[3] - 5)**2 + (x[4] - 6)**2 + (x[5] - 7)**2 + (x[6] - 8)**2 + (x[7] - 9)**2 + (x[8] - 10)**2 + (x[9] - 11)**2 + (x[10] - 12)**2 + (x[11] - 13)**2 + (x[12] - 14)**2\n\ndef f14(x):\n    return (x[0] - 2)**2 + (x[1] - 3)**2 + (x[2] - 4)**2 + (x[3] - 5)**2 + (x[4] - 6)**2 + (x[5] - 7)**2 + (x[6] - 8)**2 + (x[7] - 9)**2 + (x[8] - 10)**2 + (x[9] - 11)**2 + (x[10] - 12)**2 + (x[11] - 13)**2 + (x[12] - 14)**2 + (x[13] - 15)**2\n\ndef f15(x):\n    return (x[0] - 2)**2 + (x[1] - 3)**2 + (x[2] - 4)**2 + (x[3] - 5)**2 + (x[4] - 6)**2 + (x[5] - 7)**2 + (x[6] - 8)**2 + (x[7] - 9)**2 + (x[8] - 10)**2 + (x[9] - 11)**2 + (x[10] - 12)**2 + (x[11] - 13)**2 + (x[12] - 14)**2 + (x[13] - 15)**2 + (x[14] - 16)**2\n\ndef f16(x):\n    return (x[0] - 2)**2 + (x[1] - 3)**2 + (x[2] - 4)**2 + (x[3] - 5)**2 + (x[4] - 6)**2 + (x[5] - 7)**2 + (x[6] - 8)**2 + (x[7] - 9)**2 + (x[8] - 10)**2 + (x[9] - 11)**2 + (x[10] - 12)**2 + (x[11] - 13)**2 + (x[12] - 14)**2 + (x[13] - 15)**2 + (x[14] - 16)**2 + (x[15] - 17)**2\n\ndef f17(x):\n    return (x[0] - 2)**2 + (x[1] - 3)**2 + (x[2] - 4)**2 + (x[3] - 5)**2 + (x[4] - 6)**2 + (x[5] - 7)**2 + (x[6] - 8)**2 + (x[7] - 9)**2 + (x[8] - 10)**2 + (x[9] - 11)**2 + (x[10] - 12)**2 + (x[11] - 13)**2 + (x[12] - 14)**2 + (x[13] - 15)**2 + (x[14] - 16)**2 + (x[15] - 17)**2 + (x[16] - 18)**2\n\ndef f18(x):\n    return (x[0] - 2)**2 + (x[1] - 3)**2 + (x[2] - 4)**2 + (x[3] - 5)**2 + (x[4] - 6)**2 + (x[5] - 7)**2 + (x[6] - 8)**2 + (x[7] - 9)**2 + (x[8] - 10)**2 + (x[9] - 11)**2 + (x[10] - 12)**2 + (x[11] - 13)**2 + (x[12] - 14)**2 + (x[13] - 15)**2 + (x[14] - 16)**2 + (x[15] - 17)**2 + (x[16] - 18)**2 + (x[17] - 19)**2\n\ndef f19(x):\n    return (x[0] - 2)**2 + (x[1] - 3)**2 + (x[2] - 4)**2 + (x[3] - 5)**2 + (x[4] - 6)**2 + (x[5] - 7)**2 + (x[6] - 8)**2 + (x[7] - 9)**2 + (x[8] - 10)**2 + (x[9] - 11)**2 + (x[10] - 12)**2 + (x[11] - 13)**2 + (x[12] - 14)**2 + (x[13] - 15)**2 + (x[14] - 16)**2 + (x[15] - 17)**2 + (x[16] - 18)**2 + (x[17] - 19)**2 + (x[18] - 20)**2\n\ndef f20(x):\n    return (x[0] - 2)**2 + (x[1] - 3)**2 + (x[2] - 4)**2 + (x[3] - 5)**2 + (x[4] - 6)**2 + (x[5] - 7)**2 + (x[6] - 8)**2 + (x[7] - 9)**2 + (x[8] - 10)**2 + (x[9] - 11)**2 + (x[10] - 12)**2 + (x[11] - 13)**2 + (x[12] - 14)**2 + (x[13] - 15)**2 + (x[14] - 16)**2 + (x[15] - 17)**2 + (x[16] - 18)**2 + (x[17] - 19)**2 + (x[18] - 20)**2 + (x[19] - 21)**2\n\ndef f21(x):\n    return (x[0] - 2)**2 + (x[1] - 3)**2 + (x[2] - 4)**2 + (x[3] - 5)**2 + (x[4] - 6)**2 + (x[5] - 7)**2 + (x[6] - 8)**2 + (x[7] - 9)**2 + (x[8] - 10)**2 + (x[9] - 11)**2 + (x[10] - 12)**2 + (x[11] - 13)**2 + (x[12] - 14)**2 + (x[13] - 15)**2 + (x[14] - 16)**2 + (x[15] - 17)**2 + (x[16] - 18)**2 + (x[17] - 19)**2 + (x[18] - 20)**2 + (x[19] - 21)**2 + (x[20] - 22)**2\n\ndef f22(x):\n    return (x[0] - 2)**2 + (x[1] - 3)**2 + (x[2] - 4)**2 + (x[3] - 5)**2 + (x[4] - 6)**2 + (x[5] - 7)**2 + (x[6] - 8)**2 + (x[7] - 9)**2 + (x[8] - 10)**2 + (x[9] - 11)**2 + (x[10] - 12)**2 + (x[11] - 13)**2 + (x[12] - 14)**2 + (x[13] - 15)**2 + (x[14] - 16)**2 + (x[15] - 17)**2 + (x[16] - 18)**2 + (x[17] - 19)**2 + (x[18] - 20)**2 + (x[19] - 21)**2 + (x[20] - 22)**2 + (x[21] - 23)**2\n\ndef f23(x):\n    return (x[0] - 2)**2 + (x[1] - 3)**2 + (x[2] - 4)**2 + (x[3] - 5)**2 + (x[4] - 6)**2 + (x[5] - 7)**2 + (x[6] - 8)**2 + (x[7] - 9)**2 + (x[8] - 10)**2 + (x[9] - 11)**2 + (x[10] - 12)**2 + (x[11] - 13)**2 + (x[12] - 14)**2 + (x[13] - 15)**2 + (x[14] - 16)**2 + (x[15] - 17)**2 + (x[16] - 18)**2 + (x[17] - 19)**2 + (x[18] - 20)**2 + (x[19] - 21)**2 + (x[20] - 22)**2 + (x[21] - 23)**2 + (x[22] - 24)**2\n\ndef f24(x):\n    return (x[0] - 2)**2 + (x[1] - 3)**2 + (x[2] - 4)**2 + (x[3] - 5)**2 + (x[4] - 6)**2 + (x[5] - 7)**2 + (x[6] - 8)**2 + (x[7] - 9)**2 + (x[8] - 10)**2 + (x[9] - 11)**2 + (x[10] - 12)**2 + (x[11] - 13)**2 + (x[12] - 14)**2 + (x[13] - 15)**2 + (x[14] - 16)**2 + (x[15] - 17)**2 + (x[16] - 18)**2 + (x[17] - 19)**2 + (x[18] - 20)**2 + (x[19] - 21)**2 + (x[20] - 22)**2 + (x[21] - 23)**2 + (x[22] - 24)**2 + (x[23] - 25)**2\n\n# Usage\nif __name__ == \"__main__\":\n    # Initialize the HEACOMBBO\n    heacombbo = HEACOMBBO(budget=50, dim=2)\n\n    # Define the function\n    def f(x):\n        return x[0]**2 + x[1]**2\n\n    # Optimize the function\n    best_individual, best_fitness = heacombbo.hybridize(f)\n\n    # Print the best individual and fitness\n    print(f\"Best Individual = {best_individual}, Best Fitness = {best_fitness}\")", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) with adaptive strategy refinement", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 32, 142, None, 32, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 32, 142, None, 32, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "6d7be25e-09e1-4bb1-908a-4db659b680f6", "solution": "import numpy as np\nimport random\n\nclass HybridEvolutionaryAlgorithmWithCrossoverAndMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        # Initialize population\n        population = [np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim) for _ in range(100)]\n\n        for _ in range(self.budget):\n            # Evaluate fitness\n            fitness = [func(individual) for individual in population]\n\n            # Select parents using tournament selection\n            parents = []\n            for _ in range(10):\n                tournament = random.sample(population, 3)\n                parents.append(min(tournament, key=lambda x: fitness[tournament.index(x)]))\n\n            # Perform crossover and mutation\n            new_population = []\n            for _ in range(10):\n                parent1, parent2 = random.sample(parents, 2)\n                child = []\n                for i in range(self.dim):\n                    if random.random() < 0.4:\n                        child.append((parent1[i] + parent2[i]) / 2)\n                    else:\n                        child.append(random.choice([parent1[i], parent2[i]]))\n                new_population.append(child)\n\n            # Replace least fit individual\n            new_population = sorted(new_population, key=lambda x: func(x))[:10]\n            population = new_population\n\n        # Return best individual\n        return min(population, key=lambda x: func(x))\n\n# Example usage:\ndef f1(x):\n    return sum(x**2)\n\ndef f2(x):\n    return sum(x**2) + sum(y**2 for y in x)\n\ndef f3(x):\n    return sum(x**2) + sum(y**2 for y in x) + sum(z**2 for z in x)\n\ndef f4(x):\n    return sum(x**2) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(w**2 for w in x)\n\ndef f5(x):\n    return sum(x**2) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(w**2 for w in x) + sum(u**2 for u in x)\n\ndef f6(x):\n    return sum(x**2) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(w**2 for w in x) + sum(u**2 for u in x)\n\ndef f7(x):\n    return sum(x**2) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(w**2 for w in x) + sum(u**2 for u in x) + sum(v**2 for v in x)\n\ndef f8(x):\n    return sum(x**2) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(w**2 for w in x) + sum(u**2 for u in x) + sum(v**2 for v in x) + sum(w**2 for w in x)\n\ndef f9(x):\n    return sum(x**2) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(w**2 for w in x) + sum(u**2 for u in x) + sum(v**2 for v in x) + sum(w**2 for w in x) + sum(x**2 for x in x)\n\ndef f10(x):\n    return sum(x**2) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(w**2 for w in x) + sum(u**2 for u in x) + sum(v**2 for v in x) + sum(w**2 for w in x) + sum(x**2 for x in x) + sum(y**2 for y in x)\n\ndef f11(x):\n    return sum(x**2) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(w**2 for w in x) + sum(u**2 for u in x) + sum(v**2 for v in x) + sum(w**2 for w in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x)\n\ndef f12(x):\n    return sum(x**2) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(w**2 for w in x) + sum(u**2 for u in x) + sum(v**2 for v in x) + sum(w**2 for w in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x)\n\ndef f13(x):\n    return sum(x**2) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(w**2 for w in x) + sum(u**2 for u in x) + sum(v**2 for v in x) + sum(w**2 for w in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x)\n\ndef f14(x):\n    return sum(x**2) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(w**2 for w in x) + sum(u**2 for u in x) + sum(v**2 for v in x) + sum(w**2 for w in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x)\n\ndef f15(x):\n    return sum(x**2) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(w**2 for w in x) + sum(u**2 for u in x) + sum(v**2 for v in x) + sum(w**2 for w in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x)\n\ndef f16(x):\n    return sum(x**2) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(w**2 for w in x) + sum(u**2 for u in x) + sum(v**2 for v in x) + sum(w**2 for w in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x)\n\ndef f17(x):\n    return sum(x**2) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(w**2 for w in x) + sum(u**2 for u in x) + sum(v**2 for v in x) + sum(w**2 for w in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x)\n\ndef f18(x):\n    return sum(x**2) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(w**2 for w in x) + sum(u**2 for u in x) + sum(v**2 for v in x) + sum(w**2 for w in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x)\n\ndef f19(x):\n    return sum(x**2) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(w**2 for w in x) + sum(u**2 for u in x) + sum(v**2 for v in x) + sum(w**2 for w in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x)\n\ndef f20(x):\n    return sum(x**2) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(w**2 for w in x) + sum(u**2 for u in x) + sum(v**2 for v in x) + sum(w**2 for w in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x)\n\ndef f21(x):\n    return sum(x**2) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(w**2 for w in x) + sum(u**2 for u in x) + sum(v**2 for v in x) + sum(w**2 for w in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x)\n\ndef f22(x):\n    return sum(x**2) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(w**2 for w in x) + sum(u**2 for u in x) + sum(v**2 for v in x) + sum(w**2 for w in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x)\n\ndef f23(x):\n    return sum(x**2) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(w**2 for w in x) + sum(u**2 for u in x) + sum(v**2 for v in x) + sum(w**2 for w in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x)\n\ndef f24(x):\n    return sum(x**2) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(w**2 for w in x) + sum(u**2 for u in x) + sum(v**2 for v in x) + sum(w**2 for w in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x) + sum(z**2 for z in x) + sum(x**2 for x in x) + sum(y**2 for y in x)\n\nhybrid_evolutionary_algorithm_with_crossover_and_mutation = HybridEvolutionaryAlgorithmWithCrossoverAndMutation(budget=100, dim=10)\n\ndef optimize_bbob(func):\n    return hybrid_evolutionary_algorithm_with_crossover_and_mutation(func)\n\n# Example usage:\ndef f1(x):\n    return sum(x**2)\n\nresult = optimize_bbob(f1)\nprint(result)", "name": "HybridEvolutionaryAlgorithmWithCrossoverAndMutation", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization using probability-based strategy refinement", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "4354c08b-7a51-4dc1-b846-665911299d75", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "4e902e1a-2712-4f9f-b83f-03f70330c960", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.logger = {}\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n        # Hybrid Evolutionary Algorithm\n        def hybrid_evolution(func):\n            # Initialize population\n            population = [np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim) for _ in range(100)]\n\n            # Evolutionary algorithm\n            for _ in range(100):\n                # Selection\n                parents = []\n                for _ in range(10):\n                    parents.append(differential_evolution(func, self.bounds, x0=np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)))\n\n                # Crossover\n                offspring = []\n                for _ in range(10):\n                    parent1, parent2 = random.sample(parents, 2)\n                    child = (parent1 + parent2) / 2\n                    offspring.append(child)\n\n                # Mutation\n                for _ in range(10):\n                    child = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n                    offspring.append(child)\n\n                # Replace worst individual with the best offspring\n                population = sorted(population, key=lambda x: func(x), reverse=True)[:10] + offspring[:10]\n\n            # Select best individual\n            best_individual = min(population, key=lambda x: func(x))\n\n            return best_individual\n\n        # Refine strategy by changing individual lines\n        def refine_strategy(func):\n            # Initialize population\n            population = [np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim) for _ in range(100)]\n\n            # Evolutionary algorithm\n            for _ in range(100):\n                # Selection\n                parents = []\n                for _ in range(10):\n                    parents.append(differential_evolution(func, self.bounds, x0=np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)))\n\n                # Crossover\n                offspring = []\n                for _ in range(10):\n                    parent1, parent2 = random.sample(parents, 2)\n                    child = (parent1 + parent2) / 2\n                    offspring.append(child)\n\n                # Mutation\n                for _ in range(10):\n                    child = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n                    offspring.append(child)\n\n                # Replace worst individual with the best offspring\n                population = sorted(population, key=lambda x: func(x), reverse=True)[:10] + offspring[:10]\n\n                # Refine strategy by changing individual lines\n                for i in range(len(population)):\n                    if random.random() < 0.4:\n                        population[i] += np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Select best individual\n            best_individual = min(population, key=lambda x: func(x))\n\n            return best_individual\n\n        # Evaluate fitness\n        def evaluate_fitness(func):\n            # Hybrid Evolutionary Algorithm\n            best_individual = hybrid_evolution(func)\n            return best_individual\n\n        # Evaluate fitness\n        def evaluateBBOB(func):\n            # Refine strategy\n            best_individual = refine_strategy(func)\n            return best_individual\n\n        # Evaluate fitness\n        def evaluate(func):\n            # Evaluate fitness\n            best_individual = evaluateBBOB(func)\n            return best_individual\n\n        # Evaluate fitness\n        def evaluate_single(func):\n            # Evaluate fitness\n            best_individual = evaluate(func)\n            return best_individual\n\n        return evaluate_single\n\n# Usage\nfunc = lambda x: x[0]**2 + x[1]**2\noptimizer = HybridEvolutionaryAlgorithm(100, 2)\nresult = optimizer(func)\nprint(result)", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 34, 142, None, 34, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 34, 142, None, 34, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "093de550-29d4-4f4c-853f-60e87665359d", "solution": "import numpy as np\nimport random\nimport subprocess\nimport os\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def evaluate_fitness(self, individual):\n        func_name = individual.__class__.__name__\n        if func_name in ['f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'f11', 'f12', 'f13', 'f14', 'f15', 'f16', 'f17', 'f18', 'f19', 'f20', 'f21', 'f22', 'f23', 'f24']:\n            result = subprocess.run(['python', '-c', f'differential_evolution(lambda x: {func_name}(x), {str(self.bounds)})'], shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            if result.returncode!= 0:\n                raise Exception(f'Failed to evaluate function {func_name}')\n            return np.nan, np.nan\n        else:\n            raise Exception(f'Unsupported function {func_name}')\n\n    def refine_strategy(self, individual):\n        if random.random() < 0.4:\n            individual.cxpb = random.uniform(0, 1)\n            individual.mu = random.uniform(0, 1)\n            individual.w = random.uniform(0, 1)\n            individual.strategy = random.choice(['sbx', 'rand1', 'uniform', 'log-uniform'])\n            return individual\n        else:\n            return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            individual = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n            individual = self.refine_strategy(individual)\n            fitness, _ = self.evaluate_fitness(individual)\n            if fitness!= np.nan:\n                # update individual\n                pass\n\n# Usage:\n# heacombbo = HEACOMBBO(100, 10)\n# heacombbo.optimize(f1)", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) with strategy refinement.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 34, 142, None, 34, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 34, 142, None, 34, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "ac870718-00df-4233-b672-dc321038ef53", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def refine_strategy(self, func):\n        if self.budget > 0:\n            # Select a random individual\n            individual = np.random.choice(self.x0, size=self.dim)\n            # Refine the strategy of the individual\n            for i in range(self.dim):\n                if random.random() < 0.4:\n                    individual[i] = np.random.uniform(self.bounds[i][0], self.bounds[i][1])\n            # Evaluate the fitness of the individual\n            fitness = func(individual)\n            # Return the refined individual and its fitness\n            return individual, fitness\n\n# Example usage\nif __name__ == \"__main__\":\n    # Define the functions to optimize\n    def f1(x):\n        return x[0]**2 + x[1]**2\n\n    def f2(x):\n        return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1])\n\n    def f3(x):\n        return x[0]**2 + x[1]**2 + 0.1 * np.sin(10 * x[0]) + 0.1 * np.cos(10 * x[1]) + 0.01 * np.sin(100 * x[0]) + 0.01 * np.cos(100 * x[1])\n\n    # Create an instance of the HEACOMBBO class\n    heacombbo = HEACOMBBO(budget=10, dim=2)\n\n    # Optimize the functions\n    for func in [f1, f2, f3]:\n        individual, fitness = heacombbo(func)\n        print(f\"Function: {func.__name__}, Individual: {individual}, Fitness: {fitness}\")", "name": "HEACOMBBO", "description": "Novel metaheuristic algorithm using Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) with refinement of strategy.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "a6f52764-df87-4802-b8ba-f84bccab7d5a", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        def mutate(individual):\n            for i in range(self.dim):\n                if np.random.rand() < 0.4:\n                    individual[i] += np.random.uniform(-1, 1)\n                    individual[i] = max(self.bounds[i][0], min(individual[i], self.bounds[i][1]))\n            return individual\n\n        def crossover(individual1, individual2):\n            child = individual1.copy()\n            for i in range(self.dim):\n                if np.random.rand() < 0.4:\n                    child[i] = individual2[i]\n            return child\n\n        def evaluate_fitness(individual):\n            return func(individual)\n\n        def hybrid_evolution():\n            population = [self.x0]\n            for _ in range(self.budget):\n                new_population = []\n                for _ in range(len(population)):\n                    individual = population.pop(0)\n                    mutated_individual = mutate(individual)\n                    new_population.append(mutated_individual)\n                population = new_population\n                population = [crossover(individual1, individual2) for individual1, individual2 in zip(population, population)]\n                fitness = [evaluate_fitness(individual) for individual in population]\n                best_individual = np.argmin(fitness)\n                population = [population[best_individual]]\n            return population[0]\n\n        return hybrid_evolution()\n\n# Usage\nbudget = 100\ndim = 10\nfunc = lambda x: x[0]**2 + x[1]**2\nalgorithm = HybridEvolutionaryAlgorithm(budget, dim)\nbest_individual = algorithm(func)\nprint(best_individual)", "name": "HybridEvolutionaryAlgorithm", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization using 0.4 probability to change individual lines of strategy", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "b7b43ac4-8996-4698-8704-5b9cacaffea1", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def hybrid_evolution(self, func):\n        for i in range(self.budget):\n            if random.random() < 0.4:\n                new_individual = random.uniform(self.bounds[0][0], self.bounds[0][1])\n            else:\n                new_individual = self.x0\n            updated_individual = self.f(new_individual, self.logger)\n            self.x0 = updated_individual\n\n    def f(self, individual, logger):\n        # Differential Evolution\n        def de(func, bounds, x0, tol=1e-5, x0_init=None, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, scaling='uniform', strategy_init=None):\n            from scipy.optimize import differential_evolution\n\n            if x0_init is None:\n                x0 = np.random.uniform(bounds[0][0], bounds[0][1], len(bounds))\n            else:\n                x0 = x0_init\n\n            if scaling == 'uniform':\n                scaling = lambda x: 1.0 / (1.0 + np.exp(-x))\n            elif scaling == 'log-uniform':\n                scaling = lambda x: np.log(1.0 + np.exp(-x))\n\n            bounds = [(a, b) for a, b in zip(bounds, [scaling(a) for a in x0])]\n            res = differential_evolution(func, bounds, x0=x0, tol=tol, strategy=strategy, cxpb=cxpb, mu=mu, w=w, scaling=scaling, strategy_init=strategy_init)\n\n            return res.x\n\n        # Hybrid Evolutionary Algorithm\n        def hybrid(func, bounds, x0, tol=1e-5, x0_init=None, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, scaling='uniform', strategy_init=None):\n            from scipy.optimize import differential_evolution\n\n            if x0_init is None:\n                x0 = np.random.uniform(bounds[0][0], bounds[0][1], len(bounds))\n            else:\n                x0 = x0_init\n\n            bounds = [(a, b) for a, b in zip(bounds, [scaling(a) for a in x0])]\n\n            def de_func(x):\n                return func(x)\n\n            res = differential_evolution(de_func, bounds, x0=x0, tol=tol, strategy=strategy, cxpb=cxpb, mu=mu, w=w, scaling=scaling, strategy_init=strategy_init)\n\n            return res.x\n\n        res = de(func, self.bounds, x0=self.x0, tol=tol, x0_init=x0_init, strategy=strategy, cxpb=cxpb, mu=mu, w=w, scaling=scaling, strategy_init=strategy_init)\n        return hybrid(func, self.bounds, res, tol=tol, x0_init=x0_init, strategy=strategy, cxpb=cxpb, mu=mu, w=w, scaling=scaling, strategy_init=strategy_init)\n\n# Usage\nif __name__ == \"__main__\":\n    import sys\n    import matplotlib.pyplot as plt\n\n    budget = 50\n    dim = 10\n\n    heacombbo = HybridEvolutionaryAlgorithm(budget, dim)\n\n    # Test the algorithm\n    def f(x):\n        return sum([i**2 for i in x])\n\n    heacombbo.logger = lambda x: x\n    heacombbo.f = f\n\n    for _ in range(100):\n        heacombbo.hybrid_evolution(f)\n\n    # Print the optimized value\n    print(\"Optimized value:\", f(heacombbo.x0))\n\n    # Plot the objective function\n    x = np.linspace(-5, 5, 100)\n    y = [f(i) for i in x]\n    plt.plot(x, y)\n    plt.scatter(heacombbo.x0, f(heacombbo.x0), color='r')\n    plt.show()", "name": "HybridEvolutionaryAlgorithm", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization using Differential Evolution", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "3dc37501-d2ca-4a4b-9169-2e89c92e7515", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def refine_strategy(self, func):\n        if self.budget > 0:\n            if random.random() < 0.4:\n                new_individual = self.x0 + np.random.uniform(-1, 1, self.dim)\n                new_individual = np.clip(new_individual, self.bounds[0][0], self.bounds[0][1])\n            else:\n                new_individual = self.x0\n            return new_individual\n        else:\n            return self.x0\n\n    def evaluate_fitness(self, individual):\n        new_individual = self.refine_strategy(individual)\n        return self.f(new_individual)\n\n    def f(self, individual):\n        # Assuming the function to be optimized is f(x) = x^2\n        return individual ** 2", "name": "HEACOMBBO", "description": "Novel Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) with probability-based strategy refinement.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "f942f9c2-5838-4359-a2e3-4dea037772b4", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\n\nclass ProbRefinedHEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.prob_refine = 0.4\n        self.refine_strategy ='sbx'\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def refine_strategy(self, individual):\n        if random.random() < self.prob_refine:\n            new_individual = individual\n            if self.refine_strategy =='sbx':\n                new_individual = self.sbx(individual)\n            elif self.refine_strategy == 'rand1':\n                new_individual = self.rand1(individual)\n            return new_individual\n        else:\n            return individual\n\n    def sbx(self, individual):\n        # Simple Binary XOR crossover\n        child = [0] * self.dim\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = individual[i]\n            else:\n                child[i] = 1 - individual[i]\n        return child\n\n    def rand1(self, individual):\n        # Random 1 crossover\n        child = [0] * self.dim\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = individual[i]\n            else:\n                child[i] = individual[i] + 1\n        return child\n\n# Usage:\nprob_refined_heacombbo = ProbRefinedHEACOMBBO(budget=100, dim=10)\nbest_individual = prob_refined_heacombbo()", "name": "ProbRefinedHEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization using Probabilistic Refinement", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 35, 142, None, 35, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 35, 142, None, 35, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "97506df6-ddc0-4f64-9602-46a3a2eb84dd", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.population_size = 10\n        self.mutation_rate = 0.1\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        population = np.random.uniform(self.bounds[0][0], self.bounds[0][1], (self.population_size, self.dim))\n        for _ in range(self.budget):\n            new_individuals = []\n            for individual in population:\n                if np.random.rand() < self.mutation_rate:\n                    new_individual = individual + np.random.uniform(-1, 1, self.dim)\n                    new_individuals.append(new_individual)\n                else:\n                    new_individuals.append(individual)\n            population = np.array(new_individuals)\n\n        fitness_values = [func(individual) for individual in population]\n        indices = np.argsort(fitness_values)\n        population = population[indices]\n        fitness_values = fitness_values[indices]\n\n        new_population = population[:self.population_size//2]\n        for _ in range(self.population_size//2):\n            parent1, parent2 = np.random.choice(population, size=2, replace=False)\n            child = (parent1 + parent2) / 2\n            new_population.append(child)\n\n        return np.min(fitness_values), np.min([func(individual) for individual in new_population])\n\n# Example usage:\ndef f1(x):\n    return x[0]**2 + x[1]**2\n\ndef f2(x):\n    return x[0]**2 + x[1]**2 + 1.5 * np.sin(2 * np.pi * x[0]) + 0.5 * np.sin(4 * np.pi * x[1])\n\ndef f3(x):\n    return x[0]**2 + x[1]**2 + 2 * np.sin(2 * np.pi * x[0]) + 1 * np.sin(4 * np.pi * x[1])\n\ndef f4(x):\n    return x[0]**2 + x[1]**2 + 2 * np.sin(2 * np.pi * x[0]) + 2 * np.sin(4 * np.pi * x[1])\n\ndef f5(x):\n    return x[0]**2 + x[1]**2 + 2 * np.sin(2 * np.pi * x[0]) + 2 * np.sin(4 * np.pi * x[1])\n\ndef f6(x):\n    return x[0]**2 + x[1]**2 + 2 * np.sin(2 * np.pi * x[0]) + 2 * np.sin(4 * np.pi * x[1])\n\ndef f7(x):\n    return x[0]**2 + x[1]**2 + 2 * np.sin(2 * np.pi * x[0]) + 2 * np.sin(4 * np.pi * x[1])\n\ndef f8(x):\n    return x[0]**2 + x[1]**2 + 2 * np.sin(2 * np.pi * x[0]) + 2 * np.sin(4 * np.pi * x[1])\n\ndef f9(x):\n    return x[0]**2 + x[1]**2 + 2 * np.sin(2 * np.pi * x[0]) + 2 * np.sin(4 * np.pi * x[1])\n\ndef f10(x):\n    return x[0]**2 + x[1]**2 + 2 * np.sin(2 * np.pi * x[0]) + 2 * np.sin(4 * np.pi * x[1])\n\ndef f11(x):\n    return x[0]**2 + x[1]**2 + 2 * np.sin(2 * np.pi * x[0]) + 2 * np.sin(4 * np.pi * x[1])\n\ndef f12(x):\n    return x[0]**2 + x[1]**2 + 2 * np.sin(2 * np.pi * x[0]) + 2 * np.sin(4 * np.pi * x[1])\n\ndef f13(x):\n    return x[0]**2 + x[1]**2 + 2 * np.sin(2 * np.pi * x[0]) + 2 * np.sin(4 * np.pi * x[1])\n\ndef f14(x):\n    return x[0]**2 + x[1]**2 + 2 * np.sin(2 * np.pi * x[0]) + 2 * np.sin(4 * np.pi * x[1])\n\ndef f15(x):\n    return x[0]**2 + x[1]**2 + 2 * np.sin(2 * np.pi * x[0]) + 2 * np.sin(4 * np.pi * x[1])\n\ndef f16(x):\n    return x[0]**2 + x[1]**2 + 2 * np.sin(2 * np.pi * x[0]) + 2 * np.sin(4 * np.pi * x[1])\n\ndef f17(x):\n    return x[0]**2 + x[1]**2 + 2 * np.sin(2 * np.pi * x[0]) + 2 * np.sin(4 * np.pi * x[1])\n\ndef f18(x):\n    return x[0]**2 + x[1]**2 + 2 * np.sin(2 * np.pi * x[0]) + 2 * np.sin(4 * np.pi * x[1])\n\ndef f19(x):\n    return x[0]**2 + x[1]**2 + 2 * np.sin(2 * np.pi * x[0]) + 2 * np.sin(4 * np.pi * x[1])\n\ndef f20(x):\n    return x[0]**2 + x[1]**2 + 2 * np.sin(2 * np.pi * x[0]) + 2 * np.sin(4 * np.pi * x[1])\n\ndef f21(x):\n    return x[0]**2 + x[1]**2 + 2 * np.sin(2 * np.pi * x[0]) + 2 * np.sin(4 * np.pi * x[1])\n\ndef f22(x):\n    return x[0]**2 + x[1]**2 + 2 * np.sin(2 * np.pi * x[0]) + 2 * np.sin(4 * np.pi * x[1])\n\ndef f23(x):\n    return x[0]**2 + x[1]**2 + 2 * np.sin(2 * np.pi * x[0]) + 2 * np.sin(4 * np.pi * x[1])\n\ndef f24(x):\n    return x[0]**2 + x[1]**2 + 2 * np.sin(2 * np.pi * x[0]) + 2 * np.sin(4 * np.pi * x[1])\n\n# Initialize the algorithm\nalgorithm = HybridEvolutionaryAlgorithm(budget=10, dim=2)\n\n# Evaluate the function\nresult = algorithm(f1)\n\nprint(result)", "name": "HybridEvolutionaryAlgorithm", "description": "Novel hybrid evolutionary algorithm with crossover and mutation for black box optimization.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('only integer scalar arrays can be converted to a scalar index').", "error": "TypeError('only integer scalar arrays can be converted to a scalar index')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "59de2362-a454-4671-a3c8-26deed0c4561", "solution": "import numpy as np\nimport random\nimport copy\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.fitness = np.zeros(self.budget)\n        self.x = np.zeros((self.budget, self.dim))\n        self.logger = []\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        for i in range(self.budget):\n            if i > 0:\n                new_individual = copy.deepcopy(self.x[i-1])\n                if random.random() < 0.4:\n                    new_individual = self.mutate(new_individual)\n                self.fitness[i] = func(new_individual)\n                self.x[i] = new_individual\n\n            if i < self.budget // 2:\n                new_individual = copy.deepcopy(self.x[i])\n                new_individual = self.crossover(new_individual)\n                self.fitness[i] = func(new_individual)\n                self.x[i] = new_individual\n\n        best_individual = self.x[np.argmin(self.fitness)]\n        return np.min(self.fitness), np.min(self.fitness)\n\n    def mutate(self, individual):\n        mutated_individual = list(individual)\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                mutated_individual[i] += np.random.uniform(-1, 1)\n                if mutated_individual[i] < self.bounds[i][0]:\n                    mutated_individual[i] = self.bounds[i][0]\n                elif mutated_individual[i] > self.bounds[i][1]:\n                    mutated_individual[i] = self.bounds[i][1]\n        return mutated_individual\n\n    def crossover(self, individual):\n        crossover_point = random.randint(1, self.dim - 1)\n        child1 = list(individual[:crossover_point])\n        child2 = list(individual[crossover_point:])\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child1[i], child2[i] = child2[i], child1[i]\n        return child1 + child2\n\n# Usage\ndef f1(x):\n    return x[0]**2 + x[1]**2\n\ndef f2(x):\n    return x[0]**2 + 2*x[1]**2\n\ndef f3(x):\n    return x[0]**3 + 3*x[1]**3\n\ndef f4(x):\n    return x[0]**4 + 4*x[1]**4\n\ndef f5(x):\n    return x[0]**5 + 5*x[1]**5\n\ndef f6(x):\n    return x[0]**6 + 6*x[1]**6\n\ndef f7(x):\n    return x[0]**7 + 7*x[1]**7\n\ndef f8(x):\n    return x[0]**8 + 8*x[1]**8\n\ndef f9(x):\n    return x[0]**9 + 9*x[1]**9\n\ndef f10(x):\n    return x[0]**10 + 10*x[1]**10\n\ndef f11(x):\n    return x[0]**11 + 11*x[1]**11\n\ndef f12(x):\n    return x[0]**12 + 12*x[1]**12\n\ndef f13(x):\n    return x[0]**13 + 13*x[1]**13\n\ndef f14(x):\n    return x[0]**14 + 14*x[1]**14\n\ndef f15(x):\n    return x[0]**15 + 15*x[1]**15\n\ndef f16(x):\n    return x[0]**16 + 16*x[1]**16\n\ndef f17(x):\n    return x[0]**17 + 17*x[1]**17\n\ndef f18(x):\n    return x[0]**18 + 18*x[1]**18\n\ndef f19(x):\n    return x[0]**19 + 19*x[1]**19\n\ndef f20(x):\n    return x[0]**20 + 20*x[1]**20\n\ndef f21(x):\n    return x[0]**21 + 21*x[1]**21\n\ndef f22(x):\n    return x[0]**22 + 22*x[1]**22\n\ndef f23(x):\n    return x[0]**23 + 23*x[1]**23\n\ndef f24(x):\n    return x[0]**24 + 24*x[1]**24\n\nif __name__ == \"__main__\":\n    heacombbo = HEACOMBBO(100, 2)\n    print(heacombbo(heacombbo.f1))", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) with 0.4 probability to change the individual lines of the selected solution to refine its strategy", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'HEACOMBBO' object has no attribute 'f1'\").", "error": "AttributeError(\"'HEACOMBBO' object has no attribute 'f1'\")", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "c95e0047-df80-4760-927a-44752936d960", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.refine_strategy = 0.4\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        for _ in range(int(self.budget * self.refine_strategy)):\n            new_individual = np.copy(self.x0)\n            for i in range(self.dim):\n                if random.random() < self.refine_strategy:\n                    new_individual[i] = self.x0[i] + random.uniform(-1, 1)\n                    new_individual[i] = np.clip(new_individual[i], self.bounds[i][0], self.bounds[i][1])\n            self.x0 = new_individual\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization using 0.4 probability to refine strategy", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 42, 142, None, 42, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 42, 142, None, 42, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "f0ab7448-fe0a-4fbc-86fe-5ebc635482e0", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass AdaptiveHEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.strategies = ['sbx', 'rand1', 'log-uniform', 'uniform']\n        self.strategy_probabilities = np.array([0.4, 0.3, 0.2, 0.1])\n        self.current_strategy = np.random.choice(self.strategies)\n        self.strategy_update_count = 0\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.current_strategy)\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.current_strategy, cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.current_strategy, cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.current_strategy, cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.current_strategy, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.current_strategy, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.current_strategy, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.current_strategy, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.current_strategy, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.current_strategy, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.current_strategy, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.current_strategy, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.current_strategy, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.current_strategy, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.current_strategy, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.current_strategy, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.current_strategy, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.current_strategy, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.current_strategy, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.current_strategy, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n        if np.random.rand() < 0.4:\n            self.current_strategy = np.random.choice(self.strategies)\n            self.strategy_update_count += 1\n            if self.strategy_update_count > 10:\n                self.strategy_update_count = 0\n\n        return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.current_strategy, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "AdaptiveHEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Adaptive Strategy for Black Box Optimization", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 36, 158, None, 36, 174)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 36, 158, None, 36, 174))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "146174a7-b91d-4482-8f73-ada6a7bd122b", "solution": "import numpy as np\nimport random\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.fitness = np.zeros(self.dim)\n        self.logger = []\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return self.differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return self.differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return self.differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return self.differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return self.differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return self.differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return self.differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return self.differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return self.differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return self.differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return self.differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return self.differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return self.differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return self.differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return self.differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return self.differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return self.differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return self.differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return self.differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return self.differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return self.differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return self.differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return self.differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return self.differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def differential_evolution(self, func, bounds, x0=None, tol=1e-5, x0_init=None, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform'):\n        if x0 is None:\n            x0 = np.random.uniform(bounds[0][0], bounds[0][1], self.dim)\n        if x0_init is not None:\n            x0 = x0_init\n        if strategy =='sbx':\n            cxpb = cxpb\n        if strategy == 'rand1':\n            cxpb = cxpb\n        if scaling == 'uniform':\n            w = w\n        if scaling == 'log-uniform':\n            w = w\n\n        def f(x):\n            return func(x)\n\n        def fitness(x):\n            return f(x)\n\n        def mutate(x):\n            if random.random() < cxpb:\n                idx = random.randint(0, self.dim-1)\n                x[idx] = x[idx] + random.uniform(-1, 1)\n                if x[idx] < bounds[idx][0]:\n                    x[idx] = bounds[idx][0]\n                elif x[idx] > bounds[idx][1]:\n                    x[idx] = bounds[idx][1]\n            return x\n\n        def crossover(x1, x2):\n            idx = random.randint(0, self.dim-1)\n            return x1[:idx] + x2[idx:]\n\n        def selection(x):\n            fitness_x = [fitness(x) for x in x]\n            idx = np.argsort(fitness_x)\n            return x[idx[0]]\n\n        def mutate_x(x):\n            return mutate(x)\n\n        def crossover_x(x1, x2):\n            return crossover(x1, x2)\n\n        def selection_x(x):\n            return selection(x)\n\n        def initialize_population(pop_size):\n            population = []\n            for _ in range(pop_size):\n                individual = mutate_x(np.random.uniform(bounds[0][0], bounds[0][1], self.dim))\n                population.append(individual)\n            return population\n\n        def update_population(population):\n            new_population = []\n            for _ in range(pop_size):\n                parent1 = selection_x(population)\n                parent2 = selection_x(population)\n                child = crossover_x(parent1, parent2)\n                new_population.append(child)\n            return new_population\n\n        population = initialize_population(pop_size)\n        for _ in range(100):\n            population = update_population(population)\n            self.logger.append([fitness(x) for x in population])\n\n        best_individual = min(population, key=fitness)\n        return best_individual, np.min([fitness(x) for x in population])\n\n# Usage\ndef f1(x):\n    return sum(x**2)\n\ndef f2(x):\n    return sum(x**2) + 1\n\ndef f3(x):\n    return sum(x**2) + 1 + np.sin(2*np.pi*x)\n\ndef f4(x):\n    return sum(x**2) + 1 + np.sin(2*np.pi*x) + np.cos(2*np.pi*x)\n\ndef f5(x):\n    return sum(x**2) + 1 + np.sin(2*np.pi*x) + np.cos(2*np.pi*x) + np.exp(x)\n\ndef f6(x):\n    return sum(x**2) + 1 + np.sin(2*np.pi*x) + np.cos(2*np.pi*x) + np.exp(x) + np.exp(x)\n\ndef f7(x):\n    return sum(x**2) + 1 + np.sin(2*np.pi*x) + np.cos(2*np.pi*x) + np.exp(x) + np.exp(x) + np.exp(x)\n\ndef f8(x):\n    return sum(x**2) + 1 + np.sin(2*np.pi*x) + np.cos(2*np.pi*x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x)\n\ndef f9(x):\n    return sum(x**2) + 1 + np.sin(2*np.pi*x) + np.cos(2*np.pi*x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x)\n\ndef f10(x):\n    return sum(x**2) + 1 + np.sin(2*np.pi*x) + np.cos(2*np.pi*x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x)\n\ndef f11(x):\n    return sum(x**2) + 1 + np.sin(2*np.pi*x) + np.cos(2*np.pi*x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x)\n\ndef f12(x):\n    return sum(x**2) + 1 + np.sin(2*np.pi*x) + np.cos(2*np.pi*x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x)\n\ndef f13(x):\n    return sum(x**2) + 1 + np.sin(2*np.pi*x) + np.cos(2*np.pi*x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x)\n\ndef f14(x):\n    return sum(x**2) + 1 + np.sin(2*np.pi*x) + np.cos(2*np.pi*x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x)\n\ndef f15(x):\n    return sum(x**2) + 1 + np.sin(2*np.pi*x) + np.cos(2*np.pi*x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x)\n\ndef f16(x):\n    return sum(x**2) + 1 + np.sin(2*np.pi*x) + np.cos(2*np.pi*x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x)\n\ndef f17(x):\n    return sum(x**2) + 1 + np.sin(2*np.pi*x) + np.cos(2*np.pi*x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x)\n\ndef f18(x):\n    return sum(x**2) + 1 + np.sin(2*np.pi*x) + np.cos(2*np.pi*x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x)\n\ndef f19(x):\n    return sum(x**2) + 1 + np.sin(2*np.pi*x) + np.cos(2*np.pi*x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x)\n\ndef f20(x):\n    return sum(x**2) + 1 + np.sin(2*np.pi*x) + np.cos(2*np.pi*x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x)\n\ndef f21(x):\n    return sum(x**2) + 1 + np.sin(2*np.pi*x) + np.cos(2*np.pi*x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x)\n\ndef f22(x):\n    return sum(x**2) + 1 + np.sin(2*np.pi*x) + np.cos(2*np.pi*x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x)\n\ndef f23(x):\n    return sum(x**2) + 1 + np.sin(2*np.pi*x) + np.cos(2*np.pi*x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x)\n\ndef f24(x):\n    return sum(x**2) + 1 + np.sin(2*np.pi*x) + np.cos(2*np.pi*x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x) + np.exp(x)\n\nbudget = 100\ndim = 10\noptimizer = HEACOMBBO(budget, dim)\n\nfor i in range(24):\n    func = globals()[f'f{i+1}']\n    best_individual, best_fitness = optimizer(func)\n    print(f'Function: f{i+1}, Best Individual: {best_individual}, Best Fitness: {best_fitness}')", "name": "HEACOMBBO", "description": "Novel Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError(\"duplicate argument 'strategy' in function definition\").", "error": "SyntaxError(\"duplicate argument 'strategy' in function definition\")", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "ccfaf1a1-0556-4b23-80a7-0cd0a2e7a16e", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.population_size = 10\n        self.population = [np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim) for _ in range(self.population_size)]\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        for _ in range(self.budget):\n            # Select parents using tournament selection\n            parents = []\n            for _ in range(self.population_size):\n                tournament = random.sample(self.population, 3)\n                winner = min(tournament, key=lambda x: func(x))\n                parents.append(winner)\n\n            # Perform crossover and mutation\n            new_population = []\n            for _ in range(self.population_size):\n                parent1, parent2 = random.sample(parents, 2)\n                child = parent1 + (parent2 - parent1) * 0.4\n                child = np.clip(child, self.bounds[0][0], self.bounds[0][1])\n                new_population.append(child)\n\n            # Replace the old population with the new one\n            self.population = new_population\n\n            # Evaluate the fitness of the new population\n            fitness = [func(individual) for individual in self.population]\n            min_fitness, min_individual = min(zip(fitness, self.population), key=lambda x: x[0])\n            self.population = [individual for individual, fitness in zip(self.population, fitness) if fitness > min_fitness]\n\n        # Return the best individual\n        min_fitness, min_individual = min(zip([func(individual) for individual in self.population], self.population), key=lambda x: x[0])\n        return min_individual, min_fitness\n\n# Example usage:\ndef f1(x):\n    return x[0]**2 + x[1]**2\n\ndef f2(x):\n    return x[0]**2 + 2*x[1]**2\n\ndef f3(x):\n    return x[0]**3 + 3*x[1]**3\n\ndef f4(x):\n    return x[0]**4 + 4*x[1]**4\n\ndef f5(x):\n    return x[0]**5 + 5*x[1]**5\n\ndef f6(x):\n    return x[0]**6 + 6*x[1]**6\n\ndef f7(x):\n    return x[0]**7 + 7*x[1]**7\n\ndef f8(x):\n    return x[0]**8 + 8*x[1]**8\n\ndef f9(x):\n    return x[0]**9 + 9*x[1]**9\n\ndef f10(x):\n    return x[0]**10 + 10*x[1]**10\n\ndef f11(x):\n    return x[0]**11 + 11*x[1]**11\n\ndef f12(x):\n    return x[0]**12 + 12*x[1]**12\n\ndef f13(x):\n    return x[0]**13 + 13*x[1]**13\n\ndef f14(x):\n    return x[0]**14 + 14*x[1]**14\n\ndef f15(x):\n    return x[0]**15 + 15*x[1]**15\n\ndef f16(x):\n    return x[0]**16 + 16*x[1]**16\n\ndef f17(x):\n    return x[0]**17 + 17*x[1]**17\n\ndef f18(x):\n    return x[0]**18 + 18*x[1]**18\n\ndef f19(x):\n    return x[0]**19 + 19*x[1]**19\n\ndef f20(x):\n    return x[0]**20 + 20*x[1]**20\n\ndef f21(x):\n    return x[0]**21 + 21*x[1]**21\n\ndef f22(x):\n    return x[0]**22 + 22*x[1]**22\n\ndef f23(x):\n    return x[0]**23 + 23*x[1]**23\n\ndef f24(x):\n    return x[0]**24 + 24*x[1]**24\n\n# Create an instance of the algorithm\nalgorithm = HybridEvolutionaryAlgorithm(budget=100, dim=2)\n\n# Optimize a function\nbest_individual, best_fitness = algorithm(f1)\n\nprint(\"Best individual:\", best_individual)\nprint(\"Best fitness:\", best_fitness)", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm with Adaptive Crossover and Mutation for Black Box Optimization", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "7178f4d8-55cd-4fe5-b9f9-ae5885c160cd", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        # Define the probability distribution for refining the strategy\n        strategy_distribution = np.random.choice(['sbx', 'rand1'], p=[0.3, 0.7])\n\n        # Define the probability distribution for scaling\n        scaling_distribution = np.random.choice(['uniform', 'log-uniform'], p=[0.4, 0.6])\n\n        # Initialize the population\n        population = [np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim) for _ in range(10)]\n\n        # Evaluate the fitness of each individual in the population\n        for individual in population:\n            exec(f\"individual = {func}({individual})\")\n\n        # Refine the strategy for each individual in the population\n        refined_population = []\n        for individual in population:\n            strategy = np.random.choice(['sbx', 'rand1'])\n            scaling = np.random.choice(['uniform', 'log-uniform'])\n            exec(f\"individual = {strategy}({individual}, {scaling})\")\n            refined_population.append(individual)\n\n        # Evaluate the fitness of each individual in the refined population\n        for individual in refined_population:\n            exec(f\"individual = {func}({individual})\")\n\n        # Return the individual with the best fitness\n        best_individual = min(refined_population, key=lambda x: exec(f\"{func}({x})\"))\n        return best_individual\n\n# Test the algorithm\ndef f1(x):\n    return np.sum(x**2)\n\ndef f2(x):\n    return np.sum(x**3)\n\ndef f3(x):\n    return np.sum(x**4)\n\ndef f4(x):\n    return np.sum(x**5)\n\ndef f5(x):\n    return np.sum(x**6)\n\ndef f6(x):\n    return np.sum(x**7)\n\ndef f7(x):\n    return np.sum(x**8)\n\ndef f8(x):\n    return np.sum(x**9)\n\ndef f9(x):\n    return np.sum(x**10)\n\ndef f10(x):\n    return np.sum(x**11)\n\ndef f11(x):\n    return np.sum(x**12)\n\ndef f12(x):\n    return np.sum(x**13)\n\ndef f13(x):\n    return np.sum(x**14)\n\ndef f14(x):\n    return np.sum(x**15)\n\ndef f15(x):\n    return np.sum(x**16)\n\ndef f16(x):\n    return np.sum(x**17)\n\ndef f17(x):\n    return np.sum(x**18)\n\ndef f18(x):\n    return np.sum(x**19)\n\ndef f19(x):\n    return np.sum(x**20)\n\ndef f20(x):\n    return np.sum(x**21)\n\ndef f21(x):\n    return np.sum(x**22)\n\ndef f22(x):\n    return np.sum(x**23)\n\ndef f23(x):\n    return np.sum(x**24)\n\ndef f24(x):\n    return np.sum(x**25)\n\nalgorithm = HybridEvolutionaryAlgorithm(10, 2)\nprint(algorithm(f1))", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization using probability-based strategy refinement.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 1, 14, 'individual = <function f1 at 0x7fa14baf8400>([-3.73769717  4.34513739])\\n', 1, 15)).", "error": "SyntaxError('invalid syntax', ('<string>', 1, 14, 'individual = <function f1 at 0x7fa14baf8400>([-3.73769717  4.34513739])\\n', 1, 15))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "74865c8a-6bf9-4528-a113-2e32a567f024", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass AdaptiveHEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.adaptive_strategies = ['sbx', 'rand1', 'uniform', 'log-uniform']\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.adaptive_strategies[np.random.choice(len(self.adaptive_strategies))])\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.adaptive_strategies[np.random.choice(len(self.adaptive_strategies))], cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.adaptive_strategies[np.random.choice(len(self.adaptive_strategies))], cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.adaptive_strategies[np.random.choice(len(self.adaptive_strategies))], cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.adaptive_strategies[np.random.choice(len(self.adaptive_strategies))], cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.adaptive_strategies[np.random.choice(len(self.adaptive_strategies))], cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.adaptive_strategies[np.random.choice(len(self.adaptive_strategies))], cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.adaptive_strategies[np.random.choice(len(self.adaptive_strategies))], cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.adaptive_strategies[np.random.choice(len(self.adaptive_strategies))], cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.adaptive_strategies[np.random.choice(len(self.adaptive_strategies))], cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.adaptive_strategies[np.random.choice(len(self.adaptive_strategies))], cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.adaptive_strategies[np.random.choice(len(self.adaptive_strategies))], cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.adaptive_strategies[np.random.choice(len(self.adaptive_strategies))], cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.adaptive_strategies[np.random.choice(len(self.adaptive_strategies))], cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.adaptive_strategies[np.random.choice(len(self.adaptive_strategies))], cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.adaptive_strategies[np.random.choice(len(self.adaptive_strategies))], cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.adaptive_strategies[np.random.choice(len(self.adaptive_strategies))], cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.adaptive_strategies[np.random.choice(len(self.adaptive_strategies))], cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.adaptive_strategies[np.random.choice(len(self.adaptive_strategies))], cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=self.adaptive_strategies[np.random.choice(len(self.adaptive_strategies))], cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n# Usage\nbudget = 100\ndim = 10\nalgorithm = AdaptiveHEACOMBBO(budget, dim)\nfor i in range(budget):\n    func_name = f\"f{i+1}\"\n    func = globals()[func_name]\n    result = algorithm(func)\n    print(f\"Function: {func_name}, Result: {result}\")", "name": "AdaptiveHEACOMBBO", "description": "Novel Hybrid Evolutionary Algorithm with Adaptive Crossover and Mutation for Black Box Optimization", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 210, None, 33, 226)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 210, None, 33, 226))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "00fbebc0-131b-4ae5-9bae-2a3fca8f4e51", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        population_size = 100\n        mutation_rate = 0.2\n        strategy_probabilities = [0.4, 0.3, 0.3]\n\n        population = np.random.uniform(self.bounds[0][0], self.bounds[0][1], (population_size, self.dim))\n        fitness = np.zeros(population_size)\n\n        for i in range(population_size):\n            individual = population[i]\n            func_value = func(individual)\n\n            if np.random.rand() < mutation_rate:\n                new_individual = individual + np.random.uniform(-1, 1, self.dim)\n                new_individual = np.clip(new_individual, self.bounds[0][0], self.bounds[0][1])\n                fitness[i] = func(new_individual)\n\n            else:\n                fitness[i] = func_value\n\n        best_individual = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        # Refine strategy\n        strategy = np.random.choice(['sbx', 'rand1', 'log-uniform'], p=strategy_probabilities)\n        if strategy =='sbx':\n            new_individual = best_individual + np.random.uniform(-1, 1, self.dim)\n            new_individual = np.clip(new_individual, self.bounds[0][0], self.bounds[0][1])\n        elif strategy == 'rand1':\n            new_individual = best_individual + np.random.uniform(-1, 1, self.dim)\n            new_individual = np.clip(new_individual, self.bounds[0][0], self.bounds[0][1])\n        elif strategy == 'log-uniform':\n            new_individual = best_individual + np.random.uniform(-1, 1, self.dim)\n            new_individual = np.clip(new_individual, self.bounds[0][0], self.bounds[0][1])\n\n        # Update population\n        population = np.vstack((population, [new_individual]))\n        fitness = np.append(fitness, [func(new_individual)])\n\n        # Update best individual\n        best_individual = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        # Update budget\n        self.budget -= 1\n\n        return best_individual, best_fitness\n\n# Test the algorithm\ndef f1(x):\n    return x[0]**2 + x[1]**2\n\ndef f2(x):\n    return x[0]**2 + x[1]**2 + 1e-5\n\ndef f3(x):\n    return x[0]**2 + x[1]**2 + 1e-5 + 1e-8\n\ndef f4(x):\n    return x[0]**2 + x[1]**2 + 1e-5 + 1e-8 + 1e-10\n\ndef f5(x):\n    return x[0]**2 + x[1]**2 + 1e-5 + 1e-8 + 1e-10 + 1e-12\n\ndef f6(x):\n    return x[0]**2 + x[1]**2 + 1e-5 + 1e-8 + 1e-10 + 1e-12 + 1e-15\n\ndef f7(x):\n    return x[0]**2 + x[1]**2 + 1e-5 + 1e-8 + 1e-10 + 1e-12 + 1e-15 + 1e-18\n\ndef f8(x):\n    return x[0]**2 + x[1]**2 + 1e-5 + 1e-8 + 1e-10 + 1e-12 + 1e-15 + 1e-18 + 1e-20\n\ndef f9(x):\n    return x[0]**2 + x[1]**2 + 1e-5 + 1e-8 + 1e-10 + 1e-12 + 1e-15 + 1e-18 + 1e-20 + 1e-22\n\ndef f10(x):\n    return x[0]**2 + x[1]**2 + 1e-5 + 1e-8 + 1e-10 + 1e-12 + 1e-15 + 1e-18 + 1e-20 + 1e-22 + 1e-24\n\ndef f11(x):\n    return x[0]**2 + x[1]**2 + 1e-5 + 1e-8 + 1e-10 + 1e-12 + 1e-15 + 1e-18 + 1e-20 + 1e-22 + 1e-24 + 1e-26\n\ndef f12(x):\n    return x[0]**2 + x[1]**2 + 1e-5 + 1e-8 + 1e-10 + 1e-12 + 1e-15 + 1e-18 + 1e-20 + 1e-22 + 1e-24 + 1e-26 + 1e-28\n\ndef f13(x):\n    return x[0]**2 + x[1]**2 + 1e-5 + 1e-8 + 1e-10 + 1e-12 + 1e-15 + 1e-18 + 1e-20 + 1e-22 + 1e-24 + 1e-26 + 1e-28 + 1e-30\n\ndef f14(x):\n    return x[0]**2 + x[1]**2 + 1e-5 + 1e-8 + 1e-10 + 1e-12 + 1e-15 + 1e-18 + 1e-20 + 1e-22 + 1e-24 + 1e-26 + 1e-28 + 1e-30 + 1e-32\n\ndef f15(x):\n    return x[0]**2 + x[1]**2 + 1e-5 + 1e-8 + 1e-10 + 1e-12 + 1e-15 + 1e-18 + 1e-20 + 1e-22 + 1e-24 + 1e-26 + 1e-28 + 1e-30 + 1e-32 + 1e-34\n\ndef f16(x):\n    return x[0]**2 + x[1]**2 + 1e-5 + 1e-8 + 1e-10 + 1e-12 + 1e-15 + 1e-18 + 1e-20 + 1e-22 + 1e-24 + 1e-26 + 1e-28 + 1e-30 + 1e-32 + 1e-34 + 1e-36\n\ndef f17(x):\n    return x[0]**2 + x[1]**2 + 1e-5 + 1e-8 + 1e-10 + 1e-12 + 1e-15 + 1e-18 + 1e-20 + 1e-22 + 1e-24 + 1e-26 + 1e-28 + 1e-30 + 1e-32 + 1e-34 + 1e-36 + 1e-38\n\ndef f18(x):\n    return x[0]**2 + x[1]**2 + 1e-5 + 1e-8 + 1e-10 + 1e-12 + 1e-15 + 1e-18 + 1e-20 + 1e-22 + 1e-24 + 1e-26 + 1e-28 + 1e-30 + 1e-32 + 1e-34 + 1e-36 + 1e-38 + 1e-40\n\ndef f19(x):\n    return x[0]**2 + x[1]**2 + 1e-5 + 1e-8 + 1e-10 + 1e-12 + 1e-15 + 1e-18 + 1e-20 + 1e-22 + 1e-24 + 1e-26 + 1e-28 + 1e-30 + 1e-32 + 1e-34 + 1e-36 + 1e-38 + 1e-40 + 1e-42\n\ndef f20(x):\n    return x[0]**2 + x[1]**2 + 1e-5 + 1e-8 + 1e-10 + 1e-12 + 1e-15 + 1e-18 + 1e-20 + 1e-22 + 1e-24 + 1e-26 + 1e-28 + 1e-30 + 1e-32 + 1e-34 + 1e-36 + 1e-38 + 1e-40 + 1e-42 + 1e-44\n\ndef f21(x):\n    return x[0]**2 + x[1]**2 + 1e-5 + 1e-8 + 1e-10 + 1e-12 + 1e-15 + 1e-18 + 1e-20 + 1e-22 + 1e-24 + 1e-26 + 1e-28 + 1e-30 + 1e-32 + 1e-34 + 1e-36 + 1e-38 + 1e-40 + 1e-42 + 1e-44 + 1e-46\n\ndef f22(x):\n    return x[0]**2 + x[1]**2 + 1e-5 + 1e-8 + 1e-10 + 1e-12 + 1e-15 + 1e-18 + 1e-20 + 1e-22 + 1e-24 + 1e-26 + 1e-28 + 1e-30 + 1e-32 + 1e-34 + 1e-36 + 1e-38 + 1e-40 + 1e-42 + 1e-44 + 1e-46 + 1e-48\n\ndef f23(x):\n    return x[0]**2 + x[1]**2 + 1e-5 + 1e-8 + 1e-10 + 1e-12 + 1e-15 + 1e-18 + 1e-20 + 1e-22 + 1e-24 + 1e-26 + 1e-28 + 1e-30 + 1e-32 + 1e-34 + 1e-36 + 1e-38 + 1e-40 + 1e-42 + 1e-44 + 1e-46 + 1e-48 + 1e-50\n\ndef f24(x):\n    return x[0]**2 + x[1]**2 + 1e-5 + 1e-8 + 1e-10 + 1e-12 + 1e-15 + 1e-18 + 1e-20 + 1e-22 + 1e-24 + 1e-26 + 1e-28 + 1e-30 + 1e-32 + 1e-34 + 1e-36 + 1e-38 + 1e-40 + 1e-42 + 1e-44 + 1e-46 + 1e-48 + 1e-50 + 1e-52\n\n# Test the algorithm\nif __name__ == '__main__':\n    algorithm = HybridEvolutionaryAlgorithm(100, 2)\n    func = f1\n    individual, fitness = algorithm(func)\n    print(individual, fitness)", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm with Crossover, Mutation, and Strategy Refinement for Black Box Optimization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "46c22055-4eec-4303-b410-25acdaed7872", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.probability = 0.4\n        self.refine_strategy = False\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if self.refine_strategy:\n            new_individual = self.refine_individual(self.x0)\n        else:\n            new_individual = self.x0\n\n        if random.random() < self.probability:\n            new_individual = self.mutate(new_individual)\n\n        return self.f(new_individual, func)\n\n    def refine_individual(self, individual):\n        new_individual = list(individual)\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                new_individual[i] = np.random.uniform(self.bounds[i][0], self.bounds[i][1])\n        return tuple(new_individual)\n\n    def mutate(self, individual):\n        mutation_type = random.random()\n        if mutation_type < 0.5:\n            return self.mutate_add(individual)\n        elif mutation_type < 0.8:\n            return self.mutate_subtract(individual)\n        else:\n            return self.mutate_multiply(individual)\n\n    def mutate_add(self, individual):\n        index = random.randint(0, self.dim - 1)\n        individual[index] += np.random.uniform(-1, 1)\n        return tuple(individual)\n\n    def mutate_subtract(self, individual):\n        index = random.randint(0, self.dim - 1)\n        individual[index] -= np.random.uniform(-1, 1)\n        return tuple(individual)\n\n    def mutate_multiply(self, individual):\n        index = random.randint(0, self.dim - 1)\n        factor = np.random.uniform(0.5, 1.5)\n        individual[index] *= factor\n        return tuple(individual)\n\n    def f(self, individual, func):\n        return func(*individual)\n\n# Usage\nbudget = 100\ndim = 10\nalgorithm = HybridEvolutionaryAlgorithm(budget, dim)\n\n# Test the algorithm on a sample function\ndef f1(x):\n    return x[0]**2 + x[1]**2\n\nalgorithm.refine_strategy = True\nresult = algorithm(f1)\n\nprint(result)", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm with Crossover, Mutation, and Probability-based Refinement for Black Box Optimization", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('f1() takes 1 positional argument but 10 were given').", "error": "TypeError('f1() takes 1 positional argument but 10 were given')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "896bdfcc-97df-4275-995a-2c975f67a048", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        def mutate(individual):\n            if random.random() < 0.4:\n                # Randomly select two indices\n                i, j = random.sample(range(self.dim), 2)\n                # Swap the values\n                individual[i], individual[j] = individual[j], individual[i]\n            return individual\n\n        def crossover(individual1, individual2):\n            # Randomly select two indices\n            i, j = random.sample(range(self.dim), 2)\n            # Swap the values\n            individual1[i], individual2[i] = individual2[i], individual1[i]\n            return individual1, individual2\n\n        def evaluate_fitness(individual):\n            return func(individual)\n\n        def hybrid_evolution(func, bounds):\n            population = [np.random.uniform(bounds[0][0], bounds[0][1], self.dim) for _ in range(100)]\n            for _ in range(self.budget):\n                # Evaluate the fitness\n                fitness = [evaluate_fitness(individual) for individual in population]\n                # Select the fittest individuals\n                population = [individual for _, individual in sorted(zip(fitness, population))[:50]]\n                # Perform crossover and mutation\n                population = [mutate(crossover(population[0], individual)) for individual in population[1:]]\n            return np.min(fitness)\n\n        return hybrid_evolution(func, self.bounds)\n\n# Usage:\n# ```python\n# import numpy as np\n# from scipy.optimize import differential_evolution\n\n# def func(x):\n#     return x[0]**2 + x[1]**2\n\n# algorithm = HybridEvolutionaryAlgorithm(100, 2)\n# result = algorithm(func)\n# print(result)", "name": "HybridEvolutionaryAlgorithm", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization using Differential Evolution strategy with 0.4 probability.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'tuple' object does not support item assignment\").", "error": "TypeError(\"'tuple' object does not support item assignment\")", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "4ba77f27-e588-4f36-830a-4f1eeb2cf1fd", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        for _ in range(int(self.budget * 0.6)):\n            # Evolutionary strategy\n            strategy = np.random.choice(['sbx', 'rand1', 'log-uniform'])\n            if strategy =='sbx':\n                x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n                res = differential_evolution(func, self.bounds, x0=x0, tol=1e-5, cxpb=0.5, mu=0.5, w=0.5)\n            elif strategy == 'rand1':\n                x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n                res = differential_evolution(func, self.bounds, x0=x0, tol=1e-5, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n            elif strategy == 'log-uniform':\n                x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n                res = differential_evolution(func, self.bounds, x0=x0, tol=1e-5, cxpb=0.5, mu=0.5, w=0.5, strategy='sbx', scaling='log-uniform')\n\n            # Mutation\n            mutated_individual = res.x\n            for i in range(self.dim):\n                if np.random.rand() < 0.4:\n                    mutated_individual[i] += np.random.uniform(-1, 1)\n                    mutated_individual[i] = max(self.bounds[i][0], min(mutated_individual[i], self.bounds[i][1]))\n\n            # Update the best individual\n            if np.any(func(mutated_individual) < func(res.x)):\n                self.x0 = mutated_individual\n\n        # Final evaluation\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, cxpb=0.5, mu=0.5, w=0.5)\n        return res.x, res.fun\n\n# Example usage\ndef f1(x):\n    return x[0]**2 + x[1]**2\n\ndef f2(x):\n    return x[0]**2 + x[1]**2 + 1e-3 * x[0] * x[1]\n\ndef f3(x):\n    return x[0]**2 + x[1]**2 + 1e-3 * x[0] * x[1] + 1e-6 * x[0]**2 * x[1]**2\n\ndef f4(x):\n    return x[0]**2 + x[1]**2 + 1e-3 * x[0] * x[1] + 1e-6 * x[0]**2 * x[1]**2 + 1e-9 * x[0]**3 * x[1]**3\n\ndef f5(x):\n    return x[0]**2 + x[1]**2 + 1e-3 * x[0] * x[1] + 1e-6 * x[0]**2 * x[1]**2 + 1e-9 * x[0]**3 * x[1]**3 + 1e-12 * x[0]**4 * x[1]**4\n\ndef f6(x):\n    return x[0]**2 + x[1]**2 + 1e-3 * x[0] * x[1] + 1e-6 * x[0]**2 * x[1]**2 + 1e-9 * x[0]**3 * x[1]**3 + 1e-12 * x[0]**4 * x[1]**4 + 1e-15 * x[0]**5 * x[1]**5\n\ndef f7(x):\n    return x[0]**2 + x[1]**2 + 1e-3 * x[0] * x[1] + 1e-6 * x[0]**2 * x[1]**2 + 1e-9 * x[0]**3 * x[1]**3 + 1e-12 * x[0]**4 * x[1]**4 + 1e-15 * x[0]**5 * x[1]**5 + 1e-18 * x[0]**6 * x[1]**6\n\ndef f8(x):\n    return x[0]**2 + x[1]**2 + 1e-3 * x[0] * x[1] + 1e-6 * x[0]**2 * x[1]**2 + 1e-9 * x[0]**3 * x[1]**3 + 1e-12 * x[0]**4 * x[1]**4 + 1e-15 * x[0]**5 * x[1]**5 + 1e-18 * x[0]**6 * x[1]**6 + 1e-21 * x[0]**7 * x[1]**7\n\ndef f9(x):\n    return x[0]**2 + x[1]**2 + 1e-3 * x[0] * x[1] + 1e-6 * x[0]**2 * x[1]**2 + 1e-9 * x[0]**3 * x[1]**3 + 1e-12 * x[0]**4 * x[1]**4 + 1e-15 * x[0]**5 * x[1]**5 + 1e-18 * x[0]**6 * x[1]**6 + 1e-21 * x[0]**7 * x[1]**7 + 1e-24 * x[0]**8 * x[1]**8\n\ndef f10(x):\n    return x[0]**2 + x[1]**2 + 1e-3 * x[0] * x[1] + 1e-6 * x[0]**2 * x[1]**2 + 1e-9 * x[0]**3 * x[1]**3 + 1e-12 * x[0]**4 * x[1]**4 + 1e-15 * x[0]**5 * x[1]**5 + 1e-18 * x[0]**6 * x[1]**6 + 1e-21 * x[0]**7 * x[1]**7 + 1e-24 * x[0]**8 * x[1]**8 + 1e-27 * x[0]**9 * x[1]**9\n\ndef f11(x):\n    return x[0]**2 + x[1]**2 + 1e-3 * x[0] * x[1] + 1e-6 * x[0]**2 * x[1]**2 + 1e-9 * x[0]**3 * x[1]**3 + 1e-12 * x[0]**4 * x[1]**4 + 1e-15 * x[0]**5 * x[1]**5 + 1e-18 * x[0]**6 * x[1]**6 + 1e-21 * x[0]**7 * x[1]**7 + 1e-24 * x[0]**8 * x[1]**8 + 1e-27 * x[0]**9 * x[1]**9 + 1e-30 * x[0]**10 * x[1]**10\n\ndef f12(x):\n    return x[0]**2 + x[1]**2 + 1e-3 * x[0] * x[1] + 1e-6 * x[0]**2 * x[1]**2 + 1e-9 * x[0]**3 * x[1]**3 + 1e-12 * x[0]**4 * x[1]**4 + 1e-15 * x[0]**5 * x[1]**5 + 1e-18 * x[0]**6 * x[1]**6 + 1e-21 * x[0]**7 * x[1]**7 + 1e-24 * x[0]**8 * x[1]**8 + 1e-27 * x[0]**9 * x[1]**9 + 1e-30 * x[0]**10 * x[1]**10 + 1e-33 * x[0]**11 * x[1]**11\n\ndef f13(x):\n    return x[0]**2 + x[1]**2 + 1e-3 * x[0] * x[1] + 1e-6 * x[0]**2 * x[1]**2 + 1e-9 * x[0]**3 * x[1]**3 + 1e-12 * x[0]**4 * x[1]**4 + 1e-15 * x[0]**5 * x[1]**5 + 1e-18 * x[0]**6 * x[1]**6 + 1e-21 * x[0]**7 * x[1]**7 + 1e-24 * x[0]**8 * x[1]**8 + 1e-27 * x[0]**9 * x[1]**9 + 1e-30 * x[0]**10 * x[1]**10 + 1e-33 * x[0]**11 * x[1]**11 + 1e-36 * x[0]**12 * x[1]**12\n\ndef f14(x):\n    return x[0]**2 + x[1]**2 + 1e-3 * x[0] * x[1] + 1e-6 * x[0]**2 * x[1]**2 + 1e-9 * x[0]**3 * x[1]**3 + 1e-12 * x[0]**4 * x[1]**4 + 1e-15 * x[0]**5 * x[1]**5 + 1e-18 * x[0]**6 * x[1]**6 + 1e-21 * x[0]**7 * x[1]**7 + 1e-24 * x[0]**8 * x[1]**8 + 1e-27 * x[0]**9 * x[1]**9 + 1e-30 * x[0]**10 * x[1]**10 + 1e-33 * x[0]**11 * x[1]**11 + 1e-36 * x[0]**12 * x[1]**12 + 1e-39 * x[0]**13 * x[1]**13\n\ndef f15(x):\n    return x[0]**2 + x[1]**2 + 1e-3 * x[0] * x[1] + 1e-6 * x[0]**2 * x[1]**2 + 1e-9 * x[0]**3 * x[1]**3 + 1e-12 * x[0]**4 * x[1]**4 + 1e-15 * x[0]**5 * x[1]**5 + 1e-18 * x[0]**6 * x[1]**6 + 1e-21 * x[0]**7 * x[1]**7 + 1e-24 * x[0]**8 * x[1]**8 + 1e-27 * x[0]**9 * x[1]**9 + 1e-30 * x[0]**10 * x[1]**10 + 1e-33 * x[0]**11 * x[1]**11 + 1e-36 * x[0]**12 * x[1]**12 + 1e-39 * x[0]**13 * x[1]**13 + 1e-42 * x[0]**14 * x[1]**14\n\ndef f16(x):\n    return x[0]**2 + x[1]**2 + 1e-3 * x[0] * x[1] + 1e-6 * x[0]**2 * x[1]**2 + 1e-9 * x[0]**3 * x[1]**3 + 1e-12 * x[0]**4 * x[1]**4 + 1e-15 * x[0]**5 * x[1]**5 + 1e-18 * x[0]**6 * x[1]**6 + 1e-21 * x[0]**7 * x[1]**7 + 1e-24 * x[0]**8 * x[1]**8 + 1e-27 * x[0]**9 * x[1]**9 + 1e-30 * x[0]**10 * x[1]**10 + 1e-33 * x[0]**11 * x[1]**11 + 1e-36 * x[0]**12 * x[1]**12 + 1e-39 * x[0]**13 * x[1]**13 + 1e-42 * x[0]**14 * x[1]**14 + 1e-45 * x[0]**15 * x[1]**15\n\ndef f17(x):\n    return x[0]**2 + x[1]**2 + 1e-3 * x[0] * x[1] + 1e-6 * x[0]**2 * x[1]**2 + 1e-9 * x[0]**3 * x[1]**3 + 1e-12 * x[0]**4 * x[1]**4 + 1e-15 * x[0]**5 * x[1]**5 + 1e-18 * x[0]**6 * x[1]**6 + 1e-21 * x[0]**7 * x[1]**7 + 1e-24 * x[0]**8 * x[1]**8 + 1e-27 * x[0]**9 * x[1]**9 + 1e-30 * x[0]**10 * x[1]**10 + 1e-33 * x[0]**11 * x[1]**11 + 1e-36 * x[0]**12 * x[1]**12 + 1e-39 * x[0]**13 * x[1]**13 + 1e-42 * x[0]**14 * x[1]**14 + 1e-45 * x[0]**15 * x[1]**15 + 1e-48 * x[0]**16 * x[1]**16\n\ndef f18(x):\n    return x[0]**2 + x[1]**2 + 1e-3 * x[0] * x[1] + 1e-6 * x[0]**2 * x[1]**2 + 1e-9 * x[0]**3 * x[1]**3 + 1e-12 * x[0]**4 * x[1]**4 + 1e-15 * x[0]**5 * x[1]**5 + 1e-18 * x[0]**6 * x[1]**6 + 1e-21 * x[0]**7 * x[1]**7 + 1e-24 * x[0]**8 * x[1]**8 + 1e-27 * x[0]**9 * x[1]**9 + 1e-30 * x[0]**10 * x[1]**10 + 1e-33 * x[0]**11 * x[1]**11 + 1e-36 * x[0]**12 * x[1]**12 + 1e-39 * x[0]**13 * x[1]**13 + 1e-42 * x[0]**14 * x[1]**14 + 1e-45 * x[0]**15 * x[1]**15 + 1e-48 * x[0]**16 * x[1]**16 + 1e-51 * x[0]**17 * x[1]**17\n\ndef f19(x):\n    return x[0]**2 + x[1]**2 + 1e-3 * x[0] * x[1] + 1e-6 * x[0]**2 * x[1]**2 + 1e-9 * x[0]**3 * x[1]**3 + 1e-12 * x[0]**4 * x[1]**4 + 1e-15 * x[0]**5 * x[1]**5 + 1e-18 * x[0]**6 * x[1]**6 + 1e-21 * x[0]**7 * x[1]**7 + 1e-24 * x[0]**8 * x[1]**8 + 1e-27 * x[0]**9 * x[1]**9 + 1e-30 * x[0]**10 * x[1]**10 + 1e-33 * x[0]**11 * x[1]**11 + 1e-36 * x[0]**12 * x[1]**12 + 1e-39 * x[0]**13 * x[1]**13 + 1e-42 * x[0]**14 * x[1]**14 + 1e-45 * x[0]**15 * x[1]**15 + 1e-48 * x[0]**16 * x[1]**16 + 1e-51 * x[0]**17 * x[1]**17 + 1e-54 * x[0]**18 * x[1]**18\n\ndef f20(x):\n    return x[0]**2 + x[1]**2 + 1e-3 * x[0] * x[1] + 1e-6 * x[0]**2 * x[1]**2 + 1e-9 * x[0]**3 * x[1]**3 + 1e-12 * x[0]**4 * x[1]**4 + 1e-15 * x[0]**5 * x[1]**5 + 1e-18 * x[0]**6 * x[1]**6 + 1e-21 * x[0]**7 * x[1]**7 + 1e-24 * x[0]**8 * x[1]**8 + 1e-27 * x[0]**9 * x[1]**9 + 1e-30 * x[0]**10 * x[1]**10 + 1e-33 * x[0]**11 * x[1]**11 + 1e-36 * x[0]**12 * x[1]**12 + 1e-39 * x[0]**13 * x[1]**13 + 1e-42 * x[0]**14 * x[1]**14 + 1e-45 * x[0]**15 * x[1]**15 + 1e-48 * x[0]**16 * x[1]**16 + 1e-51 * x[0]**17 * x[1]**17 + 1e-54 * x[0]**18 * x[1]**18 + 1e-57 * x[0]**19 * x[1]**19\n\ndef f21(x):\n    return x[0]**2 + x[1]**2 + 1e-3 * x[0] * x[1] + 1e-6 * x[0]**2 * x[1]**2 + 1e-9 * x[0]**3 * x[1]**3 + 1e-12 * x[0]**4 * x[1]**4 + 1e-15 * x[0]**5 * x[1]**5 + 1e-18 * x[0]**6 * x[1]**6 + 1e-21 * x[0]**7 * x[1]**7 + 1e-24 * x[0]**8 * x[1]**8 + 1e-27 * x[0]**9 * x[1]**9 + 1e-30 * x[0]**10 * x[1]**10 + 1e-33 * x[0]**11 * x[1]**11 + 1e-36 * x[0]**12 * x[1]**12 + 1e-39 * x[0]**13 * x[1]**13 + 1e-42 * x[0]**14 * x[1]**14 + 1e-45 * x[0]**15 * x[1]**15 + 1e-48 * x[0]**16 * x[1]**16 + 1e-51 * x[0]**17 * x[1]**17 + 1e-54 * x[0]**18 * x[1]**18 + 1e-57 * x[0]**19 * x[1]**19 + 1e-60 * x[0]**20 * x[1]**20\n\ndef f22(x):\n    return x[0]**2 + x[1]**2 + 1e-3 * x[0] * x[1] + 1e-6 * x[0]**2 * x[1]**2 + 1e-9 * x[0]**3 * x[1]**3 + 1e-12 * x[0]**4 * x[1]**4 + 1e-15 * x[0]**5 * x[1]**5 + 1e-18 * x[0]**6 * x[1]**6 + 1e-21 * x[0]**7 * x[1]**7 + 1e-24 * x[0]**8 * x[1]**8 + 1e-27 * x[0]**9 * x[1]**9 + 1e-30 * x[0]**10 * x[1]**10 + 1e-33 * x[0]**11 * x[1]**11 + 1e-36 * x[0]**12 * x[1]**12 + 1e-39 * x[0]**13 * x[1]**13 + 1e-42 * x[0]**14 * x[1]**14 + 1e-45 * x[0]**15 * x[1]**15 + 1e-48 * x[0]**16 * x[1]**16 + 1e-51 * x[0]**17 * x[1]**17 + 1e-54 * x[0]**18 * x[1]**18 + 1e-57 * x[0]**19 * x[1]**19 + 1e-60 * x[0]**20 * x[1]**20 + 1e-63 * x[0]**21 * x[1]**21\n\ndef f23(x):\n    return x[0]**2 + x[1]**2 + 1e-3 * x[0] * x[1] + 1e-6 * x[0]**2 * x[1]**2 + 1e-9 * x[0]**3 * x[1]**3 + 1e-12 * x[0]**4 * x[1]**4 + 1e-15 * x[0]**5 * x[1]**5 + 1e-18 * x[0]**6 * x[1]**6 + 1e-21 * x[0]**7 * x[1]**7 + 1e-24 * x[0]**8 * x[1]**8 + 1e-27 * x[0]**9 * x[1]**9 + 1e-30 * x[0]**10 * x[1]**10 + 1e-33 * x[0]**11 * x[1]**11 + 1e-36 * x[0]**12 * x[1]**12 + 1e-39 * x[0]**13 * x[1]**13 + 1e-42 * x[0]**14 * x[1]**14 + 1e-45 * x[0]**15 * x[1]**15 + 1e-48 * x[0]**16 * x[1]**16 + 1e-51 * x[0]**17 * x[1]**17 + 1e-54 * x[0]**18 * x[1]**18 + 1e-57 * x[0]**19 * x[1]**19 + 1e-60 * x[0]**20 * x[1]**20 + 1e-63 * x[0]**21 * x[1]**21 + 1e-66 * x[0]**22 * x[1]**22\n\ndef f24(x):\n    return x[0]**2 + x[1]**2 + 1e-3 * x[0] * x[1] + 1e-6 * x[0]**2 * x[1]**2 + 1e-9 * x[0]**3 * x[1]**3 + 1e-12 * x[0]**4 * x[1]**4 + 1e-15 * x[0]**5 * x[1]**5 + 1e-18 * x[0]**6 * x[1]**6 + 1e-21 * x[0]**7 * x[1]**7 + 1e-24 * x[0]**8 * x[1]**8 + 1e-27 * x[0]**9 * x[1]**9 + 1e-30 * x[0]**10 * x[1]**10 + 1e-33 * x[0]**11 * x[1]**11 + 1e-36 * x[0]**12 * x[1]**12 + 1e-39 * x[0]**13 * x[1]**13 + 1e-42 * x[0]**14 * x[1]**14 + 1e-45 * x[0]**15 * x[1]**15 + 1e-48 * x[0]**16 * x[1]**16 + 1e-51 * x[0]**17 * x[1]**17 + 1e-54 * x[0]**18 * x[1]**18 + 1e-57 * x[0]**19 * x[1]**19 + 1e-60 * x[0]**20 * x[1]**20 + 1e-63 * x[0]**21 * x[1]**21 + 1e-66 * x[0]**22 * x[1]**22 + 1e-69 * x[0]**23 * x[1]**23\n\ndef optimize_function(func, budget, dim):\n    algorithm = HybridEvolutionaryAlgorithm(budget, dim)\n    return algorithm(func)\n\n# Test the function\nbudget = 100\ndim = 2\nfunc = f1\nresult = optimize_function(func, budget, dim)\nprint(result)", "name": "HybridEvolutionaryAlgorithm", "description": "Novel hybrid algorithm combining evolutionary strategies with mutation to optimize black box functions.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"differential_evolution() got an unexpected keyword argument 'cxpb'\").", "error": "TypeError(\"differential_evolution() got an unexpected keyword argument 'cxpb'\")", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "be8e36ef-8e02-4b9c-8f10-7deb506e170d", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "6341db7c-9656-4caf-a1f9-f56fe3c53bfe", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        # Initialize population\n        population = [np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim) for _ in range(100)]\n\n        # Initialize logger\n        logger = {}\n\n        # Evolve population\n        for i in range(self.budget):\n            # Evaluate fitness\n            fitness = [func(individual) for individual in population]\n\n            # Select parents\n            parents = np.array(population)[np.argsort(fitness)]\n\n            # Crossover\n            offspring = []\n            for _ in range(20):\n                parent1, parent2 = parents[np.random.randint(0, len(parents)-1)], parents[np.random.randint(0, len(parents)-1)]\n                child = (parent1 + parent2) / 2\n                offspring.append(child)\n\n            # Mutation\n            for child in offspring:\n                if random.random() < 0.4:\n                    child += np.random.uniform(-1, 1, self.dim)\n\n            # Replace worst individual\n            population = np.array(population)[np.argsort(fitness)]\n            population = np.concatenate((offspring, population))\n\n            # Update logger\n            for individual in population:\n                logger[individual] = fitness[np.where(population == individual)[0][0]]\n\n        # Return best individual\n        best_individual = population[np.argmin([func(individual) for individual in population])]\n        return func(best_individual), best_individual\n\n# Test the algorithm\ndef f1(x):\n    return x[0]**2 + x[1]**2\n\ndef f2(x):\n    return x[0]**2 + x[1]**2 + 0.5 * (x[0] + x[1])**2\n\ndef f3(x):\n    return x[0]**2 + x[1]**2 + 0.5 * (x[0] + x[1])**2 + 0.1 * (x[0] - x[1])**2\n\ndef f4(x):\n    return x[0]**2 + x[1]**2 + 0.5 * (x[0] + x[1])**2 + 0.1 * (x[0] - x[1])**2 + 0.01 * (x[0]**2 + x[1]**2)\n\ndef f5(x):\n    return x[0]**2 + x[1]**2 + 0.5 * (x[0] + x[1])**2 + 0.1 * (x[0] - x[1])**2 + 0.01 * (x[0]**2 + x[1]**2)\n\ndef f6(x):\n    return x[0]**2 + x[1]**2 + 0.5 * (x[0] + x[1])**2 + 0.1 * (x[0] - x[1])**2 + 0.01 * (x[0]**2 + x[1]**2)\n\ndef f7(x):\n    return x[0]**2 + x[1]**2 + 0.5 * (x[0] + x[1])**2 + 0.1 * (x[0] - x[1])**2 + 0.01 * (x[0]**2 + x[1]**2)\n\ndef f8(x):\n    return x[0]**2 + x[1]**2 + 0.5 * (x[0] + x[1])**2 + 0.1 * (x[0] - x[1])**2 + 0.01 * (x[0]**2 + x[1]**2)\n\ndef f9(x):\n    return x[0]**2 + x[1]**2 + 0.5 * (x[0] + x[1])**2 + 0.1 * (x[0] - x[1])**2 + 0.01 * (x[0]**2 + x[1]**2)\n\ndef f10(x):\n    return x[0]**2 + x[1]**2 + 0.5 * (x[0] + x[1])**2 + 0.1 * (x[0] - x[1])**2 + 0.01 * (x[0]**2 + x[1]**2)\n\ndef f11(x):\n    return x[0]**2 + x[1]**2 + 0.5 * (x[0] + x[1])**2 + 0.1 * (x[0] - x[1])**2 + 0.01 * (x[0]**2 + x[1]**2)\n\ndef f12(x):\n    return x[0]**2 + x[1]**2 + 0.5 * (x[0] + x[1])**2 + 0.1 * (x[0] - x[1])**2 + 0.01 * (x[0]**2 + x[1]**2)\n\ndef f13(x):\n    return x[0]**2 + x[1]**2 + 0.5 * (x[0] + x[1])**2 + 0.1 * (x[0] - x[1])**2 + 0.01 * (x[0]**2 + x[1]**2)\n\ndef f14(x):\n    return x[0]**2 + x[1]**2 + 0.5 * (x[0] + x[1])**2 + 0.1 * (x[0] - x[1])**2 + 0.01 * (x[0]**2 + x[1]**2)\n\ndef f15(x):\n    return x[0]**2 + x[1]**2 + 0.5 * (x[0] + x[1])**2 + 0.1 * (x[0] - x[1])**2 + 0.01 * (x[0]**2 + x[1]**2)\n\ndef f16(x):\n    return x[0]**2 + x[1]**2 + 0.5 * (x[0] + x[1])**2 + 0.1 * (x[0] - x[1])**2 + 0.01 * (x[0]**2 + x[1]**2)\n\ndef f17(x):\n    return x[0]**2 + x[1]**2 + 0.5 * (x[0] + x[1])**2 + 0.1 * (x[0] - x[1])**2 + 0.01 * (x[0]**2 + x[1]**2)\n\ndef f18(x):\n    return x[0]**2 + x[1]**2 + 0.5 * (x[0] + x[1])**2 + 0.1 * (x[0] - x[1])**2 + 0.01 * (x[0]**2 + x[1]**2)\n\ndef f19(x):\n    return x[0]**2 + x[1]**2 + 0.5 * (x[0] + x[1])**2 + 0.1 * (x[0] - x[1])**2 + 0.01 * (x[0]**2 + x[1]**2)\n\ndef f20(x):\n    return x[0]**2 + x[1]**2 + 0.5 * (x[0] + x[1])**2 + 0.1 * (x[0] - x[1])**2 + 0.01 * (x[0]**2 + x[1]**2)\n\ndef f21(x):\n    return x[0]**2 + x[1]**2 + 0.5 * (x[0] + x[1])**2 + 0.1 * (x[0] - x[1])**2 + 0.01 * (x[0]**2 + x[1]**2)\n\ndef f22(x):\n    return x[0]**2 + x[1]**2 + 0.5 * (x[0] + x[1])**2 + 0.1 * (x[0] - x[1])**2 + 0.01 * (x[0]**2 + x[1]**2)\n\ndef f23(x):\n    return x[0]**2 + x[1]**2 + 0.5 * (x[0] + x[1])**2 + 0.1 * (x[0] - x[1])**2 + 0.01 * (x[0]**2 + x[1]**2)\n\ndef f24(x):\n    return x[0]**2 + x[1]**2 + 0.5 * (x[0] + x[1])**2 + 0.1 * (x[0] - x[1])**2 + 0.01 * (x[0]**2 + x[1]**2)\n\n# Test the algorithm\nbudget = 100\ndim = 2\nalgorithm = HybridEvolutionaryAlgorithm(budget, dim)\nbest_function, best_individual = algorithm(f1)\nprint(f\"Best function: {best_function}, Best individual: {best_individual}\")", "name": "HybridEvolutionaryAlgorithm", "description": "Novel hybrid evolutionary algorithm with crossover and mutation for black box optimization.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unhashable type: 'numpy.ndarray'\").", "error": "TypeError(\"unhashable type: 'numpy.ndarray'\")", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "a5b4b013-b91b-4805-9ff5-f7c072937eba", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def refine_strategy(self, func):\n        if self.budget > 0:\n            best_individual = np.array(self.f(func))\n            self.budget -= 1\n            new_individual = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n            while np.any(new_individual == best_individual):\n                new_individual = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n            self.x0 = new_individual\n            return new_individual\n        else:\n            return np.nan, np.nan\n\n    def evaluate_fitness(self, individual):\n        func_name = individual.__class__.__name__\n        if func_name == 'f1':\n            return self.f(func_name)\n        elif func_name == 'f2':\n            return self.f(func_name, x0=individual)\n        elif func_name == 'f3':\n            return self.f(func_name, tol=1e-5)\n        elif func_name == 'f4':\n            return self.f(func_name, x0_init=individual)\n        elif func_name == 'f5':\n            return self.f(func_name, strategy='sbx')\n        elif func_name == 'f6':\n            return self.f(func_name, cxpb=0.5)\n        elif func_name == 'f7':\n            return self.f(func_name, cxpb=0.5, mu=0.5)\n        elif func_name == 'f8':\n            return self.f(func_name, cxpb=0.5, mu=0.5, w=0.5)\n        elif func_name == 'f9':\n            return self.f(func_name, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func_name == 'f10':\n            return self.f(func_name, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func_name == 'f11':\n            return self.f(func_name, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func_name == 'f12':\n            return self.f(func_name, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func_name == 'f13':\n            return self.f(func_name, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func_name == 'f14':\n            return self.f(func_name, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func_name == 'f15':\n            return self.f(func_name, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func_name == 'f16':\n            return self.f(func_name, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func_name == 'f17':\n            return self.f(func_name, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func_name == 'f18':\n            return self.f(func_name, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func_name == 'f19':\n            return self.f(func_name, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func_name == 'f20':\n            return self.f(func_name, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func_name == 'f21':\n            return self.f(func_name, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func_name == 'f22':\n            return self.f(func_name, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func_name == 'f23':\n            return self.f(func_name, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func_name == 'f24':\n            return self.f(func_name, cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def optimize(self, func):\n        if self.budget > 0:\n            best_individual = np.array(self.f(func))\n            self.budget -= 1\n            new_individual = self.refine_strategy(func)\n            return new_individual\n        else:\n            return np.nan, np.nan\n\n# Usage\nif __name__ == \"__main__\":\n    bbo_functions = ['f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'f11', 'f12', 'f13', 'f14', 'f15', 'f16', 'f17', 'f18', 'f19', 'f20', 'f21', 'f22', 'f23', 'f24']\n    for func in bbo_functions:\n        bbo = HEACOMBBO(100, 10)\n        best_individual, best_fitness = bbo.optimize(func)\n        print(f\"Function: {func}, Best Individual: {best_individual}, Best Fitness: {best_fitness}\")", "name": "HEACOMBBO", "description": "Novel Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) with strategy refinement.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 32, 142, None, 32, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 32, 142, None, 32, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "24419d59-06b8-4bf6-a32e-2e4070ee5379", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "c6d2c299-b40d-4d4a-86cf-e8244d10d4b8", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.population_size = 20\n        self.population = [self.x0 + np.random.uniform(-1, 1, self.dim) for _ in range(self.population_size)]\n        self.strategy_refinement_probability = 0.4\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        for _ in range(self.budget):\n            best_individual = self.f(func)\n            self.population = [self.evaluate_fitness(individual) for individual in self.population]\n            self.population.sort()\n            self.population = self.population[:self.population_size]\n\n            if random.random() < self.strategy_refinement_probability:\n                new_individual = random.choice(self.population)\n                new_individual = new_individual + np.random.uniform(-1, 1, self.dim)\n                self.population = [self.evaluate_fitness(individual) for individual in self.population]\n                self.population.sort()\n                self.population = self.population[:self.population_size]\n\n            best_individual = self.f(func)\n            self.population = [self.evaluate_fitness(individual) for individual in self.population]\n            self.population.sort()\n            self.population = self.population[:self.population_size]\n\n        return best_individual\n\n    def f(self, func):\n        return min(func(individual) for individual in self.population)\n\n    def evaluate_fitness(self, individual):\n        fitness = func(individual)\n        if fitness < self.f(func):\n            self.population = [self.evaluate_fitness(individual) for individual in self.population]\n            self.population.sort()\n            self.population = self.population[:self.population_size]\n        return fitness\n\n# Usage\ndef f1(x):\n    return x[0]**2 + x[1]**2\n\ndef f2(x):\n    return x[0]**2 + x[1]**2 + 0.5*x[0] + 0.5*x[1]\n\ndef f3(x):\n    return x[0]**2 + x[1]**2 + 0.5*x[0] + 0.5*x[1] + 1e-5\n\ndef f4(x):\n    return x[0]**2 + x[1]**2 + 0.5*x[0] + 0.5*x[1] + 1e-5\n\ndef f5(x):\n    return x[0]**2 + x[1]**2 + 0.5*x[0] + 0.5*x[1] + 1e-5\n\ndef f6(x):\n    return x[0]**2 + x[1]**2 + 0.5*x[0] + 0.5*x[1] + 1e-5\n\ndef f7(x):\n    return x[0]**2 + x[1]**2 + 0.5*x[0] + 0.5*x[1] + 1e-5\n\ndef f8(x):\n    return x[0]**2 + x[1]**2 + 0.5*x[0] + 0.5*x[1] + 1e-5\n\ndef f9(x):\n    return x[0]**2 + x[1]**2 + 0.5*x[0] + 0.5*x[1] + 1e-5\n\ndef f10(x):\n    return x[0]**2 + x[1]**2 + 0.5*x[0] + 0.5*x[1] + 1e-5\n\ndef f11(x):\n    return x[0]**2 + x[1]**2 + 0.5*x[0] + 0.5*x[1] + 1e-5\n\ndef f12(x):\n    return x[0]**2 + x[1]**2 + 0.5*x[0] + 0.5*x[1] + 1e-5\n\ndef f13(x):\n    return x[0]**2 + x[1]**2 + 0.5*x[0] + 0.5*x[1] + 1e-5\n\ndef f14(x):\n    return x[0]**2 + x[1]**2 + 0.5*x[0] + 0.5*x[1] + 1e-5\n\ndef f15(x):\n    return x[0]**2 + x[1]**2 + 0.5*x[0] + 0.5*x[1] + 1e-5\n\ndef f16(x):\n    return x[0]**2 + x[1]**2 + 0.5*x[0] + 0.5*x[1] + 1e-5\n\ndef f17(x):\n    return x[0]**2 + x[1]**2 + 0.5*x[0] + 0.5*x[1] + 1e-5\n\ndef f18(x):\n    return x[0]**2 + x[1]**2 + 0.5*x[0] + 0.5*x[1] + 1e-5\n\ndef f19(x):\n    return x[0]**2 + x[1]**2 + 0.5*x[0] + 0.5*x[1] + 1e-5\n\ndef f20(x):\n    return x[0]**2 + x[1]**2 + 0.5*x[0] + 0.5*x[1] + 1e-5\n\ndef f21(x):\n    return x[0]**2 + x[1]**2 + 0.5*x[0] + 0.5*x[1] + 1e-5\n\ndef f22(x):\n    return x[0]**2 + x[1]**2 + 0.5*x[0] + 0.5*x[1] + 1e-5\n\ndef f23(x):\n    return x[0]**2 + x[1]**2 + 0.5*x[0] + 0.5*x[1] + 1e-5\n\ndef f24(x):\n    return x[0]**2 + x[1]**2 + 0.5*x[0] + 0.5*x[1] + 1e-5\n\n# Usage\nbudget = 100\ndim = 2\nalgorithm = HybridEvolutionaryAlgorithm(budget, dim)\nbest_individual, _ = algorithm(f1)\nprint(best_individual)", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm with Crossover, Mutation and Strategy Refinement for Black Box Optimization", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "292d2250-10b4-4fd9-8ae1-cad4921c67d2", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def mutate(self, individual):\n        if random.random() < 0.4:\n            for i in range(self.dim):\n                if random.random() < 0.5:\n                    individual[i] = self.bounds[i][0] + random.uniform(0, self.bounds[i][1] - self.bounds[i][0])\n                else:\n                    individual[i] = self.bounds[i][1] - random.uniform(0, self.bounds[i][1] - self.bounds[i][0])\n        return individual\n\n    def crossover(self, parent1, parent2):\n        child = np.zeros(self.dim)\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def hybrid_evolutionary_algorithm(self, func):\n        population = [self.x0]\n        for _ in range(self.budget):\n            population.append(self.mutate(self.crossover(population[-1], population[np.random.choice(len(population))])))\n        best_individual = min(population, key=lambda individual: func(individual))\n        return best_individual, func(best_individual)\n\n# Example usage\nif __name__ == \"__main__\":\n    func = lambda x: x[0]**2 + x[1]**2\n    algorithm = HybridEvolutionaryAlgorithm(budget=100, dim=2)\n    best_individual, best_function_value = algorithm.hybrid_evolutionary_algorithm(func)\n    print(f\"Best individual: {best_individual}\")\n    print(f\"Best function value: {best_function_value}\")", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "a677d4d2-2537-451c-9679-a965f8a72a43", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.fitness_history = np.zeros(budget)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def evaluate_fitness(self, func, individual):\n        if func.__name__ == 'f1':\n            return -func(individual)\n        elif func.__name__ == 'f2':\n            return -func(individual)\n        elif func.__name__ == 'f3':\n            return -func(individual)\n        elif func.__name__ == 'f4':\n            return -func(individual)\n        elif func.__name__ == 'f5':\n            return -func(individual)\n        elif func.__name__ == 'f6':\n            return -func(individual)\n        elif func.__name__ == 'f7':\n            return -func(individual)\n        elif func.__name__ == 'f8':\n            return -func(individual)\n        elif func.__name__ == 'f9':\n            return -func(individual)\n        elif func.__name__ == 'f10':\n            return -func(individual)\n        elif func.__name__ == 'f11':\n            return -func(individual)\n        elif func.__name__ == 'f12':\n            return -func(individual)\n        elif func.__name__ == 'f13':\n            return -func(individual)\n        elif func.__name__ == 'f14':\n            return -func(individual)\n        elif func.__name__ == 'f15':\n            return -func(individual)\n        elif func.__name__ == 'f16':\n            return -func(individual)\n        elif func.__name__ == 'f17':\n            return -func(individual)\n        elif func.__name__ == 'f18':\n            return -func(individual)\n        elif func.__name__ == 'f19':\n            return -func(individual)\n        elif func.__name__ == 'f20':\n            return -func(individual)\n        elif func.__name__ == 'f21':\n            return -func(individual)\n        elif func.__name__ == 'f22':\n            return -func(individual)\n        elif func.__name__ == 'f23':\n            return -func(individual)\n        elif func.__name__ == 'f24':\n            return -func(individual)\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + (parent2 - parent1) * 0.5\n        return child\n\n    def mutation(self, individual):\n        mutation_rate = 0.1\n        if random.random() < mutation_rate:\n            individual = individual + random.uniform(-1.0, 1.0, self.dim)\n        return individual\n\n    def refine_strategy(self, individual):\n        if random.random() < 0.4:\n            if random.random() < 0.5:\n                individual = self.crossover(individual, individual)\n            else:\n                individual = self.mutation(individual)\n        return individual\n\n    def update(self, func):\n        self.fitness_history = np.zeros(self.budget)\n        for i in range(self.budget):\n            individual = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n            individual = self.refine_strategy(individual)\n            self.fitness_history[i] = self.evaluate_fitness(func, individual)\n            individual = self.refine_strategy(individual)\n            self.fitness_history[i] = self.evaluate_fitness(func, individual)\n            individual = self.refine_strategy(individual)\n            self.fitness_history[i] = self.evaluate_fitness(func, individual)\n            individual = self.refine_strategy(individual)\n            self.fitness_history[i] = self.evaluate_fitness(func, individual)\n            individual = self.refine_strategy(individual)\n            self.fitness_history[i] = self.evaluate_fitness(func, individual)\n            individual = self.refine_strategy(individual)\n            self.fitness_history[i] = self.evaluate_fitness(func, individual)\n            individual = self.refine_strategy(individual)\n            self.fitness_history[i] = self.evaluate_fitness(func, individual)\n        return np.min(self.fitness_history)\n\n# Usage:\nbudget = 50\ndim = 10\nfunc = lambda x: x[0]**2 + x[1]**2\nheacombbo = HEACOMBBO(budget, dim)\nprint(heacombbo.update(func))", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) using probability 0.4 to refine strategy.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 34, 142, None, 34, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 34, 142, None, 34, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "1d89dec0-2b53-46ad-a683-78c3bc5a73f5", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "07122473-13b9-444c-82b0-802109c2a135", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.strategies = ['sbx', 'rand1', 'log-uniform']\n        self.strategy_refinement_prob = 0.4\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def evaluate_fitness(self, individual):\n        func = globals()[individual['func']]\n        if func.__name__ == 'f1':\n            return func(self.bounds[0], self.bounds[1])\n        elif func.__name__ == 'f2':\n            return func(self.bounds[0], self.bounds[1], x0=individual['x0'])\n        elif func.__name__ == 'f3':\n            return func(self.bounds[0], self.bounds[1], tol=1e-5)\n        elif func.__name__ == 'f4':\n            return func(self.bounds[0], self.bounds[1], tol=1e-5, x0_init=individual['x0'])\n        elif func.__name__ == 'f5':\n            return func(self.bounds[0], self.bounds[1], x0=individual['x0'], strategy='sbx')\n        elif func.__name__ == 'f6':\n            return func(self.bounds[0], self.bounds[1], x0=individual['x0'], tol=1e-5, cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return func(self.bounds[0], self.bounds[1], x0=individual['x0'], tol=1e-5, x0_init=individual['x0'], mu=0.5)\n        elif func.__name__ == 'f8':\n            return func(self.bounds[0], self.bounds[1], x0=individual['x0'], tol=1e-5, x0_init=individual['x0'], strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return func(self.bounds[0], self.bounds[1], x0=individual['x0'], tol=1e-5, x0_init=individual['x0'], strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return func(self.bounds[0], self.bounds[1], x0=individual['x0'], tol=1e-5, x0_init=individual['x0'], strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return func(self.bounds[0], self.bounds[1], x0=individual['x0'], tol=1e-5, x0_init=individual['x0'], strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return func(self.bounds[0], self.bounds[1], x0=individual['x0'], tol=1e-5, x0_init=individual['x0'], strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return func(self.bounds[0], self.bounds[1], x0=individual['x0'], tol=1e-5, x0_init=individual['x0'], strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return func(self.bounds[0], self.bounds[1], x0=individual['x0'], tol=1e-5, x0_init=individual['x0'], strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return func(self.bounds[0], self.bounds[1], x0=individual['x0'], tol=1e-5, x0_init=individual['x0'], strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return func(self.bounds[0], self.bounds[1], x0=individual['x0'], tol=1e-5, x0_init=individual['x0'], strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return func(self.bounds[0], self.bounds[1], x0=individual['x0'], tol=1e-5, x0_init=individual['x0'], strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return func(self.bounds[0], self.bounds[1], x0=individual['x0'], tol=1e-5, x0_init=individual['x0'], strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return func(self.bounds[0], self.bounds[1], x0=individual['x0'], tol=1e-5, x0_init=individual['x0'], strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return func(self.bounds[0], self.bounds[1], x0=individual['x0'], tol=1e-5, x0_init=individual['x0'], strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return func(self.bounds[0], self.bounds[1], x0=individual['x0'], tol=1e-5, x0_init=individual['x0'], strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return func(self.bounds[0], self.bounds[1], x0=individual['x0'], tol=1e-5, x0_init=individual['x0'], strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return func(self.bounds[0], self.bounds[1], x0=individual['x0'], tol=1e-5, x0_init=individual['x0'], strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return func(self.bounds[0], self.bounds[1], x0=individual['x0'], tol=1e-5, x0_init=individual['x0'], strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def refine_strategy(self, individual):\n        strategy = individual['strategy']\n        if np.random.rand() < self.strategy_refinement_prob:\n            strategies = self.strategies\n            strategy = np.random.choice(strategies)\n            individual['strategy'] = strategy\n        return individual\n\n    def update(self, func):\n        if self.budget > 0:\n            self.budget -= 1\n            individual = {'func': func.__name__, 'x0': np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim),'strategy': np.random.choice(self.strategies)}\n            new_individual = self.evaluate_fitness(individual)\n            new_individual = self.refine_strategy(new_individual)\n            return new_individual\n        else:\n            return np.nan, np.nan\n\n# Usage\nif __name__ == \"__main__\":\n    budget = 10\n    dim = 10\n    func = 'f1'\n    heacombbo = HEACOMBBO(budget, dim)\n    new_individual = heacombbo.update(func)\n    print(new_individual)", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) with adaptive strategy refinement.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 34, 142, None, 34, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 34, 142, None, 34, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "acdbf337-30f1-457e-be21-ddeab13badc5", "solution": "import numpy as np\nimport random\nimport operator\n\nclass HybridEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.population_size = 100\n        self.mutation_rate = 0.2\n        self.crossover_rate = 0.4\n        self.logger = {}\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            self.population = self.initialize_population(func)\n            for _ in range(self.budget):\n                self.evolve_population(func)\n            return self.fittest_individual(func)\n\n        elif func.__name__ == 'f2':\n            self.population = self.initialize_population(func)\n            for _ in range(self.budget):\n                self.evolve_population(func)\n            return self.fittest_individual(func)\n\n        elif func.__name__ == 'f3':\n            self.population = self.initialize_population(func)\n            for _ in range(self.budget):\n                self.evolve_population(func)\n            return self.fittest_individual(func)\n\n        elif func.__name__ == 'f4':\n            self.population = self.initialize_population(func)\n            for _ in range(self.budget):\n                self.evolve_population(func)\n            return self.fittest_individual(func)\n\n        elif func.__name__ == 'f5':\n            self.population = self.initialize_population(func)\n            for _ in range(self.budget):\n                self.evolve_population(func)\n            return self.fittest_individual(func)\n\n        elif func.__name__ == 'f6':\n            self.population = self.initialize_population(func)\n            for _ in range(self.budget):\n                self.evolve_population(func)\n            return self.fittest_individual(func)\n\n        elif func.__name__ == 'f7':\n            self.population = self.initialize_population(func)\n            for _ in range(self.budget):\n                self.evolve_population(func)\n            return self.fittest_individual(func)\n\n        elif func.__name__ == 'f8':\n            self.population = self.initialize_population(func)\n            for _ in range(self.budget):\n                self.evolve_population(func)\n            return self.fittest_individual(func)\n\n        elif func.__name__ == 'f9':\n            self.population = self.initialize_population(func)\n            for _ in range(self.budget):\n                self.evolve_population(func)\n            return self.fittest_individual(func)\n\n        elif func.__name__ == 'f10':\n            self.population = self.initialize_population(func)\n            for _ in range(self.budget):\n                self.evolve_population(func)\n            return self.fittest_individual(func)\n\n        elif func.__name__ == 'f11':\n            self.population = self.initialize_population(func)\n            for _ in range(self.budget):\n                self.evolve_population(func)\n            return self.fittest_individual(func)\n\n        elif func.__name__ == 'f12':\n            self.population = self.initialize_population(func)\n            for _ in range(self.budget):\n                self.evolve_population(func)\n            return self.fittest_individual(func)\n\n        elif func.__name__ == 'f13':\n            self.population = self.initialize_population(func)\n            for _ in range(self.budget):\n                self.evolve_population(func)\n            return self.fittest_individual(func)\n\n        elif func.__name__ == 'f14':\n            self.population = self.initialize_population(func)\n            for _ in range(self.budget):\n                self.evolve_population(func)\n            return self.fittest_individual(func)\n\n        elif func.__name__ == 'f15':\n            self.population = self.initialize_population(func)\n            for _ in range(self.budget):\n                self.evolve_population(func)\n            return self.fittest_individual(func)\n\n        elif func.__name__ == 'f16':\n            self.population = self.initialize_population(func)\n            for _ in range(self.budget):\n                self.evolve_population(func)\n            return self.fittest_individual(func)\n\n        elif func.__name__ == 'f17':\n            self.population = self.initialize_population(func)\n            for _ in range(self.budget):\n                self.evolve_population(func)\n            return self.fittest_individual(func)\n\n        elif func.__name__ == 'f18':\n            self.population = self.initialize_population(func)\n            for _ in range(self.budget):\n                self.evolve_population(func)\n            return self.fittest_individual(func)\n\n        elif func.__name__ == 'f19':\n            self.population = self.initialize_population(func)\n            for _ in range(self.budget):\n                self.evolve_population(func)\n            return self.fittest_individual(func)\n\n        elif func.__name__ == 'f20':\n            self.population = self.initialize_population(func)\n            for _ in range(self.budget):\n                self.evolve_population(func)\n            return self.fittest_individual(func)\n\n        elif func.__name__ == 'f21':\n            self.population = self.initialize_population(func)\n            for _ in range(self.budget):\n                self.evolve_population(func)\n            return self.fittest_individual(func)\n\n        elif func.__name__ == 'f22':\n            self.population = self.initialize_population(func)\n            for _ in range(self.budget):\n                self.evolve_population(func)\n            return self.fittest_individual(func)\n\n        elif func.__name__ == 'f23':\n            self.population = self.initialize_population(func)\n            for _ in range(self.budget):\n                self.evolve_population(func)\n            return self.fittest_individual(func)\n\n        elif func.__name__ == 'f24':\n            self.population = self.initialize_population(func)\n            for _ in range(self.budget):\n                self.evolve_population(func)\n            return self.fittest_individual(func)\n\n    def initialize_population(self, func):\n        population = []\n        for _ in range(self.population_size):\n            individual = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n            population.append(individual)\n        return population\n\n    def evolve_population(self, func):\n        new_population = []\n        for individual in self.population:\n            fitness = func(individual)\n            if np.random.rand() < self.crossover_rate:\n                parent1 = np.random.choice(self.population)\n                parent2 = np.random.choice(self.population)\n                child = self.crossover(parent1, parent2)\n                if np.random.rand() < self.mutation_rate:\n                    child = self.mutate(child)\n            else:\n                child = individual\n            new_population.append(child)\n        self.population = new_population\n\n    def crossover(self, parent1, parent2):\n        child = []\n        for i in range(self.dim):\n            if np.random.rand() < 0.5:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def mutate(self, individual):\n        mutated_individual = individual.copy()\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                mutated_individual[i] += np.random.uniform(-1, 1)\n        return mutated_individual\n\n    def fittest_individual(self, func):\n        fitness = []\n        for individual in self.population:\n            fitness.append(func(individual))\n        fittest_index = np.argmin(fitness)\n        fittest_individual = self.population[fittest_index]\n        return fittest_individual, np.min(fitness)\n\n# Usage:\n# ```python\n# bbo = HybridEvolutionAlgorithm(100, 10)\n# best_individual, best_fitness = bbo('f1')\n# print(best_individual, best_fitness)\n# ```", "name": "HybridEvolutionAlgorithm", "description": "Novel hybrid evolution algorithm with crossover and mutation for black box optimization", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ioh.iohcpp.problem.Sphere' object has no attribute '__name__'\").", "error": "AttributeError(\"'ioh.iohcpp.problem.Sphere' object has no attribute '__name__'\")", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "28646deb-20c9-4224-889d-e63054ddfa0f", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nfrom scipy.stats import randint\n\nclass HybridDEGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        for _ in range(int(self.budget * 0.6)):\n            population_size = 50\n            population = np.random.uniform(self.bounds[0][0], self.bounds[0][1], (population_size, self.dim))\n            for _ in range(10):\n                new_population = []\n                for _ in range(population_size):\n                    parent1 = np.random.choice(population, 1, p=None)[0]\n                    parent2 = np.random.choice(population, 1, p=None)[0]\n                    child = (parent1 + parent2) / 2\n                    new_population.append(child)\n                population = new_population\n\n        best_individual = np.min(population, axis=0)\n        return func(best_individual), best_individual\n\n# Example usage:\nif __name__ == \"__main__\":\n    func = lambda x: x[0]**2 + 2*x[1]**2\n    hybridDEGA = HybridDEGA(10, 2)\n    f_min, x_min = hybridDEGA(func)\n    print(f\"f_min: {f_min}, x_min: {x_min}\")", "name": "HybridDEGA", "description": "Novel metaheuristic algorithm combining Differential Evolution and Genetic Algorithm to optimize black box functions.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "4e924187-7c71-4a3e-bf4b-fb08eff0a540", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.population_size = 20\n        self.probability = 0.4\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n        new_individual = self.evaluate_fitness(func)\n        if random.random() < self.probability:\n            new_individual = self.mutate(new_individual)\n        return new_individual\n\n    def evaluate_fitness(self, func):\n        return func(self.x0)\n\n    def mutate(self, individual):\n        mutated_individual = list(individual)\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                mutated_individual[i] += random.uniform(-1.0, 1.0)\n                mutated_individual[i] = max(self.bounds[i][0], min(self.bounds[i][1], mutated_individual[i]))\n        return mutated_individual\n\n# Usage\nif __name__ == \"__main__\":\n    budget = 100\n    dim = 10\n    optimizer = HEACOMBBO(budget, dim)\n    for i in range(budget):\n        func_name = f\"f{i+1}\"\n        func = globals()[func_name]\n        individual, _ = optimizer(func)\n        print(f\"Individual: {individual}\")", "name": "HEACOMBBO", "description": "Novel Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 35, 142, None, 35, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 35, 142, None, 35, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "b44d6b0e-119f-4ca2-92f2-61297aee6541", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.probability = 0.4\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def refine_strategy(self, individual):\n        if np.random.rand() < self.probability:\n            strategy = np.random.choice(['sbx', 'rand1', 'uniform', 'log-uniform'])\n            if strategy =='sbx':\n                cxpb = np.random.uniform(0.0, 0.5)\n                mu = np.random.uniform(0.0, 0.5)\n                w = np.random.uniform(0.0, 0.5)\n            elif strategy == 'rand1':\n                cxpb = np.random.uniform(0.0, 0.5)\n                mu = np.random.uniform(0.0, 0.5)\n                w = np.random.uniform(0.0, 0.5)\n            elif strategy == 'uniform':\n                cxpb = np.random.uniform(0.0, 0.5)\n                mu = np.random.uniform(0.0, 0.5)\n                w = np.random.uniform(0.0, 0.5)\n            elif strategy == 'log-uniform':\n                cxpb = np.random.uniform(0.0, 0.5)\n                mu = np.random.uniform(0.0, 0.5)\n                w = np.random.uniform(0.0, 0.5)\n            individual['cxpb'] = cxpb\n            individual['mu'] = mu\n            individual['w'] = w\n        return individual", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) with probability-based strategy refinement.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "7ecc47ba-4c81-4830-8b87-cdabec4a75ea", "solution": "import numpy as np\nimport random\nimport copy\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        population_size = 50\n        probability_refine = 0.4\n\n        # Initialize population\n        population = [np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim) for _ in range(population_size)]\n\n        # Refine strategy for 20% of the population\n        for _ in range(int(population_size * probability_refine)):\n            i = random.randint(0, population_size - 1)\n            new_individual = copy.deepcopy(population[i])\n            new_individual = self.refine_strategy(new_individual, func, self.bounds)\n            population[i] = new_individual\n\n        # Evaluate fitness\n        fitness = [self.evaluate_fitness(individual, func, self.bounds) for individual in population]\n\n        # Select fittest individuals\n        fittest_individuals = sorted(zip(population, fitness), key=lambda x: x[1])[:10]\n\n        # Perform crossover and mutation\n        new_population = []\n        for _ in range(population_size):\n            parent1, parent2 = random.sample(fittest_individuals, 2)\n            child = self.crossover(parent1[0], parent2[0])\n            child = self.mutate(child, func, self.bounds)\n            new_population.append(child)\n\n        return self.evaluate_fitness(new_population, func, self.bounds)\n\n    def refine_strategy(self, individual, func, bounds):\n        # Refine strategy by changing individual lines with probability 0.4\n        new_individual = copy.deepcopy(individual)\n        for i in range(self.dim):\n            if random.random() < 0.4:\n                new_individual[i] = random.uniform(bounds[i][0], bounds[i][1])\n        return new_individual\n\n    def evaluate_fitness(self, individual, func, bounds):\n        return func(individual)\n\n    def crossover(self, parent1, parent2):\n        # Perform crossover using uniform crossover\n        child = []\n        for i in range(self.dim):\n            if random.random() < 0.5:\n                child.append(parent1[i])\n            else:\n                child.append(parent2[i])\n        return child\n\n    def mutate(self, individual, func, bounds):\n        # Perform mutation using Gaussian mutation\n        for i in range(self.dim):\n            if random.random() < 0.1:\n                individual[i] += np.random.normal(0, 1)\n                individual[i] = max(bounds[i][0], min(bounds[i][1], individual[i]))\n        return individual", "name": "HybridEvolutionaryAlgorithm", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization using Probability Refinement", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "1be59be5-103f-4f71-973f-1953289eb91d", "solution": "import numpy as np\nimport random\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n        # Refine strategy using probability\n        if random.random() < 0.4:\n            strategy = random.choice(['sbx', 'rand1', 'uniform', 'log-uniform'])\n            if strategy =='sbx':\n                cxpb = random.uniform(0.1, 0.9)\n            elif strategy == 'rand1':\n                cxpb = random.uniform(0.1, 0.9)\n            elif strategy == 'uniform':\n                cxpb = random.uniform(0.1, 0.9)\n            elif strategy == 'log-uniform':\n                cxpb = random.uniform(0.1, 0.9)\n            if random.random() < 0.4:\n                mu = random.uniform(0.1, 0.9)\n            if random.random() < 0.4:\n                w = random.uniform(0.1, 0.9)\n\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy=strategy, cxpb=cxpb, mu=mu, w=w)\n\n        return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) using probability to refine strategy", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 32, 142, None, 32, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 32, 142, None, 32, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "ec067f7c-5f06-429f-8f17-c7e6b8e0ef2a", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.num_individuals = 10\n        self.p = 0.4\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        population = np.random.uniform(self.bounds[0][0], self.bounds[0][1], (self.num_individuals, self.dim))\n        for i in range(self.num_individuals):\n            if np.random.rand() < self.p:\n                new_individual = population[i]\n                new_individual[0] += np.random.uniform(-1, 1)\n                population[i] = new_individual\n\n        fitness = np.zeros((self.num_individuals, 1))\n        for i in range(self.num_individuals):\n            fitness[i] = func(population[i])\n\n        indices = np.argsort(fitness)\n        population = population[indices]\n        fitness = fitness[indices]\n\n        new_population = np.zeros((self.num_individuals, self.dim))\n        for i in range(self.num_individuals):\n            new_population[i] = population[i] + np.random.uniform(-1, 1)\n\n        return np.min(fitness), np.min(fitness, axis=0), new_population\n\n# Example usage\ndef f1(x):\n    return x[0]**2 + x[1]**2\n\ndef f2(x):\n    return x[0]**2 + x[1]**2 + x[0]*x[1]\n\ndef f3(x):\n    return x[0]**2 + x[1]**2 + x[0]*x[1] + x[0]*x[1]**2\n\ndef f4(x):\n    return x[0]**2 + x[1]**2 + x[0]*x[1] + x[0]*x[1]**2 + x[0]**2*x[1]**2\n\ndef f5(x):\n    return x[0]**2 + x[1]**2 + x[0]*x[1] + x[0]*x[1]**2 + x[0]**2*x[1]**2 + x[0]*x[1]**3\n\ndef f6(x):\n    return x[0]**2 + x[1]**2 + x[0]*x[1] + x[0]*x[1]**2 + x[0]**2*x[1]**2 + x[0]*x[1]**3 + x[0]**3*x[1]**3\n\ndef f7(x):\n    return x[0]**2 + x[1]**2 + x[0]*x[1] + x[0]*x[1]**2 + x[0]**2*x[1]**2 + x[0]*x[1]**3 + x[0]**3*x[1]**3 + x[0]**4*x[1]**4\n\ndef f8(x):\n    return x[0]**2 + x[1]**2 + x[0]*x[1] + x[0]*x[1]**2 + x[0]**2*x[1]**2 + x[0]*x[1]**3 + x[0]**3*x[1]**3 + x[0]**4*x[1]**4 + x[0]**5*x[1]**5\n\ndef f9(x):\n    return x[0]**2 + x[1]**2 + x[0]*x[1] + x[0]*x[1]**2 + x[0]**2*x[1]**2 + x[0]*x[1]**3 + x[0]**3*x[1]**3 + x[0]**4*x[1]**4 + x[0]**5*x[1]**5 + x[0]**6*x[1]**6\n\ndef f10(x):\n    return x[0]**2 + x[1]**2 + x[0]*x[1] + x[0]*x[1]**2 + x[0]**2*x[1]**2 + x[0]*x[1]**3 + x[0]**3*x[1]**3 + x[0]**4*x[1]**4 + x[0]**5*x[1]**5 + x[0]**6*x[1]**6 + x[0]**7*x[1]**7\n\ndef f11(x):\n    return x[0]**2 + x[1]**2 + x[0]*x[1] + x[0]*x[1]**2 + x[0]**2*x[1]**2 + x[0]*x[1]**3 + x[0]**3*x[1]**3 + x[0]**4*x[1]**4 + x[0]**5*x[1]**5 + x[0]**6*x[1]**6 + x[0]**7*x[1]**7 + x[0]**8*x[1]**8\n\ndef f12(x):\n    return x[0]**2 + x[1]**2 + x[0]*x[1] + x[0]*x[1]**2 + x[0]**2*x[1]**2 + x[0]*x[1]**3 + x[0]**3*x[1]**3 + x[0]**4*x[1]**4 + x[0]**5*x[1]**5 + x[0]**6*x[1]**6 + x[0]**7*x[1]**7 + x[0]**8*x[1]**8 + x[0]**9*x[1]**9\n\ndef f13(x):\n    return x[0]**2 + x[1]**2 + x[0]*x[1] + x[0]*x[1]**2 + x[0]**2*x[1]**2 + x[0]*x[1]**3 + x[0]**3*x[1]**3 + x[0]**4*x[1]**4 + x[0]**5*x[1]**5 + x[0]**6*x[1]**6 + x[0]**7*x[1]**7 + x[0]**8*x[1]**8 + x[0]**9*x[1]**9 + x[0]**10*x[1]**10\n\ndef f14(x):\n    return x[0]**2 + x[1]**2 + x[0]*x[1] + x[0]*x[1]**2 + x[0]**2*x[1]**2 + x[0]*x[1]**3 + x[0]**3*x[1]**3 + x[0]**4*x[1]**4 + x[0]**5*x[1]**5 + x[0]**6*x[1]**6 + x[0]**7*x[1]**7 + x[0]**8*x[1]**8 + x[0]**9*x[1]**9 + x[0]**10*x[1]**10 + x[0]**11*x[1]**11\n\ndef f15(x):\n    return x[0]**2 + x[1]**2 + x[0]*x[1] + x[0]*x[1]**2 + x[0]**2*x[1]**2 + x[0]*x[1]**3 + x[0]**3*x[1]**3 + x[0]**4*x[1]**4 + x[0]**5*x[1]**5 + x[0]**6*x[1]**6 + x[0]**7*x[1]**7 + x[0]**8*x[1]**8 + x[0]**9*x[1]**9 + x[0]**10*x[1]**10 + x[0]**11*x[1]**11 + x[0]**12*x[1]**12\n\ndef f16(x):\n    return x[0]**2 + x[1]**2 + x[0]*x[1] + x[0]*x[1]**2 + x[0]**2*x[1]**2 + x[0]*x[1]**3 + x[0]**3*x[1]**3 + x[0]**4*x[1]**4 + x[0]**5*x[1]**5 + x[0]**6*x[1]**6 + x[0]**7*x[1]**7 + x[0]**8*x[1]**8 + x[0]**9*x[1]**9 + x[0]**10*x[1]**10 + x[0]**11*x[1]**11 + x[0]**12*x[1]**12 + x[0]**13*x[1]**13\n\ndef f17(x):\n    return x[0]**2 + x[1]**2 + x[0]*x[1] + x[0]*x[1]**2 + x[0]**2*x[1]**2 + x[0]*x[1]**3 + x[0]**3*x[1]**3 + x[0]**4*x[1]**4 + x[0]**5*x[1]**5 + x[0]**6*x[1]**6 + x[0]**7*x[1]**7 + x[0]**8*x[1]**8 + x[0]**9*x[1]**9 + x[0]**10*x[1]**10 + x[0]**11*x[1]**11 + x[0]**12*x[1]**12 + x[0]**13*x[1]**13 + x[0]**14*x[1]**14\n\ndef f18(x):\n    return x[0]**2 + x[1]**2 + x[0]*x[1] + x[0]*x[1]**2 + x[0]**2*x[1]**2 + x[0]*x[1]**3 + x[0]**3*x[1]**3 + x[0]**4*x[1]**4 + x[0]**5*x[1]**5 + x[0]**6*x[1]**6 + x[0]**7*x[1]**7 + x[0]**8*x[1]**8 + x[0]**9*x[1]**9 + x[0]**10*x[1]**10 + x[0]**11*x[1]**11 + x[0]**12*x[1]**12 + x[0]**13*x[1]**13 + x[0]**14*x[1]**14 + x[0]**15*x[1]**15\n\ndef f19(x):\n    return x[0]**2 + x[1]**2 + x[0]*x[1] + x[0]*x[1]**2 + x[0]**2*x[1]**2 + x[0]*x[1]**3 + x[0]**3*x[1]**3 + x[0]**4*x[1]**4 + x[0]**5*x[1]**5 + x[0]**6*x[1]**6 + x[0]**7*x[1]**7 + x[0]**8*x[1]**8 + x[0]**9*x[1]**9 + x[0]**10*x[1]**10 + x[0]**11*x[1]**11 + x[0]**12*x[1]**12 + x[0]**13*x[1]**13 + x[0]**14*x[1]**14 + x[0]**15*x[1]**15 + x[0]**16*x[1]**16\n\ndef f20(x):\n    return x[0]**2 + x[1]**2 + x[0]*x[1] + x[0]*x[1]**2 + x[0]**2*x[1]**2 + x[0]*x[1]**3 + x[0]**3*x[1]**3 + x[0]**4*x[1]**4 + x[0]**5*x[1]**5 + x[0]**6*x[1]**6 + x[0]**7*x[1]**7 + x[0]**8*x[1]**8 + x[0]**9*x[1]**9 + x[0]**10*x[1]**10 + x[0]**11*x[1]**11 + x[0]**12*x[1]**12 + x[0]**13*x[1]**13 + x[0]**14*x[1]**14 + x[0]**15*x[1]**15 + x[0]**16*x[1]**16 + x[0]**17*x[1]**17\n\ndef f21(x):\n    return x[0]**2 + x[1]**2 + x[0]*x[1] + x[0]*x[1]**2 + x[0]**2*x[1]**2 + x[0]*x[1]**3 + x[0]**3*x[1]**3 + x[0]**4*x[1]**4 + x[0]**5*x[1]**5 + x[0]**6*x[1]**6 + x[0]**7*x[1]**7 + x[0]**8*x[1]**8 + x[0]**9*x[1]**9 + x[0]**10*x[1]**10 + x[0]**11*x[1]**11 + x[0]**12*x[1]**12 + x[0]**13*x[1]**13 + x[0]**14*x[1]**14 + x[0]**15*x[1]**15 + x[0]**16*x[1]**16 + x[0]**17*x[1]**17 + x[0]**18*x[1]**18\n\ndef f22(x):\n    return x[0]**2 + x[1]**2 + x[0]*x[1] + x[0]*x[1]**2 + x[0]**2*x[1]**2 + x[0]*x[1]**3 + x[0]**3*x[1]**3 + x[0]**4*x[1]**4 + x[0]**5*x[1]**5 + x[0]**6*x[1]**6 + x[0]**7*x[1]**7 + x[0]**8*x[1]**8 + x[0]**9*x[1]**9 + x[0]**10*x[1]**10 + x[0]**11*x[1]**11 + x[0]**12*x[1]**12 + x[0]**13*x[1]**13 + x[0]**14*x[1]**14 + x[0]**15*x[1]**15 + x[0]**16*x[1]**16 + x[0]**17*x[1]**17 + x[0]**18*x[1]**18 + x[0]**19*x[1]**19\n\ndef f23(x):\n    return x[0]**2 + x[1]**2 + x[0]*x[1] + x[0]*x[1]**2 + x[0]**2*x[1]**2 + x[0]*x[1]**3 + x[0]**3*x[1]**3 + x[0]**4*x[1]**4 + x[0]**5*x[1]**5 + x[0]**6*x[1]**6 + x[0]**7*x[1]**7 + x[0]**8*x[1]**8 + x[0]**9*x[1]**9 + x[0]**10*x[1]**10 + x[0]**11*x[1]**11 + x[0]**12*x[1]**12 + x[0]**13*x[1]**13 + x[0]**14*x[1]**14 + x[0]**15*x[1]**15 + x[0]**16*x[1]**16 + x[0]**17*x[1]**17 + x[0]**18*x[1]**18 + x[0]**19*x[1]**19 + x[0]**20*x[1]**20\n\ndef f24(x):\n    return x[0]**2 + x[1]**2 + x[0]*x[1] + x[0]*x[1]**2 + x[0]**2*x[1]**2 + x[0]*x[1]**3 + x[0]**3*x[1]**3 + x[0]**4*x[1]**4 + x[0]**5*x[1]**5 + x[0]**6*x[1]**6 + x[0]**7*x[1]**7 + x[0]**8*x[1]**8 + x[0]**9*x[1]**9 + x[0]**10*x[1]**10 + x[0]**11*x[1]**11 + x[0]**12*x[1]**12 + x[0]**13*x[1]**13 + x[0]**14*x[1]**14 + x[0]**15*x[1]**15 + x[0]**16*x[1]**16 + x[0]**17*x[1]**17 + x[0]**18*x[1]**18 + x[0]**19*x[1]**19 + x[0]**20*x[1]**20 + x[0]**21*x[1]**21\n\nbudget = 100\ndim = 10\nalgorithm = HEACOMBBO(budget, dim)\nbest_fitness, best_solution, new_population = algorithm(f1)\nprint(\"Best fitness:\", best_fitness)\nprint(\"Best solution:\", best_solution)", "name": "HEACOMBBO", "description": "Novel Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "95852454-1ec3-452d-8d02-4168e4b0665e", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "83525c14-c6a1-4f74-b098-950cddff94a2", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "001ccd47-ed4f-49c6-b1bd-a8586de8717a", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def evaluate_fitness(self, individual):\n        if self.budget == 0:\n            return np.nan, np.nan\n        else:\n            try:\n                result = self(individual)\n                return result[0], result[1]\n            except Exception as e:\n                print(f\"Error occurred: {e}\")\n                return np.nan, np.nan\n\n    def refine_strategy(self, individual):\n        if self.budget == 0:\n            return individual\n        else:\n            strategy = random.choice(['sbx', 'rand1'])\n            if random.random() < 0.4:\n                strategy ='sbx'\n            return individual, strategy\n\n    def hybrid_evolution(self, func):\n        population_size = 100\n        population = [self.x0 + np.random.uniform(-1, 1, self.dim) for _ in range(population_size)]\n        for _ in range(100):\n            new_population = []\n            for individual in population:\n                result = self(func, individual)\n                if result[0]!= np.nan:\n                    new_population.append(result[1])\n            population = new_population\n        return population[0]\n\n# Usage\ndef f1(x):\n    return np.sum(x**2)\n\ndef f2(x):\n    return np.sum(x**2) + 0.1 * np.sum(x**4)\n\ndef f3(x):\n    return np.sum(x**2) + 0.1 * np.sum(x**4) + 0.01 * np.sum(x**6)\n\ndef f4(x):\n    return np.sum(x**2) + 0.1 * np.sum(x**4) + 0.01 * np.sum(x**6) + 0.001 * np.sum(x**8)\n\ndef f5(x):\n    return np.sum(x**2) + 0.1 * np.sum(x**4) + 0.01 * np.sum(x**6) + 0.001 * np.sum(x**8) + 0.0001 * np.sum(x**10)\n\ndef f6(x):\n    return np.sum(x**2) + 0.1 * np.sum(x**4) + 0.01 * np.sum(x**6) + 0.001 * np.sum(x**8) + 0.0001 * np.sum(x**10) + 0.00001 * np.sum(x**12)\n\ndef f7(x):\n    return np.sum(x**2) + 0.1 * np.sum(x**4) + 0.01 * np.sum(x**6) + 0.001 * np.sum(x**8) + 0.0001 * np.sum(x**10) + 0.00001 * np.sum(x**12) + 0.000001 * np.sum(x**14)\n\ndef f8(x):\n    return np.sum(x**2) + 0.1 * np.sum(x**4) + 0.01 * np.sum(x**6) + 0.001 * np.sum(x**8) + 0.0001 * np.sum(x**10) + 0.00001 * np.sum(x**12) + 0.000001 * np.sum(x**14) + 0.0000001 * np.sum(x**16)\n\ndef f9(x):\n    return np.sum(x**2) + 0.1 * np.sum(x**4) + 0.01 * np.sum(x**6) + 0.001 * np.sum(x**8) + 0.0001 * np.sum(x**10) + 0.00001 * np.sum(x**12) + 0.000001 * np.sum(x**14) + 0.0000001 * np.sum(x**16) + 0.00000001 * np.sum(x**18)\n\ndef f10(x):\n    return np.sum(x**2) + 0.1 * np.sum(x**4) + 0.01 * np.sum(x**6) + 0.001 * np.sum(x**8) + 0.0001 * np.sum(x**10) + 0.00001 * np.sum(x**12) + 0.000001 * np.sum(x**14) + 0.0000001 * np.sum(x**16) + 0.00000001 * np.sum(x**18) + 0.000000001 * np.sum(x**20)\n\ndef f11(x):\n    return np.sum(x**2) + 0.1 * np.sum(x**4) + 0.01 * np.sum(x**6) + 0.001 * np.sum(x**8) + 0.0001 * np.sum(x**10) + 0.00001 * np.sum(x**12) + 0.000001 * np.sum(x**14) + 0.0000001 * np.sum(x**16) + 0.00000001 * np.sum(x**18) + 0.000000001 * np.sum(x**20) + 0.0000000001 * np.sum(x**22)\n\ndef f12(x):\n    return np.sum(x**2) + 0.1 * np.sum(x**4) + 0.01 * np.sum(x**6) + 0.001 * np.sum(x**8) + 0.0001 * np.sum(x**10) + 0.00001 * np.sum(x**12) + 0.000001 * np.sum(x**14) + 0.0000001 * np.sum(x**16) + 0.00000001 * np.sum(x**18) + 0.000000001 * np.sum(x**20) + 0.0000000001 * np.sum(x**22) + 0.00000000001 * np.sum(x**24)\n\ndef f13(x):\n    return np.sum(x**2) + 0.1 * np.sum(x**4) + 0.01 * np.sum(x**6) + 0.001 * np.sum(x**8) + 0.0001 * np.sum(x**10) + 0.00001 * np.sum(x**12) + 0.000001 * np.sum(x**14) + 0.0000001 * np.sum(x**16) + 0.00000001 * np.sum(x**18) + 0.000000001 * np.sum(x**20) + 0.0000000001 * np.sum(x**22) + 0.00000000001 * np.sum(x**24) + 0.000000000001 * np.sum(x**26)\n\ndef f14(x):\n    return np.sum(x**2) + 0.1 * np.sum(x**4) + 0.01 * np.sum(x**6) + 0.001 * np.sum(x**8) + 0.0001 * np.sum(x**10) + 0.00001 * np.sum(x**12) + 0.000001 * np.sum(x**14) + 0.0000001 * np.sum(x**16) + 0.00000001 * np.sum(x**18) + 0.000000001 * np.sum(x**20) + 0.0000000001 * np.sum(x**22) + 0.00000000001 * np.sum(x**24) + 0.000000000001 * np.sum(x**26) + 0.000000000001 * np.sum(x**28)\n\ndef f15(x):\n    return np.sum(x**2) + 0.1 * np.sum(x**4) + 0.01 * np.sum(x**6) + 0.001 * np.sum(x**8) + 0.0001 * np.sum(x**10) + 0.00001 * np.sum(x**12) + 0.000001 * np.sum(x**14) + 0.0000001 * np.sum(x**16) + 0.00000001 * np.sum(x**18) + 0.000000001 * np.sum(x**20) + 0.0000000001 * np.sum(x**22) + 0.00000000001 * np.sum(x**24) + 0.000000000001 * np.sum(x**26) + 0.000000000001 * np.sum(x**28) + 0.000000000001 * np.sum(x**30)\n\ndef f16(x):\n    return np.sum(x**2) + 0.1 * np.sum(x**4) + 0.01 * np.sum(x**6) + 0.001 * np.sum(x**8) + 0.0001 * np.sum(x**10) + 0.00001 * np.sum(x**12) + 0.000001 * np.sum(x**14) + 0.0000001 * np.sum(x**16) + 0.00000001 * np.sum(x**18) + 0.000000001 * np.sum(x**20) + 0.0000000001 * np.sum(x**22) + 0.00000000001 * np.sum(x**24) + 0.000000000001 * np.sum(x**26) + 0.000000000001 * np.sum(x**28) + 0.000000000001 * np.sum(x**30) + 0.000000000001 * np.sum(x**32)\n\ndef f17(x):\n    return np.sum(x**2) + 0.1 * np.sum(x**4) + 0.01 * np.sum(x**6) + 0.001 * np.sum(x**8) + 0.0001 * np.sum(x**10) + 0.00001 * np.sum(x**12) + 0.000001 * np.sum(x**14) + 0.0000001 * np.sum(x**16) + 0.00000001 * np.sum(x**18) + 0.000000001 * np.sum(x**20) + 0.0000000001 * np.sum(x**22) + 0.00000000001 * np.sum(x**24) + 0.000000000001 * np.sum(x**26) + 0.000000000001 * np.sum(x**28) + 0.000000000001 * np.sum(x**30) + 0.000000000001 * np.sum(x**32) + 0.000000000001 * np.sum(x**34)\n\ndef f18(x):\n    return np.sum(x**2) + 0.1 * np.sum(x**4) + 0.01 * np.sum(x**6) + 0.001 * np.sum(x**8) + 0.0001 * np.sum(x**10) + 0.00001 * np.sum(x**12) + 0.000001 * np.sum(x**14) + 0.0000001 * np.sum(x**16) + 0.00000001 * np.sum(x**18) + 0.000000001 * np.sum(x**20) + 0.0000000001 * np.sum(x**22) + 0.00000000001 * np.sum(x**24) + 0.000000000001 * np.sum(x**26) + 0.000000000001 * np.sum(x**28) + 0.000000000001 * np.sum(x**30) + 0.000000000001 * np.sum(x**32) + 0.000000000001 * np.sum(x**34) + 0.000000000001 * np.sum(x**36)\n\ndef f19(x):\n    return np.sum(x**2) + 0.1 * np.sum(x**4) + 0.01 * np.sum(x**6) + 0.001 * np.sum(x**8) + 0.0001 * np.sum(x**10) + 0.00001 * np.sum(x**12) + 0.000001 * np.sum(x**14) + 0.0000001 * np.sum(x**16) + 0.00000001 * np.sum(x**18) + 0.000000001 * np.sum(x**20) + 0.0000000001 * np.sum(x**22) + 0.00000000001 * np.sum(x**24) + 0.000000000001 * np.sum(x**26) + 0.000000000001 * np.sum(x**28) + 0.000000000001 * np.sum(x**30) + 0.000000000001 * np.sum(x**32) + 0.000000000001 * np.sum(x**34) + 0.000000000001 * np.sum(x**36) + 0.000000000001 * np.sum(x**38)\n\ndef f20(x):\n    return np.sum(x**2) + 0.1 * np.sum(x**4) + 0.01 * np.sum(x**6) + 0.001 * np.sum(x**8) + 0.0001 * np.sum(x**10) + 0.00001 * np.sum(x**12) + 0.000001 * np.sum(x**14) + 0.0000001 * np.sum(x**16) + 0.00000001 * np.sum(x**18) + 0.000000001 * np.sum(x**20) + 0.0000000001 * np.sum(x**22) + 0.00000000001 * np.sum(x**24) + 0.000000000001 * np.sum(x**26) + 0.000000000001 * np.sum(x**28) + 0.000000000001 * np.sum(x**30) + 0.000000000001 * np.sum(x**32) + 0.000000000001 * np.sum(x**34) + 0.000000000001 * np.sum(x**36) + 0.000000000001 * np.sum(x**38) + 0.000000000001 * np.sum(x**40)\n\ndef f21(x):\n    return np.sum(x**2) + 0.1 * np.sum(x**4) + 0.01 * np.sum(x**6) + 0.001 * np.sum(x**8) + 0.0001 * np.sum(x**10) + 0.00001 * np.sum(x**12) + 0.000001 * np.sum(x**14) + 0.0000001 * np.sum(x**16) + 0.00000001 * np.sum(x**18) + 0.000000001 * np.sum(x**20) + 0.0000000001 * np.sum(x**22) + 0.00000000001 * np.sum(x**24) + 0.000000000001 * np.sum(x**26) + 0.000000000001 * np.sum(x**28) + 0.000000000001 * np.sum(x**30) + 0.000000000001 * np.sum(x**32) + 0.000000000001 * np.sum(x**34) + 0.000000000001 * np.sum(x**36) + 0.000000000001 * np.sum(x**38) + 0.000000000001 * np.sum(x**40) + 0.000000000001 * np.sum(x**42)\n\ndef f22(x):\n    return np.sum(x**2) + 0.1 * np.sum(x**4) + 0.01 * np.sum(x**6) + 0.001 * np.sum(x**8) + 0.0001 * np.sum(x**10) + 0.00001 * np.sum(x**12) + 0.000001 * np.sum(x**14) + 0.0000001 * np.sum(x**16) + 0.00000001 * np.sum(x**18) + 0.000000001 * np.sum(x**20) + 0.0000000001 * np.sum(x**22) + 0.00000000001 * np.sum(x**24) + 0.000000000001 * np.sum(x**26) + 0.000000000001 * np.sum(x**28) + 0.000000000001 * np.sum(x**30) + 0.000000000001 * np.sum(x**32) + 0.000000000001 * np.sum(x**34) + 0.000000000001 * np.sum(x**36) + 0.000000000001 * np.sum(x**38) + 0.000000000001 * np.sum(x**40) + 0.000000000001 * np.sum(x**42) + 0.000000000001 * np.sum(x**44)\n\ndef f23(x):\n    return np.sum(x**2) + 0.1 * np.sum(x**4) + 0.01 * np.sum(x**6) + 0.001 * np.sum(x**8) + 0.0001 * np.sum(x**10) + 0.00001 * np.sum(x**12) + 0.000001 * np.sum(x**14) + 0.0000001 * np.sum(x**16) + 0.00000001 * np.sum(x**18) + 0.000000001 * np.sum(x**20) + 0.0000000001 * np.sum(x**22) + 0.00000000001 * np.sum(x**24) + 0.000000000001 * np.sum(x**26) + 0.000000000001 * np.sum(x**28) + 0.000000000001 * np.sum(x**30) + 0.000000000001 * np.sum(x**32) + 0.000000000001 * np.sum(x**34) + 0.000000000001 * np.sum(x**36) + 0.000000000001 * np.sum(x**38) + 0.000000000001 * np.sum(x**40) + 0.000000000001 * np.sum(x**42) + 0.000000000001 * np.sum(x**44) + 0.000000000001 * np.sum(x**46)\n\ndef f24(x):\n    return np.sum(x**2) + 0.1 * np.sum(x**4) + 0.01 * np.sum(x**6) + 0.001 * np.sum(x**8) + 0.0001 * np.sum(x**10) + 0.00001 * np.sum(x**12) + 0.000001 * np.sum(x**14) + 0.0000001 * np.sum(x**16) + 0.00000001 * np.sum(x**18) + 0.000000001 * np.sum(x**20) + 0.0000000001 * np.sum(x**22) + 0.00000000001 * np.sum(x**24) + 0.000000000001 * np.sum(x**26) + 0.000000000001 * np.sum(x**28) + 0.000000000001 * np.sum(x**30) + 0.000000000001 * np.sum(x**32) + 0.000000000001 * np.sum(x**34) + 0.000000000001 * np.sum(x**36) + 0.000000000001 * np.sum(x**38) + 0.000000000001 * np.sum(x**40) + 0.000000000001 * np.sum(x**42) + 0.000000000001 * np.sum(x**44) + 0.000000000001 * np.sum(x**46) + 0.000000000001 * np.sum(x**48)\n\n# Usage\ndef evaluateBBOB(func):\n    heacombbo = HEACOMBBO(100, 10)\n    best_individual = heacombbo.hybrid_evolution(func)\n    return best_individual\n\n# Usage\nbest_individual = evaluateBBOB(f1)\nprint(best_individual)", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) with probabilistic refinement of strategy", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "a3dad185-be0a-4661-a133-2e05cacb2273", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "54205614-9657-40b7-bfcb-6d646d34fdb1", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.population = [self.x0]\n        self.adaptive_strategy = np.random.uniform(0.0, 1.0, size=self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        new_individuals = []\n        for individual in self.population:\n            new_individuals.append(individual)\n            if np.random.rand() < 0.4:\n                new_individual = individual + np.random.uniform(-1.0, 1.0, size=self.dim)\n                new_individuals.append(new_individual)\n\n        self.population = new_individuals\n        self.adaptive_strategy = np.mean(self.population, axis=0)\n\n        min_value = np.inf\n        best_individual = None\n        for individual in self.population:\n            value = func(individual)\n            if value < min_value:\n                min_value = value\n                best_individual = individual\n\n        return min_value, best_individual\n\n# Example usage:\nbudget = 100\ndim = 10\nfunc = lambda x: x[0]**2 + x[1]**2\nheacombbo = HybridEvolutionaryAlgorithm(budget, dim)\nmin_value, best_individual = heacombbo(func)\nprint(f\"Minimum value: {min_value}, Best individual: {best_individual}\")", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm with Crossover, Mutation, and Adaptive Strategy for Black Box Optimization", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "8e7f1e4f-b0d8-4941-9ac0-b8fceb97fe15", "solution": "import numpy as np\nimport random\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return self.f1(func)\n        elif func.__name__ == 'f2':\n            return self.f2(func)\n        elif func.__name__ == 'f3':\n            return self.f3(func)\n        elif func.__name__ == 'f4':\n            return self.f4(func)\n        elif func.__name__ == 'f5':\n            return self.f5(func)\n        elif func.__name__ == 'f6':\n            return self.f6(func)\n        elif func.__name__ == 'f7':\n            return self.f7(func)\n        elif func.__name__ == 'f8':\n            return self.f8(func)\n        elif func.__name__ == 'f9':\n            return self.f9(func)\n        elif func.__name__ == 'f10':\n            return self.f10(func)\n        elif func.__name__ == 'f11':\n            return self.f11(func)\n        elif func.__name__ == 'f12':\n            return self.f12(func)\n        elif func.__name__ == 'f13':\n            return self.f13(func)\n        elif func.__name__ == 'f14':\n            return self.f14(func)\n        elif func.__name__ == 'f15':\n            return self.f15(func)\n        elif func.__name__ == 'f16':\n            return self.f16(func)\n        elif func.__name__ == 'f17':\n            return self.f17(func)\n        elif func.__name__ == 'f18':\n            return self.f18(func)\n        elif func.__name__ == 'f19':\n            return self.f19(func)\n        elif func.__name__ == 'f20':\n            return self.f20(func)\n        elif func.__name__ == 'f21':\n            return self.f21(func)\n        elif func.__name__ == 'f22':\n            return self.f22(func)\n        elif func.__name__ == 'f23':\n            return self.f23(func)\n        elif func.__name__ == 'f24':\n            return self.f24(func)\n\n    def f1(self, func):\n        # Differential Evolution\n        res = differential_evolution(func, self.bounds)\n        return res.x, res.fun\n\n    def f2(self, func):\n        # Differential Evolution with initial guess\n        res = differential_evolution(func, self.bounds, x0=self.x0)\n        return res.x, res.fun\n\n    def f3(self, func):\n        # Differential Evolution with initial guess and tolerance\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        return res.x, res.fun\n\n    def f4(self, func):\n        # Differential Evolution with initial guess, tolerance, and scaling\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, scaling='uniform')\n        return res.x, res.fun\n\n    def f5(self, func):\n        # Differential Evolution with initial guess, tolerance, scaling, and strategy\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, scaling='log-uniform', strategy='sbx')\n        return res.x, res.fun\n\n    def f6(self, func):\n        # Differential Evolution with initial guess, tolerance, scaling, strategy, and crossover probability\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, scaling='log-uniform', strategy='sbx', cxpb=0.5)\n        return res.x, res.fun\n\n    def f7(self, func):\n        # Differential Evolution with initial guess, tolerance, scaling, strategy, crossover probability, and mutation probability\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, scaling='log-uniform', strategy='sbx', cxpb=0.5, mu=0.5)\n        return res.x, res.fun\n\n    def f8(self, func):\n        # Differential Evolution with initial guess, tolerance, scaling, strategy, crossover probability, mutation probability, and weight\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, scaling='log-uniform', strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        return res.x, res.fun\n\n    def f9(self, func):\n        # Differential Evolution with initial guess, tolerance, scaling, strategy, crossover probability, mutation probability, weight, and scaling\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, scaling='log-uniform', strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        return res.x, res.fun\n\n    def f10(self, func):\n        # Differential Evolution with initial guess, tolerance, scaling, strategy, crossover probability, mutation probability, weight, scaling, and scaling\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, scaling='log-uniform', strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        return res.x, res.fun\n\n    def f11(self, func):\n        # Differential Evolution with initial guess, tolerance, scaling, strategy, crossover probability, mutation probability, weight, scaling, strategy, and scaling\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, scaling='log-uniform', strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        return res.x, res.fun\n\n    def f12(self, func):\n        # Differential Evolution with initial guess, tolerance, scaling, strategy, crossover probability, mutation probability, weight, scaling, strategy, scaling, and scaling\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, scaling='log-uniform', strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        return res.x, res.fun\n\n    def f13(self, func):\n        # Differential Evolution with initial guess, tolerance, scaling, strategy, crossover probability, mutation probability, weight, scaling, strategy, scaling, and scaling, and scaling\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, scaling='log-uniform', strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        return res.x, res.fun\n\n    def f14(self, func):\n        # Differential Evolution with initial guess, tolerance, scaling, strategy, crossover probability, mutation probability, weight, scaling, strategy, scaling, scaling, and scaling\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, scaling='log-uniform', strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        return res.x, res.fun\n\n    def f15(self, func):\n        # Differential Evolution with initial guess, tolerance, scaling, strategy, crossover probability, mutation probability, weight, scaling, strategy, scaling, scaling, scaling, and scaling\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, scaling='log-uniform', strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        return res.x, res.fun\n\n    def f16(self, func):\n        # Differential Evolution with initial guess, tolerance, scaling, strategy, crossover probability, mutation probability, weight, scaling, strategy, scaling, scaling, scaling, scaling, and scaling\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, scaling='log-uniform', strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        return res.x, res.fun\n\n    def f17(self, func):\n        # Differential Evolution with initial guess, tolerance, scaling, strategy, crossover probability, mutation probability, weight, scaling, strategy, scaling, scaling, scaling, scaling, and scaling, and scaling\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, scaling='log-uniform', strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        return res.x, res.fun\n\n    def f18(self, func):\n        # Differential Evolution with initial guess, tolerance, scaling, strategy, crossover probability, mutation probability, weight, scaling, strategy, scaling, scaling, scaling, scaling, and scaling, and scaling, and scaling\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, scaling='log-uniform', strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        return res.x, res.fun\n\n    def f19(self, func):\n        # Differential Evolution with initial guess, tolerance, scaling, strategy, crossover probability, mutation probability, weight, scaling, strategy, scaling, scaling, scaling, scaling, and scaling, and scaling, and scaling, and scaling\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, scaling='log-uniform', strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        return res.x, res.fun\n\n    def f20(self, func):\n        # Differential Evolution with initial guess, tolerance, scaling, strategy, crossover probability, mutation probability, weight, scaling, strategy, scaling, scaling, scaling, scaling, and scaling, and scaling, and scaling, and scaling, and scaling\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, scaling='log-uniform', strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        return res.x, res.fun\n\n    def f21(self, func):\n        # Differential Evolution with initial guess, tolerance, scaling, strategy, crossover probability, mutation probability, weight, scaling, strategy, scaling, scaling, scaling, scaling, and scaling, and scaling, and scaling, and scaling, and scaling, and scaling\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, scaling='log-uniform', strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        return res.x, res.fun\n\n    def f22(self, func):\n        # Differential Evolution with initial guess, tolerance, scaling, strategy, crossover probability, mutation probability, weight, scaling, strategy, scaling, scaling, scaling, scaling, and scaling, and scaling, and scaling, and scaling, and scaling, and scaling, and scaling\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, scaling='log-uniform', strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        return res.x, res.fun\n\n    def f23(self, func):\n        # Differential Evolution with initial guess, tolerance, scaling, strategy, crossover probability, mutation probability, weight, scaling, strategy, scaling, scaling, scaling, scaling, and scaling, and scaling, and scaling, and scaling, and scaling, and scaling, and scaling, and scaling\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, scaling='log-uniform', strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        return res.x, res.fun\n\n    def f24(self, func):\n        # Differential Evolution with initial guess, tolerance, scaling, strategy, crossover probability, mutation probability, weight, scaling, strategy, scaling, scaling, scaling, scaling, and scaling, and scaling, and scaling, and scaling, and scaling, and scaling, and scaling, and scaling, and scaling\n        res = differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, scaling='log-uniform', strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        return res.x, res.fun\n\n    def refine_strategy(self, func):\n        if self.budget > 0:\n            res = self.f(func)\n            if random.random() < 0.4:\n                # Randomly select a strategy from the current population\n                strategies = [self.f1, self.f2, self.f3, self.f4, self.f5, self.f6, self.f7, self.f8, self.f9, self.f10, self.f11, self.f12, self.f13, self.f14, self.f15, self.f16, self.f17, self.f18, self.f19, self.f20, self.f21, self.f22, self.f23, self.f24]\n                strategy = random.choice(strategies)\n                new_res = strategy(func)\n                return new_res.x, new_res.fun\n            else:\n                return res.x, res.fun\n        else:\n            return np.nan, np.nan\n\n# Usage\nif __name__ == '__main__':\n    # Initialize the algorithm with a budget of 100 and a dimension of 10\n    algorithm = HEACOMBBO(budget=100, dim=10)\n    # Optimize the function f1\n    res = algorithm('f1')\n    print(\"Optimal solution:\", res.x)\n    print(\"Optimal value:\", res.fun)", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) using probability 0.4 to refine its strategy", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 106, 143, None, 106, 159)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 106, 143, None, 106, 159))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "ef28bbbf-cd37-482f-956f-079a47d3ce33", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def evaluate_fitness(self, individual):\n        func_name = individual['func']\n        if func_name not in self.funcs:\n            raise ValueError(f\"Unknown function: {func_name}\")\n\n        func = getattr(self, func_name)\n        return func(individual['x'])\n\n    def f(self, individual, logger):\n        func_name = individual['func']\n        if func_name not in self.funcs:\n            raise ValueError(f\"Unknown function: {func_name}\")\n\n        func = getattr(self, func_name)\n\n        # Refine the strategy with a probability of 0.4\n        if random.random() < 0.4:\n            # Select two random individuals\n            other_individual = random.choice([i for i in self.population if i['func']!= individual['func']])\n            # Create a new individual by crossover\n            child = self.crossover(individual, other_individual)\n            # Mutate the child\n            child = self.mutate(child)\n            # Replace the original individual with the child\n            individual = child\n\n        # Evaluate the fitness of the individual\n        fitness = self.evaluate_fitness(individual)\n        # Update the logger\n        logger.update(individual, fitness)\n\n        return individual, fitness\n\n    def crossover(self, parent1, parent2):\n        # Select a random crossover point\n        crossover_point = random.randint(1, self.dim - 1)\n        # Create a child by crossover\n        child = {\n            'x': np.concatenate((parent1['x'][:crossover_point], parent2['x'][crossover_point:]))\n        }\n        return child\n\n    def mutate(self, individual):\n        # Select a random mutation point\n        mutation_point = random.randint(0, self.dim - 1)\n        # Mutate the individual\n        individual['x'][mutation_point] += np.random.uniform(-1, 1)\n        return individual\n\n    def initialize_single(self, func):\n        self.population = [{'func': func, 'x': np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)}]\n        self.logger = {'fitnesses': []}\n        return self.f(self.population[0], self.logger)\n\n# Example usage\nbudget = 50\ndim = 10\nheacombbo = HEACOMBBO(budget, dim)\nfor i in range(budget):\n    heacombbo.initialize_single('f' + str(i + 1))", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) with probabilistic refinement of strategy.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "73bd7fef-1466-44e7-8465-e97a05645421", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nimport random\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def refine_strategy(self, individual):\n        strategy = random.choice(['sbx', 'rand1', 'uniform', 'log-uniform'])\n        return individual, strategy\n\n    def evaluate_fitness(self, individual):\n        if isinstance(individual, tuple):\n            individual, strategy = individual\n        else:\n            individual, strategy = individual, random.choice(['sbx', 'rand1', 'uniform', 'log-uniform'])\n        if strategy =='sbx':\n            new_individual = np.array([self.bounds[i][0] + (self.bounds[i][1] - self.bounds[i][0]) * np.random.uniform() for i in range(self.dim)])\n        elif strategy == 'rand1':\n            new_individual = np.array([self.bounds[i][0] + (self.bounds[i][1] - self.bounds[i][0]) * np.random.uniform() for i in range(self.dim)])\n        elif strategy == 'uniform':\n            new_individual = np.array([np.random.uniform(self.bounds[i][0], self.bounds[i][1]) for i in range(self.dim)])\n        elif strategy == 'log-uniform':\n            new_individual = np.array([np.random.loguniform(self.bounds[i][0], self.bounds[i][1]) for i in range(self.dim)])\n        new_individual, func_value = self(f=new_individual)\n        return new_individual, func_value\n\n# Usage:\ndef f(individual):\n    # Define your black box function here\n    return np.sum(individual ** 2)\n\nheacombbo = HEACOMBBO(budget=100, dim=10)\nfor _ in range(100):\n    individual, func_value = heacombbo(individual=f)\n    heacombbo.refine_strategy(individual)", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) with probabilistic refinement of strategy", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 33, 142, None, 33, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "686b4a4f-10cc-4b39-9efe-30786fd0753b", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "02e33d3f-20f3-4347-a219-b929dc12416c", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def refine_strategy(self, func):\n        if self.budget > 0:\n            import random\n            individuals = [self.f(func) for _ in range(10)]\n            new_individuals = []\n            for individual in individuals:\n                new_individual = individual.copy()\n                for i in range(self.dim):\n                    if random.random() < 0.4:\n                        new_individual[i] = random.uniform(self.bounds[i][0], self.bounds[i][1])\n                new_individuals.append(new_individual)\n            return new_individuals\n        else:\n            return []\n\n# Usage\ndef f1(x):\n    return x[0]**2 + x[1]**2\n\ndef f2(x):\n    return x[0]**2 + x[1]**2\n\ndef f3(x):\n    return x[0]**2 + x[1]**2\n\ndef f4(x):\n    return x[0]**2 + x[1]**2\n\ndef f5(x):\n    return x[0]**2 + x[1]**2\n\ndef f6(x):\n    return x[0]**2 + x[1]**2\n\ndef f7(x):\n    return x[0]**2 + x[1]**2\n\ndef f8(x):\n    return x[0]**2 + x[1]**2\n\ndef f9(x):\n    return x[0]**2 + x[1]**2\n\ndef f10(x):\n    return x[0]**2 + x[1]**2\n\ndef f11(x):\n    return x[0]**2 + x[1]**2\n\ndef f12(x):\n    return x[0]**2 + x[1]**2\n\ndef f13(x):\n    return x[0]**2 + x[1]**2\n\ndef f14(x):\n    return x[0]**2 + x[1]**2\n\ndef f15(x):\n    return x[0]**2 + x[1]**2\n\ndef f16(x):\n    return x[0]**2 + x[1]**2\n\ndef f17(x):\n    return x[0]**2 + x[1]**2\n\ndef f18(x):\n    return x[0]**2 + x[1]**2\n\ndef f19(x):\n    return x[0]**2 + x[1]**2\n\ndef f20(x):\n    return x[0]**2 + x[1]**2\n\ndef f21(x):\n    return x[0]**2 + x[1]**2\n\ndef f22(x):\n    return x[0]**2 + x[1]**2\n\ndef f23(x):\n    return x[0]**2 + x[1]**2\n\ndef f24(x):\n    return x[0]**2 + x[1]**2\n\ndef main():\n    heacombbo = HEACOMBBO(10, 2)\n    for func in [f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16, f17, f18, f19, f20, f21, f22, f23, f24]:\n        heacombbo.refine_strategy(func)\n\nif __name__ == \"__main__\":\n    main()", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) with strategy refinement.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 32, 142, None, 32, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 32, 142, None, 32, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "9ed6c2b3-dda0-4347-8aae-cb30143c0abf", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "c3ac95d6-8675-4cb9-9065-99ef8fedada0", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n        self.population_size = 20\n        self.population = [np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim) for _ in range(self.population_size)]\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        for _ in range(self.budget):\n            fitness = []\n            for individual in self.population:\n                # Refine the strategy with probability 0.4\n                if random.random() < 0.4:\n                    strategy = random.choice(['sbx', 'rand1', 'log-uniform'])\n                else:\n                    strategy = random.choice(['sbx', 'rand1', 'log-uniform', 'uniform'])\n                fitness.append(func(individual, strategy=strategy))\n\n            # Evaluate the best individual\n            self.population = [min(fitness)]\n            self.population = [min(fitness) if fitness else np.nan for fitness in fitness]\n\n        # Return the best individual\n        best_individual = min(self.population)\n        return best_individual, np.nan\n\n# Example usage:\ndef f1(x):\n    return x[0]**2 + x[1]**2\n\ndef f2(x):\n    return x[0]**2 + x[1]**2 + 0.1*np.sin(10*x[0]) + 0.1*np.cos(10*x[1])\n\ndef f3(x):\n    return x[0]**2 + x[1]**2 + 0.1*np.sin(10*x[0]) + 0.1*np.cos(10*x[1]) + 0.01*np.sin(100*x[0]) + 0.01*np.cos(100*x[1])\n\ndef f4(x):\n    return x[0]**2 + x[1]**2 + 0.1*np.sin(10*x[0]) + 0.1*np.cos(10*x[1]) + 0.01*np.sin(100*x[0]) + 0.01*np.cos(100*x[1]) + 0.001*np.sin(1000*x[0]) + 0.001*np.cos(1000*x[1])\n\ndef f5(x):\n    return x[0]**2 + x[1]**2 + 0.1*np.sin(10*x[0]) + 0.1*np.cos(10*x[1]) + 0.01*np.sin(100*x[0]) + 0.01*np.cos(100*x[1]) + 0.001*np.sin(1000*x[0]) + 0.001*np.cos(1000*x[1]) + 0.0001*np.sin(10000*x[0]) + 0.0001*np.cos(10000*x[1])\n\ndef f6(x):\n    return x[0]**2 + x[1]**2 + 0.1*np.sin(10*x[0]) + 0.1*np.cos(10*x[1]) + 0.01*np.sin(100*x[0]) + 0.01*np.cos(100*x[1]) + 0.001*np.sin(1000*x[0]) + 0.001*np.cos(1000*x[1]) + 0.0001*np.sin(10000*x[0]) + 0.0001*np.cos(10000*x[1]) + 0.00001*np.sin(100000*x[0]) + 0.00001*np.cos(100000*x[1])\n\ndef f7(x):\n    return x[0]**2 + x[1]**2 + 0.1*np.sin(10*x[0]) + 0.1*np.cos(10*x[1]) + 0.01*np.sin(100*x[0]) + 0.01*np.cos(100*x[1]) + 0.001*np.sin(1000*x[0]) + 0.001*np.cos(1000*x[1]) + 0.0001*np.sin(10000*x[0]) + 0.0001*np.cos(10000*x[1]) + 0.00001*np.sin(100000*x[0]) + 0.00001*np.cos(100000*x[1]) + 0.000001*np.sin(1000000*x[0]) + 0.000001*np.cos(1000000*x[1])\n\ndef f8(x):\n    return x[0]**2 + x[1]**2 + 0.1*np.sin(10*x[0]) + 0.1*np.cos(10*x[1]) + 0.01*np.sin(100*x[0]) + 0.01*np.cos(100*x[1]) + 0.001*np.sin(1000*x[0]) + 0.001*np.cos(1000*x[1]) + 0.0001*np.sin(10000*x[0]) + 0.0001*np.cos(10000*x[1]) + 0.00001*np.sin(100000*x[0]) + 0.00001*np.cos(100000*x[1]) + 0.000001*np.sin(1000000*x[0]) + 0.000001*np.cos(1000000*x[1]) + 0.0000001*np.sin(10000000*x[0]) + 0.0000001*np.cos(10000000*x[1])\n\ndef f9(x):\n    return x[0]**2 + x[1]**2 + 0.1*np.sin(10*x[0]) + 0.1*np.cos(10*x[1]) + 0.01*np.sin(100*x[0]) + 0.01*np.cos(100*x[1]) + 0.001*np.sin(1000*x[0]) + 0.001*np.cos(1000*x[1]) + 0.0001*np.sin(10000*x[0]) + 0.0001*np.cos(10000*x[1]) + 0.00001*np.sin(100000*x[0]) + 0.00001*np.cos(100000*x[1]) + 0.000001*np.sin(1000000*x[0]) + 0.000001*np.cos(1000000*x[1]) + 0.0000001*np.sin(10000000*x[0]) + 0.0000001*np.cos(10000000*x[1]) + 0.00000001*np.sin(100000000*x[0]) + 0.00000001*np.cos(100000000*x[1])\n\ndef f10(x):\n    return x[0]**2 + x[1]**2 + 0.1*np.sin(10*x[0]) + 0.1*np.cos(10*x[1]) + 0.01*np.sin(100*x[0]) + 0.01*np.cos(100*x[1]) + 0.001*np.sin(1000*x[0]) + 0.001*np.cos(1000*x[1]) + 0.0001*np.sin(10000*x[0]) + 0.0001*np.cos(10000*x[1]) + 0.00001*np.sin(100000*x[0]) + 0.00001*np.cos(100000*x[1]) + 0.000001*np.sin(1000000*x[0]) + 0.000001*np.cos(1000000*x[1]) + 0.0000001*np.sin(10000000*x[0]) + 0.0000001*np.cos(10000000*x[1]) + 0.00000001*np.sin(100000000*x[0]) + 0.00000001*np.cos(100000000*x[1]) + 0.000000001*np.sin(1000000000*x[0]) + 0.000000001*np.cos(1000000000*x[1])\n\ndef f11(x):\n    return x[0]**2 + x[1]**2 + 0.1*np.sin(10*x[0]) + 0.1*np.cos(10*x[1]) + 0.01*np.sin(100*x[0]) + 0.01*np.cos(100*x[1]) + 0.001*np.sin(1000*x[0]) + 0.001*np.cos(1000*x[1]) + 0.0001*np.sin(10000*x[0]) + 0.0001*np.cos(10000*x[1]) + 0.00001*np.sin(100000*x[0]) + 0.00001*np.cos(100000*x[1]) + 0.000001*np.sin(1000000*x[0]) + 0.000001*np.cos(1000000*x[1]) + 0.0000001*np.sin(10000000*x[0]) + 0.0000001*np.cos(10000000*x[1]) + 0.00000001*np.sin(100000000*x[0]) + 0.00000001*np.cos(100000000*x[1]) + 0.000000001*np.sin(1000000000*x[0]) + 0.000000001*np.cos(1000000000*x[1]) + 0.0000000001*np.sin(10000000000*x[0]) + 0.0000000001*np.cos(10000000000*x[1])\n\ndef f12(x):\n    return x[0]**2 + x[1]**2 + 0.1*np.sin(10*x[0]) + 0.1*np.cos(10*x[1]) + 0.01*np.sin(100*x[0]) + 0.01*np.cos(100*x[1]) + 0.001*np.sin(1000*x[0]) + 0.001*np.cos(1000*x[1]) + 0.0001*np.sin(10000*x[0]) + 0.0001*np.cos(10000*x[1]) + 0.00001*np.sin(100000*x[0]) + 0.00001*np.cos(100000*x[1]) + 0.000001*np.sin(1000000*x[0]) + 0.000001*np.cos(1000000*x[1]) + 0.0000001*np.sin(10000000*x[0]) + 0.0000001*np.cos(10000000*x[1]) + 0.00000001*np.sin(100000000*x[0]) + 0.00000001*np.cos(100000000*x[1]) + 0.000000001*np.sin(1000000000*x[0]) + 0.000000001*np.cos(1000000000*x[1]) + 0.0000000001*np.sin(10000000000*x[0]) + 0.0000000001*np.cos(10000000000*x[1]) + 0.00000000001*np.sin(100000000000*x[0]) + 0.00000000001*np.cos(100000000000*x[1])\n\ndef f13(x):\n    return x[0]**2 + x[1]**2 + 0.1*np.sin(10*x[0]) + 0.1*np.cos(10*x[1]) + 0.01*np.sin(100*x[0]) + 0.01*np.cos(100*x[1]) + 0.001*np.sin(1000*x[0]) + 0.001*np.cos(1000*x[1]) + 0.0001*np.sin(10000*x[0]) + 0.0001*np.cos(10000*x[1]) + 0.00001*np.sin(100000*x[0]) + 0.00001*np.cos(100000*x[1]) + 0.000001*np.sin(1000000*x[0]) + 0.000001*np.cos(1000000*x[1]) + 0.0000001*np.sin(10000000*x[0]) + 0.0000001*np.cos(10000000*x[1]) + 0.00000001*np.sin(100000000*x[0]) + 0.00000001*np.cos(100000000*x[1]) + 0.000000001*np.sin(1000000000*x[0]) + 0.000000001*np.cos(1000000000*x[1]) + 0.0000000001*np.sin(10000000000*x[0]) + 0.0000000001*np.cos(10000000000*x[1]) + 0.00000000001*np.sin(100000000000*x[0]) + 0.00000000001*np.cos(100000000000*x[1]) + 0.000000000001*np.sin(1000000000000*x[0]) + 0.000000000001*np.cos(1000000000000*x[1])\n\ndef f14(x):\n    return x[0]**2 + x[1]**2 + 0.1*np.sin(10*x[0]) + 0.1*np.cos(10*x[1]) + 0.01*np.sin(100*x[0]) + 0.01*np.cos(100*x[1]) + 0.001*np.sin(1000*x[0]) + 0.001*np.cos(1000*x[1]) + 0.0001*np.sin(10000*x[0]) + 0.0001*np.cos(10000*x[1]) + 0.00001*np.sin(100000*x[0]) + 0.00001*np.cos(100000*x[1]) + 0.000001*np.sin(1000000*x[0]) + 0.000001*np.cos(1000000*x[1]) + 0.0000001*np.sin(10000000*x[0]) + 0.0000001*np.cos(10000000*x[1]) + 0.00000001*np.sin(100000000*x[0]) + 0.00000001*np.cos(100000000*x[1]) + 0.000000001*np.sin(1000000000*x[0]) + 0.000000001*np.cos(1000000000*x[1]) + 0.0000000001*np.sin(10000000000*x[0]) + 0.0000000001*np.cos(10000000000*x[1]) + 0.00000000001*np.sin(100000000000*x[0]) + 0.00000000001*np.cos(100000000000*x[1]) + 0.000000000001*np.sin(1000000000000*x[0]) + 0.000000000001*np.cos(1000000000000*x[1])\n\ndef f15(x):\n    return x[0]**2 + x[1]**2 + 0.1*np.sin(10*x[0]) + 0.1*np.cos(10*x[1]) + 0.01*np.sin(100*x[0]) + 0.01*np.cos(100*x[1]) + 0.001*np.sin(1000*x[0]) + 0.001*np.cos(1000*x[1]) + 0.0001*np.sin(10000*x[0]) + 0.0001*np.cos(10000*x[1]) + 0.00001*np.sin(100000*x[0]) + 0.00001*np.cos(100000*x[1]) + 0.000001*np.sin(1000000*x[0]) + 0.000001*np.cos(1000000*x[1]) + 0.0000001*np.sin(10000000*x[0]) + 0.0000001*np.cos(10000000*x[1]) + 0.00000001*np.sin(100000000*x[0]) + 0.00000001*np.cos(100000000*x[1]) + 0.000000001*np.sin(1000000000*x[0]) + 0.000000001*np.cos(1000000000*x[1]) + 0.0000000001*np.sin(10000000000*x[0]) + 0.0000000001*np.cos(10000000000*x[1]) + 0.00000000001*np.sin(100000000000*x[0]) + 0.00000000001*np.cos(100000000000*x[1]) + 0.000000000001*np.sin(1000000000000*x[0]) + 0.000000000001*np.cos(1000000000000*x[1])\n\ndef f16(x):\n    return x[0]**2 + x[1]**2 + 0.1*np.sin(10*x[0]) + 0.1*np.cos(10*x[1]) + 0.01*np.sin(100*x[0]) + 0.01*np.cos(100*x[1]) + 0.001*np.sin(1000*x[0]) + 0.001*np.cos(1000*x[1]) + 0.0001*np.sin(10000*x[0]) + 0.0001*np.cos(10000*x[1]) + 0.00001*np.sin(100000*x[0]) + 0.00001*np.cos(100000*x[1]) + 0.000001*np.sin(1000000*x[0]) + 0.000001*np.cos(1000000*x[1]) + 0.0000001*np.sin(10000000*x[0]) + 0.0000001*np.cos(10000000*x[1]) + 0.00000001*np.sin(100000000*x[0]) + 0.00000001*np.cos(100000000*x[1]) + 0.000000001*np.sin(1000000000*x[0]) + 0.000000001*np.cos(1000000000*x[1]) + 0.0000000001*np.sin(10000000000*x[0]) + 0.0000000001*np.cos(10000000000*x[1]) + 0.00000000001*np.sin(100000000000*x[0]) + 0.00000000001*np.cos(100000000000*x[1]) + 0.000000000001*np.sin(1000000000000*x[0]) + 0.000000000001*np.cos(1000000000000*x[1])\n\ndef f17(x):\n    return x[0]**2 + x[1]**2 + 0.1*np.sin(10*x[0]) + 0.1*np.cos(10*x[1]) + 0.01*np.sin(100*x[0]) + 0.01*np.cos(100*x[1]) + 0.001*np.sin(1000*x[0]) + 0.001*np.cos(1000*x[1]) + 0.0001*np.sin(10000*x[0]) + 0.0001*np.cos(10000*x[1]) + 0.00001*np.sin(100000*x[0]) + 0.00001*np.cos(100000*x[1]) + 0.000001*np.sin(1000000*x[0]) + 0.000001*np.cos(1000000*x[1]) + 0.0000001*np.sin(10000000*x[0]) + 0.0000001*np.cos(10000000*x[1]) + 0.00000001*np.sin(100000000*x[0]) + 0.00000001*np.cos(100000000*x[1]) + 0.000000001*np.sin(1000000000*x[0]) + 0.000000001*np.cos(1000000000*x[1]) + 0.0000000001*np.sin(10000000000*x[0]) + 0.0000000001*np.cos(10000000000*x[1]) + 0.00000000001*np.sin(100000000000*x[0]) + 0.00000000001*np.cos(100000000000*x[1]) + 0.000000000001*np.sin(1000000000000*x[0]) + 0.000000000001*np.cos(1000000000000*x[1])\n\ndef f18(x):\n    return x[0]**2 + x[1]**2 + 0.1*np.sin(10*x[0]) + 0.1*np.cos(10*x[1]) + 0.01*np.sin(100*x[0]) + 0.01*np.cos(100*x[1]) + 0.001*np.sin(1000*x[0]) + 0.001*np.cos(1000*x[1]) + 0.0001*np.sin(10000*x[0]) + 0.0001*np.cos(10000*x[1]) + 0.00001*np.sin(100000*x[0]) + 0.00001*np.cos(100000*x[1]) + 0.000001*np.sin(1000000*x[0]) + 0.000001*np.cos(1000000*x[1]) + 0.0000001*np.sin(10000000*x[0]) + 0.0000001*np.cos(10000000*x[1]) + 0.00000001*np.sin(100000000*x[0]) + 0.00000001*np.cos(100000000*x[1]) + 0.000000001*np.sin(1000000000*x[0]) + 0.000000001*np.cos(1000000000*x[1]) + 0.0000000001*np.sin(10000000000*x[0]) + 0.0000000001*np.cos(10000000000*x[1]) + 0.00000000001*np.sin(100000000000*x[0]) + 0.00000000001*np.cos(100000000000*x[1]) + 0.000000000001*np.sin(1000000000000*x[0]) + 0.000000000001*np.cos(1000000000000*x[1])\n\ndef f19(x):\n    return x[0]**2 + x[1]**2 + 0.1*np.sin(10*x[0]) + 0.1*np.cos(10*x[1]) + 0.01*np.sin(100*x[0]) + 0.01*np.cos(100*x[1]) + 0.001*np.sin(1000*x[0]) + 0.001*np.cos(1000*x[1]) + 0.0001*np.sin(10000*x[0]) + 0.0001*np.cos(10000*x[1]) + 0.00001*np.sin(100000*x[0]) + 0.00001*np.cos(100000*x[1]) + 0.000001*np.sin(1000000*x[0]) + 0.000001*np.cos(1000000*x[1]) + 0.0000001*np.sin(10000000*x[0]) + 0.0000001*np.cos(10000000*x[1]) + 0.00000001*np.sin(100000000*x[0]) + 0.00000001*np.cos(100000000*x[1]) + 0.000000001*np.sin(1000000000*x[0]) + 0.000000001*np.cos(1000000000*x[1]) + 0.0000000001*np.sin(10000000000*x[0]) + 0.0000000001*np.cos(10000000000*x[1]) + 0.00000000001*np.sin(100000000000*x[0]) + 0.00000000001*np.cos(100000000000*x[1]) + 0.000000000001*np.sin(1000000000000*x[0]) + 0.000000000001*np.cos(1000000000000*x[1])\n\ndef f20(x):\n    return x[0]**2 + x[1]**2 + 0.1*np.sin(10*x[0]) + 0.1*np.cos(10*x[1]) + 0.01*np.sin(100*x[0]) + 0.01*np.cos(100*x[1]) + 0.001*np.sin(1000*x[0]) + 0.001*np.cos(1000*x[1]) + 0.0001*np.sin(10000*x[0]) + 0.0001*np.cos(10000*x[1]) + 0.00001*np.sin(100000*x[0]) + 0.00001*np.cos(100000*x[1]) + 0.000001*np.sin(1000000*x[0]) + 0.000001*np.cos(1000000*x[1]) + 0.0000001*np.sin(10000000*x[0]) + 0.0000001*np.cos(10000000*x[1]) + 0.00000001*np.sin(100000000*x[0]) + 0.00000001*np.cos(100000000*x[1]) + 0.000000001*np.sin(1000000000*x[0]) + 0.000000001*np.cos(1000000000*x[1]) + 0.0000000001*np.sin(10000000000*x[0]) + 0.0000000001*np.cos(10000000000*x[1]) + 0.00000000001*np.sin(100000000000*x[0]) + 0.00000000001*np.cos(100000000000*x[1]) + 0.000000000001*np.sin(1000000000000*x[0]) + 0.000000000001*np.cos(1000000000000*x[1])\n\ndef f21(x):\n    return x[0]**2 + x[1]**2 + 0.1*np.sin(10*x[0]) + 0.1*np.cos(10*x[1]) + 0.01*np.sin(100*x[0]) + 0.01*np.cos(100*x[1]) + 0.001*np.sin(1000*x[0]) + 0.001*np.cos(1000*x[1]) + 0.0001*np.sin(10000*x[0]) + 0.0001*np.cos(10000*x[1]) + 0.00001*np.sin(100000*x[0]) + 0.00001*np.cos(100000*x[1]) + 0.000001*np.sin(1000000*x[0]) + 0.000001*np.cos(1000000*x[1]) + 0.0000001*np.sin(10000000*x[0]) + 0.0000001*np.cos(10000000*x[1]) + 0.00000001*np.sin(100000000*x[0]) + 0.00000001*np.cos(100000000*x[1]) + 0.000000001*np.sin(1000000000*x[0]) + 0.000000001*np.cos(1000000000*x[1]) + 0.0000000001*np.sin(10000000000*x[0]) + 0.0000000001*np.cos(10000000000*x[1]) + 0.00000000001*np.sin(100000000000*x[0]) + 0.00000000001*np.cos(100000000000*x[1]) + 0.000000000001*np.sin(1000000000000*x[0]) + 0.000000000001*np.cos(1000000000000*x[1])\n\ndef f22(x):\n    return x[0]**2 + x[1]**2 + 0.1*np.sin(10*x[0]) + 0.1*np.cos(10*x[1]) + 0.01*np.sin(100*x[0]) + 0.01*np.cos(100*x[1]) + 0.001*np.sin(1000*x[0]) + 0.001*np.cos(1000*x[1]) + 0.0001*np.sin(10000*x[0]) + 0.0001*np.cos(10000*x[1]) + 0.00001*np.sin(100000*x[0]) + 0.00001*np.cos(100000*x[1]) + 0.000001*np.sin(1000000*x[0]) + 0.000001*np.cos(1000000*x[1]) + 0.0000001*np.sin(10000000*x[0]) + 0.0000001*np.cos(10000000*x[1]) + 0.00000001*np.sin(100000000*x[0]) + 0.00000001*np.cos(100000000*x[1]) + 0.000000001*np.sin(1000000000*x[0]) + 0.000000001*np.cos(1000000000*x[1]) + 0.0000000001*np.sin(10000000000*x[0]) + 0.0000000001*np.cos(10000000000*x[1]) + 0.00000000001*np.sin(100000000000*x[0]) + 0.00000000001*np.cos(100000000000*x[1]) + 0.000000000001*np.sin(1000000000000*x[0]) + 0.000000000001*np.cos(1000000000000*x[1])\n\ndef f23(x):\n    return x[0]**2 + x[1]**2 + 0.1*np.sin(10*x[0]) + 0.1*np.cos(10*x[1]) + 0.01*np.sin(100*x[0]) + 0.01*np.cos(100*x[1]) + 0.001*np.sin(1000*x[0]) + 0.001*np.cos(1000*x[1]) + 0.0001*np.sin(10000*x[0]) + 0.0001*np.cos(10000*x[1]) + 0.00001*np.sin(100000*x[0]) + 0.00001*np.cos(100000*x[1]) + 0.000001*np.sin(1000000*x[0]) + 0.000001*np.cos(1000000*x[1]) + 0.0000001*np.sin(10000000*x[0]) + 0.0000001*np.cos(10000000*x[1]) + 0.00000001*np.sin(100000000*x[0]) + 0.00000001*np.cos(100000000*x[1]) + 0.000000001*np.sin(1000000000*x[0]) + 0.000000001*np.cos(1000000000*x[1]) + 0.0000000001*np.sin(10000000000*x[0]) + 0.0000000001*np.cos(10000000000*x[1]) + 0.00000000001*np.sin(100000000000*x[0]) + 0.00000000001*np.cos(100000000000*x[1]) + 0.000000000001*np.sin(1000000000000*x[0]) + 0.000000000001*np.cos(1000000000000*x[1])\n\ndef f24(x):\n    return x[0]**2 + x[1]**2 + 0.1*np.sin(10*x[0]) + 0.1*np.cos(10*x[1]) + 0.01*np.sin(100*x[0]) + 0.01*np.cos(100*x[1]) + 0.001*np.sin(1000*x[0]) + 0.001*np.cos(1000*x[1]) + 0.0001*np.sin(10000*x[0]) + 0.0001*np.cos(10000*x[1]) + 0.00001*np.sin(100000*x[0]) + 0.00001*np.cos(100000*x[1]) + 0.000001*np.sin(1000000*x[0]) + 0.000001*np.cos(1000000*x[1]) + 0.0000001*np.sin(10000000*x[0]) + 0.0000001*np.cos(10000000*x[1]) + 0.00000001*np.sin(100000000*x[0]) + 0.00000001*np.cos(100000000*x[1]) + 0.000000001*np.sin(1000000000*x[0]) + 0.000000001*np.cos(1000000000*x[1]) + 0.0000000001*np.sin(10000000000*x[0]) + 0.0000000001*np.cos(10000000000*x[1]) + 0.00000000001*np.sin(100000000000*x[0]) + 0.00000000001*np.cos(100000000000*x[1]) + 0.000000000001*np.sin(1000000000000*x[0]) + 0.000000000001*np.cos(1000000000000*x[1])\n\ndef evaluateBBOB(func, budget, dim):\n    heacombbo = HEACOMBBO(budget, dim)\n    for i in range(budget):\n        best_individual, _ = heacombbo()\n        if i % 10 == 0:\n            print(f\"Iteration {i}: Best individual = {best_individual}\")\n\n    return best_individual\n\nevaluateBBOB(f1, 50, 2)\nevaluateBBOB(f2, 50, 2)\nevaluateBBOB(f3, 50, 2)\nevaluateBBOB(f4, 50, 2)\nevaluateBBOB(f5, 50, 2)\nevaluateBBOB(f6, 50, 2)\nevaluateBBOB(f7, 50, 2)\nevaluateBBOB(f8, 50, 2)\nevaluateBBOB(f9, 50, 2)\nevaluateBBOB(f10, 50, 2)\nevaluateBBOB(f11, 50, 2)\nevaluateBBOB(f12, 50, 2)\nevaluateBBOB(f13, 50, 2)\nevaluateBBOB(f14, 50, 2)\nevaluateBBOB(f15, 50, 2)\nevaluateBBOB(f16, 50, 2)\nevaluateBBOB(f17, 50, 2)\nevaluateBBOB(f18, 50, 2)\nevaluateBBOB(f19, 50, 2)\nevaluateBBOB(f20, 50, 2)\nevaluateBBOB(f21, 50, 2)\nevaluateBBOB(f22, 50, 2)\nevaluateBBOB(f23, 50, 2)\nevaluateBBOB(f24, 50, 2)", "name": "HEACOMBBO", "description": "Novel Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) with strategy refinement.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"HEACOMBBO.__call__() missing 1 required positional argument: 'func'\").", "error": "TypeError(\"HEACOMBBO.__call__() missing 1 required positional argument: 'func'\")", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "affa788d-f0d4-40ae-987c-e45d2a6e0a77", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "8cac7d14-7dd3-4995-b847-13a74a3718bb", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n    def refine_strategy(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n\n        # Refine strategy with probability 0.4\n        if np.random.rand() < 0.4:\n            # Randomly select two individuals from the current population\n            individuals = [self.f(i) for i in range(self.budget)]\n            # Randomly select two strategies\n            strategies = ['sbx','sbx', 'rand1', 'rand1']\n            # Replace the two selected individuals with new ones using the selected strategies\n            new_individuals = []\n            for i in range(self.budget):\n                if i % 2 == 0:\n                    new_individuals.append(self.f(strategies[np.random.randint(0, 3)](i)))\n                else:\n                    new_individuals.append(self.f(strategies[np.random.randint(0, 3)](i)))\n            # Replace the two selected individuals with the new ones\n            individuals = new_individuals\n        # Return the refined individuals\n        return individuals\n\n# Usage\ndef main():\n    # Initialize the algorithm\n    algorithm = HEACOMBBO(budget=10, dim=5)\n\n    # Evaluate the function\n    func = lambda x: x[0]**2 + x[1]**2 + x[2]**2 + x[3]**2 + x[4]**2\n    result = algorithm(func)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO) with probabilistic refinement of strategy.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('keyword argument repeated: strategy', ('<string>', 32, 142, None, 32, 158)).", "error": "SyntaxError('keyword argument repeated: strategy', ('<string>', 32, 142, None, 32, 158))", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "268133c6-51bf-4012-a937-575db7ccc2d9", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass HEACOMBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        if func.__name__ == 'f1':\n            return differential_evolution(func, self.bounds)\n        elif func.__name__ == 'f2':\n            return differential_evolution(func, self.bounds, x0=self.x0)\n        elif func.__name__ == 'f3':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5)\n        elif func.__name__ == 'f4':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0)\n        elif func.__name__ == 'f5':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx')\n        elif func.__name__ == 'f6':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5)\n        elif func.__name__ == 'f7':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5)\n        elif func.__name__ == 'f8':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5)\n        elif func.__name__ == 'f9':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1')\n        elif func.__name__ == 'f10':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform')\n        elif func.__name__ == 'f11':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform')\n        elif func.__name__ == 'f12':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f13':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform')\n        elif func.__name__ == 'f14':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform')\n        elif func.__name__ == 'f15':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f16':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f17':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f18':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f19':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f20':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f21':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f22':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f23':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')\n        elif func.__name__ == 'f24':\n            return differential_evolution(func, self.bounds, x0=self.x0, tol=1e-5, x0_init=self.x0, strategy='sbx', cxpb=0.5, mu=0.5, w=0.5, strategy='rand1', scaling='uniform', scaling='log-uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform', scaling='uniform')", "name": "HEACOMBBO", "description": "Hybrid Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization (HEACOMB-BO)", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
{"id": "6f9a9180-58dd-4931-99a5-f29f3993b8f1", "solution": "import numpy as np\nimport random\nimport copy\n\nclass HybridEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [(-5.0, 5.0)] * dim\n        self.x0 = np.random.uniform(self.bounds[0][0], self.bounds[0][1], self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return np.nan, np.nan\n\n        def crossover(parent1, parent2):\n            child = copy.deepcopy(parent1)\n            for i in range(self.dim):\n                if random.random() < 0.4:\n                    child[i] = parent2[i]\n            return child\n\n        def mutate(individual):\n            for i in range(self.dim):\n                if random.random() < 0.4:\n                    individual[i] += random.uniform(-1.0, 1.0)\n                    individual[i] = max(self.bounds[i][0], min(individual[i], self.bounds[i][1]))\n            return individual\n\n        def evaluate_fitness(individual):\n            return func(individual)\n\n        population = [self.x0]\n        for _ in range(self.budget - 1):\n            parent1, parent2 = sorted(population, key=evaluate_fitness)[0], sorted(population, key=evaluate_fitness)[1]\n            child = crossover(parent1, parent2)\n            child = mutate(child)\n            population.append(child)\n\n        best_individual = min(population, key=evaluate_fitness)\n        return evaluate_fitness(best_individual), best_individual\n\n# Example usage:\ndef f1(x):\n    return sum(x**2)\n\ndef f2(x):\n    return sum(x**2) + 1\n\ndef f3(x):\n    return sum(x**2) + 1e-5\n\ndef f4(x):\n    return sum(x**2) + 1e-5 + np.sin(x)\n\ndef f5(x):\n    return sum(x**2) + 1e-5 + np.sin(x) * np.cos(x)\n\ndef f6(x):\n    return sum(x**2) + 1e-5 + np.sin(x) * np.cos(x) * np.cos(x)\n\ndef f7(x):\n    return sum(x**2) + 1e-5 + np.sin(x) * np.cos(x) * np.cos(x) * np.cos(x)\n\ndef f8(x):\n    return sum(x**2) + 1e-5 + np.sin(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x)\n\ndef f9(x):\n    return sum(x**2) + 1e-5 + np.sin(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x)\n\ndef f10(x):\n    return sum(x**2) + 1e-5 + np.sin(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x)\n\ndef f11(x):\n    return sum(x**2) + 1e-5 + np.sin(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x)\n\ndef f12(x):\n    return sum(x**2) + 1e-5 + np.sin(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x)\n\ndef f13(x):\n    return sum(x**2) + 1e-5 + np.sin(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x)\n\ndef f14(x):\n    return sum(x**2) + 1e-5 + np.sin(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x)\n\ndef f15(x):\n    return sum(x**2) + 1e-5 + np.sin(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x)\n\ndef f16(x):\n    return sum(x**2) + 1e-5 + np.sin(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x)\n\ndef f17(x):\n    return sum(x**2) + 1e-5 + np.sin(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x)\n\ndef f18(x):\n    return sum(x**2) + 1e-5 + np.sin(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x)\n\ndef f19(x):\n    return sum(x**2) + 1e-5 + np.sin(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x)\n\ndef f20(x):\n    return sum(x**2) + 1e-5 + np.sin(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x)\n\ndef f21(x):\n    return sum(x**2) + 1e-5 + np.sin(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x)\n\ndef f22(x):\n    return sum(x**2) + 1e-5 + np.sin(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x)\n\ndef f23(x):\n    return sum(x**2) + 1e-5 + np.sin(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x)\n\ndef f24(x):\n    return sum(x**2) + 1e-5 + np.sin(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x) * np.cos(x)\n\nhybrid_eva = HybridEvolutionaryAlgorithm(budget=10, dim=10)\nbest_fitness, best_individual = hybrid_eva(f1)\nprint(f\"Best fitness: {best_fitness}, Best individual: {best_individual}\")", "name": "HybridEvolutionaryAlgorithm", "description": "Novel Hybrid Evolutionary Algorithm with Crossover, Mutation, and Strategy Refinement for Black Box Optimization", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "e6e7891b-54d2-4982-bf6a-4726743f0032", "metadata": {}, "mutation_prompt": null}
